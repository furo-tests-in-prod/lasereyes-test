"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllU128 = exports.u128 = exports.U128_MAX_BIGINT = void 0;
const monads_1 = require("../monads");
const seekbuffer_1 = require("../seekbuffer");
const u64_1 = require("./u64");
const u32_1 = require("./u32");
const u8_1 = require("./u8");
exports.U128_MAX_BIGINT = 0xffffffffffffffffffffffffffffffffn;
/**
 * Convert Number or BigInt to 128-bit unsigned integer.
 * @param num - The Number or BigInt to convert.
 * @returns - The resulting 128-bit unsigned integer (BigInt).
 */
function u128(num) {
    const bigNum = typeof num == 'bigint' ? num : BigInt(num);
    return (bigNum & exports.U128_MAX_BIGINT);
}
exports.u128 = u128;
(function (u128) {
    u128.MAX = u128(exports.U128_MAX_BIGINT);
    function checkedAdd(x, y) {
        const result = x + y;
        if (result > u128.MAX) {
            return monads_1.None;
        }
        return (0, monads_1.Some)(u128(result));
    }
    u128.checkedAdd = checkedAdd;
    function checkedAddThrow(x, y) {
        const option = u128.checkedAdd(x, y);
        if (option.isNone()) {
            throw new Error('checked add overflow');
        }
        return option.unwrap();
    }
    u128.checkedAddThrow = checkedAddThrow;
    function checkedSub(x, y) {
        const result = x - y;
        if (result < 0n) {
            return monads_1.None;
        }
        return (0, monads_1.Some)(u128(result));
    }
    u128.checkedSub = checkedSub;
    function checkedSubThrow(x, y) {
        const option = u128.checkedSub(x, y);
        if (option.isNone()) {
            throw new Error('checked sub overflow');
        }
        return option.unwrap();
    }
    u128.checkedSubThrow = checkedSubThrow;
    function checkedMultiply(x, y) {
        const result = x * y;
        if (result > u128.MAX) {
            return monads_1.None;
        }
        return (0, monads_1.Some)(u128(result));
    }
    u128.checkedMultiply = checkedMultiply;
    function saturatingAdd(x, y) {
        const result = x + y;
        return result > u128.MAX ? u128.MAX : u128(result);
    }
    u128.saturatingAdd = saturatingAdd;
    function saturatingMultiply(x, y) {
        const result = x * y;
        return result > u128.MAX ? u128.MAX : u128(result);
    }
    u128.saturatingMultiply = saturatingMultiply;
    function saturatingSub(x, y) {
        return u128(x < y ? 0 : x - y);
    }
    u128.saturatingSub = saturatingSub;
    function decodeVarInt(seekBuffer) {
        try {
            return (0, monads_1.Some)(tryDecodeVarInt(seekBuffer));
        }
        catch (e) {
            return monads_1.None;
        }
    }
    u128.decodeVarInt = decodeVarInt;
    function tryDecodeVarInt(seekBuffer) {
        let result = u128(0);
        for (let i = 0; i <= 18; i++) {
            const byte = seekBuffer.readUInt8();
            if (byte === undefined) {
                throw new Error('Unterminated');
            }
            const value = u128(byte) & 127n;
            if (i === 18 && (value & 124n) !== 0n) {
                throw new Error('Overflow');
            }
            result = u128(result | (value << u128(7 * i)));
            if ((byte & 128) === 0) {
                return result;
            }
        }
        throw new Error('Overlong');
    }
    u128.tryDecodeVarInt = tryDecodeVarInt;
    function encodeVarInt(value) {
        const v = [];
        while (value >> 7n > 0n) {
            v.push(Number(value & 0xffn) | 128);
            value = u128(value >> 7n);
        }
        v.push(Number(value & 0xffn));
        return Buffer.from(v);
    }
    u128.encodeVarInt = encodeVarInt;
    function tryIntoU64(n) {
        return n > u64_1.u64.MAX ? monads_1.None : (0, monads_1.Some)((0, u64_1.u64)(n));
    }
    u128.tryIntoU64 = tryIntoU64;
    function tryIntoU32(n) {
        return n > u32_1.u32.MAX ? monads_1.None : (0, monads_1.Some)((0, u32_1.u32)(n));
    }
    u128.tryIntoU32 = tryIntoU32;
    function tryIntoU8(n) {
        return n > u8_1.u8.MAX ? monads_1.None : (0, monads_1.Some)((0, u8_1.u8)(n));
    }
    u128.tryIntoU8 = tryIntoU8;
})(u128 || (exports.u128 = u128 = {}));
function* getAllU128(buffer) {
    const seekBuffer = new seekbuffer_1.SeekBuffer(buffer);
    while (!seekBuffer.isFinished()) {
        const nextValue = u128.tryDecodeVarInt(seekBuffer);
        if (nextValue === undefined) {
            return;
        }
        yield nextValue;
    }
}
exports.getAllU128 = getAllU128;
//# sourceMappingURL=u128.js.map