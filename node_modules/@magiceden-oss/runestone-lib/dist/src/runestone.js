"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runestone = exports.isValidPayload = exports.MAX_SPACERS = void 0;
const constants_1 = require("./constants");
const etching_1 = require("./etching");
const seekbuffer_1 = require("./seekbuffer");
const tag_1 = require("./tag");
const integer_1 = require("./integer");
const monads_1 = require("./monads");
const rune_1 = require("./rune");
const flag_1 = require("./flag");
const utils_1 = require("./utils");
const runeid_1 = require("./runeid");
const script_1 = require("./script");
const message_1 = require("./message");
const flaw_1 = require("./flaw");
const cenotaph_1 = require("./cenotaph");
exports.MAX_SPACERS = 134217727;
function isValidPayload(payload) {
    return Buffer.isBuffer(payload);
}
exports.isValidPayload = isValidPayload;
class Runestone {
    constructor(mint, pointer, edicts, etching) {
        this.mint = mint;
        this.pointer = pointer;
        this.edicts = edicts;
        this.etching = etching;
    }
    static decipher(transaction) {
        const optionPayload = Runestone.payload(transaction);
        if (optionPayload.isNone()) {
            return monads_1.None;
        }
        const payload = optionPayload.unwrap();
        if (!isValidPayload(payload)) {
            return (0, monads_1.Some)(new cenotaph_1.Cenotaph([payload]));
        }
        const optionIntegers = Runestone.integers(payload);
        if (optionIntegers.isNone()) {
            return (0, monads_1.Some)(new cenotaph_1.Cenotaph([flaw_1.Flaw.VARINT]));
        }
        const { flaws, edicts, fields } = message_1.Message.fromIntegers(transaction.vout.length, optionIntegers.unwrap());
        let flags = tag_1.Tag.take(tag_1.Tag.FLAGS, fields, 1, ([value]) => (0, monads_1.Some)(value)).unwrapOr((0, integer_1.u128)(0));
        const etchingResult = flag_1.Flag.take(flags, flag_1.Flag.ETCHING);
        const etchingFlag = etchingResult.set;
        flags = etchingResult.flags;
        const etching = etchingFlag
            ? (() => {
                const divisibility = tag_1.Tag.take(tag_1.Tag.DIVISIBILITY, fields, 1, ([value]) => integer_1.u128
                    .tryIntoU8(value)
                    .andThen((value) => (value <= constants_1.MAX_DIVISIBILITY ? (0, monads_1.Some)(value) : monads_1.None)));
                const rune = tag_1.Tag.take(tag_1.Tag.RUNE, fields, 1, ([value]) => (0, monads_1.Some)(new rune_1.Rune(value)));
                const spacers = tag_1.Tag.take(tag_1.Tag.SPACERS, fields, 1, ([value]) => integer_1.u128.tryIntoU32(value).andThen((value) => (value <= exports.MAX_SPACERS ? (0, monads_1.Some)(value) : monads_1.None)));
                const symbol = tag_1.Tag.take(tag_1.Tag.SYMBOL, fields, 1, ([value]) => integer_1.u128.tryIntoU32(value).andThen((value) => {
                    try {
                        return (0, monads_1.Some)(String.fromCodePoint(Number(value)));
                    }
                    catch (e) {
                        return monads_1.None;
                    }
                }));
                const termsResult = flag_1.Flag.take(flags, flag_1.Flag.TERMS);
                const termsFlag = termsResult.set;
                flags = termsResult.flags;
                const terms = termsFlag
                    ? (() => {
                        const amount = tag_1.Tag.take(tag_1.Tag.AMOUNT, fields, 1, ([value]) => (0, monads_1.Some)(value));
                        const cap = tag_1.Tag.take(tag_1.Tag.CAP, fields, 1, ([value]) => (0, monads_1.Some)(value));
                        const offset = [
                            tag_1.Tag.take(tag_1.Tag.OFFSET_START, fields, 1, ([value]) => integer_1.u128.tryIntoU64(value)),
                            tag_1.Tag.take(tag_1.Tag.OFFSET_END, fields, 1, ([value]) => integer_1.u128.tryIntoU64(value)),
                        ];
                        const height = [
                            tag_1.Tag.take(tag_1.Tag.HEIGHT_START, fields, 1, ([value]) => integer_1.u128.tryIntoU64(value)),
                            tag_1.Tag.take(tag_1.Tag.HEIGHT_END, fields, 1, ([value]) => integer_1.u128.tryIntoU64(value)),
                        ];
                        return (0, monads_1.Some)({ amount, cap, offset, height });
                    })()
                    : monads_1.None;
                const premine = tag_1.Tag.take(tag_1.Tag.PREMINE, fields, 1, ([value]) => (0, monads_1.Some)(value));
                const turboResult = flag_1.Flag.take(flags, flag_1.Flag.TURBO);
                const turbo = etchingResult.set;
                flags = turboResult.flags;
                return (0, monads_1.Some)(new etching_1.Etching(divisibility, rune, spacers, symbol, terms, premine, turbo));
            })()
            : monads_1.None;
        const mint = tag_1.Tag.take(tag_1.Tag.MINT, fields, 2, ([block, tx]) => {
            const optionBlockU64 = integer_1.u128.tryIntoU64(block);
            const optionTxU32 = integer_1.u128.tryIntoU32(tx);
            if (optionBlockU64.isNone() || optionTxU32.isNone()) {
                return monads_1.None;
            }
            return runeid_1.RuneId.new(optionBlockU64.unwrap(), optionTxU32.unwrap());
        });
        const pointer = tag_1.Tag.take(tag_1.Tag.POINTER, fields, 1, ([value]) => integer_1.u128
            .tryIntoU32(value)
            .andThen((value) => (value < transaction.vout.length ? (0, monads_1.Some)(value) : monads_1.None)));
        if (etching.map((etching) => etching.supply.isNone()).unwrapOr(false)) {
            flaws.push(flaw_1.Flaw.SUPPLY_OVERFLOW);
        }
        if (flags !== 0n) {
            flaws.push(flaw_1.Flaw.UNRECOGNIZED_FLAG);
        }
        if ([...fields.keys()].find((tag) => tag % 2n === 0n) !== undefined) {
            flaws.push(flaw_1.Flaw.UNRECOGNIZED_EVEN_TAG);
        }
        if (flaws.length !== 0) {
            return (0, monads_1.Some)(new cenotaph_1.Cenotaph(flaws, etching.andThen((etching) => etching.rune), mint));
        }
        return (0, monads_1.Some)(new Runestone(mint, pointer, edicts, etching));
    }
    encipher() {
        const payloads = [];
        if (this.etching.isSome()) {
            const etching = this.etching.unwrap();
            let flags = (0, integer_1.u128)(0);
            flags = flag_1.Flag.set(flags, flag_1.Flag.ETCHING);
            if (etching.terms.isSome()) {
                flags = flag_1.Flag.set(flags, flag_1.Flag.TERMS);
            }
            if (etching.turbo) {
                flags = flag_1.Flag.set(flags, flag_1.Flag.TURBO);
            }
            payloads.push(tag_1.Tag.encode(tag_1.Tag.FLAGS, [flags]));
            payloads.push(tag_1.Tag.encodeOptionInt(tag_1.Tag.RUNE, etching.rune.map((rune) => rune.value)));
            payloads.push(tag_1.Tag.encodeOptionInt(tag_1.Tag.DIVISIBILITY, etching.divisibility.map(integer_1.u128)));
            payloads.push(tag_1.Tag.encodeOptionInt(tag_1.Tag.SPACERS, etching.spacers.map(integer_1.u128)));
            payloads.push(tag_1.Tag.encodeOptionInt(tag_1.Tag.SYMBOL, etching.symbol.map((symbol) => (0, integer_1.u128)(symbol.codePointAt(0)))));
            payloads.push(tag_1.Tag.encodeOptionInt(tag_1.Tag.PREMINE, etching.premine));
            if (etching.terms.isSome()) {
                const terms = etching.terms.unwrap();
                payloads.push(tag_1.Tag.encodeOptionInt(tag_1.Tag.AMOUNT, terms.amount));
                payloads.push(tag_1.Tag.encodeOptionInt(tag_1.Tag.CAP, terms.cap));
                payloads.push(tag_1.Tag.encodeOptionInt(tag_1.Tag.HEIGHT_START, terms.height[0]));
                payloads.push(tag_1.Tag.encodeOptionInt(tag_1.Tag.HEIGHT_END, terms.height[1]));
                payloads.push(tag_1.Tag.encodeOptionInt(tag_1.Tag.OFFSET_START, terms.offset[0]));
                payloads.push(tag_1.Tag.encodeOptionInt(tag_1.Tag.OFFSET_END, terms.offset[1]));
            }
        }
        if (this.mint.isSome()) {
            const claim = this.mint.unwrap();
            payloads.push(tag_1.Tag.encode(tag_1.Tag.MINT, [claim.block, claim.tx].map(integer_1.u128)));
        }
        payloads.push(tag_1.Tag.encodeOptionInt(tag_1.Tag.POINTER, this.pointer.map(integer_1.u128)));
        if (this.edicts.length) {
            payloads.push(integer_1.u128.encodeVarInt((0, integer_1.u128)(tag_1.Tag.BODY)));
            const edicts = [...this.edicts].sort((x, y) => Number(x.id.block - y.id.block || x.id.tx - y.id.tx));
            let previous = new runeid_1.RuneId((0, integer_1.u64)(0), (0, integer_1.u32)(0));
            for (const edict of edicts) {
                const [block, tx] = previous.delta(edict.id).unwrap();
                payloads.push(integer_1.u128.encodeVarInt(block));
                payloads.push(integer_1.u128.encodeVarInt(tx));
                payloads.push(integer_1.u128.encodeVarInt(edict.amount));
                payloads.push(integer_1.u128.encodeVarInt((0, integer_1.u128)(edict.output)));
                previous = edict.id;
            }
        }
        const stack = [];
        stack.push(constants_1.OP_RETURN);
        stack.push(constants_1.MAGIC_NUMBER);
        const payload = Buffer.concat(payloads);
        let i = 0;
        for (let i = 0; i < payload.length; i += constants_1.MAX_SCRIPT_ELEMENT_SIZE) {
            stack.push(payload.subarray(i, i + constants_1.MAX_SCRIPT_ELEMENT_SIZE));
        }
        return script_1.script.compile(stack);
    }
    static payload(transaction) {
        // search transaction outputs for payload
        for (const output of transaction.vout) {
            const instructions = script_1.script.decompile(Buffer.from(output.scriptPubKey.hex, 'hex'));
            if (instructions === null) {
                throw new Error('unable to decompile');
            }
            // payload starts with OP_RETURN
            let nextInstructionResult = instructions.next();
            if (nextInstructionResult.done || nextInstructionResult.value !== constants_1.OP_RETURN) {
                continue;
            }
            // followed by the protocol identifier
            nextInstructionResult = instructions.next();
            if (nextInstructionResult.done ||
                utils_1.Instruction.isBuffer(nextInstructionResult.value) ||
                nextInstructionResult.value !== constants_1.MAGIC_NUMBER) {
                continue;
            }
            // construct the payload by concatinating remaining data pushes
            let payloads = [];
            do {
                nextInstructionResult = instructions.next();
                if (nextInstructionResult.done) {
                    const decodedSuccessfully = nextInstructionResult.value;
                    if (!decodedSuccessfully) {
                        return (0, monads_1.Some)(flaw_1.Flaw.INVALID_SCRIPT);
                    }
                    break;
                }
                const instruction = nextInstructionResult.value;
                if (utils_1.Instruction.isBuffer(instruction)) {
                    payloads.push(instruction);
                }
                else {
                    return (0, monads_1.Some)(flaw_1.Flaw.OPCODE);
                }
            } while (true);
            return (0, monads_1.Some)(Buffer.concat(payloads));
        }
        return monads_1.None;
    }
    static integers(payload) {
        const integers = [];
        const seekBuffer = new seekbuffer_1.SeekBuffer(payload);
        while (!seekBuffer.isFinished()) {
            const optionInt = integer_1.u128.decodeVarInt(seekBuffer);
            if (optionInt.isNone()) {
                return monads_1.None;
            }
            integers.push(optionInt.unwrap());
        }
        return (0, monads_1.Some)(integers);
    }
}
exports.Runestone = Runestone;
//# sourceMappingURL=runestone.js.map