import { Artifact } from '../artifact';
import { Option } from '../monads';
import { Network } from '../network';
import { BitcoinRpcClient } from '../rpcclient';
import { Rune } from '../rune';
import { BlockInfo, RuneBalance, RuneBlockIndex, RuneEtching, RuneLocation, RuneMintCount, RuneUtxoBalance, RunestoneStorage, RuneSpentUtxoBalance } from './types';
export type UpdaterTx = {
    txid: string;
    vin: ({
        txid: string;
        vout: number;
        txinwitness: string[];
    } | {
        coinbase: string;
    })[];
    vout: {
        scriptPubKey: {
            hex: string;
            address?: string;
        };
    }[];
};
export declare class RuneUpdater implements RuneBlockIndex {
    readonly reorg: boolean;
    private readonly _storage;
    private readonly _rpc;
    block: BlockInfo;
    etchings: RuneEtching[];
    utxoBalances: RuneUtxoBalance[];
    spentBalances: RuneSpentUtxoBalance[];
    private _minimum;
    private _mintCountsByRuneLocation;
    private _burnedBalancesByRuneLocation;
    constructor(network: Network, block: BlockInfo, reorg: boolean, _storage: RunestoneStorage, _rpc: BitcoinRpcClient);
    get mintCounts(): RuneMintCount[];
    get burnedBalances(): RuneBalance[];
    indexRunes(tx: UpdaterTx, txIndex: number): Promise<void>;
    etched(txIndex: number, tx: UpdaterTx, artifact: Artifact): Promise<Option<{
        runeId: RuneLocation;
        rune: Rune;
    }>>;
    private mint;
    private unallocated;
    txCommitsToRune(tx: UpdaterTx, rune: Rune): Promise<boolean>;
    createEtching(txid: string, artifact: Artifact, runeId: RuneLocation, rune: Rune): void;
}
//# sourceMappingURL=updater.d.ts.map