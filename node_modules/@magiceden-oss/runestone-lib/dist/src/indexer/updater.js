"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuneUpdater = void 0;
const artifact_1 = require("../artifact");
const constants_1 = require("../constants");
const integer_1 = require("../integer");
const monads_1 = require("../monads");
const rune_1 = require("../rune");
const runestone_1 = require("../runestone");
const script_1 = require("../script");
const spacedrune_1 = require("../spacedrune");
const types_1 = require("./types");
function isScriptPubKeyHexOpReturn(scriptPubKeyHex) {
    return scriptPubKeyHex && Buffer.from(scriptPubKeyHex, 'hex')[0] === constants_1.OP_RETURN;
}
class RuneUpdater {
    constructor(network, block, reorg, _storage, _rpc) {
        this.reorg = reorg;
        this._storage = _storage;
        this._rpc = _rpc;
        this.etchings = [];
        this.utxoBalances = [];
        this.spentBalances = [];
        this._mintCountsByRuneLocation = new Map();
        this._burnedBalancesByRuneLocation = new Map();
        this.block = {
            height: block.height,
            hash: block.hash,
            previousblockhash: block.previousblockhash,
            time: block.time,
        };
        this._minimum = rune_1.Rune.getMinimumAtHeight(network, (0, integer_1.u128)(block.height));
    }
    get mintCounts() {
        return [...this._mintCountsByRuneLocation.values()];
    }
    get burnedBalances() {
        return [...this._burnedBalancesByRuneLocation.values()];
    }
    async indexRunes(tx, txIndex) {
        const optionArtifact = runestone_1.Runestone.decipher(tx);
        const unallocated = await this.unallocated(tx);
        const allocated = [...new Array(tx.vout.length)].map(() => new Map());
        function getUnallocatedRuneBalance(runeId) {
            const key = types_1.RuneLocation.toString(runeId);
            const balance = unallocated.get(key) ?? { runeId, amount: 0n };
            unallocated.set(key, balance);
            return balance;
        }
        function getAllocatedRuneBalance(vout, runeId) {
            const key = types_1.RuneLocation.toString(runeId);
            const balance = allocated[vout].get(key) ?? { runeId, amount: 0n };
            allocated[vout].set(key, balance);
            return balance;
        }
        if (optionArtifact.isSome()) {
            const artifact = optionArtifact.unwrap();
            const optionMint = artifact.mint;
            if (optionMint.isSome()) {
                const runeId = optionMint.unwrap();
                const runeLocation = {
                    block: Number(runeId.block),
                    tx: Number(runeId.tx),
                };
                const optionAmount = await this.mint(runeLocation, tx.txid);
                if (optionAmount.isSome()) {
                    const amount = optionAmount.unwrap();
                    const unallocatedBalance = getUnallocatedRuneBalance(runeLocation);
                    unallocatedBalance.amount = integer_1.u128.checkedAddThrow((0, integer_1.u128)(unallocatedBalance.amount), (0, integer_1.u128)(amount));
                }
            }
            const optionEtched = await this.etched(txIndex, tx, artifact);
            if ((0, artifact_1.isRunestone)(artifact)) {
                const runestone = artifact;
                if (optionEtched.isSome()) {
                    const etched = optionEtched.unwrap();
                    const unallocatedBalance = getUnallocatedRuneBalance(etched.runeId);
                    unallocatedBalance.amount = integer_1.u128.checkedAddThrow((0, integer_1.u128)(unallocatedBalance.amount), runestone.etching.unwrap().premine.unwrapOr((0, integer_1.u128)(0)));
                }
                for (const { id, amount, output } of [...runestone.edicts]) {
                    // edicts with output values greater than the number of outputs
                    // should never be produced by the edict parser
                    if (output > tx.vout.length) {
                        throw new Error('Runestone edict output should never exceed transaction output size');
                    }
                    if (id.block === 0n && id.tx === 0n && optionEtched.isNone()) {
                        continue;
                    }
                    const runeLocation = id.block === 0n && id.tx === 0n
                        ? optionEtched.unwrap().runeId
                        : { block: Number(id.block), tx: Number(id.tx) };
                    const runeLocationString = types_1.RuneLocation.toString(runeLocation);
                    const maybeBalance = unallocated.get(runeLocationString);
                    if (maybeBalance === undefined) {
                        continue;
                    }
                    let allocate = (amount, output) => {
                        if (amount > 0n) {
                            const currentAllocated = getAllocatedRuneBalance(output, runeLocation);
                            maybeBalance.amount = integer_1.u128.checkedSubThrow((0, integer_1.u128)(maybeBalance.amount), amount);
                            currentAllocated.amount = integer_1.u128.checkedAddThrow((0, integer_1.u128)(currentAllocated.amount), amount);
                        }
                    };
                    if (Number(output) === tx.vout.length) {
                        // find non-OP_RETURN outputs
                        const destinations = [...tx.vout.entries()]
                            .filter(([_, vout]) => !isScriptPubKeyHexOpReturn(vout.scriptPubKey.hex))
                            .map(([index]) => index);
                        if (destinations.length !== 0) {
                            if (amount === 0n) {
                                // if amount is zero, divide balance between eligible outputs
                                const amount = (0, integer_1.u128)((0, integer_1.u128)(maybeBalance.amount) / (0, integer_1.u128)(destinations.length));
                                const remainder = (0, integer_1.u128)(maybeBalance.amount) % (0, integer_1.u128)(destinations.length);
                                for (const [i, output] of destinations.entries()) {
                                    allocate(i < remainder ? integer_1.u128.checkedAddThrow(amount, (0, integer_1.u128)(1)) : amount, output);
                                }
                            }
                            else {
                                // if amount is non-zero, distribute amount to eligible outputs
                                for (const output of destinations) {
                                    allocate(amount < maybeBalance.amount ? amount : (0, integer_1.u128)(maybeBalance.amount), output);
                                }
                            }
                        }
                    }
                    else {
                        // Get the allocatable amount
                        allocate(amount !== 0n && amount < (0, integer_1.u128)(maybeBalance.amount)
                            ? amount
                            : (0, integer_1.u128)(maybeBalance.amount), Number(output));
                    }
                }
            }
            if (optionEtched.isSome()) {
                const { runeId, rune } = optionEtched.unwrap();
                this.createEtching(tx.txid, artifact, runeId, rune);
            }
        }
        const burned = new Map();
        function getBurnedRuneBalance(runeId) {
            const key = types_1.RuneLocation.toString(runeId);
            const balance = burned.get(key) ?? { runeId, amount: 0n };
            burned.set(key, balance);
            return balance;
        }
        if (optionArtifact.isSome() && !(0, artifact_1.isRunestone)(optionArtifact.unwrap())) {
            for (const balance of unallocated.values()) {
                const currentBalance = getBurnedRuneBalance(balance.runeId);
                currentBalance.amount = integer_1.u128.checkedAddThrow((0, integer_1.u128)(currentBalance.amount), (0, integer_1.u128)(balance.amount));
            }
        }
        else {
            const pointer = optionArtifact
                .map((artifact) => {
                if (!(0, artifact_1.isRunestone)(artifact)) {
                    throw new Error('unreachable');
                }
                return artifact.pointer;
            })
                .unwrapOr(monads_1.None);
            const optionVout = pointer
                .map((pointer) => Number(pointer))
                .inspect((pointer) => {
                if (pointer < 0 || pointer >= allocated.length)
                    throw new Error('Pointer is invalid');
            })
                .orElse(() => {
                const entry = [...tx.vout.entries()].find(([_, txOut]) => !isScriptPubKeyHexOpReturn(txOut.scriptPubKey.hex));
                return entry !== undefined ? (0, monads_1.Some)(entry[0]) : monads_1.None;
            });
            if (optionVout.isSome()) {
                const vout = optionVout.unwrap();
                for (const balance of unallocated.values()) {
                    if (balance.amount > 0) {
                        const currentBalance = getAllocatedRuneBalance(vout, balance.runeId);
                        currentBalance.amount = integer_1.u128.checkedAddThrow((0, integer_1.u128)(currentBalance.amount), (0, integer_1.u128)(balance.amount));
                    }
                }
            }
            else {
                for (const [id, balance] of unallocated) {
                    if (balance.amount > 0) {
                        const currentBalance = getBurnedRuneBalance(balance.runeId);
                        burned.set(id, {
                            runeId: balance.runeId,
                            amount: integer_1.u128.checkedAddThrow((0, integer_1.u128)(currentBalance.amount), (0, integer_1.u128)(balance.amount)),
                        });
                    }
                }
            }
        }
        // update outpoint balances
        for (const [vout, balances] of allocated.entries()) {
            if (balances.size === 0) {
                continue;
            }
            // increment burned balances
            const output = tx.vout[vout];
            if (isScriptPubKeyHexOpReturn(output.scriptPubKey.hex)) {
                for (const [id, balance] of balances) {
                    const currentBurned = getBurnedRuneBalance(balance.runeId);
                    currentBurned.amount = integer_1.u128.checkedAddThrow((0, integer_1.u128)(currentBurned.amount), (0, integer_1.u128)(balance.amount));
                }
                continue;
            }
            const etchingByRuneId = new Map(this.etchings.map((etching) => [types_1.RuneLocation.toString(etching.runeId), etching]));
            for (const balance of balances.values()) {
                const runeIdString = types_1.RuneLocation.toString(balance.runeId);
                const etching = etchingByRuneId.get(runeIdString) ?? (await this._storage.getEtching(runeIdString));
                if (etching === null) {
                    throw new Error('Rune should exist at this point');
                }
                this.utxoBalances.push({
                    runeId: balance.runeId,
                    runeTicker: etching.runeTicker,
                    amount: balance.amount,
                    scriptPubKey: Buffer.from(output.scriptPubKey.hex),
                    txid: tx.txid,
                    vout,
                    address: output.scriptPubKey.address,
                });
            }
        }
        // update entries with burned runes
        for (const [id, balance] of burned) {
            this._burnedBalancesByRuneLocation.set(id, balance);
        }
        return;
    }
    async etched(txIndex, tx, artifact) {
        let optionRune;
        if ((0, artifact_1.isRunestone)(artifact)) {
            const runestone = artifact;
            if (runestone.etching.isNone()) {
                return monads_1.None;
            }
            optionRune = runestone.etching.unwrap().rune;
        }
        else {
            const cenotaph = artifact;
            if (cenotaph.etching.isNone()) {
                return monads_1.None;
            }
            optionRune = cenotaph.etching;
        }
        let rune;
        if (optionRune.isSome()) {
            rune = optionRune.unwrap();
            if (rune.value < this._minimum.value) {
                return monads_1.None;
            }
            if (rune.reserved) {
                return monads_1.None;
            }
            if (this.etchings.find((etching) => spacedrune_1.SpacedRune.fromString(etching.runeName).rune.toString() === rune.toString())) {
                return monads_1.None;
            }
            const runeLocation = await this._storage.getRuneLocation(rune.toString());
            if (runeLocation && runeLocation.block < this.block.height) {
                return monads_1.None;
            }
            const txCommitsToRune = await this.txCommitsToRune(tx, rune);
            if (!txCommitsToRune) {
                return monads_1.None;
            }
        }
        else {
            rune = rune_1.Rune.getReserved((0, integer_1.u64)(this.block.height), (0, integer_1.u32)(txIndex));
        }
        return (0, monads_1.Some)({
            runeId: {
                block: this.block.height,
                tx: txIndex,
            },
            rune,
        });
    }
    async mint(id, txid) {
        const runeLocation = types_1.RuneLocation.toString(id);
        const etchingByRuneId = new Map(this.etchings.map((etching) => [types_1.RuneLocation.toString(etching.runeId), etching]));
        const etching = etchingByRuneId.get(runeLocation) ?? (await this._storage.getEtching(runeLocation));
        if (etching === null || !etching.valid || !etching.terms) {
            return monads_1.None;
        }
        const terms = etching.terms;
        const startRelative = terms.offset?.start !== undefined ? etching.runeId.block + Number(terms.offset.start) : null;
        const startAbsolute = terms.height?.start !== undefined ? Number(terms.height.start) : null;
        const start = startRelative !== null || startAbsolute !== null
            ? Math.max(startRelative ?? -Infinity, startAbsolute ?? -Infinity)
            : null;
        if (start !== null && this.block.height < start) {
            return monads_1.None;
        }
        const endRelative = terms.offset?.end !== undefined ? etching.runeId.block + Number(terms.offset.end) : null;
        const endAbsolute = terms.height?.end !== undefined ? Number(terms.height.end) : null;
        const end = endRelative !== null || endAbsolute !== null
            ? Math.max(endRelative ?? -Infinity, endAbsolute ?? -Infinity)
            : null;
        if (end !== null && this.block.height >= end) {
            return monads_1.None;
        }
        const cap = terms.cap ?? 0n;
        const currentBlockMints = this._mintCountsByRuneLocation.get(runeLocation) ?? {
            mint: id,
            count: 0,
        };
        this._mintCountsByRuneLocation.set(runeLocation, currentBlockMints);
        const totalMints = currentBlockMints.count +
            (await this._storage.getValidMintCount(runeLocation, this.block.height - 1));
        if (totalMints >= cap) {
            return monads_1.None;
        }
        const amount = terms.amount ?? 0n;
        currentBlockMints.count++;
        return (0, monads_1.Some)(amount);
    }
    async unallocated(tx) {
        const unallocated = new Map();
        const utxoBalancesByOutputLocation = new Map();
        for (const utxoBalance of this.utxoBalances) {
            const location = `${utxoBalance.txid}:${utxoBalance.vout}`;
            const balances = utxoBalancesByOutputLocation.get(location) ?? [];
            balances.push(utxoBalance);
            utxoBalancesByOutputLocation.set(location, balances);
        }
        for (const input of tx.vin) {
            if ('coinbase' in input) {
                continue;
            }
            const utxoBalance = utxoBalancesByOutputLocation.get(`${input.txid}:${input.vout}`) ??
                (await this._storage.getUtxoBalance(input.txid, input.vout));
            for (const additionalBalance of utxoBalance) {
                const runeId = additionalBalance.runeId;
                const runeLocation = types_1.RuneLocation.toString(runeId);
                const balance = unallocated.get(runeLocation) ?? { runeId, amount: 0n };
                unallocated.set(runeLocation, balance);
                balance.amount = integer_1.u128.checkedAddThrow((0, integer_1.u128)(balance.amount), (0, integer_1.u128)(additionalBalance.amount));
                this.spentBalances.push({
                    txid: input.txid,
                    vout: input.vout,
                    address: additionalBalance.address,
                    scriptPubKey: additionalBalance.scriptPubKey,
                    runeId: additionalBalance.runeId,
                    runeTicker: additionalBalance.runeTicker,
                    amount: additionalBalance.amount,
                    spentTxid: tx.txid,
                });
            }
        }
        return unallocated;
    }
    async txCommitsToRune(tx, rune) {
        const commitment = rune.commitment;
        for (const input of tx.vin) {
            if ('coinbase' in input) {
                continue;
            }
            const witnessStack = input.txinwitness.map((item) => Buffer.from(item, 'hex'));
            const lastWitnessElement = witnessStack[witnessStack.length - 1];
            const offset = witnessStack.length >= 2 && lastWitnessElement[0] === constants_1.TAPROOT_ANNEX_PREFIX ? 3 : 2;
            if (offset > witnessStack.length) {
                continue;
            }
            const potentiallyTapscript = witnessStack[witnessStack.length - offset];
            if (potentiallyTapscript === undefined) {
                continue;
            }
            const instructions = script_1.script.decompile(potentiallyTapscript);
            for (const instruction of instructions) {
                if (!Buffer.isBuffer(instruction)) {
                    continue;
                }
                if (Buffer.compare(instruction, commitment) !== 0) {
                    continue;
                }
                // rpc client
                const inputTxResult = await this._rpc.getrawtransaction({
                    txid: input.txid,
                    verbose: true,
                });
                if (inputTxResult.error !== null) {
                    throw inputTxResult.error;
                }
                const inputTx = inputTxResult.result;
                const isTaproot = inputTx.vout[input.vout].scriptPubKey.type === constants_1.TAPROOT_SCRIPT_PUBKEY_TYPE;
                if (!isTaproot) {
                    continue;
                }
                const commitTxHeightResult = await this._rpc.getblock({ blockhash: inputTx.blockhash });
                if (commitTxHeightResult.error !== null) {
                    throw commitTxHeightResult.error;
                }
                const commitTxHeight = commitTxHeightResult.result.height;
                const confirmations = integer_1.u128.checkedSubThrow((0, integer_1.u128)(this.block.height), (0, integer_1.u128)(commitTxHeight)) + 1n;
                if (confirmations >= constants_1.COMMIT_CONFIRMATIONS) {
                    return true;
                }
            }
        }
        return false;
    }
    createEtching(txid, artifact, runeId, rune) {
        if ((0, artifact_1.isRunestone)(artifact)) {
            const { divisibility, terms, premine, spacers, symbol } = artifact.etching.unwrap();
            this.etchings.push({
                valid: true,
                runeTicker: rune.toString(),
                runeName: new spacedrune_1.SpacedRune(rune, Number(spacers.map(Number).unwrapOr(0))).toString(),
                runeId,
                txid,
                ...(divisibility.isSome() ? { divisibility: divisibility.map(Number).unwrap() } : {}),
                ...(premine.isSome() ? { premine: premine.unwrap() } : {}),
                ...(symbol.isSome() ? { symbol: symbol.unwrap() } : {}),
                ...(terms.isSome()
                    ? {
                        terms: (() => {
                            const unwrappedTerms = terms.unwrap();
                            return {
                                ...(unwrappedTerms.amount.isSome()
                                    ? { amount: unwrappedTerms.amount.unwrap() }
                                    : {}),
                                ...(unwrappedTerms.cap.isSome() ? { cap: unwrappedTerms.cap.unwrap() } : {}),
                                ...(unwrappedTerms.height.filter((option) => option.isSome()).length
                                    ? {
                                        height: {
                                            ...(unwrappedTerms.height[0].isSome()
                                                ? { start: unwrappedTerms.height[0].unwrap() }
                                                : {}),
                                            ...(unwrappedTerms.height[1].isSome()
                                                ? { end: unwrappedTerms.height[1].unwrap() }
                                                : {}),
                                        },
                                    }
                                    : {}),
                                ...(unwrappedTerms.offset.filter((option) => option.isSome()).length
                                    ? {
                                        offset: {
                                            ...(unwrappedTerms.offset[0].isSome()
                                                ? { start: unwrappedTerms.offset[0].unwrap() }
                                                : {}),
                                            ...(unwrappedTerms.offset[1].isSome()
                                                ? { end: unwrappedTerms.offset[1].unwrap() }
                                                : {}),
                                        },
                                    }
                                    : {}),
                            };
                        })(),
                    }
                    : {}),
            });
        }
        else {
            // save failed entry
            this.etchings.push({
                valid: false,
                runeId,
                txid,
                runeTicker: rune.toString(),
                runeName: rune.toString(),
            });
        }
    }
}
exports.RuneUpdater = RuneUpdater;
//# sourceMappingURL=updater.js.map