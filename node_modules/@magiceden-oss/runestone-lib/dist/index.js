"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryDecodeRunestone = exports.isRunestone = exports.encodeRunestone = exports.Network = exports.RunestoneIndexer = exports.RuneUpdater = exports.RuneLocation = void 0;
const artifact_1 = require("./src/artifact");
const constants_1 = require("./src/constants");
const etching_1 = require("./src/etching");
const flaw_1 = require("./src/flaw");
const integer_1 = require("./src/integer");
const monads_1 = require("./src/monads");
const runeid_1 = require("./src/runeid");
const runestone_1 = require("./src/runestone");
const spacedrune_1 = require("./src/spacedrune");
var indexer_1 = require("./src/indexer");
Object.defineProperty(exports, "RuneLocation", { enumerable: true, get: function () { return indexer_1.RuneLocation; } });
Object.defineProperty(exports, "RuneUpdater", { enumerable: true, get: function () { return indexer_1.RuneUpdater; } });
Object.defineProperty(exports, "RunestoneIndexer", { enumerable: true, get: function () { return indexer_1.RunestoneIndexer; } });
var network_1 = require("./src/network");
Object.defineProperty(exports, "Network", { enumerable: true, get: function () { return network_1.Network; } });
function getFlawString(flaw) {
    switch (flaw) {
        case flaw_1.Flaw.EDICT_OUTPUT:
            return 'edict_output';
        case flaw_1.Flaw.EDICT_RUNE_ID:
            return 'edict_rune_id';
        case flaw_1.Flaw.INVALID_SCRIPT:
            return 'invalid_script';
        case flaw_1.Flaw.OPCODE:
            return 'opcode';
        case flaw_1.Flaw.SUPPLY_OVERFLOW:
            return 'supply_overflow';
        case flaw_1.Flaw.TRAILING_INTEGERS:
            return 'trailing_integers';
        case flaw_1.Flaw.TRUNCATED_FIELD:
            return 'truncated_field';
        case flaw_1.Flaw.UNRECOGNIZED_EVEN_TAG:
            return 'unrecognized_even_tag';
        case flaw_1.Flaw.UNRECOGNIZED_FLAG:
            return 'unrecognized_flag';
        case flaw_1.Flaw.VARINT:
            return 'varint';
    }
}
// Helper functions to ensure numbers fit the desired type correctly
const u8Strict = (n) => {
    const bigN = BigInt(n);
    if (bigN < 0n || bigN > integer_1.u8.MAX) {
        throw Error('u8 overflow');
    }
    return (0, integer_1.u8)(bigN);
};
const u32Strict = (n) => {
    const bigN = BigInt(n);
    if (bigN < 0n || bigN > integer_1.u32.MAX) {
        throw Error('u32 overflow');
    }
    return (0, integer_1.u32)(bigN);
};
const u64Strict = (n) => {
    const bigN = BigInt(n);
    if (bigN < 0n || bigN > integer_1.u64.MAX) {
        throw Error('u64 overflow');
    }
    return (0, integer_1.u64)(bigN);
};
const u128Strict = (n) => {
    const bigN = BigInt(n);
    if (bigN < 0n || bigN > integer_1.u128.MAX) {
        throw Error('u128 overflow');
    }
    return (0, integer_1.u128)(bigN);
};
// TODO: Add unit tests
/**
 * Low level function to allow for encoding runestones without any indexer and transaction checks.
 *
 * @param runestone runestone spec to encode as runestone
 * @returns encoded runestone bytes
 * @throws Error if encoding is detected to be considered a cenotaph
 */
function encodeRunestone(runestone) {
    const mint = runestone.mint
        ? (0, monads_1.Some)(new runeid_1.RuneId(u64Strict(runestone.mint.block), u32Strict(runestone.mint.tx)))
        : monads_1.None;
    const pointer = runestone.pointer !== undefined ? (0, monads_1.Some)(runestone.pointer).map(u32Strict) : monads_1.None;
    const edicts = (runestone.edicts ?? []).map((edict) => ({
        id: new runeid_1.RuneId(u64Strict(edict.id.block), u32Strict(edict.id.tx)),
        amount: u128Strict(edict.amount),
        output: u32Strict(edict.output),
    }));
    let etching = monads_1.None;
    let etchingCommitment = undefined;
    if (runestone.etching) {
        const etchingSpec = runestone.etching;
        const spacedRune = etchingSpec.runeName
            ? spacedrune_1.SpacedRune.fromString(etchingSpec.runeName)
            : undefined;
        const rune = spacedRune?.rune !== undefined ? (0, monads_1.Some)(spacedRune.rune) : monads_1.None;
        if (etchingSpec.symbol &&
            !(etchingSpec.symbol.length === 1 ||
                (etchingSpec.symbol.length === 2 && etchingSpec.symbol.codePointAt(0) >= 0x10000))) {
            throw Error('Symbol must be one code point');
        }
        const divisibility = etchingSpec.divisibility !== undefined ? (0, monads_1.Some)(etchingSpec.divisibility).map(u8Strict) : monads_1.None;
        const premine = etchingSpec.premine !== undefined ? (0, monads_1.Some)(etchingSpec.premine).map(u128Strict) : monads_1.None;
        const spacers = spacedRune?.spacers !== undefined && spacedRune.spacers !== 0
            ? (0, monads_1.Some)(u32Strict(spacedRune.spacers))
            : monads_1.None;
        const symbol = etchingSpec.symbol ? (0, monads_1.Some)(etchingSpec.symbol) : monads_1.None;
        if (divisibility.isSome() && divisibility.unwrap() > constants_1.MAX_DIVISIBILITY) {
            throw Error(`Divisibility is greater than protocol max ${constants_1.MAX_DIVISIBILITY}`);
        }
        let terms = monads_1.None;
        if (etchingSpec.terms) {
            const termsSpec = etchingSpec.terms;
            const amount = termsSpec.amount !== undefined ? (0, monads_1.Some)(termsSpec.amount).map(u128Strict) : monads_1.None;
            const cap = termsSpec.cap !== undefined ? (0, monads_1.Some)(termsSpec.cap).map(u128Strict) : monads_1.None;
            const height = termsSpec.height
                ? [
                    termsSpec.height.start !== undefined
                        ? (0, monads_1.Some)(termsSpec.height.start).map(u64Strict)
                        : monads_1.None,
                    termsSpec.height.end !== undefined ? (0, monads_1.Some)(termsSpec.height.end).map(u64Strict) : monads_1.None,
                ]
                : [monads_1.None, monads_1.None];
            const offset = termsSpec.offset
                ? [
                    termsSpec.offset.start !== undefined
                        ? (0, monads_1.Some)(termsSpec.offset.start).map(u64Strict)
                        : monads_1.None,
                    termsSpec.offset.end !== undefined ? (0, monads_1.Some)(termsSpec.offset.end).map(u64Strict) : monads_1.None,
                ]
                : [monads_1.None, monads_1.None];
            if (amount.isSome() && cap.isSome() && amount.unwrap() * cap.unwrap() > integer_1.u128.MAX) {
                throw Error('Terms overflow with amount times cap');
            }
            terms = (0, monads_1.Some)({ amount, cap, height, offset });
        }
        const turbo = etchingSpec.turbo ?? false;
        etching = (0, monads_1.Some)(new etching_1.Etching(divisibility, rune, spacers, symbol, terms, premine, turbo));
        etchingCommitment = rune.isSome() ? rune.unwrap().commitment : undefined;
    }
    return {
        encodedRunestone: new runestone_1.Runestone(mint, pointer, edicts, etching).encipher(),
        etchingCommitment,
    };
}
exports.encodeRunestone = encodeRunestone;
function isRunestone(artifact) {
    return !('flaws' in artifact);
}
exports.isRunestone = isRunestone;
function tryDecodeRunestone(tx) {
    const optionArtifact = runestone_1.Runestone.decipher(tx);
    if (optionArtifact.isNone()) {
        return null;
    }
    const artifact = optionArtifact.unwrap();
    if ((0, artifact_1.isRunestone)(artifact)) {
        const runestone = artifact;
        const etching = () => runestone.etching.unwrap();
        const terms = () => etching().terms.unwrap();
        return {
            ...(runestone.etching.isSome()
                ? {
                    etching: {
                        ...(etching().divisibility.isSome()
                            ? { divisibility: etching().divisibility.map(Number).unwrap() }
                            : {}),
                        ...(etching().premine.isSome() ? { premine: etching().premine.unwrap() } : {}),
                        ...(etching().rune.isSome()
                            ? {
                                runeName: new spacedrune_1.SpacedRune(etching().rune.unwrap(), etching().spacers.map(Number).unwrapOr(0)).toString(),
                            }
                            : {}),
                        ...(etching().symbol.isSome() ? { symbol: etching().symbol.unwrap() } : {}),
                        ...(etching().terms.isSome()
                            ? {
                                terms: {
                                    ...(terms().amount.isSome() ? { amount: terms().amount.unwrap() } : {}),
                                    ...(terms().cap.isSome() ? { cap: terms().cap.unwrap() } : {}),
                                    ...(terms().height.find((option) => option.isSome())
                                        ? {
                                            height: {
                                                ...(terms().height[0].isSome()
                                                    ? { start: terms().height[0].unwrap() }
                                                    : {}),
                                                ...(terms().height[1].isSome()
                                                    ? { end: terms().height[1].unwrap() }
                                                    : {}),
                                            },
                                        }
                                        : {}),
                                    ...(terms().offset.find((option) => option.isSome())
                                        ? {
                                            offset: {
                                                ...(terms().offset[0].isSome()
                                                    ? { start: terms().offset[0].unwrap() }
                                                    : {}),
                                                ...(terms().offset[1].isSome()
                                                    ? { end: terms().offset[1].unwrap() }
                                                    : {}),
                                            },
                                        }
                                        : {}),
                                },
                            }
                            : {}),
                        turbo: etching().turbo,
                    },
                }
                : {}),
            ...(runestone.mint.isSome()
                ? {
                    mint: {
                        block: runestone.mint.unwrap().block,
                        tx: Number(runestone.mint.unwrap().tx),
                    },
                }
                : {}),
            ...(runestone.pointer.isSome() ? { pointer: Number(runestone.pointer.unwrap()) } : {}),
            ...(runestone.edicts.length
                ? {
                    edicts: runestone.edicts.map((edict) => ({
                        id: {
                            block: edict.id.block,
                            tx: Number(edict.id.tx),
                        },
                        amount: edict.amount,
                        output: Number(edict.output),
                    })),
                }
                : {}),
        };
    }
    else {
        const cenotaph = artifact;
        return {
            flaws: cenotaph.flaws.map(getFlawString),
            ...(cenotaph.etching.isSome() ? { etching: cenotaph.etching.unwrap().toString() } : {}),
            ...(cenotaph.mint.isSome()
                ? { mint: { block: cenotaph.mint.unwrap().block, tx: Number(cenotaph.mint.unwrap().tx) } }
                : {}),
        };
    }
}
exports.tryDecodeRunestone = tryDecodeRunestone;
//# sourceMappingURL=index.js.map