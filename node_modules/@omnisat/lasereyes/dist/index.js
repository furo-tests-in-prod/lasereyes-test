"use client";
import { createContext as vU, useContext as EU, useMemo as y1, useState as kU, useEffect as xU, useCallback as yn, useSyncExternalStore as AU } from "react";
import { jsx as L, jsxs as Pt } from "react/jsx-runtime";
var SU = Object.defineProperty, _U = (e, t, r) => t in e ? SU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ke = (e, t, r) => _U(e, typeof t != "symbol" ? t + "" : t, r);
function IU(e, t) {
  for (var r = 0; r < t.length; r++) {
    const n = t[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const o in n)
        if (o !== "default" && !(o in e)) {
          const a = Object.getOwnPropertyDescriptor(n, o);
          a && Object.defineProperty(e, o, a.get ? a : {
            enumerable: !0,
            get: () => n[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
let kw = Symbol("clean"), ei = [], Es = 0;
const g0 = 4;
let xw = (e) => {
  let t = [], r = {
    get() {
      return r.lc || r.listen(() => {
      })(), r.value;
    },
    lc: 0,
    listen(n) {
      return r.lc = t.push(n), () => {
        for (let a = Es + g0; a < ei.length; )
          ei[a] === n ? ei.splice(a, g0) : a += g0;
        let o = t.indexOf(n);
        ~o && (t.splice(o, 1), --r.lc || r.off());
      };
    },
    notify(n, o) {
      let a = !ei.length;
      for (let i of t)
        ei.push(
          i,
          r.value,
          n,
          o
        );
      if (a) {
        for (Es = 0; Es < ei.length; Es += g0)
          ei[Es](
            ei[Es + 1],
            ei[Es + 2],
            ei[Es + 3]
          );
        ei.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(n) {
      let o = r.value;
      o !== n && (r.value = n, r.notify(o));
    },
    subscribe(n) {
      let o = r.listen(n);
      return n(r.value), o;
    },
    value: e
  };
  return process.env.NODE_ENV !== "production" && (r[kw] = () => {
    t = [], r.lc = 0, r.off();
  }), r;
};
const TU = 5, Pl = 6, m0 = 10;
let PU = (e, t, r, n) => (e.events = e.events || {}, e.events[r + m0] || (e.events[r + m0] = n((o) => {
  e.events[r].reduceRight((a, i) => (i(a), a), {
    shared: {},
    ...o
  });
})), e.events[r] = e.events[r] || [], e.events[r].push(t), () => {
  let o = e.events[r], a = o.indexOf(t);
  o.splice(a, 1), o.length || (delete e.events[r], e.events[r + m0](), delete e.events[r + m0]);
}), OU = 1e3, $U = (e, t) => PU(e, (r) => {
  let n = t(r);
  n && e.events[Pl].push(n);
}, TU, (r) => {
  let n = e.listen;
  e.listen = (...a) => (!e.lc && !e.active && (e.active = !0, r()), n(...a));
  let o = e.off;
  if (e.events[Pl] = [], e.off = () => {
    o(), setTimeout(() => {
      if (e.active && !e.lc) {
        e.active = !1;
        for (let a of e.events[Pl]) a();
        e.events[Pl] = [];
      }
    }, OU);
  }, process.env.NODE_ENV !== "production") {
    let a = e[kw];
    e[kw] = () => {
      for (let i of e.events[Pl]) i();
      e.events[Pl] = [], e.active = !1, a();
    };
  }
  return () => {
    e.listen = n, e.off = o;
  };
}), CU = (e) => {
  e.listen(() => {
  });
};
function Yo(e, t, r) {
  let n = /* @__PURE__ */ new Set([...t, void 0]);
  return e.listen((o, a, i) => {
    n.has(i) && r(o, a, i);
  });
}
let Nk = (e = {}) => {
  let t = xw(e);
  return t.setKey = function(r, n) {
    let o = t.value;
    typeof n > "u" && r in t.value ? (t.value = { ...t.value }, delete t.value[r], t.notify(o, r)) : t.value[r] !== n && (t.value = {
      ...t.value,
      [r]: n
    }, t.notify(o, r));
  }, t;
};
const th = "oyl", Vl = "unisat", lc = "xverse", fc = "phantom", rh = "leather", vu = "magic-eden", nh = "okx", Gl = "wizz", dc = "orange", hc = "op_net", Zl = "sparrow", tf = "p2tr", BU = "p2pkh", NU = "p2sh-p2wpkh", Aw = "p2wpkh", g8e = "p2psh", UU = "p2wsh", B8 = "p2sh", m8e = {
  leather: {
    name: "leather",
    url: "https://leather.io/install-extension"
  },
  "magic-eden": {
    name: "magic-eden",
    url: "https://wallet.magiceden.io/"
  },
  okx: {
    name: "okx",
    url: "https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge"
  },
  op_net: {
    name: "op_net",
    url: "https://opnet.org/"
  },
  orange: {
    name: "orange",
    url: "https://www.orangewallet.com/"
  },
  oyl: {
    name: "oyl",
    url: "https://www.oyl.io/#get-wallet"
  },
  phantom: {
    name: "phantom",
    url: "https://phantom.app/download"
  },
  sparrow: {
    name: "sparrow",
    url: "https://sparrowwallet.com/"
  },
  unisat: {
    name: "unisat",
    url: "https://unisat.io/download"
  },
  wizz: {
    name: "wizz",
    url: "https://wizzwallet.io/#extension"
  },
  xverse: {
    name: "xverse",
    url: "https://www.xverse.app/download"
  }
}, Db = "defaultWallet", $i = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
}, RU = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
function zU(e) {
  if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return !1;
  const t = e[3];
  if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return !1;
  const r = e[5 + t];
  return !(r === 0 || 6 + t + r !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128));
}
function jU(e) {
  if (e.length < 8) throw new Error("DER sequence length is too short");
  if (e.length > 72) throw new Error("DER sequence length is too long");
  if (e[0] !== 48) throw new Error("Expected DER sequence");
  if (e[1] !== e.length - 2)
    throw new Error("DER sequence length is invalid");
  if (e[2] !== 2) throw new Error("Expected DER integer");
  const t = e[3];
  if (t === 0) throw new Error("R length is zero");
  if (5 + t >= e.length) throw new Error("R length is too long");
  if (e[4 + t] !== 2) throw new Error("Expected DER integer (2)");
  const r = e[5 + t];
  if (r === 0) throw new Error("S length is zero");
  if (6 + t + r !== e.length) throw new Error("S length is invalid");
  if (e[4] & 128) throw new Error("R value is negative");
  if (t > 1 && e[4] === 0 && !(e[5] & 128))
    throw new Error("R value excessively padded");
  if (e[t + 6] & 128) throw new Error("S value is negative");
  if (r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: e.slice(4, 4 + t),
    s: e.slice(6 + t)
  };
}
function LU(e, t) {
  const r = e.length, n = t.length;
  if (r === 0) throw new Error("R length is zero");
  if (n === 0) throw new Error("S length is zero");
  if (r > 33) throw new Error("R length is too long");
  if (n > 33) throw new Error("S length is too long");
  if (e[0] & 128) throw new Error("R value is negative");
  if (t[0] & 128) throw new Error("S value is negative");
  if (r > 1 && e[0] === 0 && !(e[1] & 128))
    throw new Error("R value excessively padded");
  if (n > 1 && t[0] === 0 && !(t[1] & 128))
    throw new Error("S value excessively padded");
  const o = new Uint8Array(6 + r + n);
  return o[0] = 48, o[1] = o.length - 2, o[2] = 2, o[3] = e.length, o.set(e, 4), o[4 + r] = 2, o[5 + r] = t.length, o.set(t, 6 + r), o;
}
const jt = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
}, Uk = {};
for (const e of Object.keys(jt)) {
  const t = jt[e];
  Uk[t] = e;
}
const L1 = "0123456789abcdefABCDEF", H1 = L1.split("").map((e) => e.codePointAt(0)), F1 = Array(256).fill(!0).map((e, t) => {
  const r = String.fromCodePoint(t), n = L1.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), Rk = new TextEncoder(), zk = new TextDecoder();
function HU(e) {
  return zk.decode(e);
}
function FU(e) {
  return Rk.encode(e);
}
function gr(e) {
  const t = e.reduce((o, a) => o + a.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const o of e)
    r.set(o, n), n += o.length;
  return r;
}
function qe(e) {
  const t = e || new Uint8Array();
  return t.length > 512 ? MU(t) : DU(t);
}
function DU(e) {
  let t = "";
  for (let r = 0; r < e.length; ++r)
    t += L1[F1[H1[e[r] >> 4]]], t += L1[F1[H1[e[r] & 15]]];
  return t;
}
function MU(e) {
  const t = new Uint8Array(e.length * 2);
  for (let r = 0; r < e.length; ++r)
    t[r * 2] = H1[e[r] >> 4], t[r * 2 + 1] = H1[e[r] & 15];
  return zk.decode(t);
}
function hs(e) {
  const t = Rk.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let n;
  for (n = 0; n < r.length; n++) {
    const o = F1[t[n * 2]], a = F1[t[n * 2 + 1]];
    if (o === void 0 || a === void 0)
      break;
    r[n] = o << 4 | a;
  }
  return n === r.length ? r : r.slice(0, n);
}
function KU(e) {
  return btoa(String.fromCharCode(...e));
}
function jk(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t.charCodeAt(n);
  return r;
}
function fe(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; ++n)
    if (e[n] !== t[n])
      return e[n] < t[n] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function wo(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  return e[t] = r, t + 1;
}
function qU(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function hp(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function VU(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  return n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function ns(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  return e[t];
}
function GU(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function Gf(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function Lk(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 2147483647 || r < -2147483648)
    throw new Error(`The value of "value" is out of range. It must be >= -2147483648 and <= 2147483647. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function Hk(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n)
    throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function ZU(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    const n = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24 >>> 0);
    return e[t + 3] <= 127 ? n : n - 4294967296;
  } else {
    const n = (e[t] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];
    return e[t] <= 127 ? n : n - 4294967296;
  }
}
function Fk(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  r = r.toUpperCase();
  let n = 0n;
  if (r === "LE")
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? n : n - 0x10000000000000000n;
  {
    let o = 0n;
    return o = (o << 8n) + BigInt(e[t]), o = (o << 8n) + BigInt(e[t + 1]), o = (o << 8n) + BigInt(e[t + 2]), o = (o << 8n) + BigInt(e[t + 3]), o = (o << 8n) + BigInt(e[t + 4]), o = (o << 8n) + BigInt(e[t + 5]), o = (o << 8n) + BigInt(e[t + 6]), o = (o << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? o : o - 0x10000000000000000n;
  }
}
function Dk(e) {
  return e < jt.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5;
}
function WU(e, t, r) {
  const n = Dk(t);
  return n === 1 ? wo(e, r, t) : n === 2 ? (wo(e, r, jt.OP_PUSHDATA1), wo(e, r + 1, t)) : n === 3 ? (wo(e, r, jt.OP_PUSHDATA2), qU(e, r + 1, t, "LE")) : (wo(e, r, jt.OP_PUSHDATA4), hp(e, r + 1, t, "LE")), n;
}
function XU(e, t) {
  const r = ns(e, t);
  let n, o;
  if (r < jt.OP_PUSHDATA1)
    n = r, o = 1;
  else if (r === jt.OP_PUSHDATA1) {
    if (t + 2 > e.length) return null;
    n = ns(e, t + 1), o = 2;
  } else if (r === jt.OP_PUSHDATA2) {
    if (t + 3 > e.length) return null;
    n = GU(e, t + 1, "LE"), o = 3;
  } else {
    if (t + 5 > e.length) return null;
    if (r !== jt.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    n = Gf(e, t + 1, "LE"), o = 5;
  }
  return {
    opcode: r,
    number: n,
    size: o
  };
}
function YU(e) {
  return e > 2147483647 ? 5 : e > 8388607 ? 4 : e > 32767 ? 3 : e > 127 ? 2 : e > 0 ? 1 : 0;
}
function JU(e) {
  let t = Math.abs(e);
  const r = YU(t), n = new Uint8Array(r), o = e < 0;
  for (let a = 0; a < r; ++a)
    wo(n, a, t & 255), t >>= 8;
  return n[r - 1] & 128 ? wo(n, r - 1, o ? 128 : 0) : o && (n[r - 1] |= 128), n;
}
function QU(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? void 0,
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? void 0,
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? void 0
  };
}
function eR(e, t) {
  var r;
  return (r = void 0) == null ? void 0 : r.get(t);
}
function gh(e) {
  var t, r;
  const n = typeof e;
  return n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n === "object" || n === "function" ? (e && ((r = (t = Object.getPrototypeOf(e)) == null ? void 0 : t.constructor) == null ? void 0 : r.name)) ?? "null" : n;
}
function kn(e, t, r, n, o) {
  const a = o && "input" in o ? o.input : r.value, i = (o == null ? void 0 : o.expected) ?? e.expects ?? null, s = (o == null ? void 0 : o.received) ?? gh(a), u = {
    kind: e.kind,
    type: e.type,
    input: a,
    expected: i,
    received: s,
    message: `Invalid ${t}: ${i ? `Expected ${i} but r` : "R"}eceived ${s}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, l = e.kind === "schema", c = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? eR(e.reference, u.lang) ?? (l ? (u.lang, void 0) : null) ?? n.message ?? (u.lang, void 0);
  c && (u.message = typeof c == "function" ? c(u) : c), l && (r.typed = !1), r.issues ? r.issues.push(u) : r.issues = [u];
}
function tR(e, t) {
  const r = [...new Set(e)];
  return r.length > 1 ? `(${r.join(` ${t} `)})` : r[0] ?? "never";
}
var rR = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(t) {
    super(t[0].message), ke(this, "issues"), this.name = "ValiError", this.issues = t;
  }
};
function Mk(e, t) {
  return {
    kind: "validation",
    type: "every_item",
    reference: Mk,
    async: !1,
    expects: null,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !r.value.every(this.requirement) && kn(this, "item", r, n), r;
    }
  };
}
function N8(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: N8,
    async: !1,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && kn(this, "integer", t, r), t;
    }
  };
}
function Kk(e, t) {
  return {
    kind: "validation",
    type: "length",
    reference: Kk,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length !== this.requirement && kn(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function Sm(e, t) {
  return {
    kind: "validation",
    type: "max_value",
    reference: Sm,
    async: !1,
    expects: `<=${e instanceof Date ? e.toJSON() : gh(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value > this.requirement && kn(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : gh(r.value)
      }), r;
    }
  };
}
function _m(e, t) {
  return {
    kind: "validation",
    type: "min_value",
    reference: _m,
    async: !1,
    expects: `>=${e instanceof Date ? e.toJSON() : gh(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value < this.requirement && kn(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : gh(r.value)
      }), r;
    }
  };
}
function qk(e, t) {
  return {
    kind: "validation",
    type: "regex",
    reference: qk,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.test(r.value) && kn(this, "format", r, n), r;
    }
  };
}
function U8(e, t, r) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, r)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function Im(e, t) {
  return !e._run({ typed: !1, value: t }, { abortEarly: !0 }).issues;
}
function Vk() {
  return {
    kind: "schema",
    type: "any",
    reference: Vk,
    expects: "any",
    async: !1,
    _run(e) {
      return e.typed = !0, e;
    }
  };
}
function Yn(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: Yn,
    expects: "Array",
    async: !1,
    item: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (Array.isArray(a)) {
        r.typed = !0, r.value = [];
        for (let i = 0; i < a.length; i++) {
          const s = a[i], u = this.item._run({ typed: !1, value: s }, n);
          if (u.issues) {
            const l = {
              type: "array",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), r.value.push(u.value);
        }
      } else
        kn(this, "type", r, n);
      return r;
    }
  };
}
function Gk(e) {
  return {
    kind: "schema",
    type: "bigint",
    reference: Gk,
    expects: "bigint",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "bigint" ? t.typed = !0 : kn(this, "type", t, r), t;
    }
  };
}
function xi(e, t) {
  return {
    kind: "schema",
    type: "custom",
    reference: xi,
    expects: "unknown",
    async: !1,
    check: e,
    message: t,
    _run(r, n) {
      return this.check(r.value) ? r.typed = !0 : kn(this, "type", r, n), r;
    }
  };
}
function Tm(e, t) {
  return {
    kind: "schema",
    type: "instance",
    reference: Tm,
    expects: e.name,
    async: !1,
    class: e,
    message: t,
    _run(r, n) {
      return r.value instanceof this.class ? r.typed = !0 : kn(this, "type", r, n), r;
    }
  };
}
function Sw(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullable",
    reference: Sw,
    expects: `(${e.expects} | null)`,
    async: !1,
    wrapped: e,
    _run(n, o) {
      return n.value === null && ("default" in this && (n.value = U8(
        this,
        n,
        o
      )), n.value === null) ? (n.typed = !0, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function Zk(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullish",
    reference: Zk,
    expects: `(${e.expects} | null | undefined)`,
    async: !1,
    wrapped: e,
    _run(n, o) {
      return (n.value === null || n.value === void 0) && ("default" in this && (n.value = U8(
        this,
        n,
        o
      )), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function Zn(e) {
  return {
    kind: "schema",
    type: "number",
    reference: Zn,
    expects: "number",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : kn(this, "type", t, r), t;
    }
  };
}
function Ur(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: Ur,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (a && typeof a == "object") {
        r.typed = !0, r.value = {};
        for (const i in this.entries) {
          const s = a[i], u = this.entries[i]._run(
            { typed: !1, value: s },
            n
          );
          if (u.issues) {
            const l = {
              type: "object",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), (u.value !== void 0 || i in a) && (r.value[i] = u.value);
        }
      } else
        kn(this, "type", r, n);
      return r;
    }
  };
}
function D1(e, ...t) {
  const r = {
    kind: "schema",
    type: "optional",
    reference: D1,
    expects: `(${e.expects} | undefined)`,
    async: !1,
    wrapped: e,
    _run(n, o) {
      return n.value === void 0 && ("default" in this && (n.value = U8(
        this,
        n,
        o
      )), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function il(e) {
  return {
    kind: "schema",
    type: "string",
    reference: il,
    expects: "string",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = !0 : kn(this, "type", t, r), t;
    }
  };
}
function ta(e, t) {
  return {
    kind: "schema",
    type: "tuple",
    reference: ta,
    expects: "Array",
    async: !1,
    items: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (Array.isArray(a)) {
        r.typed = !0, r.value = [];
        for (let i = 0; i < this.items.length; i++) {
          const s = a[i], u = this.items[i]._run(
            { typed: !1, value: s },
            n
          );
          if (u.issues) {
            const l = {
              type: "array",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), r.value.push(u.value);
        }
      } else
        kn(this, "type", r, n);
      return r;
    }
  };
}
function f6(e) {
  let t;
  if (e)
    for (const r of e)
      t ? t.push(...r.issues) : t = r.issues;
  return t;
}
function R8(e, t) {
  return {
    kind: "schema",
    type: "union",
    reference: R8,
    expects: tR(
      e.map((r) => r.expects),
      "|"
    ),
    async: !1,
    options: e,
    message: t,
    _run(r, n) {
      let o, a, i;
      for (const s of this.options) {
        const u = s._run(
          { typed: !1, value: r.value },
          n
        );
        if (u.typed)
          if (u.issues)
            a ? a.push(u) : a = [u];
          else {
            o = u;
            break;
          }
        else
          i ? i.push(u) : i = [u];
      }
      if (o)
        return o;
      if (a) {
        if (a.length === 1)
          return a[0];
        kn(this, "type", r, n, {
          issues: f6(a)
        }), r.typed = !0;
      } else {
        if ((i == null ? void 0 : i.length) === 1)
          return i[0];
        kn(this, "type", r, n, {
          issues: f6(i)
        });
      }
      return r;
    }
  };
}
function cr(e, t, r) {
  const n = e._run(
    { typed: !1, value: t },
    QU(r)
  );
  if (n.issues)
    throw new rR(n.issues);
  return n.value;
}
function $u(e, t) {
  const r = {};
  for (const n in e.entries)
    r[n] = D1(e.entries[n]);
  return { ...e, entries: r };
}
function Zf(...e) {
  return {
    ...e[0],
    pipe: e,
    _run(t, r) {
      for (const n of e)
        if (n.kind !== "metadata") {
          if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
            t.typed = !1;
            break;
          }
          (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
        }
      return t;
    }
  };
}
const d6 = new Uint8Array(32), h6 = hs(
  "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
), Vr = (e) => Zf(Tm(Uint8Array), Kk(e));
function mh(e, t) {
  return e.length !== t.length ? !1 : e.every((r, n) => fe(r, t[n]) === 0);
}
function hi(e) {
  if (!(e instanceof Uint8Array) || e.length < 33) return !1;
  const t = e[0], r = e.slice(1, 33);
  if (fe(d6, r) === 0 || fe(r, h6) >= 0) return !1;
  if ((t === 2 || t === 3) && e.length === 33)
    return !0;
  const n = e.slice(33);
  return fe(d6, n) === 0 || fe(n, h6) >= 0 ? !1 : t === 4 && e.length === 65;
}
const b1 = 254;
function z8(e) {
  return !e || !("output" in e) || !(e.output instanceof Uint8Array) ? !1 : e.version !== void 0 ? (e.version & b1) === e.version : !0;
}
function Wk(e) {
  return Array.isArray(e) ? e.length !== 2 ? !1 : e.every((t) => Wk(t)) : z8(e);
}
const nR = Vr(32), oR = Vr(20), p6 = Vr(32), Rt = Tm(Uint8Array);
Zf(il(), qk(/^([0-9a-f]{2})+$/i));
const iR = Zf(
  Zn(),
  N8(),
  _m(0),
  Sm(255)
), Ha = Zf(
  Zn(),
  N8(),
  _m(0),
  Sm(4294967295)
), Mb = Zf(
  Gk(),
  _m(0n),
  Sm(0x7fffffffffffffffn)
), g6 = (e) => Ur(
  Object.entries(e).reduce(
    (t, r) => ({ ...t, [r[0]]: Zk(r[1]) }),
    {}
  )
), m6 = new Uint8Array(1);
function y6(e) {
  let t = 0;
  for (; e[t] === 0; ) ++t;
  return t === e.length ? m6 : (e = e.slice(t), e[0] & 128 ? gr([m6, e]) : e);
}
function b6(e) {
  e[0] === 0 && (e = e.slice(1));
  const t = new Uint8Array(32), r = Math.max(0, 32 - e.length);
  return t.set(e, r), t;
}
function aR(e) {
  const t = ns(e, e.length - 1);
  if (!L8(t))
    throw new Error("Invalid hashType " + t);
  const r = jU(e.subarray(0, -1)), n = b6(r.r), o = b6(r.s);
  return { signature: gr([n, o]), hashType: t };
}
function sR(e, t) {
  if (cr(
    Ur({
      signature: Vr(64),
      hashType: iR
    }),
    { signature: e, hashType: t }
  ), !L8(t))
    throw new Error("Invalid hashType " + t);
  const r = new Uint8Array(1);
  wo(r, 0, t);
  const n = y6(e.slice(0, 32)), o = y6(e.slice(32, 64));
  return gr([LU(n, o), r]);
}
const uR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: aR,
  encode: sR
}, Symbol.toStringTag, { value: "Module" })), Xk = jt.OP_RESERVED, Yk = Yn(R8([Tm(Uint8Array), Zn()]));
function cR(e) {
  return Im(Zn(), e) && (e === jt.OP_0 || e >= jt.OP_1 && e <= jt.OP_16 || e === jt.OP_1NEGATE);
}
function Jk(e) {
  return Im(Rt, e) || cR(e);
}
function j8(e) {
  return Im(Zf(Vk(), Mk(Jk)), e);
}
function Qk(e) {
  return e.length - e.filter(Jk).length;
}
function M1(e) {
  if (e.length === 0) return jt.OP_0;
  if (e.length === 1) {
    if (e[0] >= 1 && e[0] <= 16) return Xk + e[0];
    if (e[0] === 129) return jt.OP_1NEGATE;
  }
}
function ex(e) {
  return e instanceof Uint8Array;
}
function lR(e) {
  return Im(Yk, e);
}
function K1(e) {
  return e instanceof Uint8Array;
}
function Jn(e) {
  if (ex(e)) return e;
  cr(Yk, e);
  const t = e.reduce((o, a) => K1(a) ? a.length === 1 && M1(a) !== void 0 ? o + 1 : o + Dk(a.length) + a.length : o + 1, 0), r = new Uint8Array(t);
  let n = 0;
  if (e.forEach((o) => {
    if (K1(o)) {
      const a = M1(o);
      if (a !== void 0) {
        wo(r, n, a), n += 1;
        return;
      }
      n += WU(r, o.length, n), r.set(o, n), n += o.length;
    } else
      wo(r, n, o), n += 1;
  }), n !== r.length) throw new Error("Could not decode chunks");
  return r;
}
function fr(e) {
  if (lR(e)) return e;
  cr(Rt, e);
  const t = [];
  let r = 0;
  for (; r < e.length; ) {
    const n = e[r];
    if (n > jt.OP_0 && n <= jt.OP_PUSHDATA4) {
      const o = XU(e, r);
      if (o === null || (r += o.size, r + o.number > e.length)) return null;
      const a = e.slice(r, r + o.number);
      r += o.number;
      const i = M1(a);
      i !== void 0 ? t.push(i) : t.push(a);
    } else
      t.push(n), r += 1;
  }
  return t;
}
function fR(e) {
  if (ex(e) && (e = fr(e)), !e)
    throw new Error("Could not convert invalid chunks to ASM");
  return e.map((t) => {
    if (K1(t)) {
      const r = M1(t);
      if (r === void 0) return qe(t);
      t = r;
    }
    return Uk[t];
  }).join(" ");
}
function dR(e) {
  return e = fr(e), cr(xi(j8), e), e.map((t) => K1(t) ? t : t === jt.OP_0 ? new Uint8Array(0) : JU(t - Xk));
}
function hR(e) {
  return hi(e);
}
function L8(e) {
  const t = e & -129;
  return t > 0 && t < 4;
}
function os(e) {
  return !(e instanceof Uint8Array) || !L8(e[e.length - 1]) ? !1 : zU(e.slice(0, -1));
}
const oh = uR;
function ze(e, t, r) {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !0,
    get() {
      const n = r.call(this);
      return this[t] = n, n;
    },
    set(n) {
      Object.defineProperty(this, t, {
        configurable: !0,
        enumerable: !0,
        value: n,
        writable: !0
      });
    }
  });
}
function Go(e) {
  let t;
  return () => (t !== void 0 || (t = e()), t);
}
const Hl = jt, y0 = Hl.OP_RESERVED;
function Pm(e, t) {
  if (!e.input && !e.output && !(e.pubkeys && e.m !== void 0) && !e.signatures)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {});
  function r(s) {
    return os(s) || (t.allowIncomplete && s === Hl.OP_0) !== void 0;
  }
  cr(
    $u(
      Ur({
        network: Ur({}),
        m: Zn(),
        n: Zn(),
        output: Rt,
        pubkeys: Yn(xi(hi), "Received invalid pubkey"),
        signatures: Yn(
          xi(r),
          "Expected signature to be of type isAcceptableSignature"
        ),
        input: Rt
      })
    ),
    e
  );
  const n = { network: e.network || $i };
  let o = [], a = !1;
  function i(s) {
    a || (a = !0, o = fr(s), n.m = o[0] - y0, n.n = o[o.length - 2] - y0, n.pubkeys = o.slice(1, -2));
  }
  if (ze(n, "output", () => {
    if (e.m && n.n && e.pubkeys)
      return Jn(
        [].concat(
          y0 + e.m,
          e.pubkeys,
          y0 + n.n,
          Hl.OP_CHECKMULTISIG
        )
      );
  }), ze(n, "m", () => {
    if (n.output)
      return i(n.output), n.m;
  }), ze(n, "n", () => {
    if (n.pubkeys)
      return n.pubkeys.length;
  }), ze(n, "pubkeys", () => {
    if (e.output)
      return i(e.output), n.pubkeys;
  }), ze(n, "signatures", () => {
    if (e.input)
      return fr(e.input).slice(1);
  }), ze(n, "input", () => {
    if (e.signatures)
      return Jn([Hl.OP_0].concat(e.signatures));
  }), ze(n, "witness", () => {
    if (n.input)
      return [];
  }), ze(n, "name", () => {
    if (!(!n.m || !n.n))
      return `p2ms(${n.m} of ${n.n})`;
  }), t.validate) {
    if (e.output) {
      if (i(e.output), cr(Zn(), o[0], { message: "Output is invalid" }), cr(Zn(), o[o.length - 2], {
        message: "Output is invalid"
      }), o[o.length - 1] !== Hl.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (n.m <= 0 || n.n > 16 || n.m > n.n || n.n !== o.length - 3)
        throw new TypeError("Output is invalid");
      if (!n.pubkeys.every((s) => hi(s)))
        throw new TypeError("Output is invalid");
      if (e.m !== void 0 && e.m !== n.m) throw new TypeError("m mismatch");
      if (e.n !== void 0 && e.n !== n.n) throw new TypeError("n mismatch");
      if (e.pubkeys && !mh(e.pubkeys, n.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (e.pubkeys) {
      if (e.n !== void 0 && e.n !== e.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (n.n = e.pubkeys.length, n.n < n.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (e.signatures) {
      if (e.signatures.length < n.m)
        throw new TypeError("Not enough signatures provided");
      if (e.signatures.length > n.m)
        throw new TypeError("Too many signatures provided");
    }
    if (e.input) {
      if (e.input[0] !== Hl.OP_0) throw new TypeError("Input is invalid");
      if (n.signatures.length === 0 || !n.signatures.every(r))
        throw new TypeError("Input has invalid signature(s)");
      if (e.signatures && !mh(e.signatures, n.signatures))
        throw new TypeError("Signature mismatch");
      if (e.m !== void 0 && e.m !== e.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(n, e);
}
const w6 = jt;
function tx(e, t) {
  if (!e.input && !e.output && !e.pubkey && !e.input && !e.signature)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), cr(
    $u(
      Ur({
        network: Ur({}),
        output: Rt,
        pubkey: xi(hi, "invalid pubkey"),
        signature: xi(
          os,
          "Expected signature to be of type isCanonicalScriptSignature"
        ),
        input: Rt
      })
    ),
    e
  );
  const r = Go(() => fr(e.input)), n = { name: "p2pk", network: e.network || $i };
  if (ze(n, "output", () => {
    if (e.pubkey)
      return Jn([e.pubkey, w6.OP_CHECKSIG]);
  }), ze(n, "pubkey", () => {
    if (e.output)
      return e.output.slice(1, -1);
  }), ze(n, "signature", () => {
    if (e.input)
      return r()[0];
  }), ze(n, "input", () => {
    if (e.signature)
      return Jn([e.signature]);
  }), ze(n, "witness", () => {
    if (n.input)
      return [];
  }), t.validate) {
    if (e.output) {
      if (e.output[e.output.length - 1] !== w6.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!hi(n.pubkey)) throw new TypeError("Output pubkey is invalid");
      if (e.pubkey && fe(e.pubkey, n.pubkey) !== 0)
        throw new TypeError("Pubkey mismatch");
    }
    if (e.signature && e.input && fe(e.input, n.input) !== 0)
      throw new TypeError("Signature mismatch");
    if (e.input) {
      if (r().length !== 1) throw new TypeError("Input is invalid");
      if (!os(n.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(n, e);
}
function v6(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function pR(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function Om(e, ...t) {
  if (!pR(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function gR(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  v6(e.outputLen), v6(e.blockLen);
}
function q1(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function mR(e, t) {
  Om(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const Ol = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Kb = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Li = (e, t) => e << 32 - t | e >>> t, b0 = (e, t) => e << t | e >>> 32 - t >>> 0;
new Uint8Array(new Uint32Array([287454020]).buffer)[0];
function yR(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function H8(e) {
  return typeof e == "string" && (e = yR(e)), Om(e), e;
}
function bR(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const o = e[n];
    Om(o), t += o.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, o = 0; n < e.length; n++) {
    const a = e[n];
    r.set(a, o), o += a.length;
  }
  return r;
}
let rx = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function F8(e) {
  const t = (n) => e().update(H8(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function wR(e = 32) {
  if (Ol && typeof Ol.getRandomValues == "function")
    return Ol.getRandomValues(new Uint8Array(e));
  if (Ol && typeof Ol.randomBytes == "function")
    return Ol.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
function vR(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
const ER = (e, t, r) => e & t ^ ~e & r, kR = (e, t, r) => e & t ^ e & r ^ t & r;
let D8 = class extends rx {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Kb(this.buffer);
  }
  update(t) {
    q1(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = H8(t);
    const a = t.length;
    for (let i = 0; i < a; ) {
      const s = Math.min(o - this.pos, a - i);
      if (s === o) {
        const u = Kb(t);
        for (; o <= a - i; i += o)
          this.process(u, i);
        continue;
      }
      n.set(t.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    q1(this), mR(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: o, isLE: a } = this;
    let { pos: i } = this;
    r[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > o - i && (this.process(n, 0), i = 0);
    for (let f = i; f < o; f++)
      r[f] = 0;
    vR(n, o - 8, BigInt(this.length * 8), a), this.process(n, 0);
    const s = Kb(t), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, c = this.get();
    if (l > c.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < l; f++)
      s.setUint32(4 * f, c[f], a);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: a, destroyed: i, pos: s } = this;
    return t.length = o, t.pos = s, t.finished = a, t.destroyed = i, o % r && t.buffer.set(n), t;
  }
};
const xR = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), nx = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((e, t) => t)), AR = /* @__PURE__ */ nx.map((e) => (9 * e + 5) % 16);
let M8 = [nx], K8 = [AR];
for (let e = 0; e < 4; e++)
  for (let t of [M8, K8])
    t.push(t[e].map((r) => xR[r]));
const ox = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => new Uint8Array(e)), SR = /* @__PURE__ */ M8.map((e, t) => e.map((r) => ox[t][r])), _R = /* @__PURE__ */ K8.map((e, t) => e.map((r) => ox[t][r])), IR = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), TR = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function E6(e, t, r, n) {
  return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const w0 = /* @__PURE__ */ new Uint32Array(16);
let PR = class extends D8 {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: t, h1: r, h2: n, h3: o, h4: a } = this;
    return [t, r, n, o, a];
  }
  set(t, r, n, o, a) {
    this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = o | 0, this.h4 = a | 0;
  }
  process(t, r) {
    for (let p = 0; p < 16; p++, r += 4)
      w0[p] = t.getUint32(r, !0);
    let n = this.h0 | 0, o = n, a = this.h1 | 0, i = a, s = this.h2 | 0, u = s, l = this.h3 | 0, c = l, f = this.h4 | 0, h = f;
    for (let p = 0; p < 5; p++) {
      const y = 4 - p, m = IR[p], b = TR[p], v = M8[p], k = K8[p], E = SR[p], A = _R[p];
      for (let S = 0; S < 16; S++) {
        const _ = b0(n + E6(p, a, s, l) + w0[v[S]] + m, E[S]) + f | 0;
        n = f, f = l, l = b0(s, 10) | 0, s = a, a = _;
      }
      for (let S = 0; S < 16; S++) {
        const _ = b0(o + E6(y, i, u, c) + w0[k[S]] + b, A[S]) + h | 0;
        o = h, h = c, c = b0(u, 10) | 0, u = i, i = _;
      }
    }
    this.set(this.h1 + s + c | 0, this.h2 + l + h | 0, this.h3 + f + o | 0, this.h4 + n + i | 0, this.h0 + a + u | 0);
  }
  roundClean() {
    w0.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
};
const ix = /* @__PURE__ */ F8(() => new PR()), OR = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ks = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), xs = /* @__PURE__ */ new Uint32Array(64);
let $R = class extends D8 {
  constructor() {
    super(64, 32, 8, !1), this.A = ks[0] | 0, this.B = ks[1] | 0, this.C = ks[2] | 0, this.D = ks[3] | 0, this.E = ks[4] | 0, this.F = ks[5] | 0, this.G = ks[6] | 0, this.H = ks[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: a, F: i, G: s, H: u } = this;
    return [t, r, n, o, a, i, s, u];
  }
  // prettier-ignore
  set(t, r, n, o, a, i, s, u) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = a | 0, this.F = i | 0, this.G = s | 0, this.H = u | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      xs[f] = t.getUint32(r, !1);
    for (let f = 16; f < 64; f++) {
      const h = xs[f - 15], p = xs[f - 2], y = Li(h, 7) ^ Li(h, 18) ^ h >>> 3, m = Li(p, 17) ^ Li(p, 19) ^ p >>> 10;
      xs[f] = m + xs[f - 7] + y + xs[f - 16] | 0;
    }
    let { A: n, B: o, C: a, D: i, E: s, F: u, G: l, H: c } = this;
    for (let f = 0; f < 64; f++) {
      const h = Li(s, 6) ^ Li(s, 11) ^ Li(s, 25), p = c + h + ER(s, u, l) + OR[f] + xs[f] | 0, y = (Li(n, 2) ^ Li(n, 13) ^ Li(n, 22)) + kR(n, o, a) | 0;
      c = l, l = u, u = s, s = i + p | 0, i = a, a = o, o = n, n = p + y | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, c = c + this.H | 0, this.set(n, o, a, i, s, u, l, c);
  }
  roundClean() {
    xs.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const en = /* @__PURE__ */ F8(() => new $R());
function Ya(e) {
  return ix(en(e));
}
function oc(e) {
  return en(en(e));
}
const CR = {
  "BIP0340/challenge": Uint8Array.from([
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124,
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124
  ]),
  "BIP0340/aux": Uint8Array.from([
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144,
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144
  ]),
  "BIP0340/nonce": Uint8Array.from([
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47,
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47
  ]),
  TapLeaf: Uint8Array.from([
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238,
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238
  ]),
  TapBranch: Uint8Array.from([
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21,
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21
  ]),
  TapSighash: Uint8Array.from([
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49,
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49
  ]),
  TapTweak: Uint8Array.from([
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233,
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233
  ]),
  "KeyAgg list": Uint8Array.from([
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240,
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240
  ]),
  "KeyAgg coefficient": Uint8Array.from([
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129,
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129
  ])
};
function $m(e, t) {
  return en(gr([CR[e], t]));
}
function BR(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let l = 0; l < t.length; l++)
    t[l] = 255;
  for (let l = 0; l < e.length; l++) {
    const c = e.charAt(l), f = c.charCodeAt(0);
    if (t[f] !== 255)
      throw new TypeError(c + " is ambiguous");
    t[f] = l;
  }
  const r = e.length, n = e.charAt(0), o = Math.log(r) / Math.log(256), a = Math.log(256) / Math.log(r);
  function i(l) {
    if (l instanceof Uint8Array || (ArrayBuffer.isView(l) ? l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : Array.isArray(l) && (l = Uint8Array.from(l))), !(l instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (l.length === 0)
      return "";
    let c = 0, f = 0, h = 0;
    const p = l.length;
    for (; h !== p && l[h] === 0; )
      h++, c++;
    const y = (p - h) * a + 1 >>> 0, m = new Uint8Array(y);
    for (; h !== p; ) {
      let k = l[h], E = 0;
      for (let A = y - 1; (k !== 0 || E < f) && A !== -1; A--, E++)
        k += 256 * m[A] >>> 0, m[A] = k % r >>> 0, k = k / r >>> 0;
      if (k !== 0)
        throw new Error("Non-zero carry");
      f = E, h++;
    }
    let b = y - f;
    for (; b !== y && m[b] === 0; )
      b++;
    let v = n.repeat(c);
    for (; b < y; ++b)
      v += e.charAt(m[b]);
    return v;
  }
  function s(l) {
    if (typeof l != "string")
      throw new TypeError("Expected String");
    if (l.length === 0)
      return new Uint8Array();
    let c = 0, f = 0, h = 0;
    for (; l[c] === n; )
      f++, c++;
    const p = (l.length - c) * o + 1 >>> 0, y = new Uint8Array(p);
    for (; l[c]; ) {
      let k = t[l.charCodeAt(c)];
      if (k === 255)
        return;
      let E = 0;
      for (let A = p - 1; (k !== 0 || E < h) && A !== -1; A--, E++)
        k += r * y[A] >>> 0, y[A] = k % 256 >>> 0, k = k / 256 >>> 0;
      if (k !== 0)
        throw new Error("Non-zero carry");
      h = E, c++;
    }
    let m = p - h;
    for (; m !== p && y[m] === 0; )
      m++;
    const b = new Uint8Array(f + (p - m));
    let v = f;
    for (; m !== p; )
      b[v++] = y[m++];
    return b;
  }
  function u(l) {
    const c = s(l);
    if (c)
      return c;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: i,
    decodeUnsafe: s,
    decode: u
  };
}
var NR = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const qb = BR(NR);
function UR(e) {
  function t(a) {
    var i = Uint8Array.from(a), s = e(i), u = i.length + 4, l = new Uint8Array(u);
    return l.set(i, 0), l.set(s.subarray(0, 4), i.length), qb.encode(l);
  }
  function r(a) {
    var i = a.slice(0, -4), s = a.slice(-4), u = e(i);
    if (!(s[0] ^ u[0] | s[1] ^ u[1] | s[2] ^ u[2] | s[3] ^ u[3]))
      return i;
  }
  function n(a) {
    var i = qb.decodeUnsafe(a);
    if (i != null)
      return r(i);
  }
  function o(a) {
    var i = qb.decode(a), s = r(i);
    if (s == null)
      throw new Error("Invalid checksum");
    return s;
  }
  return {
    encode: t,
    decode: o,
    decodeUnsafe: n
  };
}
function RR(e) {
  return en(en(e));
}
const mf = UR(RR), As = jt;
function pp(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.input)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), cr(
    $u(
      Ur({
        network: Ur({}),
        address: il(),
        hash: oR,
        output: Vr(25),
        pubkey: xi(hi),
        signature: xi(os),
        input: Rt
      })
    ),
    e
  );
  const r = Go(() => {
    const i = mf.decode(e.address), s = ns(i, 0), u = i.slice(1);
    return { version: s, hash: u };
  }), n = Go(() => fr(e.input)), o = e.network || $i, a = { name: "p2pkh", network: o };
  if (ze(a, "address", () => {
    if (!a.hash) return;
    const i = new Uint8Array(21);
    return wo(i, 0, o.pubKeyHash), i.set(a.hash, 1), mf.encode(i);
  }), ze(a, "hash", () => {
    if (e.output) return e.output.slice(3, 23);
    if (e.address) return r().hash;
    if (e.pubkey || a.pubkey) return Ya(e.pubkey || a.pubkey);
  }), ze(a, "output", () => {
    if (a.hash)
      return Jn([
        As.OP_DUP,
        As.OP_HASH160,
        a.hash,
        As.OP_EQUALVERIFY,
        As.OP_CHECKSIG
      ]);
  }), ze(a, "pubkey", () => {
    if (e.input)
      return n()[1];
  }), ze(a, "signature", () => {
    if (e.input)
      return n()[0];
  }), ze(a, "input", () => {
    if (e.pubkey && e.signature)
      return Jn([e.signature, e.pubkey]);
  }), ze(a, "witness", () => {
    if (a.input)
      return [];
  }), t.validate) {
    let i = Uint8Array.from([]);
    if (e.address) {
      if (r().version !== o.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (r().hash.length !== 20) throw new TypeError("Invalid address");
      i = r().hash;
    }
    if (e.hash) {
      if (i.length > 0 && fe(i, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      i = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 25 || e.output[0] !== As.OP_DUP || e.output[1] !== As.OP_HASH160 || e.output[2] !== 20 || e.output[23] !== As.OP_EQUALVERIFY || e.output[24] !== As.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const s = e.output.slice(3, 23);
      if (i.length > 0 && fe(i, s) !== 0)
        throw new TypeError("Hash mismatch");
      i = s;
    }
    if (e.pubkey) {
      const s = Ya(e.pubkey);
      if (i.length > 0 && fe(i, s) !== 0)
        throw new TypeError("Hash mismatch");
      i = s;
    }
    if (e.input) {
      const s = n();
      if (s.length !== 2) throw new TypeError("Input is invalid");
      if (!os(s[0]))
        throw new TypeError("Input has invalid signature");
      if (!hi(s[1])) throw new TypeError("Input has invalid pubkey");
      if (e.signature && fe(e.signature, s[0]) !== 0)
        throw new TypeError("Signature mismatch");
      if (e.pubkey && fe(e.pubkey, s[1]) !== 0)
        throw new TypeError("Pubkey mismatch");
      const u = Ya(s[1]);
      if (i.length > 0 && fe(i, u) !== 0)
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(a, e);
}
const Od = jt;
function Wf(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.input)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), cr(
    $u(
      Ur({
        network: Ur({}),
        address: il(),
        hash: Vr(20),
        output: Vr(23),
        redeem: $u(
          Ur({
            network: Ur({}),
            output: Rt,
            input: Rt,
            witness: Yn(Rt)
          })
        ),
        input: Rt,
        witness: Yn(Rt)
      })
    ),
    e
  );
  let r = e.network;
  r || (r = e.redeem && e.redeem.network || $i);
  const n = { network: r }, o = Go(() => {
    const s = mf.decode(e.address), u = ns(s, 0), l = s.slice(1);
    return { version: u, hash: l };
  }), a = Go(() => fr(e.input)), i = Go(() => {
    const s = a(), u = s[s.length - 1];
    return {
      network: r,
      output: u === Od.OP_FALSE ? Uint8Array.from([]) : u,
      input: Jn(s.slice(0, -1)),
      witness: e.witness || []
    };
  });
  if (ze(n, "address", () => {
    if (!n.hash) return;
    const s = new Uint8Array(21);
    return wo(s, 0, n.network.scriptHash), s.set(n.hash, 1), mf.encode(s);
  }), ze(n, "hash", () => {
    if (e.output) return e.output.slice(2, 22);
    if (e.address) return o().hash;
    if (n.redeem && n.redeem.output) return Ya(n.redeem.output);
  }), ze(n, "output", () => {
    if (n.hash)
      return Jn([Od.OP_HASH160, n.hash, Od.OP_EQUAL]);
  }), ze(n, "redeem", () => {
    if (e.input)
      return i();
  }), ze(n, "input", () => {
    if (!(!e.redeem || !e.redeem.input || !e.redeem.output))
      return Jn(
        [].concat(fr(e.redeem.input), e.redeem.output)
      );
  }), ze(n, "witness", () => {
    if (n.redeem && n.redeem.witness) return n.redeem.witness;
    if (n.input) return [];
  }), ze(n, "name", () => {
    const s = ["p2sh"];
    return n.redeem !== void 0 && n.redeem.name !== void 0 && s.push(n.redeem.name), s.join("-");
  }), t.validate) {
    let s = Uint8Array.from([]);
    if (e.address) {
      if (o().version !== r.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (o().hash.length !== 20) throw new TypeError("Invalid address");
      s = o().hash;
    }
    if (e.hash) {
      if (s.length > 0 && fe(s, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      s = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 23 || e.output[0] !== Od.OP_HASH160 || e.output[1] !== 20 || e.output[22] !== Od.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const l = e.output.slice(2, 22);
      if (s.length > 0 && fe(s, l) !== 0)
        throw new TypeError("Hash mismatch");
      s = l;
    }
    const u = (l) => {
      if (l.output) {
        const c = fr(l.output);
        if (!c || c.length < 1)
          throw new TypeError("Redeem.output too short");
        if (l.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (Qk(c) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const f = Ya(l.output);
        if (s.length > 0 && fe(s, f) !== 0)
          throw new TypeError("Hash mismatch");
        s = f;
      }
      if (l.input) {
        const c = l.input.length > 0, f = l.witness && l.witness.length > 0;
        if (!c && !f) throw new TypeError("Empty input");
        if (c && f)
          throw new TypeError("Input and witness provided");
        if (c) {
          const h = fr(l.input);
          if (!j8(h))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (e.input) {
      const l = a();
      if (!l || l.length < 1) throw new TypeError("Input too short");
      if (!(i().output instanceof Uint8Array))
        throw new TypeError("Input is invalid");
      u(i());
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== r)
        throw new TypeError("Network mismatch");
      if (e.input) {
        const l = i();
        if (e.redeem.output && fe(e.redeem.output, l.output) !== 0)
          throw new TypeError("Redeem.output mismatch");
        if (e.redeem.input && fe(e.redeem.input, l.input) !== 0)
          throw new TypeError("Redeem.input mismatch");
      }
      u(e.redeem);
    }
    if (e.witness && e.redeem && e.redeem.witness && !mh(e.redeem.witness, e.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(n, e);
}
var Me = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function zR(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function jR(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var o = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, o.get ? o : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var yh = {};
Object.defineProperty(yh, "__esModule", { value: !0 });
var bh = yh.bech32m = Eo = yh.bech32 = void 0;
const V1 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ax = {};
for (let e = 0; e < V1.length; e++) {
  const t = V1.charAt(e);
  ax[t] = e;
}
function rf(e) {
  const t = e >> 25;
  return (e & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059;
}
function k6(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = e.charCodeAt(r);
    if (n < 33 || n > 126)
      return "Invalid prefix (" + e + ")";
    t = rf(t) ^ n >> 5;
  }
  t = rf(t);
  for (let r = 0; r < e.length; ++r) {
    const n = e.charCodeAt(r);
    t = rf(t) ^ n & 31;
  }
  return t;
}
function q8(e, t, r, n) {
  let o = 0, a = 0;
  const i = (1 << r) - 1, s = [];
  for (let u = 0; u < e.length; ++u)
    for (o = o << t | e[u], a += t; a >= r; )
      a -= r, s.push(o >> a & i);
  if (n)
    a > 0 && s.push(o << r - a & i);
  else {
    if (a >= t)
      return "Excess padding";
    if (o << r - a & i)
      return "Non-zero padding";
  }
  return s;
}
function LR(e) {
  return q8(e, 8, 5, !0);
}
function HR(e) {
  const t = q8(e, 5, 8, !1);
  if (Array.isArray(t))
    return t;
}
function FR(e) {
  const t = q8(e, 5, 8, !1);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
function sx(e) {
  let t;
  e === "bech32" ? t = 1 : t = 734539939;
  function r(i, s, u) {
    if (u = u || 90, i.length + 7 + s.length > u)
      throw new TypeError("Exceeds length limit");
    i = i.toLowerCase();
    let l = k6(i);
    if (typeof l == "string")
      throw new Error(l);
    let c = i + "1";
    for (let f = 0; f < s.length; ++f) {
      const h = s[f];
      if (h >> 5)
        throw new Error("Non 5-bit word");
      l = rf(l) ^ h, c += V1.charAt(h);
    }
    for (let f = 0; f < 6; ++f)
      l = rf(l);
    l ^= t;
    for (let f = 0; f < 6; ++f) {
      const h = l >> (5 - f) * 5 & 31;
      c += V1.charAt(h);
    }
    return c;
  }
  function n(i, s) {
    if (s = s || 90, i.length < 8)
      return i + " too short";
    if (i.length > s)
      return "Exceeds length limit";
    const u = i.toLowerCase(), l = i.toUpperCase();
    if (i !== u && i !== l)
      return "Mixed-case string " + i;
    i = u;
    const c = i.lastIndexOf("1");
    if (c === -1)
      return "No separator character for " + i;
    if (c === 0)
      return "Missing prefix for " + i;
    const f = i.slice(0, c), h = i.slice(c + 1);
    if (h.length < 6)
      return "Data too short";
    let p = k6(f);
    if (typeof p == "string")
      return p;
    const y = [];
    for (let m = 0; m < h.length; ++m) {
      const b = h.charAt(m), v = ax[b];
      if (v === void 0)
        return "Unknown character " + b;
      p = rf(p) ^ v, !(m + 6 >= h.length) && y.push(v);
    }
    return p !== t ? "Invalid checksum for " + i : { prefix: f, words: y };
  }
  function o(i, s) {
    const u = n(i, s);
    if (typeof u == "object")
      return u;
  }
  function a(i, s) {
    const u = n(i, s);
    if (typeof u == "object")
      return u;
    throw new Error(u);
  }
  return {
    decodeUnsafe: o,
    decode: a,
    encode: r,
    toWords: LR,
    fromWordsUnsafe: HR,
    fromWords: FR
  };
}
var Eo = yh.bech32 = sx("bech32");
bh = yh.bech32m = sx("bech32m");
const x6 = jt, DR = new Uint8Array(0);
function gp(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.witness)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), cr(
    $u(
      Ur({
        address: il(),
        hash: Vr(20),
        input: Vr(0),
        network: Ur({}),
        output: Vr(22),
        pubkey: xi(hi, "Not a valid pubkey"),
        signature: xi(os),
        witness: Yn(Rt)
      })
    ),
    e
  );
  const r = Go(() => {
    const a = Eo.decode(e.address), i = a.words.shift(), s = Eo.fromWords(a.words);
    return {
      version: i,
      prefix: a.prefix,
      data: Uint8Array.from(s)
    };
  }), n = e.network || $i, o = { name: "p2wpkh", network: n };
  if (ze(o, "address", () => {
    if (!o.hash) return;
    const a = Eo.toWords(o.hash);
    return a.unshift(0), Eo.encode(n.bech32, a);
  }), ze(o, "hash", () => {
    if (e.output) return e.output.slice(2, 22);
    if (e.address) return r().data;
    if (e.pubkey || o.pubkey) return Ya(e.pubkey || o.pubkey);
  }), ze(o, "output", () => {
    if (o.hash)
      return Jn([x6.OP_0, o.hash]);
  }), ze(o, "pubkey", () => {
    if (e.pubkey) return e.pubkey;
    if (e.witness)
      return e.witness[1];
  }), ze(o, "signature", () => {
    if (e.witness)
      return e.witness[0];
  }), ze(o, "input", () => {
    if (o.witness)
      return DR;
  }), ze(o, "witness", () => {
    if (e.pubkey && e.signature)
      return [e.signature, e.pubkey];
  }), t.validate) {
    let a = Uint8Array.from([]);
    if (e.address) {
      if (n && n.bech32 !== r().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== 0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 20)
        throw new TypeError("Invalid address data");
      a = r().data;
    }
    if (e.hash) {
      if (a.length > 0 && fe(a, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      a = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 22 || e.output[0] !== x6.OP_0 || e.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (a.length > 0 && fe(a, e.output.slice(2)) !== 0)
        throw new TypeError("Hash mismatch");
      a = e.output.slice(2);
    }
    if (e.pubkey) {
      const i = Ya(e.pubkey);
      if (a.length > 0 && fe(a, i) !== 0)
        throw new TypeError("Hash mismatch");
      if (a = i, !hi(e.pubkey) || e.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (e.witness) {
      if (e.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!os(e.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!hi(e.witness[1]) || e.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (e.signature && fe(e.signature, e.witness[0]) !== 0)
        throw new TypeError("Signature mismatch");
      if (e.pubkey && fe(e.pubkey, e.witness[1]) !== 0)
        throw new TypeError("Pubkey mismatch");
      const i = Ya(e.witness[1]);
      if (a.length > 0 && fe(a, i) !== 0)
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(o, e);
}
const A6 = jt, Vb = new Uint8Array(0);
function v0(e) {
  return !!(e instanceof Uint8Array && e.length === 65 && e[0] === 4 && hi(e));
}
function mp(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.witness)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), cr(
    g6({
      network: Ur({}),
      address: il(),
      hash: nR,
      output: Vr(34),
      redeem: g6({
        input: Rt,
        network: Ur({}),
        output: Rt,
        witness: Yn(Rt)
      }),
      input: Vr(0),
      witness: Yn(Rt)
    }),
    e
  );
  const r = Go(() => {
    const i = Eo.decode(e.address), s = i.words.shift(), u = Eo.fromWords(i.words);
    return {
      version: s,
      prefix: i.prefix,
      data: Uint8Array.from(u)
    };
  }), n = Go(() => fr(e.redeem.input));
  let o = e.network;
  o || (o = e.redeem && e.redeem.network || $i);
  const a = { network: o };
  if (ze(a, "address", () => {
    if (!a.hash) return;
    const i = Eo.toWords(a.hash);
    return i.unshift(0), Eo.encode(o.bech32, i);
  }), ze(a, "hash", () => {
    if (e.output) return e.output.slice(2);
    if (e.address) return r().data;
    if (a.redeem && a.redeem.output) return en(a.redeem.output);
  }), ze(a, "output", () => {
    if (a.hash)
      return Jn([A6.OP_0, a.hash]);
  }), ze(a, "redeem", () => {
    if (e.witness)
      return {
        output: e.witness[e.witness.length - 1],
        input: Vb,
        witness: e.witness.slice(0, -1)
      };
  }), ze(a, "input", () => {
    if (a.witness)
      return Vb;
  }), ze(a, "witness", () => {
    if (e.redeem && e.redeem.input && e.redeem.input.length > 0 && e.redeem.output && e.redeem.output.length > 0) {
      const i = dR(n());
      return a.redeem = Object.assign({ witness: i }, e.redeem), a.redeem.input = Vb, [].concat(i, e.redeem.output);
    }
    if (e.redeem && e.redeem.output && e.redeem.witness)
      return [].concat(e.redeem.witness, e.redeem.output);
  }), ze(a, "name", () => {
    const i = ["p2wsh"];
    return a.redeem !== void 0 && a.redeem.name !== void 0 && i.push(a.redeem.name), i.join("-");
  }), t.validate) {
    let i = Uint8Array.from([]);
    if (e.address) {
      if (r().prefix !== o.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== 0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 32)
        throw new TypeError("Invalid address data");
      i = r().data;
    }
    if (e.hash) {
      if (i.length > 0 && fe(i, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      i = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== A6.OP_0 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const s = e.output.slice(2);
      if (i.length > 0 && fe(i, s) !== 0)
        throw new TypeError("Hash mismatch");
      i = s;
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== o)
        throw new TypeError("Network mismatch");
      if (e.redeem.input && e.redeem.input.length > 0 && e.redeem.witness && e.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (e.redeem.output) {
        const s = fr(e.redeem.output);
        if (!s || s.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (e.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (Qk(s) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const u = en(e.redeem.output);
        if (i.length > 0 && fe(i, u) !== 0)
          throw new TypeError("Hash mismatch");
        i = u;
      }
      if (e.redeem.input && !j8(n()))
        throw new TypeError("Non push-only scriptSig");
      if (e.witness && e.redeem.witness && !mh(e.witness, e.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (e.redeem.input && n().some(v0) || e.redeem.output && (fr(e.redeem.output) || []).some(
        v0
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (e.witness && e.witness.length > 0) {
      const s = e.witness[e.witness.length - 1];
      if (e.redeem && e.redeem.output && fe(e.redeem.output, s) !== 0)
        throw new TypeError("Witness and redeem.output mismatch");
      if (e.witness.some(v0) || (fr(s) || []).some(v0))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(a, e);
}
const ih = {};
function V8(e) {
  e ? e !== ih.eccLib && (MR(e), ih.eccLib = e) : ih.eccLib = e;
}
function _w() {
  if (!ih.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return ih.eccLib;
}
const Ia = (e) => hs(e);
function MR(e) {
  Uo(typeof e.isXOnlyPoint == "function"), Uo(
    e.isXOnlyPoint(
      Ia("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), Uo(
    e.isXOnlyPoint(
      Ia("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), Uo(
    e.isXOnlyPoint(
      Ia("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), Uo(
    e.isXOnlyPoint(
      Ia("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), Uo(
    !e.isXOnlyPoint(
      Ia("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), Uo(
    !e.isXOnlyPoint(
      Ia("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), Uo(typeof e.xOnlyPointAddTweak == "function"), KR.forEach((t) => {
    const r = e.xOnlyPointAddTweak(Ia(t.pubkey), Ia(t.tweak));
    t.result === null ? Uo(r === null) : (Uo(r !== null), Uo(r.parity === t.parity), Uo(fe(r.xOnlyPubkey, Ia(t.result)) === 0));
  });
}
function Uo(e) {
  if (!e) throw new Error("ecc library invalid");
}
const KR = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
], ux = "0123456789abcdefABCDEF";
ux.split("").map((e) => e.codePointAt(0));
const S6 = Array(256).fill(!0).map((e, t) => {
  const r = String.fromCodePoint(t), n = ux.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), cx = new TextEncoder();
new TextDecoder();
function qR(e) {
  return cx.encode(e);
}
function VR(e) {
  const t = e.reduce((o, a) => o + a.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const o of e)
    r.set(o, n), n += o.length;
  return r;
}
function GR(e) {
  const t = cx.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let n;
  for (n = 0; n < r.length; n++) {
    const o = S6[t[n * 2]], a = S6[t[n * 2 + 1]];
    if (o === void 0 || a === void 0)
      break;
    r[n] = o << 4 | a;
  }
  return n === r.length ? r : r.slice(0, n);
}
function Ta(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; ++n)
    if (e[n] !== t[n])
      return e[n] < t[n] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function _6(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  e[t] = r;
}
function ZR(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255);
}
function uc(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255);
}
function WR(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn));
}
function XR(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function Fl(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function YR(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), n;
  } else {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 7]), n;
  }
}
const JR = (e) => {
  if (e < 0 || e > 0xffffffffffffffffn)
    throw new RangeError("value out of range");
};
function QR(e) {
  if (e < 0 || e > Number.MAX_SAFE_INTEGER || e % 1 !== 0)
    throw new RangeError("value out of range");
}
function lx(e) {
  typeof e == "number" ? QR(e) : JR(e);
}
function Cu(e, t, r) {
  lx(e), r === void 0 && (r = 0), t === void 0 && (t = new Uint8Array(Wo(e)));
  let n = 0;
  return e < 253 ? (t.set([Number(e)], r), n = 1) : e <= 65535 ? (t.set([253], r), ZR(t, r + 1, Number(e), "LE"), n = 3) : e <= 4294967295 ? (t.set([254], r), uc(t, r + 1, Number(e), "LE"), n = 5) : (t.set([255], r), WR(t, r + 1, BigInt(e), "LE"), n = 9), { buffer: t, bytes: n };
}
function Xf(e, t) {
  t === void 0 && (t = 0);
  const r = e.at(t);
  if (r === void 0)
    throw new Error("buffer too small");
  if (r < 253)
    return { numberValue: r, bigintValue: BigInt(r), bytes: 1 };
  if (r === 253) {
    const n = XR(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 3
    };
  } else if (r === 254) {
    const n = Fl(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 5
    };
  } else {
    const n = YR(e, t + 1, "LE");
    return { numberValue: n <= Number.MAX_SAFE_INTEGER ? Number(n) : null, bigintValue: n, bytes: 9 };
  }
}
function Wo(e) {
  return lx(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
const ez = 9007199254740991;
function tz(e, t) {
  if (typeof e != "number" && typeof e != "bigint")
    throw new Error("cannot write a non-number as a number");
  if (e < 0 && e < BigInt(0))
    throw new Error("specified a negative value for writing an unsigned value");
  if (e > t && e > BigInt(t))
    throw new Error("RangeError: value out of range");
  if (Math.floor(Number(e)) !== Number(e))
    throw new Error("value has a fractional component");
}
function G8(e) {
  if (e.length < 1) return e;
  let t = e.length - 1, r = 0;
  for (let n = 0; n < e.length / 2; n++)
    r = e[n], e[n] = e[t], e[t] = r, t--;
  return e;
}
function I6(e) {
  const t = new Uint8Array(e.length);
  return t.set(e), t;
}
let Vn = class fx {
  constructor(t, r = 0) {
    ke(this, "buffer"), ke(this, "offset"), this.buffer = t, this.offset = r, cr(ta([Rt, Ha]), [
      t,
      r
    ]);
  }
  static withCapacity(t) {
    return new fx(new Uint8Array(t));
  }
  writeUInt8(t) {
    this.offset = wo(this.buffer, this.offset, t);
  }
  writeInt32(t) {
    this.offset = Lk(this.buffer, this.offset, t, "LE");
  }
  writeInt64(t) {
    this.offset = Hk(this.buffer, this.offset, BigInt(t), "LE");
  }
  writeUInt32(t) {
    this.offset = hp(this.buffer, this.offset, t, "LE");
  }
  writeUInt64(t) {
    this.offset = VU(this.buffer, this.offset, BigInt(t), "LE");
  }
  writeVarInt(t) {
    const { bytes: r } = Cu(t, this.buffer, this.offset);
    this.offset += r;
  }
  writeSlice(t) {
    if (this.buffer.length < this.offset + t.length)
      throw new Error("Cannot write slice out of bounds");
    this.buffer.set(t, this.offset), this.offset += t.length;
  }
  writeVarSlice(t) {
    this.writeVarInt(t.length), this.writeSlice(t);
  }
  writeVector(t) {
    this.writeVarInt(t.length), t.forEach((r) => this.writeVarSlice(r));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}, rz = class {
  constructor(t, r = 0) {
    ke(this, "buffer"), ke(this, "offset"), this.buffer = t, this.offset = r, cr(ta([Rt, Ha]), [
      t,
      r
    ]);
  }
  readUInt8() {
    const t = ns(this.buffer, this.offset);
    return this.offset++, t;
  }
  readInt32() {
    const t = ZU(this.buffer, this.offset, "LE");
    return this.offset += 4, t;
  }
  readUInt32() {
    const t = Gf(this.buffer, this.offset, "LE");
    return this.offset += 4, t;
  }
  readInt64() {
    const t = Fk(this.buffer, this.offset, "LE");
    return this.offset += 8, t;
  }
  readVarInt() {
    const { bigintValue: t, bytes: r } = Xf(this.buffer, this.offset);
    return this.offset += r, t;
  }
  readSlice(t) {
    tz(t, ez);
    const r = Number(t);
    if (this.buffer.length < this.offset + r)
      throw new Error("Cannot read slice out of bounds");
    const n = this.buffer.slice(this.offset, this.offset + r);
    return this.offset += r, n;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const t = this.readVarInt(), r = [];
    for (let n = 0; n < t; n++) r.push(this.readVarSlice());
    return r;
  }
};
const dx = 192, nz = 128, oz = (e) => "left" in e && "right" in e;
function Iw(e, t) {
  if (e.length < 33)
    throw new TypeError(
      `The control-block length is too small. Got ${e.length}, expected min 33.`
    );
  const r = (e.length - 33) / 32;
  let n = t;
  for (let o = 0; o < r; o++) {
    const a = e.slice(33 + 32 * o, 65 + 32 * o);
    fe(n, a) < 0 ? n = Pw(n, a) : n = Pw(a, n);
  }
  return n;
}
function Tw(e) {
  if (z8(e)) return { hash: Wa(e) };
  const t = [Tw(e[0]), Tw(e[1])];
  t.sort((o, a) => fe(o.hash, a.hash));
  const [r, n] = t;
  return {
    hash: Pw(r.hash, n.hash),
    left: r,
    right: n
  };
}
function G1(e, t) {
  if (oz(e)) {
    const r = G1(e.left, t);
    if (r !== void 0) return [...r, e.right.hash];
    const n = G1(e.right, t);
    if (n !== void 0) return [...n, e.left.hash];
  } else if (fe(e.hash, t) === 0)
    return [];
}
function Wa(e) {
  const t = e.version || dx;
  return $m(
    "TapLeaf",
    gr([Uint8Array.from([t]), az(e.output)])
  );
}
function iz(e, t) {
  return $m(
    "TapTweak",
    gr(t ? [e, t] : [e])
  );
}
function E0(e, t) {
  if (!(e instanceof Uint8Array) || e.length !== 32 || t && t.length !== 32) return null;
  const r = iz(e, t), n = _w().xOnlyPointAddTweak(e, r);
  return !n || n.xOnlyPubkey === null ? null : {
    parity: n.parity,
    x: Uint8Array.from(n.xOnlyPubkey)
  };
}
function Pw(e, t) {
  return $m("TapBranch", gr([e, t]));
}
function az(e) {
  const t = Wo(e.length), r = new Uint8Array(t);
  return Cu(e.length, r), gr([r, e]);
}
const T6 = jt, P6 = 1, sz = 80;
function yp(e, t) {
  if (!e.address && !e.output && !e.pubkey && !e.internalPubkey && !(e.witness && e.witness.length > 1))
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), cr(
    $u(
      Ur({
        address: il(),
        input: Vr(0),
        network: Ur({}),
        output: Vr(34),
        internalPubkey: Vr(32),
        hash: Vr(32),
        // merkle root hash, the tweak
        pubkey: Vr(32),
        // tweaked with `hash` from `internalPubkey`
        signature: R8([
          Vr(64),
          Vr(65)
        ]),
        witness: Yn(Rt),
        scriptTree: xi(Wk, "Taptree is not of type isTaptree"),
        redeem: $u(
          Ur({
            output: Rt,
            // tapleaf script
            redeemVersion: Zn(),
            // tapleaf version
            witness: Yn(Rt)
          })
        ),
        redeemVersion: Zn()
      })
    ),
    e
  );
  const r = Go(() => Z8(e.address)), n = Go(() => {
    if (!(!e.witness || !e.witness.length))
      return e.witness.length >= 2 && e.witness[e.witness.length - 1][0] === sz ? e.witness.slice(0, -1) : e.witness.slice();
  }), o = Go(() => {
    if (e.scriptTree) return Tw(e.scriptTree);
    if (e.hash) return { hash: e.hash };
  }), a = e.network || $i, i = { name: "p2tr", network: a };
  if (ze(i, "address", () => {
    if (!i.pubkey) return;
    const s = bh.toWords(i.pubkey);
    return s.unshift(P6), bh.encode(a.bech32, s);
  }), ze(i, "hash", () => {
    const s = o();
    if (s) return s.hash;
    const u = n();
    if (u && u.length > 1) {
      const l = u[u.length - 1], c = l[0] & b1, f = u[u.length - 2], h = Wa({ output: f, version: c });
      return Iw(l, h);
    }
    return null;
  }), ze(i, "output", () => {
    if (i.pubkey)
      return Jn([T6.OP_1, i.pubkey]);
  }), ze(i, "redeemVersion", () => e.redeemVersion ? e.redeemVersion : e.redeem && e.redeem.redeemVersion !== void 0 && e.redeem.redeemVersion !== null ? e.redeem.redeemVersion : dx), ze(i, "redeem", () => {
    const s = n();
    if (!(!s || s.length < 2))
      return {
        output: s[s.length - 2],
        witness: s.slice(0, -2),
        redeemVersion: s[s.length - 1][0] & b1
      };
  }), ze(i, "pubkey", () => {
    if (e.pubkey) return e.pubkey;
    if (e.output) return e.output.slice(2);
    if (e.address) return r().data;
    if (i.internalPubkey) {
      const s = E0(i.internalPubkey, i.hash);
      if (s) return s.x;
    }
  }), ze(i, "internalPubkey", () => {
    if (e.internalPubkey) return e.internalPubkey;
    const s = n();
    if (s && s.length > 1)
      return s[s.length - 1].slice(1, 33);
  }), ze(i, "signature", () => {
    if (e.signature) return e.signature;
    const s = n();
    if (!(!s || s.length !== 1))
      return s[0];
  }), ze(i, "witness", () => {
    if (e.witness) return e.witness;
    const s = o();
    if (s && e.redeem && e.redeem.output && e.internalPubkey) {
      const u = Wa({
        output: e.redeem.output,
        version: i.redeemVersion
      }), l = G1(s, u);
      if (!l) return;
      const c = E0(e.internalPubkey, s.hash);
      if (!c) return;
      const f = gr(
        [
          Uint8Array.from([i.redeemVersion | c.parity]),
          e.internalPubkey
        ].concat(l)
      );
      return [e.redeem.output, f];
    }
    if (e.signature) return [e.signature];
  }), t.validate) {
    let s = Uint8Array.from([]);
    if (e.address) {
      if (a && a.bech32 !== r().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== P6)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 32)
        throw new TypeError("Invalid address data");
      s = r().data;
    }
    if (e.pubkey) {
      if (s.length > 0 && fe(s, e.pubkey) !== 0)
        throw new TypeError("Pubkey mismatch");
      s = e.pubkey;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== T6.OP_1 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      if (s.length > 0 && fe(s, e.output.slice(2)) !== 0)
        throw new TypeError("Pubkey mismatch");
      s = e.output.slice(2);
    }
    if (e.internalPubkey) {
      const c = E0(e.internalPubkey, i.hash);
      if (s.length > 0 && fe(s, c.x) !== 0)
        throw new TypeError("Pubkey mismatch");
      s = c.x;
    }
    if (s && s.length && !_w().isXOnlyPoint(s))
      throw new TypeError("Invalid pubkey for p2tr");
    const u = o();
    if (e.hash && u && fe(e.hash, u.hash) !== 0)
      throw new TypeError("Hash mismatch");
    if (e.redeem && e.redeem.output && u) {
      const c = Wa({
        output: e.redeem.output,
        version: i.redeemVersion
      });
      if (!G1(u, c))
        throw new TypeError("Redeem script not in tree");
    }
    const l = n();
    if (e.redeem && i.redeem) {
      if (e.redeem.redeemVersion && e.redeem.redeemVersion !== i.redeem.redeemVersion)
        throw new TypeError("Redeem.redeemVersion and witness mismatch");
      if (e.redeem.output) {
        if (fr(e.redeem.output).length === 0)
          throw new TypeError("Redeem.output is invalid");
        if (i.redeem.output && fe(e.redeem.output, i.redeem.output) !== 0)
          throw new TypeError("Redeem.output and witness mismatch");
      }
      if (e.redeem.witness && i.redeem.witness && !mh(e.redeem.witness, i.redeem.witness))
        throw new TypeError("Redeem.witness and witness mismatch");
    }
    if (l && l.length)
      if (l.length === 1) {
        if (e.signature && fe(e.signature, l[0]) !== 0)
          throw new TypeError("Signature mismatch");
      } else {
        const c = l[l.length - 1];
        if (c.length < 33)
          throw new TypeError(
            `The control-block length is too small. Got ${c.length}, expected min 33.`
          );
        if ((c.length - 33) % 32 !== 0)
          throw new TypeError(
            `The control-block length of ${c.length} is incorrect!`
          );
        const f = (c.length - 33) / 32;
        if (f > 128)
          throw new TypeError(
            `The script path is too long. Got ${f}, expected max 128.`
          );
        const h = c.slice(1, 33);
        if (e.internalPubkey && fe(e.internalPubkey, h) !== 0)
          throw new TypeError("Internal pubkey mismatch");
        if (!_w().isXOnlyPoint(h))
          throw new TypeError("Invalid internalPubkey for p2tr witness");
        const p = c[0] & b1, y = l[l.length - 2], m = Wa({ output: y, version: p }), b = Iw(c, m), v = E0(h, b);
        if (!v)
          throw new TypeError("Invalid outputKey for p2tr witness");
        if (s.length && fe(s, v.x) !== 0)
          throw new TypeError("Pubkey mismatch for p2tr witness");
        if (v.parity !== (c[0] & 1))
          throw new Error("Incorrect parity");
      }
  }
  return Object.assign(i, e);
}
const hx = 40, px = 2, gx = 16, mx = 2, yx = 80, bx = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
function uz(e, t) {
  const r = e.slice(2);
  if (r.length < px || r.length > hx)
    throw new TypeError("Invalid program length for segwit address");
  const n = e[0] - yx;
  if (n < mx || n > gx)
    throw new TypeError("Invalid version for segwit address");
  if (e[1] !== r.length)
    throw new TypeError("Invalid script for segwit address");
  return console.warn(bx), cz(r, n, t.bech32);
}
function wx(e) {
  const t = mf.decode(e);
  if (t.length < 21) throw new TypeError(e + " is too short");
  if (t.length > 21) throw new TypeError(e + " is too long");
  const r = ns(t, 0), n = t.slice(1);
  return { version: r, hash: n };
}
function Z8(e) {
  let t, r;
  try {
    t = Eo.decode(e);
  } catch {
  }
  if (t) {
    if (r = t.words[0], r !== 0) throw new TypeError(e + " uses wrong encoding");
  } else if (t = bh.decode(e), r = t.words[0], r === 0) throw new TypeError(e + " uses wrong encoding");
  const n = Eo.fromWords(t.words.slice(1));
  return {
    version: r,
    prefix: t.prefix,
    data: Uint8Array.from(n)
  };
}
function cz(e, t, r) {
  const n = Eo.toWords(e);
  return n.unshift(t), t === 0 ? Eo.encode(r, n) : bh.encode(r, n);
}
function bp(e, t) {
  t = t || $i;
  try {
    return pp({ output: e, network: t }).address;
  } catch {
  }
  try {
    return Wf({ output: e, network: t }).address;
  } catch {
  }
  try {
    return gp({ output: e, network: t }).address;
  } catch {
  }
  try {
    return mp({ output: e, network: t }).address;
  } catch {
  }
  try {
    return yp({ output: e, network: t }).address;
  } catch {
  }
  try {
    return uz(e, t);
  } catch {
  }
  throw new Error(fR(e) + " has no matching Address");
}
function wp(e, t) {
  t = t || $i;
  let r, n;
  try {
    r = wx(e);
  } catch {
  }
  if (r) {
    if (r.version === t.pubKeyHash)
      return pp({ hash: r.hash }).output;
    if (r.version === t.scriptHash)
      return Wf({ hash: r.hash }).output;
  } else {
    try {
      n = Z8(e);
    } catch {
    }
    if (n) {
      if (n.prefix !== t.bech32)
        throw new Error(e + " has an invalid prefix");
      if (n.version === 0) {
        if (n.data.length === 20)
          return gp({ hash: n.data }).output;
        if (n.data.length === 32)
          return mp({ hash: n.data }).output;
      } else if (n.version === 1) {
        if (n.data.length === 32)
          return yp({ pubkey: n.data }).output;
      } else if (n.version >= mx && n.version <= gx && n.data.length >= px && n.data.length <= hx)
        return console.warn(bx), Jn([
          n.version + yx,
          n.data
        ]);
    }
  }
  throw new Error(e + " has no matching Script");
}
function Qi(e) {
  const t = e.length;
  return Wo(t) + t;
}
function lz(e) {
  const t = e.length;
  return Wo(t) + e.reduce((r, n) => r + Qi(n), 0);
}
const mu = new Uint8Array(0), O6 = [], Gb = hs(
  "0000000000000000000000000000000000000000000000000000000000000000"
), $6 = hs(
  "0000000000000000000000000000000000000000000000000000000000000001"
), fz = hs("ffffffffffffffff"), dz = {
  script: mu,
  valueBuffer: fz
};
function hz(e) {
  return e.value !== void 0;
}
const ni = class qt {
  constructor() {
    ke(this, "version", 1), ke(this, "locktime", 0), ke(this, "ins", []), ke(this, "outs", []);
  }
  static fromBuffer(t, r) {
    const n = new rz(t), o = new qt();
    o.version = n.readInt32();
    const a = n.readUInt8(), i = n.readUInt8();
    let s = !1;
    a === qt.ADVANCED_TRANSACTION_MARKER && i === qt.ADVANCED_TRANSACTION_FLAG ? s = !0 : n.offset -= 2;
    const u = n.readVarInt();
    for (let c = 0; c < u; ++c)
      o.ins.push({
        hash: n.readSlice(32),
        index: n.readUInt32(),
        script: n.readVarSlice(),
        sequence: n.readUInt32(),
        witness: O6
      });
    const l = n.readVarInt();
    for (let c = 0; c < l; ++c)
      o.outs.push({
        value: n.readInt64(),
        script: n.readVarSlice()
      });
    if (s) {
      for (let c = 0; c < u; ++c)
        o.ins[c].witness = n.readVector();
      if (!o.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (o.locktime = n.readUInt32(), r) return o;
    if (n.offset !== t.length)
      throw new Error("Transaction has unexpected data");
    return o;
  }
  static fromHex(t) {
    return qt.fromBuffer(hs(t), !1);
  }
  static isCoinbaseHash(t) {
    cr(p6, t);
    for (let r = 0; r < 32; ++r)
      if (t[r] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && qt.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(t, r, n, o) {
    return cr(
      ta([
        p6,
        Ha,
        Sw(D1(Ha)),
        Sw(D1(Rt))
      ]),
      [t, r, n, o]
    ), n == null && (n = qt.DEFAULT_SEQUENCE), this.ins.push({
      hash: t,
      index: r,
      script: o || mu,
      sequence: n,
      witness: O6
    }) - 1;
  }
  addOutput(t, r) {
    return cr(ta([Rt, Mb]), [
      t,
      r
    ]), this.outs.push({
      script: t,
      value: r
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((t) => t.witness.length !== 0);
  }
  weight() {
    const t = this.byteLength(!1), r = this.byteLength(!0);
    return t * 3 + r;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(t = !0) {
    const r = t && this.hasWitnesses();
    return (r ? 10 : 8) + Wo(this.ins.length) + Wo(this.outs.length) + this.ins.reduce((n, o) => n + 40 + Qi(o.script), 0) + this.outs.reduce((n, o) => n + 8 + Qi(o.script), 0) + (r ? this.ins.reduce((n, o) => n + lz(o.witness), 0) : 0);
  }
  clone() {
    const t = new qt();
    return t.version = this.version, t.locktime = this.locktime, t.ins = this.ins.map((r) => ({
      hash: r.hash,
      index: r.index,
      script: r.script,
      sequence: r.sequence,
      witness: r.witness
    })), t.outs = this.outs.map((r) => ({
      script: r.script,
      value: r.value
    })), t;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(t, r, n) {
    if (cr(ta([Ha, Rt, Zn()]), [
      t,
      r,
      n
    ]), t >= this.ins.length) return $6;
    const o = Jn(
      fr(r).filter((s) => s !== jt.OP_CODESEPARATOR)
    ), a = this.clone();
    if ((n & 31) === qt.SIGHASH_NONE)
      a.outs = [], a.ins.forEach((s, u) => {
        u !== t && (s.sequence = 0);
      });
    else if ((n & 31) === qt.SIGHASH_SINGLE) {
      if (t >= this.outs.length) return $6;
      a.outs.length = t + 1;
      for (let s = 0; s < t; s++)
        a.outs[s] = dz;
      a.ins.forEach((s, u) => {
        u !== t && (s.sequence = 0);
      });
    }
    n & qt.SIGHASH_ANYONECANPAY ? (a.ins = [a.ins[t]], a.ins[0].script = o) : (a.ins.forEach((s) => {
      s.script = mu;
    }), a.ins[t].script = o);
    const i = new Uint8Array(a.byteLength(!1) + 4);
    return Lk(i, i.length - 4, n, "LE"), a.__toBuffer(i, 0, !1), oc(i);
  }
  hashForWitnessV1(t, r, n, o, a, i) {
    if (cr(
      ta([
        Ha,
        Yn(Rt),
        Yn(Mb),
        Ha
      ]),
      [t, r, n, o]
    ), n.length !== this.ins.length || r.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const s = o === qt.SIGHASH_DEFAULT ? qt.SIGHASH_ALL : o & qt.SIGHASH_OUTPUT_MASK, u = (o & qt.SIGHASH_INPUT_MASK) === qt.SIGHASH_ANYONECANPAY, l = s === qt.SIGHASH_NONE, c = s === qt.SIGHASH_SINGLE;
    let f = mu, h = mu, p = mu, y = mu, m = mu;
    if (!u) {
      let E = Vn.withCapacity(36 * this.ins.length);
      this.ins.forEach((A) => {
        E.writeSlice(A.hash), E.writeUInt32(A.index);
      }), f = en(E.end()), E = Vn.withCapacity(8 * this.ins.length), n.forEach((A) => E.writeInt64(A)), h = en(E.end()), E = Vn.withCapacity(
        r.map(Qi).reduce((A, S) => A + S)
      ), r.forEach(
        (A) => E.writeVarSlice(A)
      ), p = en(E.end()), E = Vn.withCapacity(4 * this.ins.length), this.ins.forEach((A) => E.writeUInt32(A.sequence)), y = en(E.end());
    }
    if (l || c) {
      if (c && t < this.outs.length) {
        const E = this.outs[t], A = Vn.withCapacity(
          8 + Qi(E.script)
        );
        A.writeInt64(E.value), A.writeVarSlice(E.script), m = en(A.end());
      }
    } else {
      if (!this.outs.length)
        throw new Error("Add outputs to the transaction before signing.");
      const E = this.outs.map((S) => 8 + Qi(S.script)).reduce((S, _) => S + _), A = Vn.withCapacity(E);
      this.outs.forEach((S) => {
        A.writeInt64(S.value), A.writeVarSlice(S.script);
      }), m = en(A.end());
    }
    const b = (a ? 2 : 0) + (i ? 1 : 0), v = 174 - (u ? 49 : 0) - (l ? 32 : 0) + (i ? 32 : 0) + (a ? 37 : 0), k = Vn.withCapacity(v);
    if (k.writeUInt8(o), k.writeInt32(this.version), k.writeUInt32(this.locktime), k.writeSlice(f), k.writeSlice(h), k.writeSlice(p), k.writeSlice(y), l || c || k.writeSlice(m), k.writeUInt8(b), u) {
      const E = this.ins[t];
      k.writeSlice(E.hash), k.writeUInt32(E.index), k.writeInt64(n[t]), k.writeVarSlice(r[t]), k.writeUInt32(E.sequence);
    } else
      k.writeUInt32(t);
    if (i) {
      const E = Vn.withCapacity(Qi(i));
      E.writeVarSlice(i), k.writeSlice(en(E.end()));
    }
    return c && k.writeSlice(m), a && (k.writeSlice(a), k.writeUInt8(0), k.writeUInt32(4294967295)), $m(
      "TapSighash",
      gr([Uint8Array.from([0]), k.end()])
    );
  }
  hashForWitnessV0(t, r, n, o) {
    cr(
      ta([
        Ha,
        Rt,
        Mb,
        Ha
      ]),
      [t, r, n, o]
    );
    let a = Uint8Array.from([]), i, s = Gb, u = Gb, l = Gb;
    if (o & qt.SIGHASH_ANYONECANPAY || (a = new Uint8Array(36 * this.ins.length), i = new Vn(a, 0), this.ins.forEach((f) => {
      i.writeSlice(f.hash), i.writeUInt32(f.index);
    }), u = oc(a)), !(o & qt.SIGHASH_ANYONECANPAY) && (o & 31) !== qt.SIGHASH_SINGLE && (o & 31) !== qt.SIGHASH_NONE && (a = new Uint8Array(4 * this.ins.length), i = new Vn(a, 0), this.ins.forEach((f) => {
      i.writeUInt32(f.sequence);
    }), l = oc(a)), (o & 31) !== qt.SIGHASH_SINGLE && (o & 31) !== qt.SIGHASH_NONE) {
      const f = this.outs.reduce((h, p) => h + 8 + Qi(p.script), 0);
      a = new Uint8Array(f), i = new Vn(a, 0), this.outs.forEach((h) => {
        i.writeInt64(h.value), i.writeVarSlice(h.script);
      }), s = oc(a);
    } else if ((o & 31) === qt.SIGHASH_SINGLE && t < this.outs.length) {
      const f = this.outs[t];
      a = new Uint8Array(8 + Qi(f.script)), i = new Vn(a, 0), i.writeInt64(f.value), i.writeVarSlice(f.script), s = oc(a);
    }
    a = new Uint8Array(156 + Qi(r)), i = new Vn(a, 0);
    const c = this.ins[t];
    return i.writeInt32(this.version), i.writeSlice(u), i.writeSlice(l), i.writeSlice(c.hash), i.writeUInt32(c.index), i.writeVarSlice(r), i.writeInt64(n), i.writeUInt32(c.sequence), i.writeSlice(s), i.writeUInt32(this.locktime), i.writeUInt32(o), oc(a);
  }
  getHash(t) {
    return t && this.isCoinbase() ? new Uint8Array(32) : oc(this.__toBuffer(void 0, void 0, t));
  }
  getId() {
    return qe(G8(this.getHash(!1)));
  }
  toBuffer(t, r) {
    return this.__toBuffer(t, r, !0);
  }
  toHex() {
    return qe(this.toBuffer(void 0, void 0));
  }
  setInputScript(t, r) {
    cr(ta([Zn(), Rt]), [t, r]), this.ins[t].script = r;
  }
  setWitness(t, r) {
    cr(ta([Zn(), Yn(Rt)]), [
      t,
      r
    ]), this.ins[t].witness = r;
  }
  __toBuffer(t, r, n = !1) {
    t || (t = new Uint8Array(this.byteLength(n)));
    const o = new Vn(t, r || 0);
    o.writeInt32(this.version);
    const a = n && this.hasWitnesses();
    return a && (o.writeUInt8(qt.ADVANCED_TRANSACTION_MARKER), o.writeUInt8(qt.ADVANCED_TRANSACTION_FLAG)), o.writeVarInt(this.ins.length), this.ins.forEach((i) => {
      o.writeSlice(i.hash), o.writeUInt32(i.index), o.writeVarSlice(i.script), o.writeUInt32(i.sequence);
    }), o.writeVarInt(this.outs.length), this.outs.forEach((i) => {
      hz(i) ? o.writeInt64(i.value) : o.writeSlice(i.valueBuffer), o.writeVarSlice(i.script);
    }), a && this.ins.forEach((i) => {
      o.writeVector(i.witness);
    }), o.writeUInt32(this.locktime), r !== void 0 ? t.slice(r, o.offset) : t;
  }
};
ke(ni, "DEFAULT_SEQUENCE", 4294967295), ke(ni, "SIGHASH_DEFAULT", 0), ke(ni, "SIGHASH_ALL", 1), ke(ni, "SIGHASH_NONE", 2), ke(ni, "SIGHASH_SINGLE", 3), ke(ni, "SIGHASH_ANYONECANPAY", 128), ke(ni, "SIGHASH_OUTPUT_MASK", 3), ke(ni, "SIGHASH_INPUT_MASK", 128), ke(ni, "ADVANCED_TRANSACTION_MARKER", 0), ke(ni, "ADVANCED_TRANSACTION_FLAG", 1);
let _r = ni;
var ca;
(function(e) {
  e[e.UNSIGNED_TX = 0] = "UNSIGNED_TX", e[e.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
})(ca || (ca = {}));
var Se;
(function(e) {
  e[e.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", e[e.WITNESS_UTXO = 1] = "WITNESS_UTXO", e[e.PARTIAL_SIG = 2] = "PARTIAL_SIG", e[e.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", e[e.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", e[e.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", e[e.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", e[e.POR_COMMITMENT = 9] = "POR_COMMITMENT", e[e.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", e[e.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", e[e.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", e[e.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", e[e.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
})(Se || (Se = {}));
var Ar;
(function(e) {
  e[e.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", e[e.TAP_TREE = 6] = "TAP_TREE", e[e.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
})(Ar || (Ar = {}));
const pz = (e) => [...Array(e).keys()];
function gz(e) {
  if (e.key[0] !== ca.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + qe(e.key)
    );
  if (e.key.length !== 79 || ![2, 3].includes(e.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + qe(e.key)
    );
  if (e.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const t = e.key.slice(1), r = {
    masterFingerprint: e.value.slice(0, 4),
    extendedPubkey: t,
    path: "m"
  };
  for (const n of pz(e.value.length / 4 - 1)) {
    const o = Gf(e.value, n * 4 + 4, "LE"), a = !!(o & 2147483648), i = o & 2147483647;
    r.path += "/" + i.toString(10) + (a ? "'" : "");
  }
  return r;
}
function mz(e) {
  const t = new Uint8Array([ca.GLOBAL_XPUB]), r = gr([t, e.extendedPubkey]), n = e.path.split("/"), o = new Uint8Array(n.length * 4);
  o.set(e.masterFingerprint, 0);
  let a = 4;
  return n.slice(1).forEach((i) => {
    const s = i.slice(-1) === "'";
    let u = 2147483647 & parseInt(s ? i.slice(0, -1) : i, 10);
    s && (u += 2147483648), hp(o, a, u, "LE"), a += 4;
  }), {
    key: r,
    value: o
  };
}
const yz = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function bz(e) {
  const t = e.extendedPubkey, r = e.masterFingerprint, n = e.path;
  return t instanceof Uint8Array && t.length === 78 && [2, 3].indexOf(t[45]) > -1 && r instanceof Uint8Array && r.length === 4 && typeof n == "string" && !!n.match(/^m(\/\d+'?)*$/);
}
function wz(e, t, r) {
  const n = qe(t.extendedPubkey);
  return r.has(n) ? !1 : (r.add(n), e.filter((o) => fe(o.extendedPubkey, t.extendedPubkey)).length === 0);
}
const vz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: wz,
  check: bz,
  decode: gz,
  encode: mz,
  expected: yz
}, Symbol.toStringTag, { value: "Module" }));
function Ez(e) {
  return {
    key: new Uint8Array([ca.UNSIGNED_TX]),
    value: e.toBuffer()
  };
}
const kz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  encode: Ez
}, Symbol.toStringTag, { value: "Module" }));
function xz(e) {
  if (e.key[0] !== Se.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + qe(e.key)
    );
  return e.value;
}
function Az(e) {
  return {
    key: new Uint8Array([Se.FINAL_SCRIPTSIG]),
    value: e
  };
}
const Sz = "Uint8Array";
function _z(e) {
  return e instanceof Uint8Array;
}
function Iz(e, t) {
  return !!e && !!t && e.finalScriptSig === void 0;
}
const Tz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Iz,
  check: _z,
  decode: xz,
  encode: Az,
  expected: Sz
}, Symbol.toStringTag, { value: "Module" }));
function Pz(e) {
  if (e.key[0] !== Se.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + qe(e.key)
    );
  return e.value;
}
function Oz(e) {
  return {
    key: new Uint8Array([Se.FINAL_SCRIPTWITNESS]),
    value: e
  };
}
const $z = "Uint8Array";
function Cz(e) {
  return e instanceof Uint8Array;
}
function Bz(e, t) {
  return !!e && !!t && e.finalScriptWitness === void 0;
}
const Nz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Bz,
  check: Cz,
  decode: Pz,
  encode: Oz,
  expected: $z
}, Symbol.toStringTag, { value: "Module" }));
function Uz(e) {
  if (e.key[0] !== Se.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + qe(e.key)
    );
  return e.value;
}
function Rz(e) {
  return {
    key: new Uint8Array([Se.NON_WITNESS_UTXO]),
    value: e
  };
}
const zz = "Uint8Array";
function jz(e) {
  return e instanceof Uint8Array;
}
function Lz(e, t) {
  return !!e && !!t && e.nonWitnessUtxo === void 0;
}
const Hz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Lz,
  check: jz,
  decode: Uz,
  encode: Rz,
  expected: zz
}, Symbol.toStringTag, { value: "Module" }));
function Fz(e) {
  if (e.key[0] !== Se.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + qe(e.key)
    );
  if (!(e.key.length === 34 || e.key.length === 66) || ![2, 3, 4].includes(e.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + qe(e.key)
    );
  return {
    pubkey: e.key.slice(1),
    signature: e.value
  };
}
function Dz(e) {
  const t = new Uint8Array([Se.PARTIAL_SIG]);
  return {
    key: gr([t, e.pubkey]),
    value: e.signature
  };
}
const Mz = "{ pubkey: Uint8Array; signature: Uint8Array; }";
function Kz(e) {
  return e.pubkey instanceof Uint8Array && e.signature instanceof Uint8Array && [33, 65].includes(e.pubkey.length) && [2, 3, 4].includes(e.pubkey[0]) && qz(e.signature);
}
function qz(e) {
  if (!(e instanceof Uint8Array) || e.length < 9 || e[0] !== 48 || e.length !== e[1] + 3 || e[2] !== 2) return !1;
  const t = e[3];
  if (t > 33 || t < 1 || e[3 + t + 1] !== 2) return !1;
  const r = e[3 + t + 2];
  return !(r > 33 || r < 1 || e.length !== 3 + t + 2 + r + 2);
}
function Vz(e, t, r) {
  const n = qe(t.pubkey);
  return r.has(n) ? !1 : (r.add(n), e.filter((o) => fe(o.pubkey, t.pubkey) === 0).length === 0);
}
const Gz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: Vz,
  check: Kz,
  decode: Fz,
  encode: Dz,
  expected: Mz
}, Symbol.toStringTag, { value: "Module" }));
function Zz(e) {
  if (e.key[0] !== Se.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + qe(e.key)
    );
  return HU(e.value);
}
function Wz(e) {
  return {
    key: new Uint8Array([Se.POR_COMMITMENT]),
    value: FU(e)
  };
}
const Xz = "string";
function Yz(e) {
  return typeof e == "string";
}
function Jz(e, t) {
  return !!e && !!t && e.porCommitment === void 0;
}
const Qz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Jz,
  check: Yz,
  decode: Zz,
  encode: Wz,
  expected: Xz
}, Symbol.toStringTag, { value: "Module" }));
function ej(e) {
  if (e.key[0] !== Se.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + qe(e.key)
    );
  return Number(Gf(e.value, 0, "LE"));
}
function tj(e) {
  const t = Uint8Array.from([Se.SIGHASH_TYPE]), r = new Uint8Array(4);
  return hp(r, 0, e, "LE"), {
    key: t,
    value: r
  };
}
const rj = "number";
function nj(e) {
  return typeof e == "number";
}
function oj(e, t) {
  return !!e && !!t && e.sighashType === void 0;
}
const ij = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: oj,
  check: nj,
  decode: ej,
  encode: tj,
  expected: rj
}, Symbol.toStringTag, { value: "Module" }));
function aj(e) {
  if (e.key[0] !== Se.TAP_KEY_SIG || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + qe(e.key)
    );
  if (!vx(e.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return e.value;
}
function sj(e) {
  return { key: Uint8Array.from([Se.TAP_KEY_SIG]), value: e };
}
const uj = "Uint8Array";
function vx(e) {
  return e instanceof Uint8Array && (e.length === 64 || e.length === 65);
}
function cj(e, t) {
  return !!e && !!t && e.tapKeySig === void 0;
}
const lj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: cj,
  check: vx,
  decode: aj,
  encode: sj,
  expected: uj
}, Symbol.toStringTag, { value: "Module" }));
function fj(e) {
  if (e.key[0] !== Se.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + qe(e.key)
    );
  if ((e.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + qe(e.key)
    );
  const t = e.value[e.value.length - 1];
  if ((e.key[1] & 254) !== t)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + qe(e.key)
    );
  const r = e.value.slice(0, -1);
  return { controlBlock: e.key.slice(1), script: r, leafVersion: t };
}
function dj(e) {
  const t = Uint8Array.from([Se.TAP_LEAF_SCRIPT]), r = Uint8Array.from([e.leafVersion]);
  return {
    key: gr([t, e.controlBlock]),
    value: gr([e.script, r])
  };
}
const hj = "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }";
function pj(e) {
  return e.controlBlock instanceof Uint8Array && (e.controlBlock.length - 1) % 32 === 0 && (e.controlBlock[0] & 254) === e.leafVersion && e.script instanceof Uint8Array;
}
function gj(e, t, r) {
  const n = qe(t.controlBlock);
  return r.has(n) ? !1 : (r.add(n), e.filter((o) => fe(o.controlBlock, t.controlBlock) === 0).length === 0);
}
const mj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: gj,
  check: pj,
  decode: fj,
  encode: dj,
  expected: hj
}, Symbol.toStringTag, { value: "Module" }));
function yj(e) {
  if (e.key[0] !== Se.TAP_MERKLE_ROOT || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + qe(e.key)
    );
  if (!Ex(e.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return e.value;
}
function bj(e) {
  return { key: Uint8Array.from([Se.TAP_MERKLE_ROOT]), value: e };
}
const wj = "Uint8Array";
function Ex(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function vj(e, t) {
  return !!e && !!t && e.tapMerkleRoot === void 0;
}
const Ej = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: vj,
  check: Ex,
  decode: yj,
  encode: bj,
  expected: wj
}, Symbol.toStringTag, { value: "Module" }));
function kj(e) {
  if (e.key[0] !== Se.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + qe(e.key)
    );
  if (e.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + qe(e.key)
    );
  if (e.value.length !== 64 && e.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + qe(e.key)
    );
  const t = e.key.slice(1, 33), r = e.key.slice(33);
  return {
    pubkey: t,
    leafHash: r,
    signature: e.value
  };
}
function xj(e) {
  const t = Uint8Array.from([Se.TAP_SCRIPT_SIG]);
  return {
    key: gr([t, e.pubkey, e.leafHash]),
    value: e.signature
  };
}
const Aj = "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }";
function Sj(e) {
  return e.pubkey instanceof Uint8Array && e.leafHash instanceof Uint8Array && e.signature instanceof Uint8Array && e.pubkey.length === 32 && e.leafHash.length === 32 && (e.signature.length === 64 || e.signature.length === 65);
}
function _j(e, t, r) {
  const n = qe(t.pubkey) + qe(t.leafHash);
  return r.has(n) ? !1 : (r.add(n), e.filter(
    (o) => fe(o.pubkey, t.pubkey) === 0 && fe(o.leafHash, t.leafHash) === 0
  ).length === 0);
}
const Ij = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: _j,
  check: Sj,
  decode: kj,
  encode: xj,
  expected: Aj
}, Symbol.toStringTag, { value: "Module" }));
function Tj(e) {
  if (e.key[0] !== Se.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + qe(e.key)
    );
  const t = Fk(e.value, 0, "LE");
  let r = 8;
  const { numberValue: n, bytes: o } = Xf(
    e.value,
    r
  );
  r += o;
  const a = e.value.slice(r);
  if (a.length !== n)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: a,
    value: t
  };
}
function Pj(e) {
  const { script: t, value: r } = e, n = Wo(t.length), o = new Uint8Array(8 + n + t.length);
  return Hk(o, 0, BigInt(r), "LE"), Cu(t.length, o, 8), o.set(t, 8 + n), {
    key: Uint8Array.from([Se.WITNESS_UTXO]),
    value: o
  };
}
const Oj = "{ script: Uint8Array; value: bigint; }";
function $j(e) {
  return e.script instanceof Uint8Array && typeof e.value == "bigint";
}
function Cj(e, t) {
  return !!e && !!t && e.witnessUtxo === void 0;
}
const Bj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Cj,
  check: $j,
  decode: Tj,
  encode: Pj,
  expected: Oj
}, Symbol.toStringTag, { value: "Module" }));
function Nj(e) {
  if (e.key[0] !== Ar.TAP_TREE || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + qe(e.key)
    );
  let t = 0;
  const r = [];
  for (; t < e.value.length; ) {
    const n = e.value[t++], o = e.value[t++], { numberValue: a, bytes: i } = Xf(
      e.value,
      t
    );
    t += i, r.push({
      depth: n,
      leafVersion: o,
      script: e.value.slice(t, t + a)
    }), t += a;
  }
  return { leaves: r };
}
function Uj(e) {
  const t = Uint8Array.from([Ar.TAP_TREE]), r = [].concat(
    ...e.leaves.map((n) => [
      Uint8Array.of(n.depth, n.leafVersion),
      Cu(BigInt(n.script.length)).buffer,
      n.script
    ])
  );
  return {
    key: t,
    value: gr(r)
  };
}
const Rj = "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }";
function zj(e) {
  return Array.isArray(e.leaves) && e.leaves.every(
    (t) => t.depth >= 0 && t.depth <= 128 && (t.leafVersion & 254) === t.leafVersion && t.script instanceof Uint8Array
  );
}
function jj(e, t) {
  return !!e && !!t && e.tapTree === void 0;
}
const Lj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: jj,
  check: zj,
  decode: Nj,
  encode: Uj,
  expected: Rj
}, Symbol.toStringTag, { value: "Module" })), Hj = (e) => [...Array(e).keys()], Fj = (e) => e.length === 33 && [2, 3].includes(e[0]) || e.length === 65 && e[0] === 4;
function W8(e, t = Fj) {
  function r(s) {
    if (s.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + qe(s.key)
      );
    const u = s.key.slice(1);
    if (!t(u))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + qe(s.key)
      );
    if (s.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const l = {
      masterFingerprint: s.value.slice(0, 4),
      pubkey: u,
      path: "m"
    };
    for (const c of Hj(s.value.length / 4 - 1)) {
      const f = Gf(s.value, c * 4 + 4, "LE"), h = !!(f & 2147483648), p = f & 2147483647;
      l.path += "/" + p.toString(10) + (h ? "'" : "");
    }
    return l;
  }
  function n(s) {
    const u = Uint8Array.from([e]), l = gr([u, s.pubkey]), c = s.path.split("/"), f = new Uint8Array(c.length * 4);
    f.set(s.masterFingerprint, 0);
    let h = 4;
    return c.slice(1).forEach((p) => {
      const y = p.slice(-1) === "'";
      let m = 2147483647 & parseInt(y ? p.slice(0, -1) : p, 10);
      y && (m += 2147483648), hp(f, h, m, "LE"), h += 4;
    }), {
      key: l,
      value: f
    };
  }
  const o = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }";
  function a(s) {
    return s.pubkey instanceof Uint8Array && s.masterFingerprint instanceof Uint8Array && typeof s.path == "string" && t(s.pubkey) && s.masterFingerprint.length === 4;
  }
  function i(s, u, l) {
    const c = qe(u.pubkey);
    return l.has(c) ? !1 : (l.add(c), s.filter((f) => fe(f.pubkey, u.pubkey) === 0).length === 0);
  }
  return {
    decode: r,
    encode: n,
    check: a,
    expected: o,
    canAddToArray: i
  };
}
function X8(e) {
  return t;
  function t(r) {
    let n;
    if (e.includes(r.key[0]) && (n = r.key.slice(1), !(n.length === 33 || n.length === 65) || ![2, 3, 4].includes(n[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + qe(r.key)
      );
    return n;
  }
}
function kx(e) {
  function t(i) {
    if (i.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + qe(i.key)
      );
    return i.value;
  }
  function r(i) {
    return {
      key: Uint8Array.from([e]),
      value: i
    };
  }
  const n = "Uint8Array";
  function o(i) {
    return i instanceof Uint8Array;
  }
  function a(i, s) {
    return !!i && !!s && i.redeemScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: o,
    expected: n,
    canAdd: a
  };
}
const Dj = (e) => e.length === 32;
function xx(e) {
  const t = W8(e, Dj);
  function r(i) {
    const { numberValue: s, bytes: u } = Xf(
      i.value
    ), l = t.decode({
      key: i.key,
      value: i.value.slice(u + Number(s) * 32)
    }), c = new Array(Number(s));
    for (let f = 0, h = u; f < s; f++, h += 32)
      c[f] = i.value.slice(h, h + 32);
    return { ...l, leafHashes: c };
  }
  function n(i) {
    const s = t.encode(i), u = Wo(i.leafHashes.length), l = new Uint8Array(u);
    Cu(i.leafHashes.length, l);
    const c = gr([l, ...i.leafHashes, s.value]);
    return { ...s, value: c };
  }
  const o = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }";
  function a(i) {
    return Array.isArray(i.leafHashes) && i.leafHashes.every(
      (s) => s instanceof Uint8Array && s.length === 32
    ) && t.check(i);
  }
  return {
    decode: r,
    encode: n,
    check: a,
    expected: o,
    canAddToArray: t.canAddToArray
  };
}
function Ax(e) {
  function t(i) {
    if (i.key[0] !== e || i.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + qe(i.key)
      );
    if (i.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return i.value;
  }
  function r(i) {
    return { key: Uint8Array.from([e]), value: i };
  }
  const n = "Uint8Array";
  function o(i) {
    return i instanceof Uint8Array && i.length === 32;
  }
  function a(i, s) {
    return !!i && !!s && i.tapInternalKey === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: o,
    expected: n,
    canAdd: a
  };
}
function Sx(e) {
  function t(i) {
    if (i.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + qe(i.key)
      );
    return i.value;
  }
  function r(i) {
    return {
      key: Uint8Array.from([e]),
      value: i
    };
  }
  const n = "Uint8Array";
  function o(i) {
    return i instanceof Uint8Array;
  }
  function a(i, s) {
    return !!i && !!s && i.witnessScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: o,
    expected: n,
    canAdd: a
  };
}
const Y8 = {
  unsignedTx: kz,
  globalXpub: vz,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: X8([])
}, Dr = {
  nonWitnessUtxo: Hz,
  partialSig: Gz,
  sighashType: ij,
  finalScriptSig: Tz,
  finalScriptWitness: Nz,
  porCommitment: Qz,
  witnessUtxo: Bj,
  bip32Derivation: W8(Se.BIP32_DERIVATION),
  redeemScript: kx(Se.REDEEM_SCRIPT),
  witnessScript: Sx(Se.WITNESS_SCRIPT),
  checkPubkey: X8([
    Se.PARTIAL_SIG,
    Se.BIP32_DERIVATION
  ]),
  tapKeySig: lj,
  tapScriptSig: Ij,
  tapLeafScript: mj,
  tapBip32Derivation: xx(
    Se.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: Ax(Se.TAP_INTERNAL_KEY),
  tapMerkleRoot: Ej
}, Fa = {
  bip32Derivation: W8(Ar.BIP32_DERIVATION),
  redeemScript: kx(Ar.REDEEM_SCRIPT),
  witnessScript: Sx(Ar.WITNESS_SCRIPT),
  checkPubkey: X8([Ar.BIP32_DERIVATION]),
  tapBip32Derivation: xx(
    Ar.TAP_BIP32_DERIVATION
  ),
  tapTree: Lj,
  tapInternalKey: Ax(Ar.TAP_INTERNAL_KEY)
}, Mj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  globals: Y8,
  inputs: Dr,
  outputs: Fa
}, Symbol.toStringTag, { value: "Module" })), Z1 = (e) => [...Array(e).keys()];
function C6(e) {
  const t = e.map(Kj);
  return t.push(Uint8Array.from([0])), gr(t);
}
function Kj(e) {
  const t = e.key.length, r = e.value.length, n = Wo(t), o = Wo(r), a = new Uint8Array(n + t + o + r);
  return Cu(t, a, 0), a.set(e.key, n), Cu(r, a, n + t), a.set(e.value, n + t + o), a;
}
function qj(e, t) {
  let r = 0;
  function n() {
    const { numberValue: b, bytes: v } = Xf(e, r);
    r += v;
    const k = e.slice(r, r + Number(b));
    return r += Number(b), k;
  }
  function o() {
    const b = Gf(e, r, "BE");
    return r += 4, b;
  }
  function a() {
    const b = ns(e, r);
    return r += 1, b;
  }
  function i() {
    const b = n(), v = n();
    return {
      key: b,
      value: v
    };
  }
  function s() {
    if (r >= e.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const b = ns(e, r) === 0;
    return b && r++, b;
  }
  if (o() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (a() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const u = [], l = {};
  for (; !s(); ) {
    const b = i(), v = qe(b.key);
    if (l[v])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + v
      );
    l[v] = 1, u.push(b);
  }
  const c = u.filter(
    (b) => b.key[0] === ca.UNSIGNED_TX
  );
  if (c.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const f = t(c[0].value), { inputCount: h, outputCount: p } = f.getInputOutputCounts(), y = [], m = [];
  for (const b of Z1(h)) {
    const v = {}, k = [];
    for (; !s(); ) {
      const E = i(), A = qe(E.key);
      if (v[A])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + b + " key " + A
        );
      v[A] = 1, k.push(E);
    }
    y.push(k);
  }
  for (const b of Z1(p)) {
    const v = {}, k = [];
    for (; !s(); ) {
      const E = i(), A = qe(E.key);
      if (v[A])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + b + " key " + A
        );
      v[A] = 1, k.push(E);
    }
    m.push(k);
  }
  return _x(f, {
    globalMapKeyVals: u,
    inputKeyVals: y,
    outputKeyVals: m
  });
}
function gn(e, t, r) {
  if (fe(t, Uint8Array.from([r])))
    throw new Error(
      // `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
      `Format Error: Invalid ${e} key: ${qe(t)}`
    );
}
function _x(e, { globalMapKeyVals: t, inputKeyVals: r, outputKeyVals: n }) {
  const o = {
    unsignedTx: e
  };
  let a = 0;
  for (const c of t)
    switch (c.key[0]) {
      case ca.UNSIGNED_TX:
        if (gn("global", c.key, ca.UNSIGNED_TX), a > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        a++;
        break;
      case ca.GLOBAL_XPUB:
        o.globalXpub === void 0 && (o.globalXpub = []), o.globalXpub.push(Y8.globalXpub.decode(c));
        break;
      default:
        o.unknownKeyVals || (o.unknownKeyVals = []), o.unknownKeyVals.push(c);
    }
  const i = r.length, s = n.length, u = [], l = [];
  for (const c of Z1(i)) {
    const f = {};
    for (const h of r[c])
      switch (Dr.checkPubkey(h), h.key[0]) {
        case Se.NON_WITNESS_UTXO:
          if (gn("input", h.key, Se.NON_WITNESS_UTXO), f.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          f.nonWitnessUtxo = Dr.nonWitnessUtxo.decode(h);
          break;
        case Se.WITNESS_UTXO:
          if (gn("input", h.key, Se.WITNESS_UTXO), f.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          f.witnessUtxo = Dr.witnessUtxo.decode(h);
          break;
        case Se.PARTIAL_SIG:
          f.partialSig === void 0 && (f.partialSig = []), f.partialSig.push(Dr.partialSig.decode(h));
          break;
        case Se.SIGHASH_TYPE:
          if (gn("input", h.key, Se.SIGHASH_TYPE), f.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          f.sighashType = Dr.sighashType.decode(h);
          break;
        case Se.REDEEM_SCRIPT:
          if (gn("input", h.key, Se.REDEEM_SCRIPT), f.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          f.redeemScript = Dr.redeemScript.decode(h);
          break;
        case Se.WITNESS_SCRIPT:
          if (gn("input", h.key, Se.WITNESS_SCRIPT), f.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          f.witnessScript = Dr.witnessScript.decode(h);
          break;
        case Se.BIP32_DERIVATION:
          f.bip32Derivation === void 0 && (f.bip32Derivation = []), f.bip32Derivation.push(
            Dr.bip32Derivation.decode(h)
          );
          break;
        case Se.FINAL_SCRIPTSIG:
          gn("input", h.key, Se.FINAL_SCRIPTSIG), f.finalScriptSig = Dr.finalScriptSig.decode(h);
          break;
        case Se.FINAL_SCRIPTWITNESS:
          gn("input", h.key, Se.FINAL_SCRIPTWITNESS), f.finalScriptWitness = Dr.finalScriptWitness.decode(
            h
          );
          break;
        case Se.POR_COMMITMENT:
          gn("input", h.key, Se.POR_COMMITMENT), f.porCommitment = Dr.porCommitment.decode(h);
          break;
        case Se.TAP_KEY_SIG:
          gn("input", h.key, Se.TAP_KEY_SIG), f.tapKeySig = Dr.tapKeySig.decode(h);
          break;
        case Se.TAP_SCRIPT_SIG:
          f.tapScriptSig === void 0 && (f.tapScriptSig = []), f.tapScriptSig.push(Dr.tapScriptSig.decode(h));
          break;
        case Se.TAP_LEAF_SCRIPT:
          f.tapLeafScript === void 0 && (f.tapLeafScript = []), f.tapLeafScript.push(Dr.tapLeafScript.decode(h));
          break;
        case Se.TAP_BIP32_DERIVATION:
          f.tapBip32Derivation === void 0 && (f.tapBip32Derivation = []), f.tapBip32Derivation.push(
            Dr.tapBip32Derivation.decode(h)
          );
          break;
        case Se.TAP_INTERNAL_KEY:
          gn("input", h.key, Se.TAP_INTERNAL_KEY), f.tapInternalKey = Dr.tapInternalKey.decode(h);
          break;
        case Se.TAP_MERKLE_ROOT:
          gn("input", h.key, Se.TAP_MERKLE_ROOT), f.tapMerkleRoot = Dr.tapMerkleRoot.decode(h);
          break;
        default:
          f.unknownKeyVals || (f.unknownKeyVals = []), f.unknownKeyVals.push(h);
      }
    u.push(f);
  }
  for (const c of Z1(s)) {
    const f = {};
    for (const h of n[c])
      switch (Fa.checkPubkey(h), h.key[0]) {
        case Ar.REDEEM_SCRIPT:
          if (gn("output", h.key, Ar.REDEEM_SCRIPT), f.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          f.redeemScript = Fa.redeemScript.decode(h);
          break;
        case Ar.WITNESS_SCRIPT:
          if (gn("output", h.key, Ar.WITNESS_SCRIPT), f.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          f.witnessScript = Fa.witnessScript.decode(h);
          break;
        case Ar.BIP32_DERIVATION:
          f.bip32Derivation === void 0 && (f.bip32Derivation = []), f.bip32Derivation.push(
            Fa.bip32Derivation.decode(h)
          );
          break;
        case Ar.TAP_INTERNAL_KEY:
          gn("output", h.key, Ar.TAP_INTERNAL_KEY), f.tapInternalKey = Fa.tapInternalKey.decode(h);
          break;
        case Ar.TAP_TREE:
          gn("output", h.key, Ar.TAP_TREE), f.tapTree = Fa.tapTree.decode(h);
          break;
        case Ar.TAP_BIP32_DERIVATION:
          f.tapBip32Derivation === void 0 && (f.tapBip32Derivation = []), f.tapBip32Derivation.push(
            Fa.tapBip32Derivation.decode(h)
          );
          break;
        default:
          f.unknownKeyVals || (f.unknownKeyVals = []), f.unknownKeyVals.push(h);
      }
    l.push(f);
  }
  return { globalMap: o, inputs: u, outputs: l };
}
function Vj({ globalMap: e, inputs: t, outputs: r }) {
  const { globalKeyVals: n, inputKeyVals: o, outputKeyVals: a } = Ow({
    globalMap: e,
    inputs: t,
    outputs: r
  }), i = C6(n), s = (f) => f.length === 0 ? [Uint8Array.from([0])] : f.map(C6), u = s(o), l = s(a), c = new Uint8Array(5);
  return c.set([112, 115, 98, 116, 255], 0), gr(
    [c, i].concat(u, l)
  );
}
const Gj = (e, t) => fe(e.key, t.key);
function Zb(e, t) {
  const r = /* @__PURE__ */ new Set(), n = Object.entries(e).reduce((a, [i, s]) => {
    if (i === "unknownKeyVals") return a;
    const u = t[i];
    if (u === void 0) return a;
    const l = (Array.isArray(s) ? s : [s]).map(
      u.encode
    );
    return l.map((c) => qe(c.key)).forEach((c) => {
      if (r.has(c))
        throw new Error("Serialize Error: Duplicate key: " + c);
      r.add(c);
    }), a.concat(l);
  }, []), o = e.unknownKeyVals ? e.unknownKeyVals.filter((a) => !r.has(qe(a.key))) : [];
  return n.concat(o).sort(Gj);
}
function Ow({ globalMap: e, inputs: t, outputs: r }) {
  return {
    globalKeyVals: Zb(e, Y8),
    inputKeyVals: t.map((n) => Zb(n, Dr)),
    outputKeyVals: r.map((n) => Zb(n, Fa))
  };
}
function Zj(e) {
  const t = e[0], r = Ow(t), n = e.slice(1);
  if (n.length === 0) throw new Error("Combine: Nothing to combine");
  const o = B6(t);
  if (o === void 0)
    throw new Error("Combine: Self missing transaction");
  const a = $l(r.globalKeyVals), i = r.inputKeyVals.map($l), s = r.outputKeyVals.map($l);
  for (const u of n) {
    const l = B6(u);
    if (l === void 0 || fe(l.toBuffer(), o.toBuffer()) !== 0)
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const c = Ow(u);
    $l(c.globalKeyVals).forEach(
      Wb(
        a,
        r.globalKeyVals,
        c.globalKeyVals
      )
    ), c.inputKeyVals.map($l).forEach(
      (f, h) => f.forEach(
        Wb(
          i[h],
          r.inputKeyVals[h],
          c.inputKeyVals[h]
        )
      )
    ), c.outputKeyVals.map($l).forEach(
      (f, h) => f.forEach(
        Wb(
          s[h],
          r.outputKeyVals[h],
          c.outputKeyVals[h]
        )
      )
    );
  }
  return _x(o, {
    globalMapKeyVals: r.globalKeyVals,
    inputKeyVals: r.inputKeyVals,
    outputKeyVals: r.outputKeyVals
  });
}
function Wb(e, t, r) {
  return (n) => {
    if (e.has(n)) return;
    const o = r.filter((a) => qe(a.key) === n)[0];
    t.push(o), e.add(n);
  };
}
function B6(e) {
  return e.globalMap.unsignedTx;
}
function $l(e) {
  const t = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    const n = qe(r.key);
    if (t.has(n))
      throw new Error("Combine: KeyValue Map keys should be unique");
    t.add(n);
  }), t;
}
function cn(e, t) {
  const r = e[t];
  if (r === void 0) throw new Error(`No input #${t}`);
  return r;
}
function wh(e, t) {
  const r = e[t];
  if (r === void 0) throw new Error(`No output #${t}`);
  return r;
}
function Xb(e, t, r) {
  if (e.key[0] < r)
    throw new Error(
      "Use the method for your specific key instead of addUnknownKeyVal*"
    );
  if (t && t.filter((n) => fe(n.key, e.key) === 0).length !== 0)
    throw new Error(`Duplicate Key: ${qe(e.key)}`);
}
function Yb(e) {
  let t = 0;
  return Object.keys(e).forEach((r) => {
    Number(isNaN(Number(r))) && t++;
  }), t;
}
function Wj(e, t) {
  let r = !1;
  if (t.nonWitnessUtxo || t.witnessUtxo) {
    const n = !!t.redeemScript, o = !!t.witnessScript, a = !n || !!t.finalScriptSig, i = !o || !!t.finalScriptWitness, s = !!t.finalScriptSig || !!t.finalScriptWitness;
    r = a && i && s;
  }
  if (r === !1)
    throw new Error(
      `Input #${e} has too much or too little data to clean`
    );
}
function N6(e, t, r, n) {
  throw new Error(
    `Data for ${e} key ${t} is incorrect: Expected ${r} and got ${JSON.stringify(n)}`
  );
}
function J8(e) {
  return (t, r) => {
    for (const n of Object.keys(t)) {
      const o = t[n], { canAdd: a, canAddToArray: i, check: s, expected: u } = (
        // @ts-ignore
        Mj[e + "s"][n] || {}
      ), l = !!i;
      if (s)
        if (l) {
          if (!Array.isArray(o) || // @ts-ignore
          r[n] && !Array.isArray(r[n]))
            throw new Error(`Key type ${n} must be an array`);
          o.every(s) || N6(e, n, u, o);
          const c = r[n] || [], f = /* @__PURE__ */ new Set();
          if (!o.every((h) => i(c, h, f)))
            throw new Error("Can not add duplicate data to array");
          r[n] = c.concat(o);
        } else {
          if (s(o) || N6(e, n, u, o), !a(r, o))
            throw new Error(`Can not add duplicate data to ${e}`);
          r[n] = o;
        }
    }
  };
}
const Xj = J8("global"), Ix = J8("input"), Tx = J8("output");
function Yj(e, t) {
  const r = e.length - 1, n = cn(e, r);
  Ix(t, n);
}
function Jj(e, t) {
  const r = e.length - 1, n = wh(e, r);
  Tx(t, n);
}
let U6 = class {
  constructor(t) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: t
    };
  }
  static fromBase64(t, r) {
    const n = jk(t);
    return this.fromBuffer(n, r);
  }
  static fromHex(t, r) {
    const n = hs(t);
    return this.fromBuffer(n, r);
  }
  static fromBuffer(t, r) {
    const n = qj(t, r), o = new this(n.globalMap.unsignedTx);
    return Object.assign(o, n), o;
  }
  toBase64() {
    const t = this.toBuffer();
    return KU(t);
  }
  toHex() {
    const t = this.toBuffer();
    return qe(t);
  }
  toBuffer() {
    return Vj(this);
  }
  updateGlobal(t) {
    return Xj(t, this.globalMap), this;
  }
  updateInput(t, r) {
    const n = cn(this.inputs, t);
    return Ix(r, n), this;
  }
  updateOutput(t, r) {
    const n = wh(this.outputs, t);
    return Tx(r, n), this;
  }
  addUnknownKeyValToGlobal(t) {
    return Xb(
      t,
      this.globalMap.unknownKeyVals,
      Yb(ca)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(t), this;
  }
  addUnknownKeyValToInput(t, r) {
    const n = cn(this.inputs, t);
    return Xb(r, n.unknownKeyVals, Yb(Se)), n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(r), this;
  }
  addUnknownKeyValToOutput(t, r) {
    const n = wh(this.outputs, t);
    return Xb(r, n.unknownKeyVals, Yb(Ar)), n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(r), this;
  }
  addInput(t) {
    this.globalMap.unsignedTx.addInput(t), this.inputs.push({
      unknownKeyVals: []
    });
    const r = t.unknownKeyVals || [], n = this.inputs.length - 1;
    if (!Array.isArray(r))
      throw new Error("unknownKeyVals must be an Array");
    return r.forEach(
      (o) => this.addUnknownKeyValToInput(n, o)
    ), Yj(this.inputs, t), this;
  }
  addOutput(t) {
    this.globalMap.unsignedTx.addOutput(t), this.outputs.push({
      unknownKeyVals: []
    });
    const r = t.unknownKeyVals || [], n = this.outputs.length - 1;
    if (!Array.isArray(r))
      throw new Error("unknownKeyVals must be an Array");
    return r.forEach(
      (o) => this.addUnknownKeyValToOutput(n, o)
    ), Jj(this.outputs, t), this;
  }
  clearFinalizedInput(t) {
    const r = cn(this.inputs, t);
    Wj(t, r);
    for (const n of Object.keys(r))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(n) || delete r[n];
    return this;
  }
  combine(...t) {
    const r = Zj([this].concat(t));
    return Object.assign(this, r), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
function al(e) {
  return (t) => {
    try {
      return e({ output: t }), !0;
    } catch {
      return !1;
    }
  };
}
const Qj = al(Pm), eL = al(tx), tL = al(pp), Cm = al(gp), R6 = al(mp), Px = al(Wf), Ox = al(yp);
function W1(e) {
  let t = new Uint8Array(0);
  function r(i) {
    t = gr([t, i]);
  }
  function n(i) {
    const s = t.length, u = Wo(i);
    t = gr([t, new Uint8Array(u)]), Cu(i, t, s);
  }
  function o(i) {
    n(i.length), r(i);
  }
  function a(i) {
    n(i.length), i.forEach(o);
  }
  return a(e), t;
}
function $x(e, t) {
  const r = Ya(e), n = e.slice(1, 33), o = fr(t);
  if (o === null) throw new Error("Unknown script error");
  return o.findIndex((a) => typeof a == "number" ? !1 : fe(e, a) === 0 || fe(r, a) === 0 || fe(n, a) === 0);
}
function Bm(e, t) {
  return $x(e, t) !== -1;
}
function rL(e, t) {
  return nL(e).some(
    (r) => Cx(r, oh.decode, t)
  );
}
function Cx(e, t, r) {
  const { hashType: n } = t(e), o = [];
  switch (n & _r.SIGHASH_ANYONECANPAY && o.push("addInput"), n & 31) {
    case _r.SIGHASH_ALL:
      break;
    case _r.SIGHASH_SINGLE:
    case _r.SIGHASH_NONE:
      o.push("addOutput"), o.push("setInputSequence");
      break;
  }
  return o.indexOf(r) === -1;
}
function nL(e) {
  let t = [];
  if ((e.partialSig || []).length === 0) {
    if (!e.finalScriptSig && !e.finalScriptWitness) return [];
    t = oL(e);
  } else
    t = e.partialSig;
  return t.map((r) => r.signature);
}
function oL(e) {
  const t = e.finalScriptSig ? fr(e.finalScriptSig) || [] : [], r = e.finalScriptWitness ? fr(e.finalScriptWitness) || [] : [];
  return t.concat(r).filter((n) => n instanceof Uint8Array && os(n)).map((n) => ({ signature: n }));
}
const Pc = (e) => e.length === 32 ? e : e.slice(1, 33);
function z6(e, t, r) {
  const n = bL(
    t,
    e,
    r
  );
  try {
    const o = mL(t, n).concat(n.script).concat(n.controlBlock);
    return { finalScriptWitness: W1(o) };
  } catch (o) {
    throw new Error(`Can not finalize taproot input #${e}: ${o}`);
  }
}
function k0(e, t) {
  const r = t ? Uint8Array.from([t]) : Uint8Array.from([]);
  return gr([e, r]);
}
function ui(e) {
  return e && !!(e.tapInternalKey || e.tapMerkleRoot || e.tapLeafScript && e.tapLeafScript.length || e.tapBip32Derivation && e.tapBip32Derivation.length || e.witnessUtxo && Ox(e.witnessUtxo.script));
}
function Jb(e, t) {
  return e && !!(e.tapInternalKey || e.tapTree || e.tapBip32Derivation && e.tapBip32Derivation.length || t);
}
function j6(e, t, r) {
  hL(e, t, r), gL(e, t, r);
}
function L6(e, t, r) {
  pL(e, t, r), iL(e, t);
}
function iL(e, t) {
  if (!t.tapTree && !t.tapInternalKey) return;
  const r = t.tapInternalKey || e.tapInternalKey, n = t.tapTree || e.tapTree;
  if (r) {
    const { script: o } = e, a = aL(r, n);
    if (o && fe(a, o) !== 0)
      throw new Error("Error adding output. Script or address mismatch.");
  }
}
function aL(e, t) {
  const r = t && sL(t.leaves), { output: n } = yp({
    internalPubkey: e,
    scriptTree: r
  });
  return n;
}
function sL(e = []) {
  return e.length === 1 && e[0].depth === 0 ? {
    output: e[0].script,
    version: e[0].leafVersion
  } : dL(e);
}
function uL(e, t) {
  return lL(e).some(
    (r) => Cx(r, cL, t)
  );
}
function cL(e) {
  return {
    signature: e.slice(0, 64),
    hashType: e.slice(64)[0] || _r.SIGHASH_DEFAULT
  };
}
function lL(e) {
  const t = [];
  if (e.tapKeySig && t.push(e.tapKeySig), e.tapScriptSig && t.push(...e.tapScriptSig.map((r) => r.signature)), !t.length) {
    const r = fL(e.finalScriptWitness);
    r && t.push(r);
  }
  return t;
}
function fL(e) {
  if (!e) return;
  const t = e.slice(2);
  if (t.length === 64 || t.length === 65) return t;
}
function dL(e) {
  let t;
  for (const r of e)
    if (t = $w(r, t), !t) throw new Error("No room left to insert tapleaf in tree");
  return t;
}
function $w(e, t, r = 0) {
  if (r > nz) throw new Error("Max taptree depth exceeded.");
  if (e.depth === r)
    return t ? void 0 : {
      output: e.script,
      version: e.leafVersion
    };
  if (z8(t)) return;
  const n = $w(e, t && t[0], r + 1);
  if (n) return [n, t && t[1]];
  const o = $w(e, t && t[1], r + 1);
  if (o) return [t && t[0], o];
}
function hL(e, t, r) {
  const n = ui(e) && nf(t), o = nf(e) && ui(t), a = e === t && ui(t) && nf(t);
  if (n || o || a)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function pL(e, t, r) {
  const n = Jb(e) && nf(t), o = nf(e) && Jb(t), a = e === t && Jb(t) && nf(t);
  if (n || o || a)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function gL(e, t, r) {
  if (t.tapMerkleRoot) {
    const n = (t.tapLeafScript || []).every(
      (a) => Qb(a, t.tapMerkleRoot)
    ), o = (e.tapLeafScript || []).every(
      (a) => Qb(a, t.tapMerkleRoot)
    );
    if (!n || !o)
      throw new Error(
        `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`
      );
  } else if (e.tapMerkleRoot && !(t.tapLeafScript || []).every(
    (n) => Qb(n, e.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`
    );
}
function Qb(e, t) {
  if (!t) return !0;
  const r = Wa({
    output: e.script,
    version: e.leafVersion
  }), n = Iw(e.controlBlock, r);
  return fe(n, t) === 0;
}
function mL(e, t) {
  const r = Wa({
    output: t.script,
    version: t.leafVersion
  });
  return (e.tapScriptSig || []).filter((n) => fe(n.leafHash, r) === 0).map((n) => yL(t.script, n)).sort((n, o) => o.positionInScript - n.positionInScript).map((n) => n.signature);
}
function yL(e, t) {
  return Object.assign(
    {
      positionInScript: $x(t.pubkey, e)
    },
    t
  );
}
function bL(e, t, r) {
  if (!e.tapScriptSig || !e.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${t}. No tapleaf script signature provided.`
    );
  const n = (e.tapLeafScript || []).sort((o, a) => o.controlBlock.length - a.controlBlock.length).find(
    (o) => wL(o, e.tapScriptSig, r)
  );
  if (!n)
    throw new Error(
      `Can not finalize taproot input #${t}. Signature for tapleaf script not found.`
    );
  return n;
}
function wL(e, t, r) {
  const n = Wa({
    output: e.script,
    version: e.leafVersion
  });
  return (!r || fe(n, r) === 0) && t.find((o) => fe(o.leafHash, n) === 0) !== void 0;
}
function nf(e) {
  return e && !!(e.redeemScript || e.witnessScript || e.bip32Derivation && e.bip32Derivation.length);
}
const vL = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: $i,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Gt {
  constructor(t = {}, r = new U6(new Bx())) {
    ke(this, "data"), ke(this, "__CACHE"), ke(this, "opts"), this.data = r, this.opts = Object.assign({}, vL, t), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const n = (o, a, i, s) => Object.defineProperty(o, a, {
      enumerable: i,
      writable: s
    });
    n(this, "__CACHE", !1, !0), n(this, "opts", !1, !0);
  }
  static fromBase64(t, r = {}) {
    const n = jk(t);
    return this.fromBuffer(n, r);
  }
  static fromHex(t, r = {}) {
    const n = hs(t);
    return this.fromBuffer(n, r);
  }
  static fromBuffer(t, r = {}) {
    const n = U6.fromBuffer(t, EL), o = new Gt(r, n);
    return _L(o.__CACHE.__TX, o.__CACHE), o;
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(t) {
    this.setVersion(t);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(t) {
    this.setLocktime(t);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((t) => ({
      hash: I6(t.hash),
      index: t.index,
      sequence: t.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((t) => {
      let r;
      try {
        r = bp(t.script, this.opts.network);
      } catch {
      }
      return {
        script: I6(t.script),
        value: t.value,
        address: r
      };
    });
  }
  combine(...t) {
    return this.data.combine(...t.map((r) => r.data)), this;
  }
  clone() {
    const t = Gt.fromBuffer(this.data.toBuffer());
    return t.opts = JSON.parse(JSON.stringify(this.opts)), t;
  }
  setMaximumFeeRate(t) {
    x0(t), this.opts.maximumFeeRate = t;
  }
  setVersion(t) {
    x0(t), $d(this.data.inputs, "setVersion");
    const r = this.__CACHE;
    return r.__TX.version = t, r.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(t) {
    x0(t), $d(this.data.inputs, "setLocktime");
    const r = this.__CACHE;
    return r.__TX.locktime = t, r.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(t, r) {
    x0(r), $d(this.data.inputs, "setInputSequence");
    const n = this.__CACHE;
    if (n.__TX.ins.length <= t)
      throw new Error("Input index too high");
    return n.__TX.ins[t].sequence = r, n.__EXTRACTED_TX = void 0, this;
  }
  addInputs(t) {
    return t.forEach((r) => this.addInput(r)), this;
  }
  addInput(t) {
    if (arguments.length > 1 || !t || t.hash === void 0 || t.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    j6(t, t, "addInput"), $d(this.data.inputs, "addInput"), t.witnessScript && X1(t.witnessScript);
    const r = this.__CACHE;
    this.data.addInput(t);
    const n = r.__TX.ins[r.__TX.ins.length - 1];
    Rx(r, n);
    const o = this.data.inputs.length - 1, a = this.data.inputs[o];
    return a.nonWitnessUtxo && Bw(this.__CACHE, a, o), r.__FEE = void 0, r.__FEE_RATE = void 0, r.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(t) {
    return t.forEach((r) => this.addOutput(r)), this;
  }
  addOutput(t) {
    if (arguments.length > 1 || !t || t.value === void 0 || t.address === void 0 && t.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    $d(this.data.inputs, "addOutput");
    const { address: r } = t;
    if (typeof r == "string") {
      const { network: o } = this.opts, a = wp(r, o);
      t = Object.assign({}, t, { script: a });
    }
    L6(t, t, "addOutput");
    const n = this.__CACHE;
    return this.data.addOutput(t), n.__FEE = void 0, n.__FEE_RATE = void 0, n.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(t) {
    if (!this.data.inputs.every(Nx)) throw new Error("Not finalized");
    const r = this.__CACHE;
    if (t || xL(this, r, this.opts), r.__EXTRACTED_TX) return r.__EXTRACTED_TX;
    const n = r.__TX.clone();
    return Dx(this.data.inputs, n, r, !0), n;
  }
  getFeeRate() {
    return K6(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return K6("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return cn(this.data.inputs, 0), Cd(this.data.inputs.length).forEach((t) => this.finalizeInput(t)), this;
  }
  finalizeInput(t, r) {
    const n = cn(this.data.inputs, t);
    return ui(n) ? this._finalizeTaprootInput(
      t,
      n,
      void 0,
      r
    ) : this._finalizeInput(t, n, r);
  }
  finalizeTaprootInput(t, r, n = z6) {
    const o = cn(this.data.inputs, t);
    if (ui(o))
      return this._finalizeTaprootInput(
        t,
        o,
        r,
        n
      );
    throw new Error(`Cannot finalize input #${t}. Not Taproot.`);
  }
  _finalizeInput(t, r, n = IL) {
    const { script: o, isP2SH: a, isP2WSH: i, isSegwit: s } = $L(
      t,
      r,
      this.__CACHE
    );
    if (!o) throw new Error(`No script found for input #${t}`);
    AL(r);
    const { finalScriptSig: u, finalScriptWitness: l } = n(
      t,
      r,
      o,
      s,
      a,
      i
    );
    if (u && this.data.updateInput(t, { finalScriptSig: u }), l && this.data.updateInput(t, { finalScriptWitness: l }), !u && !l)
      throw new Error(`Unknown error finalizing input #${t}`);
    return this.data.clearFinalizedInput(t), this;
  }
  _finalizeTaprootInput(t, r, n, o = z6) {
    if (!r.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${t}. Missing withness utxo.`
      );
    if (r.tapKeySig) {
      const a = yp({
        output: r.witnessUtxo.script,
        signature: r.tapKeySig
      }), i = W1(a.witness);
      this.data.updateInput(t, { finalScriptWitness: i });
    } else {
      const { finalScriptWitness: a } = o(
        t,
        r,
        n
      );
      this.data.updateInput(t, { finalScriptWitness: a });
    }
    return this.data.clearFinalizedInput(t), this;
  }
  getInputType(t) {
    const r = cn(this.data.inputs, t), n = Mx(t, r, this.__CACHE), o = Um(
      n,
      t,
      "input",
      r.redeemScript || RL(r.finalScriptSig),
      r.witnessScript || zL(r.finalScriptWitness)
    ), a = o.type === "raw" ? "" : o.type + "-", i = qx(o.meaningfulScript);
    return a + i;
  }
  inputHasPubkey(t, r) {
    const n = cn(this.data.inputs, t);
    return NL(r, n, t, this.__CACHE);
  }
  inputHasHDKey(t, r) {
    const n = cn(this.data.inputs, t), o = F6(r);
    return !!n.bip32Derivation && n.bip32Derivation.some(o);
  }
  outputHasPubkey(t, r) {
    const n = wh(this.data.outputs, t);
    return UL(r, n, t, this.__CACHE);
  }
  outputHasHDKey(t, r) {
    const n = wh(this.data.outputs, t), o = F6(r);
    return !!n.bip32Derivation && n.bip32Derivation.some(o);
  }
  validateSignaturesOfAllInputs(t) {
    return cn(this.data.inputs, 0), Cd(this.data.inputs.length).map(
      (r) => this.validateSignaturesOfInput(r, t)
    ).reduce((r, n) => n === !0 && r, !0);
  }
  validateSignaturesOfInput(t, r, n) {
    const o = this.data.inputs[t];
    return ui(o) ? this.validateSignaturesOfTaprootInput(
      t,
      r,
      n
    ) : this._validateSignaturesOfInput(t, r, n);
  }
  _validateSignaturesOfInput(t, r, n) {
    const o = this.data.inputs[t], a = (o || {}).partialSig;
    if (!o || !a || a.length < 1)
      throw new Error("No signatures to validate");
    if (typeof r != "function")
      throw new Error("Need validator function to validate signatures");
    const i = n ? a.filter((f) => fe(f.pubkey, n) === 0) : a;
    if (i.length < 1) throw new Error("No signatures for this pubkey");
    const s = [];
    let u, l, c;
    for (const f of i) {
      const h = oh.decode(f.signature), { hash: p, script: y } = c !== h.hashType ? jx(
        t,
        Object.assign({}, o, { sighashType: h.hashType }),
        this.__CACHE,
        !0
      ) : { hash: u, script: l };
      c = h.hashType, u = p, l = y, Ux(f.pubkey, y, "verify"), s.push(r(f.pubkey, p, h.signature));
    }
    return s.every((f) => f === !0);
  }
  validateSignaturesOfTaprootInput(t, r, n) {
    const o = this.data.inputs[t], a = (o || {}).tapKeySig, i = (o || {}).tapScriptSig;
    if (!o && !a && !(i && !i.length))
      throw new Error("No signatures to validate");
    if (typeof r != "function")
      throw new Error("Need validator function to validate signatures");
    n = n && Pc(n);
    const s = n ? Cw(
      t,
      o,
      this.data.inputs,
      n,
      this.__CACHE
    ) : PL(
      t,
      o,
      this.data.inputs,
      this.__CACHE
    );
    if (!s.length) throw new Error("No signatures for this pubkey");
    const u = s.find((c) => !c.leafHash);
    let l = 0;
    if (a && u) {
      if (!r(
        u.pubkey,
        u.hash,
        V6(a)
      )) return !1;
      l++;
    }
    if (i)
      for (const c of i) {
        const f = s.find(
          (h) => fe(h.pubkey, c.pubkey) === 0
        );
        if (f) {
          if (!r(
            c.pubkey,
            f.hash,
            V6(c.signature)
          )) return !1;
          l++;
        }
      }
    return l > 0;
  }
  signAllInputsHD(t, r = [_r.SIGHASH_ALL]) {
    if (!t || !t.publicKey || !t.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const n = [];
    for (const o of Cd(this.data.inputs.length))
      try {
        this.signInputHD(o, t, r), n.push(!0);
      } catch {
        n.push(!1);
      }
    if (n.every((o) => o === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(t, r = [_r.SIGHASH_ALL]) {
    return new Promise((n, o) => {
      if (!t || !t.publicKey || !t.fingerprint)
        return o(new Error("Need HDSigner to sign input"));
      const a = [], i = [];
      for (const s of Cd(this.data.inputs.length))
        i.push(
          this.signInputHDAsync(s, t, r).then(
            () => {
              a.push(!0);
            },
            () => {
              a.push(!1);
            }
          )
        );
      return Promise.all(i).then(() => {
        if (a.every((s) => s === !1))
          return o(new Error("No inputs were signed"));
        n();
      });
    });
  }
  signInputHD(t, r, n = [_r.SIGHASH_ALL]) {
    if (!r || !r.publicKey || !r.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return G6(t, this.data.inputs, r).forEach((o) => this.signInput(t, o, n)), this;
  }
  signInputHDAsync(t, r, n = [_r.SIGHASH_ALL]) {
    return new Promise((o, a) => {
      if (!r || !r.publicKey || !r.fingerprint)
        return a(new Error("Need HDSigner to sign input"));
      const i = G6(t, this.data.inputs, r).map(
        (s) => this.signInputAsync(t, s, n)
      );
      return Promise.all(i).then(() => {
        o();
      }).catch(a);
    });
  }
  signAllInputs(t, r) {
    if (!t || !t.publicKey)
      throw new Error("Need Signer to sign input");
    const n = [];
    for (const o of Cd(this.data.inputs.length))
      try {
        this.signInput(o, t, r), n.push(!0);
      } catch {
        n.push(!1);
      }
    if (n.every((o) => o === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(t, r) {
    return new Promise((n, o) => {
      if (!t || !t.publicKey)
        return o(new Error("Need Signer to sign input"));
      const a = [], i = [];
      for (const [s] of this.data.inputs.entries())
        i.push(
          this.signInputAsync(s, t, r).then(
            () => {
              a.push(!0);
            },
            () => {
              a.push(!1);
            }
          )
        );
      return Promise.all(i).then(() => {
        if (a.every((s) => s === !1))
          return o(new Error("No inputs were signed"));
        n();
      });
    });
  }
  signInput(t, r, n) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const o = cn(this.data.inputs, t);
    return ui(o) ? this._signTaprootInput(
      t,
      o,
      r,
      void 0,
      n
    ) : this._signInput(t, r, n);
  }
  signTaprootInput(t, r, n, o) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const a = cn(this.data.inputs, t);
    if (ui(a))
      return this._signTaprootInput(
        t,
        a,
        r,
        n,
        o
      );
    throw new Error(`Input #${t} is not of type Taproot.`);
  }
  _signInput(t, r, n = [_r.SIGHASH_ALL]) {
    const { hash: o, sighashType: a } = q6(
      this.data.inputs,
      t,
      r.publicKey,
      this.__CACHE,
      n
    ), i = [
      {
        pubkey: r.publicKey,
        signature: oh.encode(r.sign(o), a)
      }
    ];
    return this.data.updateInput(t, { partialSig: i }), this;
  }
  _signTaprootInput(t, r, n, o, a = [_r.SIGHASH_DEFAULT]) {
    const i = this.checkTaprootHashesForSig(
      t,
      r,
      n,
      o,
      a
    ), s = i.filter((l) => !l.leafHash).map(
      (l) => k0(
        n.signSchnorr(l.hash),
        r.sighashType
      )
    )[0], u = i.filter((l) => !!l.leafHash).map((l) => ({
      pubkey: Pc(n.publicKey),
      signature: k0(
        n.signSchnorr(l.hash),
        r.sighashType
      ),
      leafHash: l.leafHash
    }));
    return s && this.data.updateInput(t, { tapKeySig: s }), u.length && this.data.updateInput(t, { tapScriptSig: u }), this;
  }
  signInputAsync(t, r, n) {
    return Promise.resolve().then(() => {
      if (!r || !r.publicKey)
        throw new Error("Need Signer to sign input");
      const o = cn(this.data.inputs, t);
      return ui(o) ? this._signTaprootInputAsync(
        t,
        o,
        r,
        void 0,
        n
      ) : this._signInputAsync(t, r, n);
    });
  }
  signTaprootInputAsync(t, r, n, o) {
    return Promise.resolve().then(() => {
      if (!r || !r.publicKey)
        throw new Error("Need Signer to sign input");
      const a = cn(this.data.inputs, t);
      if (ui(a))
        return this._signTaprootInputAsync(
          t,
          a,
          r,
          n,
          o
        );
      throw new Error(`Input #${t} is not of type Taproot.`);
    });
  }
  _signInputAsync(t, r, n = [_r.SIGHASH_ALL]) {
    const { hash: o, sighashType: a } = q6(
      this.data.inputs,
      t,
      r.publicKey,
      this.__CACHE,
      n
    );
    return Promise.resolve(r.sign(o)).then((i) => {
      const s = [
        {
          pubkey: r.publicKey,
          signature: oh.encode(i, a)
        }
      ];
      this.data.updateInput(t, { partialSig: s });
    });
  }
  async _signTaprootInputAsync(t, r, n, o, a = [_r.SIGHASH_DEFAULT]) {
    const i = this.checkTaprootHashesForSig(
      t,
      r,
      n,
      o,
      a
    ), s = [], u = i.filter((c) => !c.leafHash)[0];
    if (u) {
      const c = Promise.resolve(
        n.signSchnorr(u.hash)
      ).then((f) => ({ tapKeySig: k0(f, r.sighashType) }));
      s.push(c);
    }
    const l = i.filter((c) => !!c.leafHash);
    if (l.length) {
      const c = l.map((f) => Promise.resolve(n.signSchnorr(f.hash)).then(
        (h) => ({ tapScriptSig: [
          {
            pubkey: Pc(n.publicKey),
            signature: k0(
              h,
              r.sighashType
            ),
            leafHash: f.leafHash
          }
        ] })
      ));
      s.push(...c);
    }
    return Promise.all(s).then((c) => {
      c.forEach((f) => this.data.updateInput(t, f));
    });
  }
  checkTaprootHashesForSig(t, r, n, o, a) {
    if (typeof n.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${t}.`
      );
    const i = Cw(
      t,
      r,
      this.data.inputs,
      n.publicKey,
      this.__CACHE,
      o,
      a
    );
    if (!i || !i.length)
      throw new Error(
        `Can not sign for input #${t} with the key ${qe(n.publicKey)}`
      );
    return i;
  }
  toBuffer() {
    return e2(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return e2(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return e2(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(t) {
    return this.data.updateGlobal(t), this;
  }
  updateInput(t, r) {
    return r.witnessScript && X1(r.witnessScript), j6(
      this.data.inputs[t],
      r,
      "updateInput"
    ), this.data.updateInput(t, r), r.nonWitnessUtxo && Bw(
      this.__CACHE,
      this.data.inputs[t],
      t
    ), this;
  }
  updateOutput(t, r) {
    const n = this.data.outputs[t];
    return L6(n, r, "updateOutput"), this.data.updateOutput(t, r), this;
  }
  addUnknownKeyValToGlobal(t) {
    return this.data.addUnknownKeyValToGlobal(t), this;
  }
  addUnknownKeyValToInput(t, r) {
    return this.data.addUnknownKeyValToInput(t, r), this;
  }
  addUnknownKeyValToOutput(t, r) {
    return this.data.addUnknownKeyValToOutput(t, r), this;
  }
  clearFinalizedInput(t) {
    return this.data.clearFinalizedInput(t), this;
  }
}
const EL = (e) => new Bx(e);
let Bx = class {
  constructor(t = Uint8Array.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    ke(this, "tx"), this.tx = _r.fromBuffer(t), SL(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(t) {
    if (t.hash === void 0 || t.index === void 0 || !(t.hash instanceof Uint8Array) && typeof t.hash != "string" || typeof t.index != "number")
      throw new Error("Error adding input.");
    const r = typeof t.hash == "string" ? G8(hs(t.hash)) : t.hash;
    this.tx.addInput(r, t.index, t.sequence);
  }
  addOutput(t) {
    if (t.script === void 0 || t.value === void 0 || !(t.script instanceof Uint8Array) || typeof t.value != "bigint")
      throw new Error("Error adding output.");
    this.tx.addOutput(t.script, t.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
};
function kL(e, t, r) {
  switch (r) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return H6(1, e.partialSig);
    case "multisig":
      const n = Pm({ output: t });
      return H6(n.m, e.partialSig, n.pubkeys);
    default:
      return !1;
  }
}
function e2(e) {
  if (e.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function H6(e, t, r) {
  if (!t) return !1;
  let n;
  if (r ? n = r.map((o) => {
    const a = jL(o);
    return t.find(
      (i) => fe(i.pubkey, a) === 0
    );
  }).filter((o) => !!o) : n = t, n.length > e) throw new Error("Too many signatures");
  return n.length === e;
}
function Nx(e) {
  return !!e.finalScriptSig || !!e.finalScriptWitness;
}
function F6(e) {
  return (t) => !(fe(e.fingerprint, t.masterFingerprint) || fe(e.derivePath(t.path).publicKey, t.pubkey));
}
function x0(e) {
  if (typeof e != "number" || e !== Math.floor(e) || e > 4294967295 || e < 0)
    throw new Error("Invalid 32 bit integer");
}
function xL(e, t, r) {
  const n = t.__FEE_RATE || e.getFeeRate(), o = t.__EXTRACTED_TX.virtualSize(), a = n * o;
  if (n >= r.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(a / 1e8).toFixed(8)} in fees, which is ${n} satoshi per byte for a transaction with a VSize of ${o} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function $d(e, t) {
  e.forEach((r) => {
    if (ui(r) ? uL(r, t) : rL(r, t))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function AL(e) {
  if (!e.sighashType || !e.partialSig) return;
  const { partialSig: t, sighashType: r } = e;
  t.forEach((n) => {
    const { hashType: o } = oh.decode(n.signature);
    if (r !== o)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function Ux(e, t, r) {
  if (!Bm(e, t))
    throw new Error(
      `Can not ${r} for this input with the key ${qe(e)}`
    );
}
function SL(e) {
  if (!e.ins.every(
    (t) => t.script && t.script.length === 0 && t.witness && t.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function _L(e, t) {
  e.ins.forEach((r) => {
    Rx(t, r);
  });
}
function Rx(e, t) {
  const r = qe(G8(Uint8Array.from(t.hash))) + ":" + t.index;
  if (e.__TX_IN_CACHE[r]) throw new Error("Duplicate input detected.");
  e.__TX_IN_CACHE[r] = 1;
}
function zx(e, t) {
  return (r, n, o, a) => {
    const i = e({
      redeem: { output: o }
    }).output;
    if (fe(n, i))
      throw new Error(
        `${t} for ${a} #${r} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const D6 = zx(Wf, "Redeem script"), M6 = zx(
  mp,
  "Witness script"
);
function K6(e, t, r, n) {
  if (!r.every(Nx))
    throw new Error(`PSBT must be finalized to calculate ${t}`);
  if (e === "__FEE_RATE" && n.__FEE_RATE) return n.__FEE_RATE;
  if (e === "__FEE" && n.__FEE) return n.__FEE;
  let o, a = !0;
  if (n.__EXTRACTED_TX ? (o = n.__EXTRACTED_TX, a = !1) : o = n.__TX.clone(), Dx(r, o, n, a), e === "__FEE_RATE") return n.__FEE_RATE;
  if (e === "__FEE") return n.__FEE;
}
function IL(e, t, r, n, o, a) {
  const i = qx(r);
  if (!kL(t, r, i))
    throw new Error(`Can not finalize input #${e}`);
  return TL(
    r,
    i,
    t.partialSig,
    n,
    o,
    a
  );
}
function TL(e, t, r, n, o, a) {
  let i, s;
  const u = OL(e, t, r), l = a ? mp({ redeem: u }) : null, c = o ? Wf({ redeem: l || u }) : null;
  return n ? (l ? s = W1(l.witness) : s = W1(u.witness), c && (i = c.input)) : c ? i = c.input : i = u.input, {
    finalScriptSig: i,
    finalScriptWitness: s
  };
}
function q6(e, t, r, n, o) {
  const a = cn(e, t), { hash: i, sighashType: s, script: u } = jx(
    t,
    a,
    n,
    !1,
    o
  );
  return Ux(r, u, "sign"), {
    hash: i,
    sighashType: s
  };
}
function jx(e, t, r, n, o) {
  const a = r.__TX, i = t.sighashType || _r.SIGHASH_ALL;
  Hx(i, o);
  let s, u;
  if (t.nonWitnessUtxo) {
    const f = Nm(
      r,
      t,
      e
    ), h = a.ins[e].hash, p = f.getHash();
    if (fe(h, p) !== 0)
      throw new Error(
        `Non-witness UTXO hash for input #${e} doesn't match the hash specified in the prevout`
      );
    const y = a.ins[e].index;
    u = f.outs[y];
  } else if (t.witnessUtxo)
    u = t.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: l, type: c } = Um(
    u.script,
    e,
    "input",
    t.redeemScript,
    t.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(c) >= 0)
    s = a.hashForWitnessV0(
      e,
      l,
      u.value,
      i
    );
  else if (Cm(l)) {
    const f = pp({
      hash: l.slice(2)
    }).output;
    s = a.hashForWitnessV0(
      e,
      f,
      u.value,
      i
    );
  } else {
    if (t.nonWitnessUtxo === void 0 && r.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${e} has witnessUtxo but non-segwit script: ${qe(l)}`
      );
    !n && r.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), s = a.hashForSignature(
      e,
      l,
      i
    );
  }
  return {
    script: l,
    sighashType: i,
    hash: s
  };
}
function PL(e, t, r, n) {
  const o = [];
  if (t.tapInternalKey) {
    const a = Lx(e, t, n);
    a && o.push(a);
  }
  if (t.tapScriptSig) {
    const a = t.tapScriptSig.map((i) => i.pubkey);
    o.push(...a);
  }
  return o.map(
    (a) => Cw(e, t, r, a, n)
  ).flat();
}
function Lx(e, t, r) {
  const { script: n } = Q8(e, t, r);
  return Ox(n) ? n.subarray(2, 34) : null;
}
function V6(e) {
  return e.length === 64 ? e : e.subarray(0, 64);
}
function Cw(e, t, r, n, o, a, i) {
  const s = o.__TX, u = t.sighashType || _r.SIGHASH_DEFAULT;
  Hx(u, i);
  const l = r.map(
    (y, m) => Q8(m, y, o)
  ), c = l.map((y) => y.script), f = l.map((y) => y.value), h = [];
  if (t.tapInternalKey && !a) {
    const y = Lx(e, t, o) || Uint8Array.from([]);
    if (fe(Pc(n), y) === 0) {
      const m = s.hashForWitnessV1(
        e,
        c,
        f,
        u
      );
      h.push({ pubkey: n, hash: m });
    }
  }
  const p = (t.tapLeafScript || []).filter((y) => Bm(n, y.script)).map((y) => {
    const m = Wa({
      output: y.script,
      version: y.leafVersion
    });
    return Object.assign({ hash: m }, y);
  }).filter(
    (y) => !a || fe(a, y.hash) === 0
  ).map((y) => {
    const m = s.hashForWitnessV1(
      e,
      c,
      f,
      u,
      y.hash
    );
    return {
      pubkey: n,
      hash: m,
      leafHash: y.hash
    };
  });
  return h.concat(p);
}
function Hx(e, t) {
  if (t && t.indexOf(e) < 0) {
    const r = BL(e);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${r}`
    );
  }
}
function OL(e, t, r) {
  let n;
  switch (t) {
    case "multisig":
      const o = CL(e, r);
      n = Pm({
        output: e,
        signatures: o
      });
      break;
    case "pubkey":
      n = tx({
        output: e,
        signature: r[0].signature
      });
      break;
    case "pubkeyhash":
      n = pp({
        output: e,
        pubkey: r[0].pubkey,
        signature: r[0].signature
      });
      break;
    case "witnesspubkeyhash":
      n = gp({
        output: e,
        pubkey: r[0].pubkey,
        signature: r[0].signature
      });
      break;
  }
  return n;
}
function $L(e, t, r) {
  const n = r.__TX, o = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (o.isP2SH = !!t.redeemScript, o.isP2WSH = !!t.witnessScript, t.witnessScript)
    o.script = t.witnessScript;
  else if (t.redeemScript)
    o.script = t.redeemScript;
  else if (t.nonWitnessUtxo) {
    const a = Nm(
      r,
      t,
      e
    ), i = n.ins[e].index;
    o.script = a.outs[i].script;
  } else t.witnessUtxo && (o.script = t.witnessUtxo.script);
  return (t.witnessScript || Cm(o.script)) && (o.isSegwit = !0), o;
}
function G6(e, t, r) {
  const n = cn(t, e);
  if (!n.bip32Derivation || n.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const o = n.bip32Derivation.map((a) => {
    if (fe(a.masterFingerprint, r.fingerprint) === 0)
      return a;
  }).filter((a) => !!a);
  if (o.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return o.map((a) => {
    const i = r.derivePath(a.path);
    if (fe(a.pubkey, i.publicKey) !== 0)
      throw new Error("pubkey did not match bip32Derivation");
    return i;
  });
}
function CL(e, t) {
  return Pm({ output: e }).pubkeys.map((r) => (t.filter((n) => fe(n.pubkey, r) === 0)[0] || {}).signature).filter((r) => !!r);
}
function Fx(e) {
  let t = 0;
  function r(i) {
    return t += i, e.slice(t - i, t);
  }
  function n() {
    const i = Xf(e, t);
    return t += Wo(i.bigintValue), i.numberValue;
  }
  function o() {
    return r(n());
  }
  function a() {
    const i = n(), s = [];
    for (let u = 0; u < i; u++) s.push(o());
    return s;
  }
  return a();
}
function BL(e) {
  let t = e & _r.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (e & 31) {
    case _r.SIGHASH_ALL:
      t += "SIGHASH_ALL";
      break;
    case _r.SIGHASH_SINGLE:
      t += "SIGHASH_SINGLE";
      break;
    case _r.SIGHASH_NONE:
      t += "SIGHASH_NONE";
      break;
  }
  return t;
}
function Bw(e, t, r) {
  e.__NON_WITNESS_UTXO_BUF_CACHE[r] = t.nonWitnessUtxo;
  const n = _r.fromBuffer(t.nonWitnessUtxo);
  e.__NON_WITNESS_UTXO_TX_CACHE[r] = n;
  const o = e, a = r;
  delete t.nonWitnessUtxo, Object.defineProperty(t, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const i = o.__NON_WITNESS_UTXO_BUF_CACHE[a], s = o.__NON_WITNESS_UTXO_TX_CACHE[a];
      if (i !== void 0)
        return i;
      {
        const u = s.toBuffer();
        return o.__NON_WITNESS_UTXO_BUF_CACHE[a] = u, u;
      }
    },
    set(i) {
      o.__NON_WITNESS_UTXO_BUF_CACHE[a] = i;
    }
  });
}
function Dx(e, t, r, n) {
  let o = 0n;
  e.forEach((u, l) => {
    if (n && u.finalScriptSig && (t.ins[l].script = u.finalScriptSig), n && u.finalScriptWitness && (t.ins[l].witness = Fx(
      u.finalScriptWitness
    )), u.witnessUtxo)
      o += u.witnessUtxo.value;
    else if (u.nonWitnessUtxo) {
      const c = Nm(r, u, l), f = t.ins[l].index, h = c.outs[f];
      o += h.value;
    }
  });
  const a = t.outs.reduce((u, l) => u + l.value, 0n), i = o - a;
  if (i < 0)
    throw new Error("Outputs are spending more than Inputs");
  const s = t.virtualSize();
  r.__FEE = i, r.__EXTRACTED_TX = t, r.__FEE_RATE = Math.floor(Number(i / BigInt(s)));
}
function Nm(e, t, r) {
  const n = e.__NON_WITNESS_UTXO_TX_CACHE;
  return n[r] || Bw(e, t, r), n[r];
}
function Mx(e, t, r) {
  const { script: n } = Q8(e, t, r);
  return n;
}
function Q8(e, t, r) {
  if (t.witnessUtxo !== void 0)
    return {
      script: t.witnessUtxo.script,
      value: t.witnessUtxo.value
    };
  if (t.nonWitnessUtxo !== void 0) {
    const n = Nm(
      r,
      t,
      e
    ).outs[r.__TX.ins[e].index];
    return { script: n.script, value: n.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function NL(e, t, r, n) {
  const o = Mx(r, t, n), { meaningfulScript: a } = Um(
    o,
    r,
    "input",
    t.redeemScript,
    t.witnessScript
  );
  return Bm(e, a);
}
function UL(e, t, r, n) {
  const o = n.__TX.outs[r].script, { meaningfulScript: a } = Um(
    o,
    r,
    "output",
    t.redeemScript,
    t.witnessScript
  );
  return Bm(e, a);
}
function RL(e) {
  if (!e) return;
  const t = fr(e);
  if (!t) return;
  const r = t[t.length - 1];
  if (!(!(r instanceof Uint8Array) || Kx(r) || LL(r) || !fr(r)))
    return r;
}
function zL(e) {
  if (!e) return;
  const t = Fx(e), r = t[t.length - 1];
  if (!(Kx(r) || !fr(r)))
    return r;
}
function jL(e) {
  if (e.length === 65) {
    const t = e[64] & 1, r = e.slice(0, 33);
    return r[0] = 2 | t, r;
  }
  return e.slice();
}
function Kx(e) {
  return e.length === 33 && hR(e);
}
function LL(e) {
  return os(e);
}
function Um(e, t, r, n, o) {
  const a = Px(e), i = a && n && R6(n), s = R6(e);
  if (a && n === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((s || i) && o === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let u;
  return i ? (u = o, D6(t, e, n, r), M6(t, n, o, r), X1(u)) : s ? (u = o, M6(t, e, o, r), X1(u)) : a ? (u = n, D6(t, e, n, r)) : u = e, {
    meaningfulScript: u,
    type: i ? "p2sh-p2wsh" : a ? "p2sh" : s ? "p2wsh" : "raw"
  };
}
function X1(e) {
  if (Cm(e) || Px(e))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function qx(e) {
  return Cm(e) ? "witnesspubkeyhash" : tL(e) ? "pubkeyhash" : Qj(e) ? "multisig" : eL(e) ? "pubkey" : "nonstandard";
}
function Cd(e) {
  return [...Array(e).keys()];
}
let Vx = class extends rx {
  constructor(t, r) {
    super(), this.finished = !1, this.destroyed = !1, gR(t);
    const n = H8(r);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o = this.blockLen, a = new Uint8Array(o);
    a.set(n.length > o ? t.create().update(n).digest() : n);
    for (let i = 0; i < a.length; i++)
      a[i] ^= 54;
    this.iHash.update(a), this.oHash = t.create();
    for (let i = 0; i < a.length; i++)
      a[i] ^= 106;
    this.oHash.update(a), a.fill(0);
  }
  update(t) {
    return q1(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    q1(this), Om(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: o, destroyed: a, blockLen: i, outputLen: s } = this;
    return t = t, t.finished = o, t.destroyed = a, t.blockLen = i, t.outputLen = s, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const e3 = (e, t, r) => new Vx(e, t).update(r).digest();
e3.create = (e, t) => new Vx(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const t3 = /* @__PURE__ */ BigInt(0), Rm = /* @__PURE__ */ BigInt(1), HL = /* @__PURE__ */ BigInt(2);
function Fc(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function vp(e) {
  if (!Fc(e))
    throw new Error("Uint8Array expected");
}
function yf(e, t) {
  if (typeof t != "boolean")
    throw new Error(`${e} must be valid boolean, got "${t}".`);
}
const FL = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function bf(e) {
  vp(e);
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += FL[e[r]];
  return t;
}
function Wl(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function r3(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
const Pa = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function Z6(e) {
  if (e >= Pa._0 && e <= Pa._9)
    return e - Pa._0;
  if (e >= Pa._A && e <= Pa._F)
    return e - (Pa._A - 10);
  if (e >= Pa._a && e <= Pa._f)
    return e - (Pa._a - 10);
}
function wf(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(r);
  for (let o = 0, a = 0; o < r; o++, a += 2) {
    const i = Z6(e.charCodeAt(a)), s = Z6(e.charCodeAt(a + 1));
    if (i === void 0 || s === void 0) {
      const u = e[a] + e[a + 1];
      throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + a);
    }
    n[o] = i * 16 + s;
  }
  return n;
}
function Oc(e) {
  return r3(bf(e));
}
function n3(e) {
  return vp(e), r3(bf(Uint8Array.from(e).reverse()));
}
function vf(e, t) {
  return wf(e.toString(16).padStart(t * 2, "0"));
}
function o3(e, t) {
  return vf(e, t).reverse();
}
function DL(e) {
  return wf(Wl(e));
}
function ii(e, t, r) {
  let n;
  if (typeof t == "string")
    try {
      n = wf(t);
    } catch (a) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${a}`);
    }
  else if (Fc(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const o = n.length;
  if (typeof r == "number" && o !== r)
    throw new Error(`${e} expected ${r} bytes, got ${o}`);
  return n;
}
function vh(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const o = e[n];
    vp(o), t += o.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, o = 0; n < e.length; n++) {
    const a = e[n];
    r.set(a, o), o += a.length;
  }
  return r;
}
function ML(e, t) {
  if (e.length !== t.length)
    return !1;
  let r = 0;
  for (let n = 0; n < e.length; n++)
    r |= e[n] ^ t[n];
  return r === 0;
}
function KL(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
const t2 = (e) => typeof e == "bigint" && t3 <= e;
function zm(e, t, r) {
  return t2(e) && t2(t) && t2(r) && t <= e && e < r;
}
function $c(e, t, r, n) {
  if (!zm(t, r, n))
    throw new Error(`expected valid ${e}: ${r} <= n < ${n}, got ${typeof t} ${t}`);
}
function Gx(e) {
  let t;
  for (t = 0; e > t3; e >>= Rm, t += 1)
    ;
  return t;
}
function qL(e, t) {
  return e >> BigInt(t) & Rm;
}
function VL(e, t, r) {
  return e | (r ? Rm : t3) << BigInt(t);
}
const i3 = (e) => (HL << BigInt(e - 1)) - Rm, r2 = (e) => new Uint8Array(e), W6 = (e) => Uint8Array.from(e);
function Zx(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = r2(e), o = r2(e), a = 0;
  const i = () => {
    n.fill(1), o.fill(0), a = 0;
  }, s = (...c) => r(o, n, ...c), u = (c = r2()) => {
    o = s(W6([0]), c), n = s(), c.length !== 0 && (o = s(W6([1]), c), n = s());
  }, l = () => {
    if (a++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let c = 0;
    const f = [];
    for (; c < t; ) {
      n = s();
      const h = n.slice();
      f.push(h), c += n.length;
    }
    return vh(...f);
  };
  return (c, f) => {
    i(), u(c);
    let h;
    for (; !(h = f(l())); )
      u();
    return i(), h;
  };
}
const GL = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || Fc(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function Ep(e, t, r = {}) {
  const n = (o, a, i) => {
    const s = GL[a];
    if (typeof s != "function")
      throw new Error(`Invalid validator "${a}", expected function`);
    const u = e[o];
    if (!(i && u === void 0) && !s(u, e))
      throw new Error(`Invalid param ${String(o)}=${u} (${typeof u}), expected ${a}`);
  };
  for (const [o, a] of Object.entries(t))
    n(o, a, !1);
  for (const [o, a] of Object.entries(r))
    n(o, a, !0);
  return e;
}
const ZL = () => {
  throw new Error("not implemented");
};
function Nw(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...n) => {
    const o = t.get(r);
    if (o !== void 0)
      return o;
    const a = e(r, ...n);
    return t.set(r, a), a;
  };
}
const WL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aInRange: $c,
  abool: yf,
  abytes: vp,
  bitGet: qL,
  bitLen: Gx,
  bitMask: i3,
  bitSet: VL,
  bytesToHex: bf,
  bytesToNumberBE: Oc,
  bytesToNumberLE: n3,
  concatBytes: vh,
  createHmacDrbg: Zx,
  ensureBytes: ii,
  equalBytes: ML,
  hexToBytes: wf,
  hexToNumber: r3,
  inRange: zm,
  isBytes: Fc,
  memoized: Nw,
  notImplemented: ZL,
  numberToBytesBE: vf,
  numberToBytesLE: o3,
  numberToHexUnpadded: Wl,
  numberToVarBytesBE: DL,
  utf8ToBytes: KL,
  validateObject: Ep
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const rn = BigInt(0), Tr = BigInt(1), pc = BigInt(2), XL = BigInt(3), Uw = BigInt(4), X6 = BigInt(5), Y6 = BigInt(8);
BigInt(9);
BigInt(16);
function Pn(e, t) {
  const r = e % t;
  return r >= rn ? r : t + r;
}
function YL(e, t, r) {
  if (r <= rn || t < rn)
    throw new Error("Expected power/modulo > 0");
  if (r === Tr)
    return rn;
  let n = Tr;
  for (; t > rn; )
    t & Tr && (n = n * e % r), e = e * e % r, t >>= Tr;
  return n;
}
function Ro(e, t, r) {
  let n = e;
  for (; t-- > rn; )
    n *= n, n %= r;
  return n;
}
function Rw(e, t) {
  if (e === rn || t <= rn)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Pn(e, t), n = t, o = rn, a = Tr;
  for (; r !== rn; ) {
    const i = n / r, s = n % r, u = o - a * i;
    n = r, r = s, o = a, a = u;
  }
  if (n !== Tr)
    throw new Error("invert: does not exist");
  return Pn(o, t);
}
function JL(e) {
  const t = (e - Tr) / pc;
  let r, n, o;
  for (r = e - Tr, n = 0; r % pc === rn; r /= pc, n++)
    ;
  for (o = pc; o < e && YL(o, t, e) !== e - Tr; o++)
    ;
  if (n === 1) {
    const i = (e + Tr) / Uw;
    return function(s, u) {
      const l = s.pow(u, i);
      if (!s.eql(s.sqr(l), u))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  const a = (r + Tr) / pc;
  return function(i, s) {
    if (i.pow(s, t) === i.neg(i.ONE))
      throw new Error("Cannot find square root");
    let u = n, l = i.pow(i.mul(i.ONE, o), r), c = i.pow(s, a), f = i.pow(s, r);
    for (; !i.eql(f, i.ONE); ) {
      if (i.eql(f, i.ZERO))
        return i.ZERO;
      let h = 1;
      for (let y = i.sqr(f); h < u && !i.eql(y, i.ONE); h++)
        y = i.sqr(y);
      const p = i.pow(l, Tr << BigInt(u - h - 1));
      l = i.sqr(p), c = i.mul(c, p), f = i.mul(f, l), u = h;
    }
    return c;
  };
}
function QL(e) {
  if (e % Uw === XL) {
    const t = (e + Tr) / Uw;
    return function(r, n) {
      const o = r.pow(n, t);
      if (!r.eql(r.sqr(o), n))
        throw new Error("Cannot find square root");
      return o;
    };
  }
  if (e % Y6 === X6) {
    const t = (e - X6) / Y6;
    return function(r, n) {
      const o = r.mul(n, pc), a = r.pow(o, t), i = r.mul(n, a), s = r.mul(r.mul(i, pc), a), u = r.mul(i, r.sub(s, r.ONE));
      if (!r.eql(r.sqr(u), n))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return JL(e);
}
const eH = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function tH(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = eH.reduce((n, o) => (n[o] = "function", n), t);
  return Ep(e, r);
}
function rH(e, t, r) {
  if (r < rn)
    throw new Error("Expected power > 0");
  if (r === rn)
    return e.ONE;
  if (r === Tr)
    return t;
  let n = e.ONE, o = t;
  for (; r > rn; )
    r & Tr && (n = e.mul(n, o)), o = e.sqr(o), r >>= Tr;
  return n;
}
function nH(e, t) {
  const r = new Array(t.length), n = t.reduce((a, i, s) => e.is0(i) ? a : (r[s] = a, e.mul(a, i)), e.ONE), o = e.inv(n);
  return t.reduceRight((a, i, s) => e.is0(i) ? a : (r[s] = e.mul(a, r[s]), e.mul(a, i)), o), r;
}
function Wx(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function a3(e, t, r = !1, n = {}) {
  if (e <= rn)
    throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: o, nByteLength: a } = Wx(e, t);
  if (a > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const i = QL(e), s = Object.freeze({
    ORDER: e,
    BITS: o,
    BYTES: a,
    MASK: i3(o),
    ZERO: rn,
    ONE: Tr,
    create: (u) => Pn(u, e),
    isValid: (u) => {
      if (typeof u != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof u}`);
      return rn <= u && u < e;
    },
    is0: (u) => u === rn,
    isOdd: (u) => (u & Tr) === Tr,
    neg: (u) => Pn(-u, e),
    eql: (u, l) => u === l,
    sqr: (u) => Pn(u * u, e),
    add: (u, l) => Pn(u + l, e),
    sub: (u, l) => Pn(u - l, e),
    mul: (u, l) => Pn(u * l, e),
    pow: (u, l) => rH(s, u, l),
    div: (u, l) => Pn(u * Rw(l, e), e),
    // Same as above, but doesn't normalize
    sqrN: (u) => u * u,
    addN: (u, l) => u + l,
    subN: (u, l) => u - l,
    mulN: (u, l) => u * l,
    inv: (u) => Rw(u, e),
    sqrt: n.sqrt || ((u) => i(s, u)),
    invertBatch: (u) => nH(s, u),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (u, l, c) => c ? l : u,
    toBytes: (u) => r ? o3(u, a) : vf(u, a),
    fromBytes: (u) => {
      if (u.length !== a)
        throw new Error(`Fp.fromBytes: expected ${a}, got ${u.length}`);
      return r ? n3(u) : Oc(u);
    }
  });
  return Object.freeze(s);
}
function Xx(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function Yx(e) {
  const t = Xx(e);
  return t + Math.ceil(t / 2);
}
function oH(e, t, r = !1) {
  const n = e.length, o = Xx(t), a = Yx(t);
  if (n < 16 || n < a || n > 1024)
    throw new Error(`expected ${a}-1024 bytes of input, got ${n}`);
  const i = r ? Oc(e) : n3(e), s = Pn(i, t - Tr) + Tr;
  return r ? o3(s, o) : vf(s, o);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const iH = BigInt(0), n2 = BigInt(1), o2 = /* @__PURE__ */ new WeakMap(), J6 = /* @__PURE__ */ new WeakMap();
function aH(e, t) {
  const r = (a, i) => {
    const s = i.negate();
    return a ? s : i;
  }, n = (a) => {
    if (!Number.isSafeInteger(a) || a <= 0 || a > t)
      throw new Error(`Wrong window size=${a}, should be [1..${t}]`);
  }, o = (a) => {
    n(a);
    const i = Math.ceil(t / a) + 1, s = 2 ** (a - 1);
    return { windows: i, windowSize: s };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(a, i) {
      let s = e.ZERO, u = a;
      for (; i > iH; )
        i & n2 && (s = s.add(u)), u = u.double(), i >>= n2;
      return s;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(a, i) {
      const { windows: s, windowSize: u } = o(i), l = [];
      let c = a, f = c;
      for (let h = 0; h < s; h++) {
        f = c, l.push(f);
        for (let p = 1; p < u; p++)
          f = f.add(c), l.push(f);
        c = f.double();
      }
      return l;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(a, i, s) {
      const { windows: u, windowSize: l } = o(a);
      let c = e.ZERO, f = e.BASE;
      const h = BigInt(2 ** a - 1), p = 2 ** a, y = BigInt(a);
      for (let m = 0; m < u; m++) {
        const b = m * l;
        let v = Number(s & h);
        s >>= y, v > l && (v -= p, s += n2);
        const k = b, E = b + Math.abs(v) - 1, A = m % 2 !== 0, S = v < 0;
        v === 0 ? f = f.add(r(A, i[k])) : c = c.add(r(S, i[E]));
      }
      return { p: c, f };
    },
    wNAFCached(a, i, s) {
      const u = J6.get(a) || 1;
      let l = o2.get(a);
      return l || (l = this.precomputeWindow(a, u), u !== 1 && o2.set(a, s(l))), this.wNAF(u, l, i);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(a, i) {
      n(i), J6.set(a, i), o2.delete(a);
    }
  };
}
function sH(e, t, r, n) {
  if (!Array.isArray(r) || !Array.isArray(n) || n.length !== r.length)
    throw new Error("arrays of points and scalars must have equal length");
  n.forEach((c, f) => {
    if (!t.isValid(c))
      throw new Error(`wrong scalar at index ${f}`);
  }), r.forEach((c, f) => {
    if (!(c instanceof e))
      throw new Error(`wrong point at index ${f}`);
  });
  const o = Gx(BigInt(r.length)), a = o > 12 ? o - 3 : o > 4 ? o - 2 : o ? 2 : 1, i = (1 << a) - 1, s = new Array(i + 1).fill(e.ZERO), u = Math.floor((t.BITS - 1) / a) * a;
  let l = e.ZERO;
  for (let c = u; c >= 0; c -= a) {
    s.fill(e.ZERO);
    for (let h = 0; h < n.length; h++) {
      const p = n[h], y = Number(p >> BigInt(c) & BigInt(i));
      s[y] = s[y].add(r[h]);
    }
    let f = e.ZERO;
    for (let h = s.length - 1, p = e.ZERO; h > 0; h--)
      p = p.add(s[h]), f = f.add(p);
    if (l = l.add(f), c !== 0)
      for (let h = 0; h < a; h++)
        l = l.double();
  }
  return l;
}
function Jx(e) {
  return tH(e.Fp), Ep(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...Wx(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Q6(e) {
  e.lowS !== void 0 && yf("lowS", e.lowS), e.prehash !== void 0 && yf("prehash", e.prehash);
}
function uH(e) {
  const t = Jx(e);
  Ep(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: n, a: o } = t;
  if (r) {
    if (!n.eql(o, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: cH, hexToBytes: lH } = WL, Ka = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: r } = Ka;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const n = t.length / 2, o = Wl(n);
      if (o.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const a = n > 127 ? Wl(o.length / 2 | 128) : "";
      return `${Wl(e)}${a}${o}${t}`;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: r } = Ka;
      let n = 0;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[n++] !== e)
        throw new r("tlv.decode: wrong tlv");
      const o = t[n++], a = !!(o & 128);
      let i = 0;
      if (!a)
        i = o;
      else {
        const u = o & 127;
        if (!u)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (u > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const l = t.subarray(n, n + u);
        if (l.length !== u)
          throw new r("tlv.decode: length bytes not complete");
        if (l[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const c of l)
          i = i << 8 | c;
        if (n += u, i < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const s = t.subarray(n, n + i);
      if (s.length !== i)
        throw new r("tlv.decode: wrong value length");
      return { v: s, l: t.subarray(n + i) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = Ka;
      if (e < Ga)
        throw new t("integer: negative integers are not allowed");
      let r = Wl(e);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected assertion");
      return r;
    },
    decode(e) {
      const { Err: t } = Ka;
      if (e[0] & 128)
        throw new t("Invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("Invalid signature integer: unnecessary leading zero");
      return cH(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: r, _tlv: n } = Ka, o = typeof e == "string" ? lH(e) : e;
    vp(o);
    const { v: a, l: i } = n.decode(48, o);
    if (i.length)
      throw new t("Invalid signature: left bytes after parsing");
    const { v: s, l: u } = n.decode(2, a), { v: l, l: c } = n.decode(2, u);
    if (c.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: r.decode(s), s: r.decode(l) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: r } = Ka, n = `${t.encode(2, r.encode(e.r))}${t.encode(2, r.encode(e.s))}`;
    return t.encode(48, n);
  }
}, Ga = BigInt(0), Xr = BigInt(1);
BigInt(2);
const eE = BigInt(3);
BigInt(4);
function fH(e) {
  const t = uH(e), { Fp: r } = t, n = a3(t.n, t.nBitLength), o = t.toBytes || ((m, b, v) => {
    const k = b.toAffine();
    return vh(Uint8Array.from([4]), r.toBytes(k.x), r.toBytes(k.y));
  }), a = t.fromBytes || ((m) => {
    const b = m.subarray(1), v = r.fromBytes(b.subarray(0, r.BYTES)), k = r.fromBytes(b.subarray(r.BYTES, 2 * r.BYTES));
    return { x: v, y: k };
  });
  function i(m) {
    const { a: b, b: v } = t, k = r.sqr(m), E = r.mul(k, m);
    return r.add(r.add(E, r.mul(m, b)), v);
  }
  if (!r.eql(r.sqr(t.Gy), i(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function s(m) {
    return zm(m, Xr, t.n);
  }
  function u(m) {
    const { allowedPrivateKeyLengths: b, nByteLength: v, wrapPrivateKey: k, n: E } = t;
    if (b && typeof m != "bigint") {
      if (Fc(m) && (m = bf(m)), typeof m != "string" || !b.includes(m.length))
        throw new Error("Invalid key");
      m = m.padStart(v * 2, "0");
    }
    let A;
    try {
      A = typeof m == "bigint" ? m : Oc(ii("private key", m, v));
    } catch {
      throw new Error(`private key must be ${v} bytes, hex or bigint, not ${typeof m}`);
    }
    return k && (A = Pn(A, E)), $c("private key", A, Xr, E), A;
  }
  function l(m) {
    if (!(m instanceof h))
      throw new Error("ProjectivePoint expected");
  }
  const c = Nw((m, b) => {
    const { px: v, py: k, pz: E } = m;
    if (r.eql(E, r.ONE))
      return { x: v, y: k };
    const A = m.is0();
    b == null && (b = A ? r.ONE : r.inv(E));
    const S = r.mul(v, b), _ = r.mul(k, b), I = r.mul(E, b);
    if (A)
      return { x: r.ZERO, y: r.ZERO };
    if (!r.eql(I, r.ONE))
      throw new Error("invZ was invalid");
    return { x: S, y: _ };
  }), f = Nw((m) => {
    if (m.is0()) {
      if (t.allowInfinityPoint && !r.is0(m.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: b, y: v } = m.toAffine();
    if (!r.isValid(b) || !r.isValid(v))
      throw new Error("bad point: x or y not FE");
    const k = r.sqr(v), E = i(b);
    if (!r.eql(k, E))
      throw new Error("bad point: equation left != right");
    if (!m.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  class h {
    constructor(b, v, k) {
      if (this.px = b, this.py = v, this.pz = k, b == null || !r.isValid(b))
        throw new Error("x required");
      if (v == null || !r.isValid(v))
        throw new Error("y required");
      if (k == null || !r.isValid(k))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(b) {
      const { x: v, y: k } = b || {};
      if (!b || !r.isValid(v) || !r.isValid(k))
        throw new Error("invalid affine point");
      if (b instanceof h)
        throw new Error("projective point not allowed");
      const E = (A) => r.eql(A, r.ZERO);
      return E(v) && E(k) ? h.ZERO : new h(v, k, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(b) {
      const v = r.invertBatch(b.map((k) => k.pz));
      return b.map((k, E) => k.toAffine(v[E])).map(h.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(b) {
      const v = h.fromAffine(a(ii("pointHex", b)));
      return v.assertValidity(), v;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(b) {
      return h.BASE.multiply(u(b));
    }
    // Multiscalar Multiplication
    static msm(b, v) {
      return sH(h, n, b, v);
    }
    // "Private method", don't use it directly
    _setWindowSize(b) {
      y.setWindowSize(this, b);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      f(this);
    }
    hasEvenY() {
      const { y: b } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(b);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(b) {
      l(b);
      const { px: v, py: k, pz: E } = this, { px: A, py: S, pz: _ } = b, I = r.eql(r.mul(v, _), r.mul(A, E)), O = r.eql(r.mul(k, _), r.mul(S, E));
      return I && O;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new h(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: b, b: v } = t, k = r.mul(v, eE), { px: E, py: A, pz: S } = this;
      let _ = r.ZERO, I = r.ZERO, O = r.ZERO, z = r.mul(E, E), D = r.mul(A, A), G = r.mul(S, S), U = r.mul(E, A);
      return U = r.add(U, U), O = r.mul(E, S), O = r.add(O, O), _ = r.mul(b, O), I = r.mul(k, G), I = r.add(_, I), _ = r.sub(D, I), I = r.add(D, I), I = r.mul(_, I), _ = r.mul(U, _), O = r.mul(k, O), G = r.mul(b, G), U = r.sub(z, G), U = r.mul(b, U), U = r.add(U, O), O = r.add(z, z), z = r.add(O, z), z = r.add(z, G), z = r.mul(z, U), I = r.add(I, z), G = r.mul(A, S), G = r.add(G, G), z = r.mul(G, U), _ = r.sub(_, z), O = r.mul(G, D), O = r.add(O, O), O = r.add(O, O), new h(_, I, O);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(b) {
      l(b);
      const { px: v, py: k, pz: E } = this, { px: A, py: S, pz: _ } = b;
      let I = r.ZERO, O = r.ZERO, z = r.ZERO;
      const D = t.a, G = r.mul(t.b, eE);
      let U = r.mul(v, A), V = r.mul(k, S), F = r.mul(E, _), C = r.add(v, k), R = r.add(A, S);
      C = r.mul(C, R), R = r.add(U, V), C = r.sub(C, R), R = r.add(v, E);
      let M = r.add(A, _);
      return R = r.mul(R, M), M = r.add(U, F), R = r.sub(R, M), M = r.add(k, E), I = r.add(S, _), M = r.mul(M, I), I = r.add(V, F), M = r.sub(M, I), z = r.mul(D, R), I = r.mul(G, F), z = r.add(I, z), I = r.sub(V, z), z = r.add(V, z), O = r.mul(I, z), V = r.add(U, U), V = r.add(V, U), F = r.mul(D, F), R = r.mul(G, R), V = r.add(V, F), F = r.sub(U, F), F = r.mul(D, F), R = r.add(R, F), U = r.mul(V, R), O = r.add(O, U), U = r.mul(M, R), I = r.mul(C, I), I = r.sub(I, U), U = r.mul(C, V), z = r.mul(M, z), z = r.add(z, U), new h(I, O, z);
    }
    subtract(b) {
      return this.add(b.negate());
    }
    is0() {
      return this.equals(h.ZERO);
    }
    wNAF(b) {
      return y.wNAFCached(this, b, h.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(b) {
      $c("scalar", b, Ga, t.n);
      const v = h.ZERO;
      if (b === Ga)
        return v;
      if (b === Xr)
        return this;
      const { endo: k } = t;
      if (!k)
        return y.unsafeLadder(this, b);
      let { k1neg: E, k1: A, k2neg: S, k2: _ } = k.splitScalar(b), I = v, O = v, z = this;
      for (; A > Ga || _ > Ga; )
        A & Xr && (I = I.add(z)), _ & Xr && (O = O.add(z)), z = z.double(), A >>= Xr, _ >>= Xr;
      return E && (I = I.negate()), S && (O = O.negate()), O = new h(r.mul(O.px, k.beta), O.py, O.pz), I.add(O);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(b) {
      const { endo: v, n: k } = t;
      $c("scalar", b, Xr, k);
      let E, A;
      if (v) {
        const { k1neg: S, k1: _, k2neg: I, k2: O } = v.splitScalar(b);
        let { p: z, f: D } = this.wNAF(_), { p: G, f: U } = this.wNAF(O);
        z = y.constTimeNegate(S, z), G = y.constTimeNegate(I, G), G = new h(r.mul(G.px, v.beta), G.py, G.pz), E = z.add(G), A = D.add(U);
      } else {
        const { p: S, f: _ } = this.wNAF(b);
        E = S, A = _;
      }
      return h.normalizeZ([E, A])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(b, v, k) {
      const E = h.BASE, A = (_, I) => I === Ga || I === Xr || !_.equals(E) ? _.multiplyUnsafe(I) : _.multiply(I), S = A(this, v).add(A(b, k));
      return S.is0() ? void 0 : S;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(b) {
      return c(this, b);
    }
    isTorsionFree() {
      const { h: b, isTorsionFree: v } = t;
      if (b === Xr)
        return !0;
      if (v)
        return v(h, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: b, clearCofactor: v } = t;
      return b === Xr ? this : v ? v(h, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(b = !0) {
      return yf("isCompressed", b), this.assertValidity(), o(h, this, b);
    }
    toHex(b = !0) {
      return yf("isCompressed", b), bf(this.toRawBytes(b));
    }
  }
  h.BASE = new h(t.Gx, t.Gy, r.ONE), h.ZERO = new h(r.ZERO, r.ONE, r.ZERO);
  const p = t.nBitLength, y = aH(h, t.endo ? Math.ceil(p / 2) : p);
  return {
    CURVE: t,
    ProjectivePoint: h,
    normPrivateKeyToScalar: u,
    weierstrassEquation: i,
    isWithinCurveOrder: s
  };
}
function dH(e) {
  const t = Jx(e);
  return Ep(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function hH(e) {
  const t = dH(e), { Fp: r, n } = t, o = r.BYTES + 1, a = 2 * r.BYTES + 1;
  function i(F) {
    return Pn(F, n);
  }
  function s(F) {
    return Rw(F, n);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: l, weierstrassEquation: c, isWithinCurveOrder: f } = fH({
    ...t,
    toBytes(F, C, R) {
      const M = C.toAffine(), re = r.toBytes(M.x), W = vh;
      return yf("isCompressed", R), R ? W(Uint8Array.from([C.hasEvenY() ? 2 : 3]), re) : W(Uint8Array.from([4]), re, r.toBytes(M.y));
    },
    fromBytes(F) {
      const C = F.length, R = F[0], M = F.subarray(1);
      if (C === o && (R === 2 || R === 3)) {
        const re = Oc(M);
        if (!zm(re, Xr, r.ORDER))
          throw new Error("Point is not on curve");
        const W = c(re);
        let ne;
        try {
          ne = r.sqrt(W);
        } catch (se) {
          const K = se instanceof Error ? ": " + se.message : "";
          throw new Error("Point is not on curve" + K);
        }
        const oe = (ne & Xr) === Xr;
        return (R & 1) === 1 !== oe && (ne = r.neg(ne)), { x: re, y: ne };
      } else if (C === a && R === 4) {
        const re = r.fromBytes(M.subarray(0, r.BYTES)), W = r.fromBytes(M.subarray(r.BYTES, 2 * r.BYTES));
        return { x: re, y: W };
      } else
        throw new Error(`Point of length ${C} was invalid. Expected ${o} compressed bytes or ${a} uncompressed bytes`);
    }
  }), h = (F) => bf(vf(F, t.nByteLength));
  function p(F) {
    const C = n >> Xr;
    return F > C;
  }
  function y(F) {
    return p(F) ? i(-F) : F;
  }
  const m = (F, C, R) => Oc(F.slice(C, R));
  class b {
    constructor(C, R, M) {
      this.r = C, this.s = R, this.recovery = M, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(C) {
      const R = t.nByteLength;
      return C = ii("compactSignature", C, R * 2), new b(m(C, 0, R), m(C, R, 2 * R));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(C) {
      const { r: R, s: M } = Ka.toSig(ii("DER", C));
      return new b(R, M);
    }
    assertValidity() {
      $c("r", this.r, Xr, n), $c("s", this.s, Xr, n);
    }
    addRecoveryBit(C) {
      return new b(this.r, this.s, C);
    }
    recoverPublicKey(C) {
      const { r: R, s: M, recovery: re } = this, W = _(ii("msgHash", C));
      if (re == null || ![0, 1, 2, 3].includes(re))
        throw new Error("recovery id invalid");
      const ne = re === 2 || re === 3 ? R + t.n : R;
      if (ne >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const oe = re & 1 ? "03" : "02", se = u.fromHex(oe + h(ne)), K = s(ne), he = i(-W * K), Ae = i(M * K), ye = u.BASE.multiplyAndAddUnsafe(se, he, Ae);
      if (!ye)
        throw new Error("point at infinify");
      return ye.assertValidity(), ye;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return p(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new b(this.r, i(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return wf(this.toDERHex());
    }
    toDERHex() {
      return Ka.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return wf(this.toCompactHex());
    }
    toCompactHex() {
      return h(this.r) + h(this.s);
    }
  }
  const v = {
    isValidPrivateKey(F) {
      try {
        return l(F), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: l,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const F = Yx(t.n);
      return oH(t.randomBytes(F), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(F = 8, C = u.BASE) {
      return C._setWindowSize(F), C.multiply(BigInt(3)), C;
    }
  };
  function k(F, C = !0) {
    return u.fromPrivateKey(F).toRawBytes(C);
  }
  function E(F) {
    const C = Fc(F), R = typeof F == "string", M = (C || R) && F.length;
    return C ? M === o || M === a : R ? M === 2 * o || M === 2 * a : F instanceof u;
  }
  function A(F, C, R = !0) {
    if (E(F))
      throw new Error("first arg must be private key");
    if (!E(C))
      throw new Error("second arg must be public key");
    return u.fromHex(C).multiply(l(F)).toRawBytes(R);
  }
  const S = t.bits2int || function(F) {
    const C = Oc(F), R = F.length * 8 - t.nBitLength;
    return R > 0 ? C >> BigInt(R) : C;
  }, _ = t.bits2int_modN || function(F) {
    return i(S(F));
  }, I = i3(t.nBitLength);
  function O(F) {
    return $c(`num < 2^${t.nBitLength}`, F, Ga, I), vf(F, t.nByteLength);
  }
  function z(F, C, R = D) {
    if (["recovered", "canonical"].some((Ge) => Ge in R))
      throw new Error("sign() legacy options not supported");
    const { hash: M, randomBytes: re } = t;
    let { lowS: W, prehash: ne, extraEntropy: oe } = R;
    W == null && (W = !0), F = ii("msgHash", F), Q6(R), ne && (F = ii("prehashed msgHash", M(F)));
    const se = _(F), K = l(C), he = [O(K), O(se)];
    if (oe != null && oe !== !1) {
      const Ge = oe === !0 ? re(r.BYTES) : oe;
      he.push(ii("extraEntropy", Ge));
    }
    const Ae = vh(...he), ye = se;
    function Et(Ge) {
      const be = S(Ge);
      if (!f(be))
        return;
      const st = s(be), Ze = u.BASE.multiply(be).toAffine(), We = i(Ze.x);
      if (We === Ga)
        return;
      const Re = i(st * i(ye + We * K));
      if (Re === Ga)
        return;
      let Tt = (Ze.x === We ? 0 : 2) | Number(Ze.y & Xr), xr = Re;
      return W && p(Re) && (xr = y(Re), Tt ^= 1), new b(We, xr, Tt);
    }
    return { seed: Ae, k2sig: Et };
  }
  const D = { lowS: t.lowS, prehash: !1 }, G = { lowS: t.lowS, prehash: !1 };
  function U(F, C, R = D) {
    const { seed: M, k2sig: re } = z(F, C, R), W = t;
    return Zx(W.hash.outputLen, W.nByteLength, W.hmac)(M, re);
  }
  u.BASE._setWindowSize(8);
  function V(F, C, R, M = G) {
    var re;
    const W = F;
    if (C = ii("msgHash", C), R = ii("publicKey", R), "strict" in M)
      throw new Error("options.strict was renamed to lowS");
    Q6(M);
    const { lowS: ne, prehash: oe } = M;
    let se, K;
    try {
      if (typeof W == "string" || Fc(W))
        try {
          se = b.fromDER(W);
        } catch (Ze) {
          if (!(Ze instanceof Ka.Err))
            throw Ze;
          se = b.fromCompact(W);
        }
      else if (typeof W == "object" && typeof W.r == "bigint" && typeof W.s == "bigint") {
        const { r: Ze, s: We } = W;
        se = new b(Ze, We);
      } else
        throw new Error("PARSE");
      K = u.fromHex(R);
    } catch (Ze) {
      if (Ze.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (ne && se.hasHighS())
      return !1;
    oe && (C = t.hash(C));
    const { r: he, s: Ae } = se, ye = _(C), Et = s(Ae), Ge = i(ye * Et), be = i(he * Et), st = (re = u.BASE.multiplyAndAddUnsafe(K, Ge, be)) == null ? void 0 : re.toAffine();
    return st ? i(st.x) === he : !1;
  }
  return {
    CURVE: t,
    getPublicKey: k,
    getSharedSecret: A,
    sign: U,
    verify: V,
    ProjectivePoint: u,
    Signature: b,
    utils: v
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function pH(e) {
  return {
    hash: e,
    hmac: (t, ...r) => e3(e, t, bR(...r)),
    randomBytes: wR
  };
}
function gH(e, t) {
  const r = (n) => hH({ ...e, ...pH(n) });
  return Object.freeze({ ...r(t), create: r });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Qx = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), tE = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), mH = BigInt(1), zw = BigInt(2), rE = (e, t) => (e + t / zw) / t;
function yH(e) {
  const t = Qx, r = BigInt(3), n = BigInt(6), o = BigInt(11), a = BigInt(22), i = BigInt(23), s = BigInt(44), u = BigInt(88), l = e * e * e % t, c = l * l * e % t, f = Ro(c, r, t) * c % t, h = Ro(f, r, t) * c % t, p = Ro(h, zw, t) * l % t, y = Ro(p, o, t) * p % t, m = Ro(y, a, t) * y % t, b = Ro(m, s, t) * m % t, v = Ro(b, u, t) * b % t, k = Ro(v, s, t) * m % t, E = Ro(k, r, t) * c % t, A = Ro(E, i, t) * y % t, S = Ro(A, n, t) * l % t, _ = Ro(S, zw, t);
  if (!jw.eql(jw.sqr(_), e))
    throw new Error("Cannot find square root");
  return _;
}
const jw = a3(Qx, void 0, void 0, { sqrt: yH }), Dc = gH({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: jw,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: tE,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = tE, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -mH * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), a = r, i = BigInt("0x100000000000000000000000000000000"), s = rE(a * e, t), u = rE(-n * e, t);
      let l = Pn(e - s * r - u * o, t), c = Pn(-s * n - u * a, t);
      const f = l > i, h = c > i;
      if (f && (l = t - l), h && (c = t - c), l > i || c > i)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: f, k1: l, k2neg: h, k2: c };
    }
  }
}, en);
BigInt(0);
Dc.ProjectivePoint;
function bH(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function nE(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function wH(e, t) {
  bH(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const vH = (e) => e instanceof Uint8Array, i2 = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Hi = (e, t) => e << 32 - t | e >>> t, EH = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!EH)
  throw new Error("Non little-endian hardware is not supported");
function kH(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function eA(e) {
  if (typeof e == "string" && (e = kH(e)), !vH(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
let xH = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function AH(e) {
  const t = (n) => e().update(eA(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function SH(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
let _H = class extends xH {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = i2(this.buffer);
  }
  update(t) {
    nE(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = eA(t);
    const a = t.length;
    for (let i = 0; i < a; ) {
      const s = Math.min(o - this.pos, a - i);
      if (s === o) {
        const u = i2(t);
        for (; o <= a - i; i += o)
          this.process(u, i);
        continue;
      }
      n.set(t.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    nE(this), wH(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: o, isLE: a } = this;
    let { pos: i } = this;
    r[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > o - i && (this.process(n, 0), i = 0);
    for (let f = i; f < o; f++)
      r[f] = 0;
    SH(n, o - 8, BigInt(this.length * 8), a), this.process(n, 0);
    const s = i2(t), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, c = this.get();
    if (l > c.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < l; f++)
      s.setUint32(4 * f, c[f], a);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: a, destroyed: i, pos: s } = this;
    return t.length = o, t.pos = s, t.finished = a, t.destroyed = i, o % r && t.buffer.set(n), t;
  }
};
const IH = (e, t, r) => e & t ^ ~e & r, TH = (e, t, r) => e & t ^ e & r ^ t & r, PH = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Ss = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), _s = /* @__PURE__ */ new Uint32Array(64);
let OH = class extends _H {
  constructor() {
    super(64, 32, 8, !1), this.A = Ss[0] | 0, this.B = Ss[1] | 0, this.C = Ss[2] | 0, this.D = Ss[3] | 0, this.E = Ss[4] | 0, this.F = Ss[5] | 0, this.G = Ss[6] | 0, this.H = Ss[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: a, F: i, G: s, H: u } = this;
    return [t, r, n, o, a, i, s, u];
  }
  // prettier-ignore
  set(t, r, n, o, a, i, s, u) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = a | 0, this.F = i | 0, this.G = s | 0, this.H = u | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      _s[f] = t.getUint32(r, !1);
    for (let f = 16; f < 64; f++) {
      const h = _s[f - 15], p = _s[f - 2], y = Hi(h, 7) ^ Hi(h, 18) ^ h >>> 3, m = Hi(p, 17) ^ Hi(p, 19) ^ p >>> 10;
      _s[f] = m + _s[f - 7] + y + _s[f - 16] | 0;
    }
    let { A: n, B: o, C: a, D: i, E: s, F: u, G: l, H: c } = this;
    for (let f = 0; f < 64; f++) {
      const h = Hi(s, 6) ^ Hi(s, 11) ^ Hi(s, 25), p = c + h + IH(s, u, l) + PH[f] + _s[f] | 0, y = (Hi(n, 2) ^ Hi(n, 13) ^ Hi(n, 22)) + TH(n, o, a) | 0;
      c = l, l = u, u = s, s = i + p | 0, i = a, a = o, o = n, n = p + y | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, c = c + this.H | 0, this.set(n, o, a, i, s, u, l, c);
  }
  roundClean() {
    _s.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const Lw = /* @__PURE__ */ AH(() => new OH());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// @__NO_SIDE_EFFECTS__
function kp(...e) {
  const t = (o, a) => (i) => o(a(i)), r = Array.from(e).reverse().reduce((o, a) => o ? t(o, a.encode) : a.encode, void 0), n = e.reduce((o, a) => o ? t(o, a.decode) : a.decode, void 0);
  return { encode: r, decode: n };
}
// @__NO_SIDE_EFFECTS__
function jm(e) {
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return t.map((r) => {
        if (r < 0 || r >= e.length)
          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
        return e[r];
      });
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return t.map((r) => {
        if (typeof r != "string")
          throw new Error(`alphabet.decode: not string element=${r}`);
        const n = e.indexOf(r);
        if (n === -1)
          throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
        return n;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function Lm(e = "") {
  if (typeof e != "string")
    throw new Error("join separator should be string");
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let r of t)
        if (typeof r != "string")
          throw new Error(`join.encode: non-string input=${r}`);
      return t.join(e);
    },
    decode: (t) => {
      if (typeof t != "string")
        throw new Error("join.decode input should be string");
      return t.split(e);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function tA(e, t = "=") {
  if (typeof t != "string")
    throw new Error("padding chr should be string");
  return {
    encode(r) {
      if (!Array.isArray(r) || r.length && typeof r[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let n of r)
        if (typeof n != "string")
          throw new Error(`padding.encode: non-string input=${n}`);
      for (; r.length * e % 8; )
        r.push(t);
      return r;
    },
    decode(r) {
      if (!Array.isArray(r) || r.length && typeof r[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let o of r)
        if (typeof o != "string")
          throw new Error(`padding.decode: non-string input=${o}`);
      let n = r.length;
      if (n * e % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; n > 0 && r[n - 1] === t; n--)
        if (!((n - 1) * e % 8))
          throw new Error("Invalid padding: string has too much padding");
      return r.slice(0, n);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function oE(e, t, r) {
  if (t < 2)
    throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
  if (!Array.isArray(e))
    throw new Error("convertRadix: data should be array");
  if (!e.length)
    return [];
  let n = 0;
  const o = [], a = Array.from(e);
  for (a.forEach((i) => {
    if (i < 0 || i >= t)
      throw new Error(`Wrong integer: ${i}`);
  }); ; ) {
    let i = 0, s = !0;
    for (let u = n; u < a.length; u++) {
      const l = a[u], c = t * i + l;
      if (!Number.isSafeInteger(c) || t * i / t !== i || c - l !== t * i)
        throw new Error("convertRadix: carry overflow");
      i = c % r;
      const f = Math.floor(c / r);
      if (a[u] = f, !Number.isSafeInteger(f) || f * r + i !== c)
        throw new Error("convertRadix: carry overflow");
      if (s)
        f ? s = !1 : n = u;
      else continue;
    }
    if (o.push(i), s)
      break;
  }
  for (let i = 0; i < e.length - 1 && e[i] === 0; i++)
    o.push(0);
  return o.reverse();
}
const rA = /* @__NO_SIDE_EFFECTS__ */ (e, t) => t ? /* @__PURE__ */ rA(t, e % t) : e, Y1 = /* @__NO_SIDE_EFFECTS__ */ (e, t) => e + (t - /* @__PURE__ */ rA(e, t));
// @__NO_SIDE_EFFECTS__
function Hw(e, t, r, n) {
  if (!Array.isArray(e))
    throw new Error("convertRadix2: data should be array");
  if (t <= 0 || t > 32)
    throw new Error(`convertRadix2: wrong from=${t}`);
  if (r <= 0 || r > 32)
    throw new Error(`convertRadix2: wrong to=${r}`);
  if (/* @__PURE__ */ Y1(t, r) > 32)
    throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${/* @__PURE__ */ Y1(t, r)}`);
  let o = 0, a = 0;
  const i = 2 ** r - 1, s = [];
  for (const u of e) {
    if (u >= 2 ** t)
      throw new Error(`convertRadix2: invalid data word=${u} from=${t}`);
    if (o = o << t | u, a + t > 32)
      throw new Error(`convertRadix2: carry overflow pos=${a} from=${t}`);
    for (a += t; a >= r; a -= r)
      s.push((o >> a - r & i) >>> 0);
    o &= 2 ** a - 1;
  }
  if (o = o << r - a & i, !n && a >= t)
    throw new Error("Excess padding");
  if (!n && o)
    throw new Error(`Non-zero padding: ${o}`);
  return n && a > 0 && s.push(o >>> 0), s;
}
// @__NO_SIDE_EFFECTS__
function $H(e) {
  return {
    encode: (t) => {
      if (!(t instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ oE(Array.from(t), 2 ** 8, e);
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(/* @__PURE__ */ oE(t, e, 2 ** 8));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function s3(e, t = !1) {
  if (e <= 0 || e > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ Y1(8, e) > 32 || /* @__PURE__ */ Y1(e, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (r) => {
      if (!(r instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return /* @__PURE__ */ Hw(Array.from(r), 8, e, !t);
    },
    decode: (r) => {
      if (!Array.isArray(r) || r.length && typeof r[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(/* @__PURE__ */ Hw(r, e, 8, t));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function iE(e) {
  if (typeof e != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...t) {
    try {
      return e.apply(null, t);
    } catch {
    }
  };
}
// @__NO_SIDE_EFFECTS__
function CH(e, t) {
  if (typeof t != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(r) {
      if (!(r instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const n = t(r).slice(0, e), o = new Uint8Array(r.length + e);
      return o.set(r), o.set(n, r.length), o;
    },
    decode(r) {
      if (!(r instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const n = r.slice(0, -e), o = t(n).slice(0, e), a = r.slice(-e);
      for (let i = 0; i < e; i++)
        if (o[i] !== a[i])
          throw new Error("Invalid checksum");
      return n;
    }
  };
}
const aE = /* @__PURE__ */ kp(/* @__PURE__ */ s3(6), /* @__PURE__ */ jm("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ tA(6), /* @__PURE__ */ Lm("")), sE = /* @__PURE__ */ kp(/* @__PURE__ */ s3(6), /* @__PURE__ */ jm("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ tA(6), /* @__PURE__ */ Lm("")), BH = (e) => /* @__PURE__ */ kp(/* @__PURE__ */ $H(58), /* @__PURE__ */ jm(e), /* @__PURE__ */ Lm("")), NH = /* @__PURE__ */ BH("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), uE = (e) => /* @__PURE__ */ kp(/* @__PURE__ */ CH(4, (t) => e(e(t))), NH), Fw = /* @__PURE__ */ kp(/* @__PURE__ */ jm("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ Lm("")), cE = [996825010, 642813549, 513874426, 1027748829, 705979059];
// @__NO_SIDE_EFFECTS__
function Bd(e) {
  const t = e >> 25;
  let r = (e & 33554431) << 5;
  for (let n = 0; n < cE.length; n++)
    (t >> n & 1) === 1 && (r ^= cE[n]);
  return r;
}
// @__NO_SIDE_EFFECTS__
function lE(e, t, r = 1) {
  const n = e.length;
  let o = 1;
  for (let a = 0; a < n; a++) {
    const i = e.charCodeAt(a);
    if (i < 33 || i > 126)
      throw new Error(`Invalid prefix (${e})`);
    o = /* @__PURE__ */ Bd(o) ^ i >> 5;
  }
  o = /* @__PURE__ */ Bd(o);
  for (let a = 0; a < n; a++)
    o = /* @__PURE__ */ Bd(o) ^ e.charCodeAt(a) & 31;
  for (let a of t)
    o = /* @__PURE__ */ Bd(o) ^ a;
  for (let a = 0; a < 6; a++)
    o = /* @__PURE__ */ Bd(o);
  return o ^= r, Fw.encode(/* @__PURE__ */ Hw([o % 2 ** 30], 30, 5, !1));
}
// @__NO_SIDE_EFFECTS__
function nA(e) {
  const t = e === "bech32" ? 1 : 734539939, r = /* @__PURE__ */ s3(5), n = r.decode, o = r.encode, a = /* @__PURE__ */ iE(n);
  function i(c, f, h = 90) {
    if (typeof c != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof c}`);
    if (!Array.isArray(f) || f.length && typeof f[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof f}`);
    const p = c.length + 7 + f.length;
    if (h !== !1 && p > h)
      throw new TypeError(`Length ${p} exceeds limit ${h}`);
    const y = c.toLowerCase(), m = /* @__PURE__ */ lE(y, f, t);
    return `${y}1${Fw.encode(f)}${m}`;
  }
  function s(c, f = 90) {
    if (typeof c != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof c}`);
    if (c.length < 8 || f !== !1 && c.length > f)
      throw new TypeError(`Wrong string length: ${c.length} (${c}). Expected (8..${f})`);
    const h = c.toLowerCase();
    if (c !== h && c !== c.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    c = h;
    const p = c.lastIndexOf("1");
    if (p === 0 || p === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const y = c.slice(0, p), m = c.slice(p + 1);
    if (m.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const b = Fw.decode(m).slice(0, -6), v = /* @__PURE__ */ lE(y, b, t);
    if (!m.endsWith(v))
      throw new Error(`Invalid checksum in ${c}: expected "${v}"`);
    return { prefix: y, words: b };
  }
  const u = /* @__PURE__ */ iE(s);
  function l(c) {
    const { prefix: f, words: h } = s(c, !1);
    return { prefix: f, words: h, bytes: n(h) };
  }
  return { encode: i, decode: s, decodeToBytes: l, decodeUnsafe: u, fromWords: n, fromWordsUnsafe: a, toWords: o };
}
const A0 = /* @__PURE__ */ nA("bech32"), S0 = /* @__PURE__ */ nA("bech32m"), na = {
  b58chk: {
    encode: (e) => uE(Lw).encode(e),
    decode: (e) => uE(Lw).decode(e)
  },
  base64: {
    encode: (e) => aE.encode(e),
    decode: (e) => aE.decode(e)
  },
  b64url: {
    encode: (e) => sE.encode(e),
    decode: (e) => sE.decode(e)
  },
  bech32: {
    to_words: A0.toWords,
    to_bytes: A0.fromWords,
    encode: (e, t, r = !1) => A0.encode(e, t, r),
    decode: (e, t = !1) => {
      const { prefix: r, words: n } = A0.decode(e, t);
      return { prefix: r, words: n };
    }
  },
  bech32m: {
    to_words: S0.toWords,
    to_bytes: S0.fromWords,
    encode: (e, t, r = !1) => S0.encode(e, t, r),
    decode: (e, t = !1) => {
      const { prefix: r, words: n } = S0.decode(e, t);
      return { prefix: r, words: n };
    }
  }
};
function UH(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function RH(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function zH(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
function oA(e, t) {
  if (e !== t)
    throw new TypeError(`Bech32 prefix does not match: ${e} !== ${t}`);
}
const jH = BigInt(0), LH = BigInt(255), iA = BigInt(256);
function HH(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function FH(e, t, r = "be") {
  t === void 0 && (t = HH(e));
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (; e > jH; ) {
    const s = e & LH, u = Number(s);
    n ? a.setUint8(i++, u) : a.setUint8(i--, u), e = (e - s) / iA;
  }
  return new Uint8Array(o);
}
function DH(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * iA + BigInt(e[r]);
  return BigInt(t);
}
function MH(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, o = 0; n < t.length; n += 8, o++) {
    let a = 0;
    for (let i = 0; i < 8; i++)
      a |= t[n + i] << 7 - i;
    r[o] = a;
  }
  return r;
}
function KH(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let o = 7; o >= 0; o--, r++)
      t[r] = n >> o & 1;
  }
  return t.join("");
}
function qH(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function VH(e, t, r = "be") {
  t === void 0 && (t = qH(e));
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (; e > 0; ) {
    const s = e & 255;
    n ? a.setUint8(i++, e) : a.setUint8(i--, e), e = (e - s) / 256;
  }
  return new Uint8Array(o);
}
function GH(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], zH(t);
  return t;
}
const ZH = new TextEncoder(), WH = new TextDecoder();
function u3(e) {
  return ZH.encode(e);
}
function a2(e) {
  return WH.decode(e);
}
function XH(e, t) {
  RH(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function YH(e, t, r = "le") {
  t = XH(e, t);
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (let s = 0; s < e.length; s += 2) {
    const u = e.substring(s, s + 2), l = parseInt(u, 16);
    n ? a.setUint8(i++, l) : a.setUint8(i--, l);
  }
  return new Uint8Array(o);
}
function JH(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
const { getRandomValues: QH } = crypto ?? globalThis.crypto ?? window.crypto;
function eF(e = 32) {
  if (typeof QH == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function aA(e) {
  return e.match(/[^a-fA-f0-9]/) === null && e.length % 2 === 0;
}
function tF(e) {
  return typeof e == "string" && aA(e) || typeof e == "number" || typeof e == "bigint" || e instanceof Uint8Array ? !0 : !!(Array.isArray(e) && e.every((t) => typeof t == "number"));
}
function rF(e, t, r = "be") {
  t === void 0 && (t = e.length), UH(e, t);
  const n = new Uint8Array(t).fill(0), o = r === "be" ? 0 : t - e.length;
  return n.set(e, o), n;
}
function sA(e) {
  let t, r = 0;
  const n = e.reduce((a, i) => a + i.length, 0), o = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const a = e[t];
    o.set(a, r), r += a.length;
  }
  return o;
}
function nF(e, t) {
  return typeof t == "bigint" ? `${t}n` : t;
}
function oF(e, t) {
  return typeof t == "string" && /n$/.test(t) ? BigInt(t.slice(0, -1)) : t;
}
function iF(e, t, r) {
  const n = e.length, o = r / t;
  if (r % t !== 0)
    throw new TypeError(`Invalid parameters: ${r} % ${t} !== 0`);
  if (n !== r)
    throw new TypeError(`Invalid data stream: ${n} !== ${r}`);
  if (n % t !== 0)
    throw new TypeError(`Invalid data stream: ${n} % ${t} !== 0`);
  const a = new Array(o);
  for (let i = 0; i < o; i++) {
    const s = i * t;
    a[i] = e.subarray(s, s + t);
  }
  return a;
}
function c3(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return rF(e, t, r);
  if (Array.isArray(e)) {
    const n = e.map((o) => c3(o, t, r));
    return sA(n);
  } else {
    if (typeof e == "string")
      return YH(e, t, r);
    if (typeof e == "bigint")
      return FH(e, t, r);
    if (typeof e == "number")
      return VH(e, t, r);
    if (typeof e == "boolean")
      return Uint8Array.of(e ? 1 : 0);
  }
  throw new TypeError("Unsupported format:" + typeof e);
}
var Ye;
let Dt = (Ye = class extends Uint8Array {
  static random(e = 32) {
    const t = eF(e);
    return new Ye(t, e);
  }
  static now(e = 4) {
    const t = Math.floor(Date.now() / 1e3);
    return new Ye(t, e);
  }
  constructor(e, t, r) {
    if (e instanceof Ye && t === void 0)
      return e;
    const n = c3(e, t, r);
    super(n);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.to_num();
  }
  get big() {
    return this.to_big();
  }
  get str() {
    return this.to_str();
  }
  get hex() {
    return this.to_hex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.to_bin();
  }
  get b58chk() {
    return this.to_b58chk();
  }
  get base64() {
    return this.to_base64();
  }
  get b64url() {
    return this.to_b64url();
  }
  get digest() {
    return this.to_hash();
  }
  get id() {
    return this.to_hash().hex;
  }
  get stream() {
    return new wF(this);
  }
  to_num(e = "be") {
    const t = e === "be" ? this.reverse() : this;
    return GH(t);
  }
  to_big(e = "be") {
    const t = e === "be" ? this.reverse() : this;
    return DH(t);
  }
  to_bin() {
    return KH(this);
  }
  to_hash() {
    const e = Lw(this);
    return new Ye(e);
  }
  to_json(e) {
    e === void 0 && (e = oF);
    const t = a2(this);
    return JSON.parse(t, e);
  }
  to_bech32(e, t) {
    const { encode: r, to_words: n } = na.bech32, o = n(this);
    return r(e, o, t);
  }
  to_bech32m(e, t) {
    const { encode: r, to_words: n } = na.bech32m, o = n(this);
    return r(e, o, t);
  }
  to_str() {
    return a2(this);
  }
  to_hex() {
    return JH(this);
  }
  to_bytes() {
    return new Uint8Array(this);
  }
  to_b58chk() {
    return na.b58chk.encode(this);
  }
  to_base64() {
    return na.base64.encode(this);
  }
  to_b64url() {
    return na.b64url.encode(this);
  }
  append(e) {
    return Ye.join([this, Ye.bytes(e)]);
  }
  prepend(e) {
    return Ye.join([Ye.bytes(e), this]);
  }
  reverse() {
    const e = new Uint8Array(this).reverse();
    return new Ye(e);
  }
  slice(e, t) {
    const r = new Uint8Array(this).slice(e, t);
    return new Ye(r);
  }
  set(e, t) {
    this.set(e, t);
  }
  subarray(e, t) {
    const r = new Uint8Array(this).subarray(e, t);
    return new Ye(r);
  }
  write(e, t) {
    const r = Ye.bytes(e);
    this.set(r, t);
  }
  add_varint(e) {
    const t = Ye.calc_varint(this.length, e);
    return Ye.join([t, this]);
  }
  static from(e) {
    return new Ye(Uint8Array.from(e));
  }
  static of(...e) {
    return new Ye(Uint8Array.of(...e));
  }
  static join(e) {
    const t = e.map((n) => Ye.bytes(n)), r = sA(t);
    return new Ye(r);
  }
  static sort(e, t) {
    const r = e.map((n) => fE(n, t).hex);
    return r.sort(), r.map((n) => Ye.hex(n, t));
  }
  static calc_varint(e, t) {
    if (e < 253)
      return Ye.num(e, 1);
    if (e < 65536)
      return Ye.of(253, ...Ye.num(e, 2, t));
    if (e < 4294967296)
      return Ye.of(254, ...Ye.num(e, 4, t));
    if (BigInt(e) < 0x10000000000000000n)
      return Ye.of(255, ...Ye.num(e, 8, t));
    throw new Error(`Value is too large: ${e}`);
  }
}, Ye.num = aF, Ye.big = uF, Ye.bin = sF, Ye.raw = cF, Ye.str = lF, Ye.hex = fF, Ye.bytes = fE, Ye.json = dF, Ye.base64 = hF, Ye.b64url = pF, Ye.bech32 = gF, Ye.bech32m = mF, Ye.b58chk = yF, Ye.encode = u3, Ye.decode = a2, Ye.parse = bF, Ye.is_bytes = tF, Ye.is_hex = aA, Ye);
function aF(e, t, r) {
  return new Dt(e, t, r);
}
function sF(e, t, r) {
  return new Dt(MH(e), t, r);
}
function uF(e, t, r) {
  return new Dt(e, t, r);
}
function cF(e, t, r) {
  return new Dt(e, t, r);
}
function lF(e, t, r) {
  return new Dt(u3(e), t, r);
}
function fF(e, t, r) {
  return new Dt(e, t, r);
}
function dF(e, t) {
  t === void 0 && (t = nF);
  const r = JSON.stringify(e, t);
  return new Dt(u3(r));
}
function hF(e) {
  return new Dt(na.base64.decode(e));
}
function pF(e) {
  return new Dt(na.b64url.decode(e));
}
function gF(e, t, r) {
  const { decode: n, to_bytes: o } = na.bech32, { prefix: a, words: i } = n(e, t), s = o(i);
  return typeof r == "string" && oA(a, r), new Dt(s);
}
function mF(e, t, r) {
  const { decode: n, to_bytes: o } = na.bech32m, { prefix: a, words: i } = n(e, t), s = o(i);
  return typeof r == "string" && oA(a, r), new Dt(s);
}
function yF(e) {
  return new Dt(na.b58chk.decode(e));
}
function bF(e, t, r) {
  const n = c3(e);
  return iF(n, t, r).map((o) => Dt.bytes(o));
}
let wF = class {
  constructor(t) {
    this.data = Dt.bytes(t), this.size = this.data.length;
  }
  peek(t) {
    if (t > this.size)
      throw new Error(`Size greater than stream: ${t} > ${this.size}`);
    return new Dt(this.data.slice(0, t));
  }
  read(t) {
    const r = this.peek(t);
    return this.data = this.data.slice(t), this.size = this.data.length, r;
  }
  read_varint(t) {
    const r = this.read(1).num;
    switch (!0) {
      case (r >= 0 && r < 253):
        return r;
      case r === 253:
        return this.read(2).to_num(t);
      case r === 254:
        return this.read(4).to_num(t);
      case r === 255:
        return this.read(8).to_num(t);
      default:
        throw new Error(`Varint is out of range: ${r}`);
    }
  }
};
function fE(e, t, r) {
  return new Dt(e, t, r);
}
const J1 = Dc.CURVE, Hm = J1.n, vF = J1.p, dE = { x: J1.Gx, y: J1.Gy }, EF = BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(4);
const kF = (e) => Pn(e, Hm);
function uA(e, t = !1) {
  if (!t)
    return !1;
  throw new Error(e);
}
function xF(e, t, r) {
  const n = Dt.bytes(e);
  return n.length !== t ? uA(`Invalid byte size: ${n.hex} !== ${t}`, r) : !0;
}
function AF(e, t) {
  return typeof e == "bigint" && EF < e && e < Hm || uA("x value is not in the field!", t), !0;
}
const SF = a3(Hm, 32, !0), hE = Dc.ProjectivePoint, Nd = SF;
var ir;
let Ef = (ir = class extends Uint8Array {
  static add(e) {
    return e.map((t) => ir.mod(t)).reduce((t, r) => t.add(r));
  }
  static mod(e) {
    return new ir(e);
  }
  static mul(e) {
    return e.map((t) => ir.mod(t)).reduce((t, r) => t.mul(r));
  }
  static is_valid(e, t) {
    const r = Dt.bytes(e, 32).big;
    return AF(r, t);
  }
  constructor(e) {
    const t = kF(_F(e));
    ir.is_valid(t, !0), super(Dt.big(t, 32), 32);
  }
  get buff() {
    return new Dt(this);
  }
  get raw() {
    return this.buff.raw;
  }
  get big() {
    return this.buff.big;
  }
  get hex() {
    return this.buff.hex;
  }
  get point() {
    return this.generate();
  }
  get hasOddY() {
    return this.point.hasOddY;
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  gt(e) {
    return new ir(e).big > this.big;
  }
  lt(e) {
    return new ir(e).big < this.big;
  }
  eq(e) {
    return new ir(e).big === this.big;
  }
  ne(e) {
    return new ir(e).big !== this.big;
  }
  add(e) {
    const t = ir.mod(e), r = Nd.add(this.big, t.big);
    return new ir(r);
  }
  sub(e) {
    const t = ir.mod(e), r = Nd.sub(this.big, t.big);
    return new ir(r);
  }
  mul(e) {
    const t = ir.mod(e), r = Nd.mul(this.big, t.big);
    return new ir(r);
  }
  pow(e) {
    const t = ir.mod(e), r = Nd.pow(this.big, t.big);
    return new ir(r);
  }
  div(e) {
    const t = ir.mod(e), r = Nd.div(this.big, t.big);
    return new ir(r);
  }
  negate() {
    return new ir(ir.N - this.big);
  }
  generate() {
    const e = Dc.ProjectivePoint.BASE.multiply(this.big);
    return l3.import(e);
  }
}, ir.N = Hm, ir);
var Ht;
let l3 = (Ht = class {
  static from_x(e, t = !1) {
    let r = IF(e);
    r.length === 32 ? r = r.prepend(2) : t && (r[0] = 2), xF(r, 33);
    const n = hE.fromHex(r.hex);
    return n.assertValidity(), new Ht(n.x, n.y);
  }
  static generate(e) {
    const t = Ef.mod(e), r = Ht.base.multiply(t.big);
    return Ht.import(r);
  }
  static import(e) {
    const t = e instanceof Ht ? { x: e.x.big, y: e.y.big } : { x: e.x, y: e.y };
    return new Ht(t.x, t.y);
  }
  constructor(e, t) {
    this._p = new hE(e, t, 1n), this.p.assertValidity();
  }
  get p() {
    return this._p;
  }
  get x() {
    return Dt.big(this.p.x, 32);
  }
  get y() {
    return Dt.big(this.p.y, 32);
  }
  get buff() {
    return Dt.raw(this.p.toRawBytes(!0));
  }
  get raw() {
    return this.buff.raw;
  }
  get hex() {
    return this.buff.hex;
  }
  get hasEvenY() {
    return this.p.hasEvenY();
  }
  get hasOddY() {
    return !this.p.hasEvenY();
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  eq(e) {
    const t = e instanceof Ht ? e : Ht.from_x(e);
    return this.x.big === t.x.big && this.y.big === t.y.big;
  }
  add(e) {
    return e instanceof Ht ? Ht.import(this.p.add(e.p)) : Ht.import(this.p.add(Ht.generate(e).p));
  }
  sub(e) {
    return e instanceof Ht ? Ht.import(this.p.subtract(e.p)) : Ht.import(this.p.subtract(Ht.generate(e).p));
  }
  mul(e) {
    return e instanceof Ht ? Ht.import(this.p.multiply(e.x.big)) : Ht.import(this.p.multiply(Ef.mod(e).big));
  }
  negate() {
    return Ht.import(this.p.negate());
  }
}, Ht.P = vF, Ht.G = new Ht(dE.x, dE.y), Ht.curve = Dc.CURVE, Ht.base = Dc.ProjectivePoint.BASE, Ht.mul = Ht.generate, Ht);
function _F(e) {
  if (e instanceof Ef)
    return e.big;
  if (e instanceof l3)
    return e.x.big;
  if (e instanceof Uint8Array)
    return Dt.raw(e).big;
  if (typeof e == "string")
    return Dt.hex(e).big;
  if (typeof e == "number")
    return Dt.num(e).big;
  if (typeof e == "bigint")
    return BigInt(e);
  throw TypeError("Invalid input type:" + typeof e);
}
function IF(e) {
  if (e instanceof Ef)
    return e.point.buff;
  if (e instanceof l3)
    return e.buff;
  if (e instanceof Uint8Array || typeof e == "string")
    return Dt.bytes(e);
  if (typeof e == "number" || typeof e == "bigint")
    return Dt.bytes(e, 32);
  throw new TypeError(`Unknown type: ${typeof e}`);
}
const _0 = /* @__PURE__ */ BigInt(2 ** 32 - 1), Dw = /* @__PURE__ */ BigInt(32);
function cA(e, t = !1) {
  return t ? { h: Number(e & _0), l: Number(e >> Dw & _0) } : { h: Number(e >> Dw & _0) | 0, l: Number(e & _0) | 0 };
}
function TF(e, t = !1) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: a, l: i } = cA(e[o], t);
    [r[o], n[o]] = [a, i];
  }
  return [r, n];
}
const PF = (e, t) => BigInt(e >>> 0) << Dw | BigInt(t >>> 0), OF = (e, t, r) => e >>> r, $F = (e, t, r) => e << 32 - r | t >>> r, CF = (e, t, r) => e >>> r | t << 32 - r, BF = (e, t, r) => e << 32 - r | t >>> r, NF = (e, t, r) => e << 64 - r | t >>> r - 32, UF = (e, t, r) => e >>> r - 32 | t << 64 - r, RF = (e, t) => t, zF = (e, t) => e, jF = (e, t, r) => e << r | t >>> 32 - r, LF = (e, t, r) => t << r | e >>> 32 - r, HF = (e, t, r) => t << r - 32 | e >>> 64 - r, FF = (e, t, r) => e << r - 32 | t >>> 64 - r;
function DF(e, t, r, n) {
  const o = (t >>> 0) + (n >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
const MF = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0), KF = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0, qF = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), VF = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0, GF = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0), ZF = (e, t, r, n, o, a) => t + r + n + o + a + (e / 2 ** 32 | 0) | 0, gt = {
  fromBig: cA,
  split: TF,
  toBig: PF,
  shrSH: OF,
  shrSL: $F,
  rotrSH: CF,
  rotrSL: BF,
  rotrBH: NF,
  rotrBL: UF,
  rotr32H: RF,
  rotr32L: zF,
  rotlSH: jF,
  rotlSL: LF,
  rotlBH: HF,
  rotlBL: FF,
  add: DF,
  add3L: MF,
  add3H: KF,
  add4L: qF,
  add4H: VF,
  add5H: ZF,
  add5L: GF
}, [WF, XF] = gt.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))), Is = /* @__PURE__ */ new Uint32Array(80), Ts = /* @__PURE__ */ new Uint32Array(80);
let YF = class extends D8 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: o, Ch: a, Cl: i, Dh: s, Dl: u, Eh: l, El: c, Fh: f, Fl: h, Gh: p, Gl: y, Hh: m, Hl: b } = this;
    return [t, r, n, o, a, i, s, u, l, c, f, h, p, y, m, b];
  }
  // prettier-ignore
  set(t, r, n, o, a, i, s, u, l, c, f, h, p, y, m, b) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = o | 0, this.Ch = a | 0, this.Cl = i | 0, this.Dh = s | 0, this.Dl = u | 0, this.Eh = l | 0, this.El = c | 0, this.Fh = f | 0, this.Fl = h | 0, this.Gh = p | 0, this.Gl = y | 0, this.Hh = m | 0, this.Hl = b | 0;
  }
  process(t, r) {
    for (let E = 0; E < 16; E++, r += 4)
      Is[E] = t.getUint32(r), Ts[E] = t.getUint32(r += 4);
    for (let E = 16; E < 80; E++) {
      const A = Is[E - 15] | 0, S = Ts[E - 15] | 0, _ = gt.rotrSH(A, S, 1) ^ gt.rotrSH(A, S, 8) ^ gt.shrSH(A, S, 7), I = gt.rotrSL(A, S, 1) ^ gt.rotrSL(A, S, 8) ^ gt.shrSL(A, S, 7), O = Is[E - 2] | 0, z = Ts[E - 2] | 0, D = gt.rotrSH(O, z, 19) ^ gt.rotrBH(O, z, 61) ^ gt.shrSH(O, z, 6), G = gt.rotrSL(O, z, 19) ^ gt.rotrBL(O, z, 61) ^ gt.shrSL(O, z, 6), U = gt.add4L(I, G, Ts[E - 7], Ts[E - 16]), V = gt.add4H(U, _, D, Is[E - 7], Is[E - 16]);
      Is[E] = V | 0, Ts[E] = U | 0;
    }
    let { Ah: n, Al: o, Bh: a, Bl: i, Ch: s, Cl: u, Dh: l, Dl: c, Eh: f, El: h, Fh: p, Fl: y, Gh: m, Gl: b, Hh: v, Hl: k } = this;
    for (let E = 0; E < 80; E++) {
      const A = gt.rotrSH(f, h, 14) ^ gt.rotrSH(f, h, 18) ^ gt.rotrBH(f, h, 41), S = gt.rotrSL(f, h, 14) ^ gt.rotrSL(f, h, 18) ^ gt.rotrBL(f, h, 41), _ = f & p ^ ~f & m, I = h & y ^ ~h & b, O = gt.add5L(k, S, I, XF[E], Ts[E]), z = gt.add5H(O, v, A, _, WF[E], Is[E]), D = O | 0, G = gt.rotrSH(n, o, 28) ^ gt.rotrBH(n, o, 34) ^ gt.rotrBH(n, o, 39), U = gt.rotrSL(n, o, 28) ^ gt.rotrBL(n, o, 34) ^ gt.rotrBL(n, o, 39), V = n & a ^ n & s ^ a & s, F = o & i ^ o & u ^ i & u;
      v = m | 0, k = b | 0, m = p | 0, b = y | 0, p = f | 0, y = h | 0, { h: f, l: h } = gt.add(l | 0, c | 0, z | 0, D | 0), l = s | 0, c = u | 0, s = a | 0, u = i | 0, a = n | 0, i = o | 0;
      const C = gt.add3L(D, U, F);
      n = gt.add3H(C, z, G, V), o = C | 0;
    }
    ({ h: n, l: o } = gt.add(this.Ah | 0, this.Al | 0, n | 0, o | 0)), { h: a, l: i } = gt.add(this.Bh | 0, this.Bl | 0, a | 0, i | 0), { h: s, l: u } = gt.add(this.Ch | 0, this.Cl | 0, s | 0, u | 0), { h: l, l: c } = gt.add(this.Dh | 0, this.Dl | 0, l | 0, c | 0), { h: f, l: h } = gt.add(this.Eh | 0, this.El | 0, f | 0, h | 0), { h: p, l: y } = gt.add(this.Fh | 0, this.Fl | 0, p | 0, y | 0), { h: m, l: b } = gt.add(this.Gh | 0, this.Gl | 0, m | 0, b | 0), { h: v, l: k } = gt.add(this.Hh | 0, this.Hl | 0, v | 0, k | 0), this.set(n, o, a, i, s, u, l, c, f, h, p, y, m, b, v, k);
  }
  roundClean() {
    Is.fill(0), Ts.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const JF = /* @__PURE__ */ F8(() => new YF());
function QF(e, t = !1) {
  const r = Ef.mod(e);
  return t ? r.negated.buff : r.buff;
}
function lA(e, t = !1) {
  const r = Ef.mod(e).point;
  return t ? r.x : r.buff;
}
Dc.ProjectivePoint;
function Mw(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function eD(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function fA(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function tD(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Mw(e.outputLen), Mw(e.blockLen);
}
function rD(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function nD(e, t) {
  fA(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const oD = {
  number: Mw,
  bool: eD,
  bytes: fA,
  hash: tD,
  exists: rD,
  output: nD
};
var s2 = oD;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u2 = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Fi = (e, t) => e << 32 - t | e >>> t, iD = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!iD)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function aD(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function dA(e) {
  if (typeof e == "string" && (e = aD(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let sD = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function hA(e) {
  const t = (n) => e().update(dA(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function uD(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
let cD = class extends sD {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = u2(this.buffer);
  }
  update(t) {
    s2.exists(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = dA(t);
    const a = t.length;
    for (let i = 0; i < a; ) {
      const s = Math.min(o - this.pos, a - i);
      if (s === o) {
        const u = u2(t);
        for (; o <= a - i; i += o)
          this.process(u, i);
        continue;
      }
      n.set(t.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    s2.exists(this), s2.output(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: o, isLE: a } = this;
    let { pos: i } = this;
    r[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > o - i && (this.process(n, 0), i = 0);
    for (let f = i; f < o; f++)
      r[f] = 0;
    uD(n, o - 8, BigInt(this.length * 8), a), this.process(n, 0);
    const s = u2(t), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, c = this.get();
    if (l > c.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < l; f++)
      s.setUint32(4 * f, c[f], a);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: a, destroyed: i, pos: s } = this;
    return t.length = o, t.pos = s, t.finished = a, t.destroyed = i, o % r && t.buffer.set(n), t;
  }
};
const lD = (e, t, r) => e & t ^ ~e & r, fD = (e, t, r) => e & t ^ e & r ^ t & r, dD = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Ps = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Os = new Uint32Array(64);
let pA = class extends cD {
  constructor() {
    super(64, 32, 8, !1), this.A = Ps[0] | 0, this.B = Ps[1] | 0, this.C = Ps[2] | 0, this.D = Ps[3] | 0, this.E = Ps[4] | 0, this.F = Ps[5] | 0, this.G = Ps[6] | 0, this.H = Ps[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: a, F: i, G: s, H: u } = this;
    return [t, r, n, o, a, i, s, u];
  }
  // prettier-ignore
  set(t, r, n, o, a, i, s, u) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = a | 0, this.F = i | 0, this.G = s | 0, this.H = u | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      Os[f] = t.getUint32(r, !1);
    for (let f = 16; f < 64; f++) {
      const h = Os[f - 15], p = Os[f - 2], y = Fi(h, 7) ^ Fi(h, 18) ^ h >>> 3, m = Fi(p, 17) ^ Fi(p, 19) ^ p >>> 10;
      Os[f] = m + Os[f - 7] + y + Os[f - 16] | 0;
    }
    let { A: n, B: o, C: a, D: i, E: s, F: u, G: l, H: c } = this;
    for (let f = 0; f < 64; f++) {
      const h = Fi(s, 6) ^ Fi(s, 11) ^ Fi(s, 25), p = c + h + lD(s, u, l) + dD[f] + Os[f] | 0, y = (Fi(n, 2) ^ Fi(n, 13) ^ Fi(n, 22)) + fD(n, o, a) | 0;
      c = l, l = u, u = s, s = i + p | 0, i = a, a = o, o = n, n = p + y | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, c = c + this.H | 0, this.set(n, o, a, i, s, u, l, c);
  }
  roundClean() {
    Os.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, hD = class extends pA {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const Kw = hA(() => new pA());
hA(() => new hD());
function pD(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function gD(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function mD(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
const { getRandomValues: yD } = crypto ?? globalThis.crypto ?? window.crypto;
function bD(e = 32) {
  if (typeof yD == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function wD(e, t, r = "be") {
  t === void 0 && (t = e.length), pD(e, t);
  const n = new Uint8Array(t).fill(0), o = r === "be" ? 0 : t - e.length;
  return n.set(e, o), n;
}
function gA(e) {
  let t, r = 0;
  const n = e.reduce((a, i) => a + i.length, 0), o = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const a = e[t];
    o.set(a, r), r += a.length;
  }
  return o;
}
const vD = new TextEncoder(), ED = [
  {
    name: "base58",
    charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }
];
function mA(e) {
  for (const t of ED)
    if (t.name === e)
      return t.charset;
  throw TypeError("Charset does not exist: " + e);
}
function kD(e, t, r = !1) {
  typeof e == "string" && (e = vD.encode(e));
  const n = mA(t), o = n.length, a = [];
  let i = "", s, u = 0, l, c;
  for (s = 0; s < e.length; s++)
    for (u = 0, l = e[s], i += l > 0 || (i.length ^ s) > 0 ? "" : "1"; u in a || l > 0; )
      c = a[u], c = c > 0 ? c * 256 + l : l, l = c / o | 0, a[u] = c % o, u++;
  for (; u-- > 0; )
    i += n[a[u]];
  return r && i.length % 4 > 0 ? i + "=".repeat(4 - i.length % 4) : i;
}
function xD(e, t) {
  const r = mA(t), n = r.length, o = [], a = [];
  e = e.replace("=", "");
  let i, s = 0, u, l;
  for (i = 0; i < e.length; i++) {
    if (s = 0, u = r.indexOf(e[i]), u < 0)
      throw new Error(`Character range out of bounds: ${u}`);
    for (u > 0 || (a.length ^ i) > 0 || a.push(0); s in o || u > 0; )
      l = o[s], l = l > 0 ? l * n + u : u, u = l >> 8, o[s] = l % 256, s++;
  }
  for (; s-- > 0; )
    a.push(o[s]);
  return new Uint8Array(a);
}
function yA(e) {
  return Kw(Kw(e));
}
function AD(e) {
  const t = yA(e);
  return gA([e, t.slice(0, 4)]);
}
function SD(e) {
  const t = e.slice(0, -4), r = e.slice(-4);
  if (yA(t).slice(0, 4).toString() !== r.toString())
    throw new Error("Invalid checksum!");
  return t;
}
const pE = {
  encode: kD,
  decode: xD
}, bA = {
  encode: (e) => {
    const t = AD(e);
    return pE.encode(t, "base58");
  },
  decode: (e) => {
    const t = pE.decode(e, "base58");
    return SD(t);
  }
}, wA = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", _D = [996825010, 642813549, 513874426, 1027748829, 705979059], Q1 = [
  { version: 0, name: "bech32", const: 1 },
  { version: 1, name: "bech32m", const: 734539939 }
];
function vA(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = t >> 25;
    t = (t & 33554431) << 5 ^ e[r];
    for (let o = 0; o < 5; ++o)
      n >> o & 1 && (t ^= _D[o]);
  }
  return t;
}
function EA(e) {
  const t = [];
  let r;
  for (r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) >> 5);
  for (t.push(0), r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) & 31);
  return t;
}
function ID(e, t, r) {
  const n = EA(e).concat(t);
  return vA(n) === r.const;
}
function TD(e, t, r) {
  const n = EA(e).concat(t).concat([0, 0, 0, 0, 0, 0]), o = vA(n) ^ r.const, a = [];
  for (let i = 0; i < 6; ++i)
    a.push(o >> 5 * (5 - i) & 31);
  return a;
}
function kA(e, t, r, n = !0) {
  const o = [];
  let a = 0, i = 0;
  const s = (1 << r) - 1, u = (1 << t + r - 1) - 1;
  for (const l of e) {
    if (l < 0 || l >> t > 0)
      throw new Error("Failed to perform base conversion. Invalid value: " + String(l));
    for (a = (a << t | l) & u, i += t; i >= r; )
      i -= r, o.push(a >> i & s);
  }
  if (n)
    i > 0 && o.push(a << r - i & s);
  else if (i >= t || (a << r - i & s) > 0)
    throw new Error("Failed to perform base conversion. Invalid Size!");
  return o;
}
function PD(e, t, r) {
  const n = t.concat(TD(e, t, r));
  let o = e + "1";
  for (let a = 0; a < n.length; ++a)
    o += wA.charAt(n[a]);
  return o;
}
function xA(e) {
  if (!OD(e))
    throw new Error("Encoded string goes out of bounds!");
  if (e = e.toLowerCase(), !$D(e))
    throw new Error("Encoded string has invalid separator!");
  const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
  for (let a = r + 1; a < e.length; ++a) {
    const i = wA.indexOf(e.charAt(a));
    if (i === -1)
      throw new Error("Character idx out of bounds: " + String(a));
    t.push(i);
  }
  const o = Q1.find((a) => a.version === t[0]) ?? Q1[0];
  if (!ID(n, t, o))
    throw new Error("Checksum verification failed!");
  return [n, t.slice(0, t.length - 6)];
}
function OD(e) {
  let t, r, n = !1, o = !1;
  for (t = 0; t < e.length; ++t) {
    if (r = e.charCodeAt(t), r < 33 || r > 126)
      return !1;
    r >= 97 && r <= 122 && (n = !0), r >= 65 && r <= 90 && (o = !0);
  }
  return !(n && o);
}
function $D(e) {
  const t = e.lastIndexOf("1");
  return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function CD(e, t = "bc", r = 0) {
  const n = [r, ...kA([...e], 8, 5)], o = Q1.find((i) => i.version === r) ?? Q1[0], a = PD(t, n, o);
  return AA(a), a;
}
function AA(e) {
  e = e.toLowerCase();
  const t = e.split("1", 1)[0], [r, n] = xA(e), o = kA(n.slice(1), 5, 8, !1), a = o.length;
  switch (!0) {
    case t !== r:
      throw new Error("Returned hrp string is invalid.");
    case (o === null || a < 2 || a > 40):
      throw new Error("Decoded string is invalid or out of spec.");
    case n[0] > 16:
      throw new Error("Returned version bit is out of range.");
    default:
      return Uint8Array.from(o);
  }
}
function BD(e) {
  e = e.toLowerCase();
  const [t, r] = xA(e);
  return r[0];
}
const SA = {
  encode: CD,
  decode: AA,
  version: BD
}, _A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", IA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", ND = new TextEncoder();
function TA(e, t = !1, r = !0) {
  typeof e == "string" && (e = ND.encode(e));
  const n = t ? IA : _A;
  let o = "", a = 0, i = 0;
  for (let s = 0; s < e.length; s++)
    for (i = i << 8 | e[s], a += 8; a >= 6; )
      a -= 6, o += n[i >> a & 63];
  if (a > 0)
    for (i <<= 6 - a, o += n[i & 63]; a < 6; )
      o += r ? "=" : "", a += 2;
  return o;
}
function PA(e, t = !1) {
  const r = t || e.includes("-") || e.includes("_") ? IA.split("") : _A.split("");
  e = e.replace(/=+$/, "");
  const n = e.split("");
  let o = 0, a = 0;
  const i = [];
  for (let s = 0; s < n.length; s++) {
    const u = n[s], l = r.indexOf(u);
    if (l === -1)
      throw new Error("Invalid character: " + u);
    o += 6, a <<= 6, a |= l, o >= 8 && (o -= 8, i.push(a >>> o & 255));
  }
  return new Uint8Array(i);
}
const OA = {
  encode: TA,
  decode: PA
}, $A = {
  encode: (e) => TA(e, !0, !1),
  decode: (e) => PA(e, !0)
}, UD = BigInt(0), RD = BigInt(255), CA = BigInt(256);
function zD(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function jD(e, t, r = "be") {
  t === void 0 && (t = zD(e));
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (; e > UD; ) {
    const s = e & RD, u = Number(s);
    n ? a.setUint8(i++, u) : a.setUint8(i--, u), e = (e - s) / CA;
  }
  return new Uint8Array(o);
}
function LD(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * CA + BigInt(e[r]);
  return BigInt(t);
}
function HD(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, o = 0; n < t.length; n += 8, o++) {
    let a = 0;
    for (let i = 0; i < 8; i++)
      a |= t[n + i] << 7 - i;
    r[o] = a;
  }
  return r;
}
function FD(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let o = 7; o >= 0; o--, r++)
      t[r] = n >> o & 1;
  }
  return t.join("");
}
function DD(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function MD(e, t, r = "be") {
  t === void 0 && (t = DD(e));
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (; e > 0; ) {
    const s = e & 255;
    n ? a.setUint8(i++, e) : a.setUint8(i--, e), e = (e - s) / 256;
  }
  return new Uint8Array(o);
}
function KD(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], mD(t);
  return t;
}
const qD = new TextEncoder(), VD = new TextDecoder();
function f3(e) {
  return qD.encode(e);
}
function c2(e) {
  return VD.decode(e);
}
function GD(e, t) {
  gD(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function ZD(e, t, r = "le") {
  t = GD(e, t);
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (let s = 0; s < e.length; s += 2) {
    const u = e.substring(s, s + 2), l = parseInt(u, 16);
    n ? a.setUint8(i++, l) : a.setUint8(i--, l);
  }
  return new Uint8Array(o);
}
function WD(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function XD(e) {
  const t = JSON.stringify(e, (r, n) => typeof n == "bigint" ? `${n}n` : n);
  return f3(t);
}
function YD(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return wD(e, t, r);
  if (typeof e == "string")
    return ZD(e, t, r);
  if (typeof e == "bigint")
    return jD(e, t, r);
  if (typeof e == "number")
    return MD(e, t, r);
  if (typeof e == "boolean")
    return Uint8Array.of(e ? 1 : 0);
  throw TypeError("Unsupported format:" + typeof e);
}
var At;
let Y = (At = class extends Uint8Array {
  static random(e = 32) {
    const t = bD(e);
    return new At(t, e);
  }
  constructor(e, t, r) {
    const n = YD(e, t, r);
    super(n);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.toNum();
  }
  get big() {
    return this.toBig();
  }
  get str() {
    return this.toStr();
  }
  get hex() {
    return this.toHex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.toBin();
  }
  get b58chk() {
    return this.tob58chk();
  }
  get base64() {
    return this.toBase64();
  }
  get b64url() {
    return this.toB64url();
  }
  get digest() {
    return this.toHash();
  }
  get id() {
    return this.toHash().hex;
  }
  get stream() {
    return new Yf(this);
  }
  toNum(e = "be") {
    const t = e === "be" ? this.reverse() : this;
    return KD(t);
  }
  toBin() {
    return FD(this);
  }
  toBig(e = "be") {
    const t = e === "be" ? this.reverse() : this;
    return LD(t);
  }
  toHash() {
    const e = Kw(this);
    return new At(e);
  }
  toJson() {
    const e = c2(this);
    return JSON.parse(e);
  }
  toBech32(e, t = 0) {
    return SA.encode(this, e, t);
  }
  toStr() {
    return c2(this);
  }
  toHex() {
    return WD(this);
  }
  toBytes() {
    return new Uint8Array(this);
  }
  tob58chk() {
    return bA.encode(this);
  }
  toBase64() {
    return OA.encode(this);
  }
  toB64url() {
    return $A.encode(this);
  }
  prepend(e) {
    return At.join([At.bytes(e), this]);
  }
  append(e) {
    return At.join([this, At.bytes(e)]);
  }
  slice(e, t) {
    const r = new Uint8Array(this).slice(e, t);
    return new At(r);
  }
  subarray(e, t) {
    const r = new Uint8Array(this).subarray(e, t);
    return new At(r);
  }
  reverse() {
    const e = new Uint8Array(this).reverse();
    return new At(e);
  }
  write(e, t) {
    const r = At.bytes(e);
    this.set(r, t);
  }
  prefixSize(e) {
    const t = At.varInt(this.length, e);
    return At.join([t, this]);
  }
  static from(e) {
    return new At(Uint8Array.from(e));
  }
  static of(...e) {
    return new At(Uint8Array.of(...e));
  }
  static join(e) {
    const t = e.map((n) => At.bytes(n)), r = gA(t);
    return new At(r);
  }
  static varInt(e, t) {
    if (e < 253)
      return At.num(e, 1);
    if (e < 65536)
      return At.of(253, ...At.num(e, 2, t));
    if (e < 4294967296)
      return At.of(254, ...At.num(e, 4, t));
    if (BigInt(e) < 0x10000000000000000n)
      return At.of(255, ...At.num(e, 8, t));
    throw new Error(`Value is too large: ${e}`);
  }
}, At.num = JD, At.big = eM, At.bin = QD, At.raw = tM, At.str = rM, At.hex = nM, At.bytes = oM, At.json = iM, At.base64 = aM, At.b64url = sM, At.bech32 = uM, At.b58chk = cM, At.encode = f3, At.decode = c2, At);
function JD(e, t, r) {
  return new Y(e, t, r);
}
function QD(e, t, r) {
  return new Y(HD(e), t, r);
}
function eM(e, t, r) {
  return new Y(e, t, r);
}
function tM(e, t, r) {
  return new Y(e, t, r);
}
function rM(e, t, r) {
  return new Y(f3(e), t, r);
}
function nM(e, t, r) {
  return new Y(e, t, r);
}
function oM(e, t, r) {
  return new Y(e, t, r);
}
function iM(e) {
  return new Y(XD(e));
}
function aM(e) {
  return new Y(OA.decode(e));
}
function sM(e) {
  return new Y($A.decode(e));
}
function uM(e) {
  return new Y(SA.decode(e));
}
function cM(e) {
  return new Y(bA.decode(e));
}
let Yf = class {
  constructor(t) {
    this.data = Y.bytes(t), this.size = this.data.length;
  }
  peek(t) {
    if (t > this.size)
      throw new Error(`Size greater than stream: ${t} > ${this.size}`);
    return new Y(this.data.slice(0, t));
  }
  read(t) {
    t = t ?? this.readSize();
    const r = this.peek(t);
    return this.data = this.data.slice(t), this.size = this.data.length, r;
  }
  readSize(t) {
    const r = this.read(1).num;
    switch (!0) {
      case (r >= 0 && r < 253):
        return r;
      case r === 253:
        return this.read(2).toNum(t);
      case r === 254:
        return this.read(4).toNum(t);
      case r === 255:
        return this.read(8).toNum(t);
      default:
        throw new Error(`Varint is out of range: ${r}`);
    }
  }
};
function pa(e, t) {
  const r = Y.bytes(e);
  if (r.length !== t)
    throw new Error(`Invalid input size: ${r.hex} !== ${t}`);
}
function wn(e, t) {
  if (t)
    throw new Error(e);
  return !1;
}
function w1(e, ...t) {
  const r = Y.str(e).digest.raw, n = t.map((o) => Y.bytes(o));
  return Y.join([r, r, Y.join(n)]).digest;
}
const BA = {
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_SUCCESS80: 80,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_SUCCESS98: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_SUCCESS126: 126,
  OP_SUCCESS127: 127,
  OP_SUCCESS128: 128,
  OP_SUCCESS129: 129,
  OP_SIZE: 130,
  OP_SUCCESS131: 131,
  OP_SUCCESS132: 132,
  OP_SUCCESS133: 133,
  OP_SUCCESS134: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_SUCCESS137: 137,
  OP_SUCCESS138: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_SUCCESS141: 141,
  OP_SUCCESS142: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_SUCCESS149: 149,
  OP_SUCCESS150: 150,
  OP_SUCCESS151: 151,
  OP_SUCCESS152: 152,
  OP_SUCCESS153: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186
};
function lM(e) {
  if (e > 186 && e < 255)
    return "OP_SUCCESS" + String(e);
  for (const [t, r] of Object.entries(BA))
    if (r === e)
      return t;
  throw new Error("OPCODE not found:" + String(e));
}
function fM(e) {
  for (const [t, r] of Object.entries(BA))
    if (t === e)
      return Number(r);
  throw new Error("OPCODE not found:" + e);
}
function dM(e) {
  switch (!0) {
    case e === 0:
      return "opcode";
    case (e >= 1 && e <= 75):
      return "varint";
    case e === 76:
      return "pushdata1";
    case e === 77:
      return "pushdata2";
    case e === 78:
      return "pushdata4";
    case e <= 254:
      return "opcode";
    default:
      throw new Error(`Invalid word range: ${e}`);
  }
}
function hM(e) {
  const t = [];
  switch (!0) {
    case typeof e != "number":
      return !1;
    case e === 0:
      return !0;
    case t.includes(e):
      return !1;
    case (75 < e && e < 254):
      return !0;
    default:
      return !1;
  }
}
function ps(e) {
  return typeof e == "string" && e.length % 2 === 0 && /[0-9a-fA-F]/.test(e);
}
function NA(e) {
  return ps(e) || e instanceof Uint8Array;
}
const eg = 520;
function sl(e = [], t = !0) {
  let r = Y.num(0);
  return Array.isArray(e) && (r = Y.raw(UA(e))), ps(e) && (r = Y.hex(e)), e instanceof Uint8Array && (r = Y.raw(e)), t && (r = r.prefixSize("le")), r;
}
function UA(e) {
  const t = [];
  for (const r of e)
    t.push(pM(r));
  return t.length > 0 ? Y.join(t) : new Uint8Array();
}
function pM(e) {
  let t = new Uint8Array();
  if (typeof e == "string") {
    if (e.startsWith("OP_"))
      return Y.num(fM(e), 1);
    ps(e) ? t = Y.hex(e) : t = Y.str(e);
  } else if (t = Y.bytes(e), t.length === 1 && t[0] <= 16)
    return t[0] !== 0 && (t[0] += 80), t;
  if (t.length > eg) {
    const r = mM(t);
    return UA(r);
  }
  return Y.join([gM(t.length), t]);
}
function gM(e) {
  const t = Y.num(76, 1), r = Y.num(77, 1);
  switch (!0) {
    case e <= 75:
      return Y.num(e);
    case (e > 75 && e < 256):
      return Y.join([t, Y.num(e, 1, "le")]);
    case (e >= 256 && e <= eg):
      return Y.join([r, Y.num(e, 2, "le")]);
    default:
      throw new Error("Invalid word size:" + e.toString());
  }
}
function mM(e) {
  const t = [], r = new Yf(e);
  for (; r.size > eg; )
    t.push(r.read(eg));
  return t.push(r.read(r.size)), t;
}
function d3(e, t = !1) {
  let r = Y.bytes(e);
  if (t) {
    const n = r.stream.readSize("le");
    if (r = r.slice(1), r.length !== n)
      throw new Error(`Varint does not match stream size: ${n} !== ${r.length}`);
  }
  return yM(r);
}
function yM(e) {
  const t = new Yf(e), r = [], n = t.size;
  let o, a, i, s = 0;
  for (; s < n; )
    switch (o = t.read(1).num, a = dM(o), s++, a) {
      case "varint":
        r.push(t.read(o).hex), s += o;
        break;
      case "pushdata1":
        i = t.read(1).reverse().num, r.push(t.read(i).hex), s += i + 1;
        break;
      case "pushdata2":
        i = t.read(2).reverse().num, r.push(t.read(i).hex), s += i + 2;
        break;
      case "pushdata4":
        i = t.read(4).reverse().num, r.push(t.read(i).hex), s += i + 4;
        break;
      case "opcode":
        if (!hM(o))
          throw new Error(`Invalid OPCODE: ${o}`);
        r.push(lM(o));
        break;
      default:
        throw new Error(`Word type undefined: ${o}`);
    }
  return r;
}
function bM(e, t) {
  if (Array.isArray(e) && (e = sl(e, t)), e instanceof Uint8Array || ps(e))
    return d3(e, t);
  throw new Error("Invalid format: " + typeof e);
}
function wM(e, t) {
  if ((e instanceof Uint8Array || ps(e)) && (e = d3(e, t)), Array.isArray(e))
    return sl(e, t);
  throw new Error("Invalid format: " + typeof e);
}
function vM(e) {
  if (!Array.isArray(e))
    return Y.bytes(e);
  throw new Error("Invalid format: " + typeof e);
}
const EM = {
  toAsm: bM,
  toBytes: wM,
  toParam: vM
}, Hn = {
  encode: sl,
  decode: d3,
  fmt: EM
};
function qw(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function kM(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function RA(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function xM(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  qw(e.outputLen), qw(e.blockLen);
}
function AM(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function SM(e, t) {
  RA(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const _M = {
  number: qw,
  bool: kM,
  bytes: RA,
  hash: xM,
  exists: AM,
  output: SM
};
var bc = _M;
const l2 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const f2 = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Di = (e, t) => e << 32 - t | e >>> t, IM = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!IM)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function TM(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function h3(e) {
  if (typeof e == "string" && (e = TM(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
function PM(...e) {
  if (!e.every((n) => n instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (e.length === 1)
    return e[0];
  const t = e.reduce((n, o) => n + o.length, 0), r = new Uint8Array(t);
  for (let n = 0, o = 0; n < e.length; n++) {
    const a = e[n];
    r.set(a, o), o += a.length;
  }
  return r;
}
let zA = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function jA(e) {
  const t = (n) => e().update(h3(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function LA(e = 32) {
  if (l2 && typeof l2.getRandomValues == "function")
    return l2.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined");
}
function OM(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
let $M = class extends zA {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = f2(this.buffer);
  }
  update(t) {
    bc.exists(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = h3(t);
    const a = t.length;
    for (let i = 0; i < a; ) {
      const s = Math.min(o - this.pos, a - i);
      if (s === o) {
        const u = f2(t);
        for (; o <= a - i; i += o)
          this.process(u, i);
        continue;
      }
      n.set(t.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    bc.exists(this), bc.output(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: o, isLE: a } = this;
    let { pos: i } = this;
    r[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > o - i && (this.process(n, 0), i = 0);
    for (let f = i; f < o; f++)
      r[f] = 0;
    OM(n, o - 8, BigInt(this.length * 8), a), this.process(n, 0);
    const s = f2(t), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, c = this.get();
    if (l > c.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < l; f++)
      s.setUint32(4 * f, c[f], a);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: a, destroyed: i, pos: s } = this;
    return t.length = o, t.pos = s, t.finished = a, t.destroyed = i, o % r && t.buffer.set(n), t;
  }
};
const CM = (e, t, r) => e & t ^ ~e & r, BM = (e, t, r) => e & t ^ e & r ^ t & r, NM = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), $s = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Cs = new Uint32Array(64);
let HA = class extends $M {
  constructor() {
    super(64, 32, 8, !1), this.A = $s[0] | 0, this.B = $s[1] | 0, this.C = $s[2] | 0, this.D = $s[3] | 0, this.E = $s[4] | 0, this.F = $s[5] | 0, this.G = $s[6] | 0, this.H = $s[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: a, F: i, G: s, H: u } = this;
    return [t, r, n, o, a, i, s, u];
  }
  // prettier-ignore
  set(t, r, n, o, a, i, s, u) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = a | 0, this.F = i | 0, this.G = s | 0, this.H = u | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      Cs[f] = t.getUint32(r, !1);
    for (let f = 16; f < 64; f++) {
      const h = Cs[f - 15], p = Cs[f - 2], y = Di(h, 7) ^ Di(h, 18) ^ h >>> 3, m = Di(p, 17) ^ Di(p, 19) ^ p >>> 10;
      Cs[f] = m + Cs[f - 7] + y + Cs[f - 16] | 0;
    }
    let { A: n, B: o, C: a, D: i, E: s, F: u, G: l, H: c } = this;
    for (let f = 0; f < 64; f++) {
      const h = Di(s, 6) ^ Di(s, 11) ^ Di(s, 25), p = c + h + CM(s, u, l) + NM[f] + Cs[f] | 0, y = (Di(n, 2) ^ Di(n, 13) ^ Di(n, 22)) + BM(n, o, a) | 0;
      c = l, l = u, u = s, s = i + p | 0, i = a, a = o, o = n, n = p + y | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, c = c + this.H | 0, this.set(n, o, a, i, s, u, l, c);
  }
  roundClean() {
    Cs.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, UM = class extends HA {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const tg = jA(() => new HA());
jA(() => new UM());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const RM = BigInt(0), p3 = BigInt(1), zM = BigInt(2), Fm = (e) => e instanceof Uint8Array, jM = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function kf(e) {
  if (!Fm(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += jM[e[r]];
  return t;
}
function FA(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function g3(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
function xf(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (e.length % 2)
    throw new Error("hex string is invalid: unpadded " + e.length);
  const t = new Uint8Array(e.length / 2);
  for (let r = 0; r < t.length; r++) {
    const n = r * 2, o = e.slice(n, n + 2), a = Number.parseInt(o, 16);
    if (Number.isNaN(a) || a < 0)
      throw new Error("invalid byte sequence");
    t[r] = a;
  }
  return t;
}
function Rn(e) {
  return g3(kf(e));
}
function m3(e) {
  if (!Fm(e))
    throw new Error("Uint8Array expected");
  return g3(kf(Uint8Array.from(e).reverse()));
}
const Pu = (e, t) => xf(e.toString(16).padStart(t * 2, "0")), DA = (e, t) => Pu(e, t).reverse(), LM = (e) => xf(FA(e));
function fn(e, t, r) {
  let n;
  if (typeof t == "string")
    try {
      n = xf(t);
    } catch (a) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${a}`);
    }
  else if (Fm(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const o = n.length;
  if (typeof r == "number" && o !== r)
    throw new Error(`${e} expected ${r} bytes, got ${o}`);
  return n;
}
function yo(...e) {
  const t = new Uint8Array(e.reduce((n, o) => n + o.length, 0));
  let r = 0;
  return e.forEach((n) => {
    if (!Fm(n))
      throw new Error("Uint8Array expected");
    t.set(n, r), r += n.length;
  }), t;
}
function HM(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function Dm(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function FM(e) {
  let t;
  for (t = 0; e > 0n; e >>= p3, t += 1)
    ;
  return t;
}
const DM = (e, t) => e >> BigInt(t) & 1n, MM = (e, t, r) => e | (r ? p3 : RM) << BigInt(t), y3 = (e) => (zM << BigInt(e - 1)) - p3, d2 = (e) => new Uint8Array(e), gE = (e) => Uint8Array.from(e);
function MA(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = d2(e), o = d2(e), a = 0;
  const i = () => {
    n.fill(1), o.fill(0), a = 0;
  }, s = (...c) => r(o, n, ...c), u = (c = d2()) => {
    o = s(gE([0]), c), n = s(), c.length !== 0 && (o = s(gE([1]), c), n = s());
  }, l = () => {
    if (a++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let c = 0;
    const f = [];
    for (; c < t; ) {
      n = s();
      const h = n.slice();
      f.push(h), c += n.length;
    }
    return yo(...f);
  };
  return (c, f) => {
    i(), u(c);
    let h;
    for (; !(h = f(l())); )
      u();
    return i(), h;
  };
}
const KM = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function Jf(e, t, r = {}) {
  const n = (o, a, i) => {
    const s = KM[a];
    if (typeof s != "function")
      throw new Error(`Invalid validator "${a}", expected function`);
    const u = e[o];
    if (!(i && u === void 0) && !s(u, e))
      throw new Error(`Invalid param ${String(o)}=${u} (${typeof u}), expected ${a}`);
  };
  for (const [o, a] of Object.entries(t))
    n(o, a, !1);
  for (const [o, a] of Object.entries(r))
    n(o, a, !0);
  return e;
}
var qM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  bitGet: DM,
  bitLen: FM,
  bitMask: y3,
  bitSet: MM,
  bytesToHex: kf,
  bytesToNumberBE: Rn,
  bytesToNumberLE: m3,
  concatBytes: yo,
  createHmacDrbg: MA,
  ensureBytes: fn,
  equalBytes: HM,
  hexToBytes: xf,
  hexToNumber: g3,
  numberToBytesBE: Pu,
  numberToBytesLE: DA,
  numberToHexUnpadded: FA,
  numberToVarBytesBE: LM,
  utf8ToBytes: Dm,
  validateObject: Jf
});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const nn = BigInt(0), Pr = BigInt(1), gc = BigInt(2), VM = BigInt(3), Vw = BigInt(4), mE = BigInt(5), yE = BigInt(8);
BigInt(9);
BigInt(16);
function Gr(e, t) {
  const r = e % t;
  return r >= nn ? r : t + r;
}
function GM(e, t, r) {
  if (r <= nn || t < nn)
    throw new Error("Expected power/modulo > 0");
  if (r === Pr)
    return nn;
  let n = Pr;
  for (; t > nn; )
    t & Pr && (n = n * e % r), e = e * e % r, t >>= Pr;
  return n;
}
function zo(e, t, r) {
  let n = e;
  for (; t-- > nn; )
    n *= n, n %= r;
  return n;
}
function Gw(e, t) {
  if (e === nn || t <= nn)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Gr(e, t), n = t, o = nn, a = Pr;
  for (; r !== nn; ) {
    const i = n / r, s = n % r, u = o - a * i;
    n = r, r = s, o = a, a = u;
  }
  if (n !== Pr)
    throw new Error("invert: does not exist");
  return Gr(o, t);
}
function ZM(e) {
  const t = (e - Pr) / gc;
  let r, n, o;
  for (r = e - Pr, n = 0; r % gc === nn; r /= gc, n++)
    ;
  for (o = gc; o < e && GM(o, t, e) !== e - Pr; o++)
    ;
  if (n === 1) {
    const i = (e + Pr) / Vw;
    return function(s, u) {
      const l = s.pow(u, i);
      if (!s.eql(s.sqr(l), u))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  const a = (r + Pr) / gc;
  return function(i, s) {
    if (i.pow(s, t) === i.neg(i.ONE))
      throw new Error("Cannot find square root");
    let u = n, l = i.pow(i.mul(i.ONE, o), r), c = i.pow(s, a), f = i.pow(s, r);
    for (; !i.eql(f, i.ONE); ) {
      if (i.eql(f, i.ZERO))
        return i.ZERO;
      let h = 1;
      for (let y = i.sqr(f); h < u && !i.eql(y, i.ONE); h++)
        y = i.sqr(y);
      const p = i.pow(l, Pr << BigInt(u - h - 1));
      l = i.sqr(p), c = i.mul(c, p), f = i.mul(f, l), u = h;
    }
    return c;
  };
}
function WM(e) {
  if (e % Vw === VM) {
    const t = (e + Pr) / Vw;
    return function(r, n) {
      const o = r.pow(n, t);
      if (!r.eql(r.sqr(o), n))
        throw new Error("Cannot find square root");
      return o;
    };
  }
  if (e % yE === mE) {
    const t = (e - mE) / yE;
    return function(r, n) {
      const o = r.mul(n, gc), a = r.pow(o, t), i = r.mul(n, a), s = r.mul(r.mul(i, gc), a), u = r.mul(i, r.sub(s, r.ONE));
      if (!r.eql(r.sqr(u), n))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return ZM(e);
}
const XM = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function KA(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = XM.reduce((n, o) => (n[o] = "function", n), t);
  return Jf(e, r);
}
function YM(e, t, r) {
  if (r < nn)
    throw new Error("Expected power > 0");
  if (r === nn)
    return e.ONE;
  if (r === Pr)
    return t;
  let n = e.ONE, o = t;
  for (; r > nn; )
    r & Pr && (n = e.mul(n, o)), o = e.sqr(o), r >>= Pr;
  return n;
}
function JM(e, t) {
  const r = new Array(t.length), n = t.reduce((a, i, s) => e.is0(i) ? a : (r[s] = a, e.mul(a, i)), e.ONE), o = e.inv(n);
  return t.reduceRight((a, i, s) => e.is0(i) ? a : (r[s] = e.mul(a, r[s]), e.mul(a, i)), o), r;
}
function b3(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function qA(e, t, r = !1, n = {}) {
  if (e <= nn)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: o, nByteLength: a } = b3(e, t);
  if (a > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const i = WM(e), s = Object.freeze({
    ORDER: e,
    BITS: o,
    BYTES: a,
    MASK: y3(o),
    ZERO: nn,
    ONE: Pr,
    create: (u) => Gr(u, e),
    isValid: (u) => {
      if (typeof u != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof u}`);
      return nn <= u && u < e;
    },
    is0: (u) => u === nn,
    isOdd: (u) => (u & Pr) === Pr,
    neg: (u) => Gr(-u, e),
    eql: (u, l) => u === l,
    sqr: (u) => Gr(u * u, e),
    add: (u, l) => Gr(u + l, e),
    sub: (u, l) => Gr(u - l, e),
    mul: (u, l) => Gr(u * l, e),
    pow: (u, l) => YM(s, u, l),
    div: (u, l) => Gr(u * Gw(l, e), e),
    // Same as above, but doesn't normalize
    sqrN: (u) => u * u,
    addN: (u, l) => u + l,
    subN: (u, l) => u - l,
    mulN: (u, l) => u * l,
    inv: (u) => Gw(u, e),
    sqrt: n.sqrt || ((u) => i(s, u)),
    invertBatch: (u) => JM(s, u),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (u, l, c) => c ? l : u,
    toBytes: (u) => r ? DA(u, a) : Pu(u, a),
    fromBytes: (u) => {
      if (u.length !== a)
        throw new Error(`Fp.fromBytes: expected ${a}, got ${u.length}`);
      return r ? m3(u) : Rn(u);
    }
  });
  return Object.freeze(s);
}
function QM(e, t, r = !1) {
  e = fn("privateHash", e);
  const n = e.length, o = b3(t).nByteLength + 8;
  if (o < 24 || n < o || n > 1024)
    throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${n}`);
  const a = r ? m3(e) : Rn(e);
  return Gr(a, t - Pr) + Pr;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const eK = BigInt(0), h2 = BigInt(1);
function tK(e, t) {
  const r = (o, a) => {
    const i = a.negate();
    return o ? i : a;
  }, n = (o) => {
    const a = Math.ceil(t / o) + 1, i = 2 ** (o - 1);
    return { windows: a, windowSize: i };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(o, a) {
      let i = e.ZERO, s = o;
      for (; a > eK; )
        a & h2 && (i = i.add(s)), s = s.double(), a >>= h2;
      return i;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(o, a) {
      const { windows: i, windowSize: s } = n(a), u = [];
      let l = o, c = l;
      for (let f = 0; f < i; f++) {
        c = l, u.push(c);
        for (let h = 1; h < s; h++)
          c = c.add(l), u.push(c);
        l = c.double();
      }
      return u;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(o, a, i) {
      const { windows: s, windowSize: u } = n(o);
      let l = e.ZERO, c = e.BASE;
      const f = BigInt(2 ** o - 1), h = 2 ** o, p = BigInt(o);
      for (let y = 0; y < s; y++) {
        const m = y * u;
        let b = Number(i & f);
        i >>= p, b > u && (b -= h, i += h2);
        const v = m, k = m + Math.abs(b) - 1, E = y % 2 !== 0, A = b < 0;
        b === 0 ? c = c.add(r(E, a[v])) : l = l.add(r(A, a[k]));
      }
      return { p: l, f: c };
    },
    wNAFCached(o, a, i, s) {
      const u = o._WINDOW_SIZE || 1;
      let l = a.get(o);
      return l || (l = this.precomputeWindow(o, u), u !== 1 && a.set(o, s(l))), this.wNAF(u, l, i);
    }
  };
}
function VA(e) {
  return KA(e.Fp), Jf(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...b3(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function rK(e) {
  const t = VA(e);
  Jf(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: n, a: o } = t;
  if (r) {
    if (!n.eql(o, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: nK, hexToBytes: oK } = qM, wc = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  _parseInt(e) {
    const { Err: t } = wc;
    if (e.length < 2 || e[0] !== 2)
      throw new t("Invalid signature integer tag");
    const r = e[1], n = e.subarray(2, r + 2);
    if (!r || n.length !== r)
      throw new t("Invalid signature integer: wrong length");
    if (n[0] === 0 && n[1] <= 127)
      throw new t("Invalid signature integer: trailing length");
    return { d: nK(n), l: e.subarray(r + 2) };
  },
  toSig(e) {
    const { Err: t } = wc, r = typeof e == "string" ? oK(e) : e;
    if (!(r instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = r.length;
    if (n < 2 || r[0] != 48)
      throw new t("Invalid signature tag");
    if (r[1] !== n - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: o, l: a } = wc._parseInt(r.subarray(2)), { d: i, l: s } = wc._parseInt(a);
    if (s.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: o, s: i };
  },
  hexFromSig(e) {
    const t = (l) => Number.parseInt(l[0], 16) >= 8 ? "00" + l : l, r = (l) => {
      const c = l.toString(16);
      return c.length & 1 ? `0${c}` : c;
    }, n = t(r(e.s)), o = t(r(e.r)), a = n.length / 2, i = o.length / 2, s = r(a), u = r(i);
    return `30${r(i + a + 4)}02${u}${o}02${s}${n}`;
  }
}, li = BigInt(0), Kr = BigInt(1), Oa = BigInt(2), rg = BigInt(3), bE = BigInt(4);
function iK(e) {
  const t = rK(e), { Fp: r } = t, n = t.toBytes || ((y, m, b) => {
    const v = m.toAffine();
    return yo(Uint8Array.from([4]), r.toBytes(v.x), r.toBytes(v.y));
  }), o = t.fromBytes || ((y) => {
    const m = y.subarray(1), b = r.fromBytes(m.subarray(0, r.BYTES)), v = r.fromBytes(m.subarray(r.BYTES, 2 * r.BYTES));
    return { x: b, y: v };
  });
  function a(y) {
    const { a: m, b } = t, v = r.sqr(y), k = r.mul(v, y);
    return r.add(r.add(k, r.mul(y, m)), b);
  }
  function i(y) {
    return typeof y == "bigint" && li < y && y < t.n;
  }
  function s(y) {
    if (!i(y))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function u(y) {
    const { allowedPrivateKeyLengths: m, nByteLength: b, wrapPrivateKey: v, n: k } = t;
    if (m && typeof y != "bigint") {
      if (y instanceof Uint8Array && (y = kf(y)), typeof y != "string" || !m.includes(y.length))
        throw new Error("Invalid key");
      y = y.padStart(b * 2, "0");
    }
    let E;
    try {
      E = typeof y == "bigint" ? y : Rn(fn("private key", y, b));
    } catch {
      throw new Error(`private key must be ${b} bytes, hex or bigint, not ${typeof y}`);
    }
    return v && (E = Gr(E, k)), s(E), E;
  }
  const l = /* @__PURE__ */ new Map();
  function c(y) {
    if (!(y instanceof f))
      throw new Error("ProjectivePoint expected");
  }
  class f {
    constructor(m, b, v) {
      if (this.px = m, this.py = b, this.pz = v, m == null || !r.isValid(m))
        throw new Error("x required");
      if (b == null || !r.isValid(b))
        throw new Error("y required");
      if (v == null || !r.isValid(v))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(m) {
      const { x: b, y: v } = m || {};
      if (!m || !r.isValid(b) || !r.isValid(v))
        throw new Error("invalid affine point");
      if (m instanceof f)
        throw new Error("projective point not allowed");
      const k = (E) => r.eql(E, r.ZERO);
      return k(b) && k(v) ? f.ZERO : new f(b, v, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(m) {
      const b = r.invertBatch(m.map((v) => v.pz));
      return m.map((v, k) => v.toAffine(b[k])).map(f.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(m) {
      const b = f.fromAffine(o(fn("pointHex", m)));
      return b.assertValidity(), b;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(m) {
      return f.BASE.multiply(u(m));
    }
    // "Private method", don't use it directly
    _setWindowSize(m) {
      this._WINDOW_SIZE = m, l.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: m, y: b } = this.toAffine();
      if (!r.isValid(m) || !r.isValid(b))
        throw new Error("bad point: x or y not FE");
      const v = r.sqr(b), k = a(m);
      if (!r.eql(v, k))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: m } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(m);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(m) {
      c(m);
      const { px: b, py: v, pz: k } = this, { px: E, py: A, pz: S } = m, _ = r.eql(r.mul(b, S), r.mul(E, k)), I = r.eql(r.mul(v, S), r.mul(A, k));
      return _ && I;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new f(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: m, b } = t, v = r.mul(b, rg), { px: k, py: E, pz: A } = this;
      let S = r.ZERO, _ = r.ZERO, I = r.ZERO, O = r.mul(k, k), z = r.mul(E, E), D = r.mul(A, A), G = r.mul(k, E);
      return G = r.add(G, G), I = r.mul(k, A), I = r.add(I, I), S = r.mul(m, I), _ = r.mul(v, D), _ = r.add(S, _), S = r.sub(z, _), _ = r.add(z, _), _ = r.mul(S, _), S = r.mul(G, S), I = r.mul(v, I), D = r.mul(m, D), G = r.sub(O, D), G = r.mul(m, G), G = r.add(G, I), I = r.add(O, O), O = r.add(I, O), O = r.add(O, D), O = r.mul(O, G), _ = r.add(_, O), D = r.mul(E, A), D = r.add(D, D), O = r.mul(D, G), S = r.sub(S, O), I = r.mul(D, z), I = r.add(I, I), I = r.add(I, I), new f(S, _, I);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(m) {
      c(m);
      const { px: b, py: v, pz: k } = this, { px: E, py: A, pz: S } = m;
      let _ = r.ZERO, I = r.ZERO, O = r.ZERO;
      const z = t.a, D = r.mul(t.b, rg);
      let G = r.mul(b, E), U = r.mul(v, A), V = r.mul(k, S), F = r.add(b, v), C = r.add(E, A);
      F = r.mul(F, C), C = r.add(G, U), F = r.sub(F, C), C = r.add(b, k);
      let R = r.add(E, S);
      return C = r.mul(C, R), R = r.add(G, V), C = r.sub(C, R), R = r.add(v, k), _ = r.add(A, S), R = r.mul(R, _), _ = r.add(U, V), R = r.sub(R, _), O = r.mul(z, C), _ = r.mul(D, V), O = r.add(_, O), _ = r.sub(U, O), O = r.add(U, O), I = r.mul(_, O), U = r.add(G, G), U = r.add(U, G), V = r.mul(z, V), C = r.mul(D, C), U = r.add(U, V), V = r.sub(G, V), V = r.mul(z, V), C = r.add(C, V), G = r.mul(U, C), I = r.add(I, G), G = r.mul(R, C), _ = r.mul(F, _), _ = r.sub(_, G), G = r.mul(F, U), O = r.mul(R, O), O = r.add(O, G), new f(_, I, O);
    }
    subtract(m) {
      return this.add(m.negate());
    }
    is0() {
      return this.equals(f.ZERO);
    }
    wNAF(m) {
      return p.wNAFCached(this, l, m, (b) => {
        const v = r.invertBatch(b.map((k) => k.pz));
        return b.map((k, E) => k.toAffine(v[E])).map(f.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(m) {
      const b = f.ZERO;
      if (m === li)
        return b;
      if (s(m), m === Kr)
        return this;
      const { endo: v } = t;
      if (!v)
        return p.unsafeLadder(this, m);
      let { k1neg: k, k1: E, k2neg: A, k2: S } = v.splitScalar(m), _ = b, I = b, O = this;
      for (; E > li || S > li; )
        E & Kr && (_ = _.add(O)), S & Kr && (I = I.add(O)), O = O.double(), E >>= Kr, S >>= Kr;
      return k && (_ = _.negate()), A && (I = I.negate()), I = new f(r.mul(I.px, v.beta), I.py, I.pz), _.add(I);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(m) {
      s(m);
      let b = m, v, k;
      const { endo: E } = t;
      if (E) {
        const { k1neg: A, k1: S, k2neg: _, k2: I } = E.splitScalar(b);
        let { p: O, f: z } = this.wNAF(S), { p: D, f: G } = this.wNAF(I);
        O = p.constTimeNegate(A, O), D = p.constTimeNegate(_, D), D = new f(r.mul(D.px, E.beta), D.py, D.pz), v = O.add(D), k = z.add(G);
      } else {
        const { p: A, f: S } = this.wNAF(b);
        v = A, k = S;
      }
      return f.normalizeZ([v, k])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(m, b, v) {
      const k = f.BASE, E = (S, _) => _ === li || _ === Kr || !S.equals(k) ? S.multiplyUnsafe(_) : S.multiply(_), A = E(this, b).add(E(m, v));
      return A.is0() ? void 0 : A;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(m) {
      const { px: b, py: v, pz: k } = this, E = this.is0();
      m == null && (m = E ? r.ONE : r.inv(k));
      const A = r.mul(b, m), S = r.mul(v, m), _ = r.mul(k, m);
      if (E)
        return { x: r.ZERO, y: r.ZERO };
      if (!r.eql(_, r.ONE))
        throw new Error("invZ was invalid");
      return { x: A, y: S };
    }
    isTorsionFree() {
      const { h: m, isTorsionFree: b } = t;
      if (m === Kr)
        return !0;
      if (b)
        return b(f, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: m, clearCofactor: b } = t;
      return m === Kr ? this : b ? b(f, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(m = !0) {
      return this.assertValidity(), n(f, this, m);
    }
    toHex(m = !0) {
      return kf(this.toRawBytes(m));
    }
  }
  f.BASE = new f(t.Gx, t.Gy, r.ONE), f.ZERO = new f(r.ZERO, r.ONE, r.ZERO);
  const h = t.nBitLength, p = tK(f, t.endo ? Math.ceil(h / 2) : h);
  return {
    CURVE: t,
    ProjectivePoint: f,
    normPrivateKeyToScalar: u,
    weierstrassEquation: a,
    isWithinCurveOrder: i
  };
}
function aK(e) {
  const t = VA(e);
  return Jf(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function sK(e) {
  const t = aK(e), { Fp: r, n } = t, o = r.BYTES + 1, a = 2 * r.BYTES + 1;
  function i(C) {
    return li < C && C < r.ORDER;
  }
  function s(C) {
    return Gr(C, n);
  }
  function u(C) {
    return Gw(C, n);
  }
  const { ProjectivePoint: l, normPrivateKeyToScalar: c, weierstrassEquation: f, isWithinCurveOrder: h } = iK({
    ...t,
    toBytes(C, R, M) {
      const re = R.toAffine(), W = r.toBytes(re.x), ne = yo;
      return M ? ne(Uint8Array.from([R.hasEvenY() ? 2 : 3]), W) : ne(Uint8Array.from([4]), W, r.toBytes(re.y));
    },
    fromBytes(C) {
      const R = C.length, M = C[0], re = C.subarray(1);
      if (R === o && (M === 2 || M === 3)) {
        const W = Rn(re);
        if (!i(W))
          throw new Error("Point is not on curve");
        const ne = f(W);
        let oe = r.sqrt(ne);
        const se = (oe & Kr) === Kr;
        return (M & 1) === 1 !== se && (oe = r.neg(oe)), { x: W, y: oe };
      } else if (R === a && M === 4) {
        const W = r.fromBytes(re.subarray(0, r.BYTES)), ne = r.fromBytes(re.subarray(r.BYTES, 2 * r.BYTES));
        return { x: W, y: ne };
      } else
        throw new Error(`Point of length ${R} was invalid. Expected ${o} compressed bytes or ${a} uncompressed bytes`);
    }
  }), p = (C) => kf(Pu(C, t.nByteLength));
  function y(C) {
    const R = n >> Kr;
    return C > R;
  }
  function m(C) {
    return y(C) ? s(-C) : C;
  }
  const b = (C, R, M) => Rn(C.slice(R, M));
  class v {
    constructor(R, M, re) {
      this.r = R, this.s = M, this.recovery = re, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(R) {
      const M = t.nByteLength;
      return R = fn("compactSignature", R, M * 2), new v(b(R, 0, M), b(R, M, 2 * M));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(R) {
      const { r: M, s: re } = wc.toSig(fn("DER", R));
      return new v(M, re);
    }
    assertValidity() {
      if (!h(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!h(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(R) {
      return new v(this.r, this.s, R);
    }
    recoverPublicKey(R) {
      const { r: M, s: re, recovery: W } = this, ne = I(fn("msgHash", R));
      if (W == null || ![0, 1, 2, 3].includes(W))
        throw new Error("recovery id invalid");
      const oe = W === 2 || W === 3 ? M + t.n : M;
      if (oe >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const se = W & 1 ? "03" : "02", K = l.fromHex(se + p(oe)), he = u(oe), Ae = s(-ne * he), ye = s(re * he), Et = l.BASE.multiplyAndAddUnsafe(K, Ae, ye);
      if (!Et)
        throw new Error("point at infinify");
      return Et.assertValidity(), Et;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return y(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new v(this.r, s(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return xf(this.toDERHex());
    }
    toDERHex() {
      return wc.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return xf(this.toCompactHex());
    }
    toCompactHex() {
      return p(this.r) + p(this.s);
    }
  }
  const k = {
    isValidPrivateKey(C) {
      try {
        return c(C), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: c,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const C = t.randomBytes(r.BYTES + 8), R = QM(C, n);
      return Pu(R, t.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(C = 8, R = l.BASE) {
      return R._setWindowSize(C), R.multiply(BigInt(3)), R;
    }
  };
  function E(C, R = !0) {
    return l.fromPrivateKey(C).toRawBytes(R);
  }
  function A(C) {
    const R = C instanceof Uint8Array, M = typeof C == "string", re = (R || M) && C.length;
    return R ? re === o || re === a : M ? re === 2 * o || re === 2 * a : C instanceof l;
  }
  function S(C, R, M = !0) {
    if (A(C))
      throw new Error("first arg must be private key");
    if (!A(R))
      throw new Error("second arg must be public key");
    return l.fromHex(R).multiply(c(C)).toRawBytes(M);
  }
  const _ = t.bits2int || function(C) {
    const R = Rn(C), M = C.length * 8 - t.nBitLength;
    return M > 0 ? R >> BigInt(M) : R;
  }, I = t.bits2int_modN || function(C) {
    return s(_(C));
  }, O = y3(t.nBitLength);
  function z(C) {
    if (typeof C != "bigint")
      throw new Error("bigint expected");
    if (!(li <= C && C < O))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return Pu(C, t.nByteLength);
  }
  function D(C, R, M = G) {
    if (["recovered", "canonical"].some((be) => be in M))
      throw new Error("sign() legacy options not supported");
    const { hash: re, randomBytes: W } = t;
    let { lowS: ne, prehash: oe, extraEntropy: se } = M;
    ne == null && (ne = !0), C = fn("msgHash", C), oe && (C = fn("prehashed msgHash", re(C)));
    const K = I(C), he = c(R), Ae = [z(he), z(K)];
    if (se != null) {
      const be = se === !0 ? W(r.BYTES) : se;
      Ae.push(fn("extraEntropy", be, r.BYTES));
    }
    const ye = yo(...Ae), Et = K;
    function Ge(be) {
      const st = _(be);
      if (!h(st))
        return;
      const Ze = u(st), We = l.BASE.multiply(st).toAffine(), Re = s(We.x);
      if (Re === li)
        return;
      const Tt = s(Ze * s(Et + Re * he));
      if (Tt === li)
        return;
      let xr = (We.x === Re ? 0 : 2) | Number(We.y & Kr), Wt = Tt;
      return ne && y(Tt) && (Wt = m(Tt), xr ^= 1), new v(Re, Wt, xr);
    }
    return { seed: ye, k2sig: Ge };
  }
  const G = { lowS: t.lowS, prehash: !1 }, U = { lowS: t.lowS, prehash: !1 };
  function V(C, R, M = G) {
    const { seed: re, k2sig: W } = D(C, R, M);
    return MA(t.hash.outputLen, t.nByteLength, t.hmac)(re, W);
  }
  l.BASE._setWindowSize(8);
  function F(C, R, M, re = U) {
    var W;
    const ne = C;
    if (R = fn("msgHash", R), M = fn("publicKey", M), "strict" in re)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: oe, prehash: se } = re;
    let K, he;
    try {
      if (typeof ne == "string" || ne instanceof Uint8Array)
        try {
          K = v.fromDER(ne);
        } catch (We) {
          if (!(We instanceof wc.Err))
            throw We;
          K = v.fromCompact(ne);
        }
      else if (typeof ne == "object" && typeof ne.r == "bigint" && typeof ne.s == "bigint") {
        const { r: We, s: Re } = ne;
        K = new v(We, Re);
      } else
        throw new Error("PARSE");
      he = l.fromHex(M);
    } catch (We) {
      if (We.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (oe && K.hasHighS())
      return !1;
    se && (R = t.hash(R));
    const { r: Ae, s: ye } = K, Et = I(R), Ge = u(ye), be = s(Et * Ge), st = s(Ae * Ge), Ze = (W = l.BASE.multiplyAndAddUnsafe(he, be, st)) == null ? void 0 : W.toAffine();
    return Ze ? s(Ze.x) === Ae : !1;
  }
  return {
    CURVE: t,
    getPublicKey: E,
    getSharedSecret: S,
    sign: V,
    verify: F,
    ProjectivePoint: l,
    Signature: v,
    utils: k
  };
}
function uK(e, t) {
  const r = e.ORDER;
  let n = li;
  for (let h = r - Kr; h % Oa === li; h /= Oa)
    n += Kr;
  const o = n, a = (r - Kr) / Oa ** o, i = (a - Kr) / Oa, s = Oa ** o - Kr, u = Oa ** (o - Kr), l = e.pow(t, a), c = e.pow(t, (a + Kr) / Oa);
  let f = (h, p) => {
    let y = l, m = e.pow(p, s), b = e.sqr(m);
    b = e.mul(b, p);
    let v = e.mul(h, b);
    v = e.pow(v, i), v = e.mul(v, m), m = e.mul(v, p), b = e.mul(v, h);
    let k = e.mul(b, m);
    v = e.pow(k, u);
    let E = e.eql(v, e.ONE);
    m = e.mul(b, c), v = e.mul(k, y), b = e.cmov(m, b, E), k = e.cmov(v, k, E);
    for (let A = o; A > 1; A--) {
      let S = Oa ** (A - Oa), _ = e.pow(k, S);
      const I = e.eql(_, e.ONE);
      m = e.mul(b, y), y = e.mul(y, y), _ = e.mul(k, y), b = e.cmov(m, b, I), k = e.cmov(_, k, I);
    }
    return { isValid: E, value: b };
  };
  if (e.ORDER % bE === rg) {
    const h = (e.ORDER - rg) / bE, p = e.sqrt(e.neg(t));
    f = (y, m) => {
      let b = e.sqr(m);
      const v = e.mul(y, m);
      b = e.mul(b, v);
      let k = e.pow(b, h);
      k = e.mul(k, v);
      const E = e.mul(k, p), A = e.mul(e.sqr(k), m), S = e.eql(A, y);
      let _ = e.cmov(E, k, S);
      return { isValid: S, value: _ };
    };
  }
  return f;
}
function cK(e, t) {
  if (KA(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const r = uK(e, t.Z);
  if (!e.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (n) => {
    let o, a, i, s, u, l, c, f;
    o = e.sqr(n), o = e.mul(o, t.Z), a = e.sqr(o), a = e.add(a, o), i = e.add(a, e.ONE), i = e.mul(i, t.B), s = e.cmov(t.Z, e.neg(a), !e.eql(a, e.ZERO)), s = e.mul(s, t.A), a = e.sqr(i), l = e.sqr(s), u = e.mul(l, t.A), a = e.add(a, u), a = e.mul(a, i), l = e.mul(l, s), u = e.mul(l, t.B), a = e.add(a, u), c = e.mul(o, i);
    const { isValid: h, value: p } = r(a, l);
    f = e.mul(o, n), f = e.mul(f, p), c = e.cmov(c, i, h), f = e.cmov(f, p, h);
    const y = e.isOdd(n) === e.isOdd(f);
    return f = e.cmov(e.neg(f), f, y), c = e.div(c, s), { x: c, y: f };
  };
}
function lK(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return Dm(e);
  throw new Error("DST must be Uint8Array or string");
}
const fK = Rn;
function Eu(e, t) {
  if (e < 0 || e >= 1 << 8 * t)
    throw new Error(`bad I2OSP call: value=${e} length=${t}`);
  const r = Array.from({ length: t }).fill(0);
  for (let n = t - 1; n >= 0; n--)
    r[n] = e & 255, e >>>= 8;
  return new Uint8Array(r);
}
function dK(e, t) {
  const r = new Uint8Array(e.length);
  for (let n = 0; n < e.length; n++)
    r[n] = e[n] ^ t[n];
  return r;
}
function Eh(e) {
  if (!(e instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function w3(e) {
  if (!Number.isSafeInteger(e))
    throw new Error("number expected");
}
function hK(e, t, r, n) {
  Eh(e), Eh(t), w3(r), t.length > 255 && (t = n(yo(Dm("H2C-OVERSIZE-DST-"), t)));
  const { outputLen: o, blockLen: a } = n, i = Math.ceil(r / o);
  if (i > 255)
    throw new Error("Invalid xmd length");
  const s = yo(t, Eu(t.length, 1)), u = Eu(0, a), l = Eu(r, 2), c = new Array(i), f = n(yo(u, e, l, Eu(0, 1), s));
  c[0] = n(yo(f, Eu(1, 1), s));
  for (let h = 1; h <= i; h++) {
    const p = [dK(f, c[h - 1]), Eu(h + 1, 1), s];
    c[h] = n(yo(...p));
  }
  return yo(...c).slice(0, r);
}
function pK(e, t, r, n, o) {
  if (Eh(e), Eh(t), w3(r), t.length > 255) {
    const a = Math.ceil(2 * n / 8);
    t = o.create({ dkLen: a }).update(Dm("H2C-OVERSIZE-DST-")).update(t).digest();
  }
  if (r > 65535 || t.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return o.create({ dkLen: r }).update(e).update(Eu(r, 2)).update(t).update(Eu(t.length, 1)).digest();
}
function wE(e, t, r) {
  Jf(r, {
    DST: "string",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: n, k: o, m: a, hash: i, expand: s, DST: u } = r;
  Eh(e), w3(t);
  const l = lK(u), c = n.toString(2).length, f = Math.ceil((c + o) / 8), h = t * a * f;
  let p;
  if (s === "xmd")
    p = hK(e, l, h, i);
  else if (s === "xof")
    p = pK(e, l, h, o, i);
  else if (s === void 0)
    p = e;
  else
    throw new Error('expand must be "xmd", "xof" or undefined');
  const y = new Array(t);
  for (let m = 0; m < t; m++) {
    const b = new Array(a);
    for (let v = 0; v < a; v++) {
      const k = f * (v + m * a), E = p.subarray(k, k + f);
      b[v] = Gr(fK(E), n);
    }
    y[m] = b;
  }
  return y;
}
function gK(e, t) {
  const r = t.map((n) => Array.from(n).reverse());
  return (n, o) => {
    const [a, i, s, u] = r.map((l) => l.reduce((c, f) => e.add(e.mul(c, n), f)));
    return n = e.div(a, i), o = e.mul(o, e.div(s, u)), { x: n, y: o };
  };
}
function mK(e, t, r) {
  if (typeof t != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    hashToCurve(n, o) {
      const a = wE(n, 2, { ...r, DST: r.DST, ...o }), i = e.fromAffine(t(a[0])), s = e.fromAffine(t(a[1])), u = i.add(s).clearCofactor();
      return u.assertValidity(), u;
    },
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    encodeToCurve(n, o) {
      const a = wE(n, 1, { ...r, DST: r.encodeDST, ...o }), i = e.fromAffine(t(a[0])).clearCofactor();
      return i.assertValidity(), i;
    }
  };
}
let GA = class extends zA {
  constructor(t, r) {
    super(), this.finished = !1, this.destroyed = !1, bc.hash(t);
    const n = h3(r);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o = this.blockLen, a = new Uint8Array(o);
    a.set(n.length > o ? t.create().update(n).digest() : n);
    for (let i = 0; i < a.length; i++)
      a[i] ^= 54;
    this.iHash.update(a), this.oHash = t.create();
    for (let i = 0; i < a.length; i++)
      a[i] ^= 106;
    this.oHash.update(a), a.fill(0);
  }
  update(t) {
    return bc.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    bc.exists(this), bc.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: o, destroyed: a, blockLen: i, outputLen: s } = this;
    return t = t, t.finished = o, t.destroyed = a, t.blockLen = i, t.outputLen = s, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const ZA = (e, t, r) => new GA(e, t).update(r).digest();
ZA.create = (e, t) => new GA(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function yK(e) {
  return {
    hash: e,
    hmac: (t, ...r) => ZA(e, t, PM(...r)),
    randomBytes: LA
  };
}
function bK(e, t) {
  const r = (n) => sK({ ...e, ...yK(n) });
  return Object.freeze({ ...r(t), create: r });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Mm = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), ng = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), WA = BigInt(1), og = BigInt(2), vE = (e, t) => (e + t / og) / t;
function XA(e) {
  const t = Mm, r = BigInt(3), n = BigInt(6), o = BigInt(11), a = BigInt(22), i = BigInt(23), s = BigInt(44), u = BigInt(88), l = e * e * e % t, c = l * l * e % t, f = zo(c, r, t) * c % t, h = zo(f, r, t) * c % t, p = zo(h, og, t) * l % t, y = zo(p, o, t) * p % t, m = zo(y, a, t) * y % t, b = zo(m, s, t) * m % t, v = zo(b, u, t) * b % t, k = zo(v, s, t) * m % t, E = zo(k, r, t) * c % t, A = zo(E, i, t) * y % t, S = zo(A, n, t) * l % t, _ = zo(S, og, t);
  if (!Bu.eql(Bu.sqr(_), e))
    throw new Error("Cannot find square root");
  return _;
}
const Bu = qA(Mm, void 0, void 0, { sqrt: XA }), ga = bK({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Bu,
  n: ng,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = ng, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -WA * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), a = r, i = BigInt("0x100000000000000000000000000000000"), s = vE(a * e, t), u = vE(-n * e, t);
      let l = Gr(e - s * r - u * o, t), c = Gr(-s * n - u * a, t);
      const f = l > i, h = c > i;
      if (f && (l = t - l), h && (c = t - c), l > i || c > i)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: f, k1: l, k2neg: h, k2: c };
    }
  }
}, tg), Km = BigInt(0), YA = (e) => typeof e == "bigint" && Km < e && e < Mm, wK = (e) => typeof e == "bigint" && Km < e && e < ng, EE = {};
function ig(e, ...t) {
  let r = EE[e];
  if (r === void 0) {
    const n = tg(Uint8Array.from(e, (o) => o.charCodeAt(0)));
    r = yo(n, n), EE[e] = r;
  }
  return tg(yo(r, ...t));
}
const v3 = (e) => e.toRawBytes(!0).slice(1), Zw = (e) => Pu(e, 32), p2 = (e) => Gr(e, Mm), kh = (e) => Gr(e, ng), E3 = ga.ProjectivePoint, vK = (e, t, r) => E3.BASE.multiplyAndAddUnsafe(e, t, r);
function Ww(e) {
  let t = ga.utils.normPrivateKeyToScalar(e), r = E3.fromPrivateKey(t);
  return { scalar: r.hasEvenY() ? t : kh(-t), bytes: v3(r) };
}
function JA(e) {
  if (!YA(e))
    throw new Error("bad x: need 0 < x < p");
  const t = p2(e * e), r = p2(t * e + BigInt(7));
  let n = XA(r);
  n % og !== Km && (n = p2(-n));
  const o = new E3(e, n, WA);
  return o.assertValidity(), o;
}
function QA(...e) {
  return kh(Rn(ig("BIP0340/challenge", ...e)));
}
function EK(e) {
  return Ww(e).bytes;
}
function kK(e, t, r = LA(32)) {
  const n = fn("message", e), { bytes: o, scalar: a } = Ww(t), i = fn("auxRand", r, 32), s = Zw(a ^ Rn(ig("BIP0340/aux", i))), u = ig("BIP0340/nonce", s, o, n), l = kh(Rn(u));
  if (l === Km)
    throw new Error("sign failed: k is zero");
  const { bytes: c, scalar: f } = Ww(l), h = QA(c, o, n), p = new Uint8Array(64);
  if (p.set(c, 0), p.set(Zw(kh(f + h * a)), 32), !eS(p, n, o))
    throw new Error("sign: Invalid signature produced");
  return p;
}
function eS(e, t, r) {
  const n = fn("signature", e, 64), o = fn("message", t), a = fn("publicKey", r, 32);
  try {
    const i = JA(Rn(a)), s = Rn(n.subarray(0, 32));
    if (!YA(s))
      return !1;
    const u = Rn(n.subarray(32, 64));
    if (!wK(u))
      return !1;
    const l = QA(Zw(s), v3(i), o), c = vK(i, u, kh(-l));
    return !(!c || !c.hasEvenY() || c.toAffine().x !== s);
  } catch {
    return !1;
  }
}
const xK = {
  getPublicKey: EK,
  sign: kK,
  verify: eS,
  utils: {
    randomPrivateKey: ga.utils.randomPrivateKey,
    lift_x: JA,
    pointToBytes: v3,
    numberToBytesBE: Pu,
    bytesToNumberBE: Rn,
    taggedHash: ig,
    mod: Gr
  }
}, AK = gK(Bu, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((e) => e.map((t) => BigInt(t)))), SK = cK(Bu, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Bu.create(BigInt("-11"))
});
mK(ga.ProjectivePoint, (e) => {
  const { x: t, y: r } = SK(Bu.create(e[0]));
  return AK(t, r);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Bu.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: tg
});
function Xw(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function _K(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function tS(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function IK(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Xw(e.outputLen), Xw(e.blockLen);
}
function TK(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function PK(e, t) {
  tS(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const OK = {
  number: Xw,
  bool: _K,
  bytes: tS,
  hash: IK,
  exists: TK,
  output: PK
};
var g2 = OK;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const m2 = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Mi = (e, t) => e << 32 - t | e >>> t, $K = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!$K)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function CK(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function rS(e) {
  if (typeof e == "string" && (e = CK(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let BK = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function nS(e) {
  const t = (n) => e().update(rS(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function NK(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
let UK = class extends BK {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = m2(this.buffer);
  }
  update(t) {
    g2.exists(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = rS(t);
    const a = t.length;
    for (let i = 0; i < a; ) {
      const s = Math.min(o - this.pos, a - i);
      if (s === o) {
        const u = m2(t);
        for (; o <= a - i; i += o)
          this.process(u, i);
        continue;
      }
      n.set(t.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    g2.exists(this), g2.output(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: o, isLE: a } = this;
    let { pos: i } = this;
    r[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > o - i && (this.process(n, 0), i = 0);
    for (let f = i; f < o; f++)
      r[f] = 0;
    NK(n, o - 8, BigInt(this.length * 8), a), this.process(n, 0);
    const s = m2(t), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, c = this.get();
    if (l > c.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < l; f++)
      s.setUint32(4 * f, c[f], a);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: a, destroyed: i, pos: s } = this;
    return t.length = o, t.pos = s, t.finished = a, t.destroyed = i, o % r && t.buffer.set(n), t;
  }
};
const RK = (e, t, r) => e & t ^ ~e & r, zK = (e, t, r) => e & t ^ e & r ^ t & r, jK = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Bs = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Ns = new Uint32Array(64);
let oS = class extends UK {
  constructor() {
    super(64, 32, 8, !1), this.A = Bs[0] | 0, this.B = Bs[1] | 0, this.C = Bs[2] | 0, this.D = Bs[3] | 0, this.E = Bs[4] | 0, this.F = Bs[5] | 0, this.G = Bs[6] | 0, this.H = Bs[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: a, F: i, G: s, H: u } = this;
    return [t, r, n, o, a, i, s, u];
  }
  // prettier-ignore
  set(t, r, n, o, a, i, s, u) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = a | 0, this.F = i | 0, this.G = s | 0, this.H = u | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      Ns[f] = t.getUint32(r, !1);
    for (let f = 16; f < 64; f++) {
      const h = Ns[f - 15], p = Ns[f - 2], y = Mi(h, 7) ^ Mi(h, 18) ^ h >>> 3, m = Mi(p, 17) ^ Mi(p, 19) ^ p >>> 10;
      Ns[f] = m + Ns[f - 7] + y + Ns[f - 16] | 0;
    }
    let { A: n, B: o, C: a, D: i, E: s, F: u, G: l, H: c } = this;
    for (let f = 0; f < 64; f++) {
      const h = Mi(s, 6) ^ Mi(s, 11) ^ Mi(s, 25), p = c + h + RK(s, u, l) + jK[f] + Ns[f] | 0, y = (Mi(n, 2) ^ Mi(n, 13) ^ Mi(n, 22)) + zK(n, o, a) | 0;
      c = l, l = u, u = s, s = i + p | 0, i = a, a = o, o = n, n = p + y | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, c = c + this.H | 0, this.set(n, o, a, i, s, u, l, c);
  }
  roundClean() {
    Ns.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, LK = class extends oS {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const Yw = nS(() => new oS());
nS(() => new LK());
function HK(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function FK(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function DK(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
const { getRandomValues: MK } = crypto ?? globalThis.crypto ?? window.crypto;
function KK(e = 32) {
  if (typeof MK == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function qK(e, t, r = "be") {
  t === void 0 && (t = e.length), HK(e, t);
  const n = new Uint8Array(t).fill(0), o = r === "be" ? 0 : t - e.length;
  return n.set(e, o), n;
}
function iS(e) {
  let t, r = 0;
  const n = e.reduce((a, i) => a + i.length, 0), o = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const a = e[t];
    o.set(a, r), r += a.length;
  }
  return o;
}
const VK = new TextEncoder(), GK = [
  {
    name: "base58",
    charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }
];
function aS(e) {
  for (const t of GK)
    if (t.name === e)
      return t.charset;
  throw TypeError("Charset does not exist: " + e);
}
function ZK(e, t, r = !1) {
  typeof e == "string" && (e = VK.encode(e));
  const n = aS(t), o = n.length, a = [];
  let i = "", s, u = 0, l, c;
  for (s = 0; s < e.length; s++)
    for (u = 0, l = e[s], i += l > 0 || (i.length ^ s) > 0 ? "" : "1"; u in a || l > 0; )
      c = a[u], c = c > 0 ? c * 256 + l : l, l = c / o | 0, a[u] = c % o, u++;
  for (; u-- > 0; )
    i += n[a[u]];
  return r && i.length % 4 > 0 ? i + "=".repeat(4 - i.length % 4) : i;
}
function WK(e, t) {
  const r = aS(t), n = r.length, o = [], a = [];
  e = e.replace("=", "");
  let i, s = 0, u, l;
  for (i = 0; i < e.length; i++) {
    if (s = 0, u = r.indexOf(e[i]), u < 0)
      throw new Error(`Character range out of bounds: ${u}`);
    for (u > 0 || (a.length ^ i) > 0 || a.push(0); s in o || u > 0; )
      l = o[s], l = l > 0 ? l * n + u : u, u = l >> 8, o[s] = l % 256, s++;
  }
  for (; s-- > 0; )
    a.push(o[s]);
  return new Uint8Array(a);
}
function sS(e) {
  return Yw(Yw(e));
}
function XK(e) {
  const t = sS(e);
  return iS([e, t.slice(0, 4)]);
}
function YK(e) {
  const t = e.slice(0, -4), r = e.slice(-4);
  if (sS(t).slice(0, 4).toString() !== r.toString())
    throw new Error("Invalid checksum!");
  return t;
}
const kE = {
  encode: ZK,
  decode: WK
}, uS = {
  encode: (e) => {
    const t = XK(e);
    return kE.encode(t, "base58");
  },
  decode: (e) => {
    const t = kE.decode(e, "base58");
    return YK(t);
  }
}, cS = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", JK = [996825010, 642813549, 513874426, 1027748829, 705979059], ag = [
  { version: 0, name: "bech32", const: 1 },
  { version: 1, name: "bech32m", const: 734539939 }
];
function lS(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = t >> 25;
    t = (t & 33554431) << 5 ^ e[r];
    for (let o = 0; o < 5; ++o)
      n >> o & 1 && (t ^= JK[o]);
  }
  return t;
}
function fS(e) {
  const t = [];
  let r;
  for (r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) >> 5);
  for (t.push(0), r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) & 31);
  return t;
}
function QK(e, t, r) {
  const n = fS(e).concat(t);
  return lS(n) === r.const;
}
function eq(e, t, r) {
  const n = fS(e).concat(t).concat([0, 0, 0, 0, 0, 0]), o = lS(n) ^ r.const, a = [];
  for (let i = 0; i < 6; ++i)
    a.push(o >> 5 * (5 - i) & 31);
  return a;
}
function dS(e, t, r, n = !0) {
  const o = [];
  let a = 0, i = 0;
  const s = (1 << r) - 1, u = (1 << t + r - 1) - 1;
  for (const l of e) {
    if (l < 0 || l >> t > 0)
      throw new Error("Failed to perform base conversion. Invalid value: " + String(l));
    for (a = (a << t | l) & u, i += t; i >= r; )
      i -= r, o.push(a >> i & s);
  }
  if (n)
    i > 0 && o.push(a << r - i & s);
  else if (i >= t || (a << r - i & s) > 0)
    throw new Error("Failed to perform base conversion. Invalid Size!");
  return o;
}
function tq(e, t, r) {
  const n = t.concat(eq(e, t, r));
  let o = e + "1";
  for (let a = 0; a < n.length; ++a)
    o += cS.charAt(n[a]);
  return o;
}
function hS(e) {
  if (!rq(e))
    throw new Error("Encoded string goes out of bounds!");
  if (e = e.toLowerCase(), !nq(e))
    throw new Error("Encoded string has invalid separator!");
  const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
  for (let a = r + 1; a < e.length; ++a) {
    const i = cS.indexOf(e.charAt(a));
    if (i === -1)
      throw new Error("Character idx out of bounds: " + String(a));
    t.push(i);
  }
  const o = ag.find((a) => a.version === t[0]) ?? ag[0];
  if (!QK(n, t, o))
    throw new Error("Checksum verification failed!");
  return [n, t.slice(0, t.length - 6)];
}
function rq(e) {
  let t, r, n = !1, o = !1;
  for (t = 0; t < e.length; ++t) {
    if (r = e.charCodeAt(t), r < 33 || r > 126)
      return !1;
    r >= 97 && r <= 122 && (n = !0), r >= 65 && r <= 90 && (o = !0);
  }
  return !(n && o);
}
function nq(e) {
  const t = e.lastIndexOf("1");
  return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function oq(e, t = "bc", r = 0) {
  const n = [r, ...dS([...e], 8, 5)], o = ag.find((i) => i.version === r) ?? ag[0], a = tq(t, n, o);
  return pS(a), a;
}
function pS(e) {
  e = e.toLowerCase();
  const t = e.split("1", 1)[0], [r, n] = hS(e), o = dS(n.slice(1), 5, 8, !1), a = o.length;
  switch (!0) {
    case t !== r:
      throw new Error("Returned hrp string is invalid.");
    case (o === null || a < 2 || a > 40):
      throw new Error("Decoded string is invalid or out of spec.");
    case n[0] > 16:
      throw new Error("Returned version bit is out of range.");
    default:
      return Uint8Array.from(o);
  }
}
function iq(e) {
  e = e.toLowerCase();
  const [t, r] = hS(e);
  return r[0];
}
const gS = {
  encode: oq,
  decode: pS,
  version: iq
}, mS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", yS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", aq = new TextEncoder();
function bS(e, t = !1, r = !0) {
  typeof e == "string" && (e = aq.encode(e));
  const n = t ? yS : mS;
  let o = "", a = 0, i = 0;
  for (let s = 0; s < e.length; s++)
    for (i = i << 8 | e[s], a += 8; a >= 6; )
      a -= 6, o += n[i >> a & 63];
  if (a > 0)
    for (i <<= 6 - a, o += n[i & 63]; a < 6; )
      o += r ? "=" : "", a += 2;
  return o;
}
function wS(e, t = !1) {
  const r = t || e.includes("-") || e.includes("_") ? yS.split("") : mS.split("");
  e = e.replace(/=+$/, "");
  const n = e.split("");
  let o = 0, a = 0;
  const i = [];
  for (let s = 0; s < n.length; s++) {
    const u = n[s], l = r.indexOf(u);
    if (l === -1)
      throw new Error("Invalid character: " + u);
    o += 6, a <<= 6, a |= l, o >= 8 && (o -= 8, i.push(a >>> o & 255));
  }
  return new Uint8Array(i);
}
const vS = {
  encode: bS,
  decode: wS
}, ES = {
  encode: (e) => bS(e, !0, !1),
  decode: (e) => wS(e, !0)
}, sq = BigInt(0), uq = BigInt(255), kS = BigInt(256);
function cq(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function lq(e, t, r = "be") {
  t === void 0 && (t = cq(e));
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (; e > sq; ) {
    const s = e & uq, u = Number(s);
    n ? a.setUint8(i++, u) : a.setUint8(i--, u), e = (e - s) / kS;
  }
  return new Uint8Array(o);
}
function fq(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * kS + BigInt(e[r]);
  return BigInt(t);
}
function dq(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, o = 0; n < t.length; n += 8, o++) {
    let a = 0;
    for (let i = 0; i < 8; i++)
      a |= t[n + i] << 7 - i;
    r[o] = a;
  }
  return r;
}
function hq(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let o = 7; o >= 0; o--, r++)
      t[r] = n >> o & 1;
  }
  return t.join("");
}
function pq(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function gq(e, t, r = "be") {
  t === void 0 && (t = pq(e));
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (; e > 0; ) {
    const s = e & 255;
    n ? a.setUint8(i++, e) : a.setUint8(i--, e), e = (e - s) / 256;
  }
  return new Uint8Array(o);
}
function mq(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], DK(t);
  return t;
}
const yq = new TextEncoder(), bq = new TextDecoder();
function k3(e) {
  return yq.encode(e);
}
function Jw(e) {
  return bq.decode(e);
}
function wq(e, t) {
  FK(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function vq(e, t, r = "le") {
  t = wq(e, t);
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (let s = 0; s < e.length; s += 2) {
    const u = e.substring(s, s + 2), l = parseInt(u, 16);
    n ? a.setUint8(i++, l) : a.setUint8(i--, l);
  }
  return new Uint8Array(o);
}
function Eq(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function kq(e) {
  const t = JSON.stringify(e, (r, n) => typeof n == "bigint" ? `${n}n` : n);
  return k3(t);
}
function xq(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return qK(e, t, r);
  if (typeof e == "string")
    return vq(e, t, r);
  if (typeof e == "bigint")
    return lq(e, t, r);
  if (typeof e == "number")
    return gq(e, t, r);
  if (typeof e == "boolean")
    return Uint8Array.of(e ? 1 : 0);
  throw TypeError("Unsupported format:" + typeof e);
}
const In = class Jt extends Uint8Array {
  static random(t = 32) {
    const r = KK(t);
    return new Jt(r, t);
  }
  constructor(t, r, n) {
    const o = xq(t, r, n);
    super(o);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.toNum();
  }
  get big() {
    return this.toBig();
  }
  get str() {
    return this.toStr();
  }
  get hex() {
    return this.toHex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.toBin();
  }
  get b58chk() {
    return this.tob58chk();
  }
  get base64() {
    return this.toBase64();
  }
  get b64url() {
    return this.toB64url();
  }
  get digest() {
    return this.toHash();
  }
  get id() {
    return this.toHash().hex;
  }
  get stream() {
    return new Rq(this);
  }
  toNum(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return mq(r);
  }
  toBin() {
    return hq(this);
  }
  toBig(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return fq(r);
  }
  toHash() {
    const t = Yw(this);
    return new Jt(t);
  }
  toJson() {
    const t = Jw(this);
    return JSON.parse(t);
  }
  toBech32(t, r = 0) {
    return gS.encode(this, t, r);
  }
  toStr() {
    return Jw(this);
  }
  toHex() {
    return Eq(this);
  }
  toBytes() {
    return new Uint8Array(this);
  }
  tob58chk() {
    return uS.encode(this);
  }
  toBase64() {
    return vS.encode(this);
  }
  toB64url() {
    return ES.encode(this);
  }
  prepend(t) {
    return Jt.join([Jt.bytes(t), this]);
  }
  append(t) {
    return Jt.join([this, Jt.bytes(t)]);
  }
  slice(t, r) {
    const n = new Uint8Array(this).slice(t, r);
    return new Jt(n);
  }
  subarray(t, r) {
    const n = new Uint8Array(this).subarray(t, r);
    return new Jt(n);
  }
  reverse() {
    const t = new Uint8Array(this).reverse();
    return new Jt(t);
  }
  write(t, r) {
    const n = Jt.bytes(t);
    this.set(n, r);
  }
  prefixSize(t) {
    const r = Jt.varInt(this.length, t);
    return Jt.join([r, this]);
  }
  static from(t) {
    return new Jt(Uint8Array.from(t));
  }
  static of(...t) {
    return new Jt(Uint8Array.of(...t));
  }
  static join(t) {
    const r = t.map((o) => Jt.bytes(o)), n = iS(r);
    return new Jt(n);
  }
  static varInt(t, r) {
    if (t < 253)
      return Jt.num(t, 1);
    if (t < 65536)
      return Jt.of(253, ...Jt.num(t, 2, r));
    if (t < 4294967296)
      return Jt.of(254, ...Jt.num(t, 4, r));
    if (BigInt(t) < 0x10000000000000000n)
      return Jt.of(255, ...Jt.num(t, 8, r));
    throw new Error(`Value is too large: ${t}`);
  }
};
In.num = Aq, In.big = _q, In.bin = Sq, In.raw = Iq, In.str = Tq, In.hex = Pq, In.bytes = Oq, In.json = $q, In.base64 = Cq, In.b64url = Bq, In.bech32 = Nq, In.b58chk = Uq, In.encode = k3, In.decode = Jw;
let Qe = In;
function Aq(e, t, r) {
  return new Qe(e, t, r);
}
function Sq(e, t, r) {
  return new Qe(dq(e), t, r);
}
function _q(e, t, r) {
  return new Qe(e, t, r);
}
function Iq(e, t, r) {
  return new Qe(e, t, r);
}
function Tq(e, t, r) {
  return new Qe(k3(e), t, r);
}
function Pq(e, t, r) {
  return new Qe(e, t, r);
}
function Oq(e, t, r) {
  return new Qe(e, t, r);
}
function $q(e) {
  return new Qe(kq(e));
}
function Cq(e) {
  return new Qe(vS.decode(e));
}
function Bq(e) {
  return new Qe(ES.decode(e));
}
function Nq(e) {
  return new Qe(gS.decode(e));
}
function Uq(e) {
  return new Qe(uS.decode(e));
}
let Rq = class {
  constructor(t) {
    this.data = Qe.bytes(t), this.size = this.data.length;
  }
  peek(t) {
    if (t > this.size)
      throw new Error(`Size greater than stream: ${t} > ${this.size}`);
    return new Qe(this.data.slice(0, t));
  }
  read(t) {
    t = t ?? this.readSize();
    const r = this.peek(t);
    return this.data = this.data.slice(t), this.size = this.data.length, r;
  }
  readSize(t) {
    const r = this.read(1).num;
    switch (!0) {
      case (r >= 0 && r < 253):
        return r;
      case r === 253:
        return this.read(2).toNum(t);
      case r === 254:
        return this.read(4).toNum(t);
      case r === 255:
        return this.read(8).toNum(t);
      default:
        throw new Error(`Varint is out of range: ${r}`);
    }
  }
};
const sg = ga.CURVE, x3 = sg.n, zq = sg.p, jq = { x: sg.Gx, y: sg.Gy }, Lq = BigInt(0), Hq = BigInt(1), Fq = BigInt(2), Dq = BigInt(3), Mq = BigInt(4), Qw = { N: x3, P: zq, G: jq, _0n: Lq, _1n: Hq, _2n: Fq, _3n: Dq, _4n: Mq }, Ud = qA(x3, 32, !0), xS = (e) => Gr(e, x3);
function A3(e, t = !1) {
  if (t)
    throw new Error(e);
  return !1;
}
function AS(e) {
  return Qe.random(e);
}
function Kq(e) {
  const t = Qe.bytes(e).big;
  return Qe.big(xS(t), 32);
}
var qq = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fail: A3,
  mod_bytes: Kq,
  random: AS
});
const { N: Vq, P: V8e, _0n: Gq } = Qw;
function Zq(e, t, r) {
  const n = Qe.bytes(e);
  return n.length !== t ? A3(`Invalid byte size: ${n.hex} !== ${t}`, r) : !0;
}
function Wq(e, t) {
  return typeof e == "bigint" && Gq < e && e < Vq || A3("x value is not in the field!", t), !0;
}
const xE = ga.ProjectivePoint, SS = class Hr extends Uint8Array {
  static mod(t) {
    return new Hr(t);
  }
  static is_valid(t, r) {
    const n = Qe.bytes(t, 32).big;
    return Wq(n, r);
  }
  constructor(t) {
    let r = Xq(t);
    r = xS(r), Hr.is_valid(r, !0), super(Qe.big(r, 32), 32);
  }
  get buff() {
    return new Qe(this);
  }
  get raw() {
    return this.buff.raw;
  }
  get big() {
    return this.buff.big;
  }
  get hex() {
    return this.buff.hex;
  }
  get point() {
    return this.generate();
  }
  get hasOddY() {
    return this.point.hasOddY;
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  gt(t) {
    return new Hr(t).big > this.big;
  }
  lt(t) {
    return new Hr(t).big < this.big;
  }
  eq(t) {
    return new Hr(t).big === this.big;
  }
  ne(t) {
    return new Hr(t).big !== this.big;
  }
  add(t) {
    const r = Hr.mod(t), n = Ud.add(this.big, r.big);
    return new Hr(n);
  }
  sub(t) {
    const r = Hr.mod(t), n = Ud.sub(this.big, r.big);
    return new Hr(n);
  }
  mul(t) {
    const r = Hr.mod(t), n = Ud.mul(this.big, r.big);
    return new Hr(n);
  }
  pow(t) {
    const r = Hr.mod(t), n = Ud.pow(this.big, r.big);
    return new Hr(n);
  }
  div(t) {
    const r = Hr.mod(t), n = Ud.div(this.big, r.big);
    return new Hr(n);
  }
  negate() {
    return new Hr(Hr.N - this.big);
  }
  generate() {
    const t = ga.ProjectivePoint.BASE.multiply(this.big);
    return ul.import(t);
  }
};
SS.N = ga.CURVE.n;
let Bn = SS;
const v1 = class Br {
  static from_x(t) {
    let r = Yq(t);
    r.length === 32 && (r = r.prepend(2)), Zq(r, 33);
    const n = xE.fromHex(r.hex);
    return n.assertValidity(), new Br(n.x, n.y);
  }
  static generate(t) {
    const r = Bn.mod(t), n = Br.base.multiply(r.big);
    return Br.import(n);
  }
  static import(t) {
    const r = t instanceof Br ? { x: t.x.big, y: t.y.big } : { x: t.x, y: t.y };
    return new Br(r.x, r.y);
  }
  constructor(t, r) {
    this._p = new xE(t, r, 1n), this.p.assertValidity();
  }
  get p() {
    return this._p;
  }
  get x() {
    return Qe.big(this.p.x, 32);
  }
  get y() {
    return Qe.big(this.p.y, 32);
  }
  get buff() {
    return Qe.raw(this.p.toRawBytes(!0));
  }
  get raw() {
    return this.buff.raw;
  }
  get hex() {
    return this.buff.hex;
  }
  get hasEvenY() {
    return this.p.hasEvenY();
  }
  get hasOddY() {
    return !this.p.hasEvenY();
  }
  eq(t) {
    const r = t instanceof Br ? t : Br.from_x(t);
    return this.x.big === r.x.big && this.y.big === r.y.big;
  }
  add(t) {
    return t instanceof Br ? Br.import(this.p.add(t.p)) : Br.import(this.p.add(Br.generate(t).p));
  }
  sub(t) {
    return t instanceof Br ? Br.import(this.p.subtract(t.p)) : Br.import(this.p.subtract(Br.generate(t).p));
  }
  mul(t) {
    return t instanceof Br ? Br.import(this.p.multiply(t.x.big)) : Br.import(this.p.multiply(Bn.mod(t).big));
  }
  negate() {
    return Br.import(this.p.negate());
  }
};
v1.P = Qw.P, v1.G = Qw.G, v1.base = ga.ProjectivePoint.BASE;
let ul = v1;
function Xq(e) {
  if (e instanceof Bn)
    return e.big;
  if (e instanceof ul)
    return e.x.big;
  if (e instanceof Uint8Array)
    return Qe.raw(e).big;
  if (typeof e == "string")
    return Qe.hex(e).big;
  if (typeof e == "number")
    return Qe.num(e).big;
  if (typeof e == "bigint")
    return BigInt(e);
  throw TypeError("Invalid input type:" + typeof e);
}
function Yq(e) {
  if (e instanceof Bn)
    return e.point.buff;
  if (e instanceof ul)
    return e.buff;
  if (e instanceof Uint8Array || typeof e == "string")
    return Qe.bytes(e);
  if (typeof e == "number" || typeof e == "bigint")
    return Qe.bytes(e, 32);
  throw new TypeError(`Unknown type: ${typeof e}`);
}
function ev(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function Jq(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function _S(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Qq(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  ev(e.outputLen), ev(e.blockLen);
}
function eV(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function tV(e, t) {
  _S(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const rV = {
  number: ev,
  bool: Jq,
  bytes: _S,
  hash: Qq,
  exists: eV,
  output: tV
};
var vc = rV;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const nV = (e) => e instanceof Uint8Array, y2 = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Ki = (e, t) => e << 32 - t | e >>> t, oV = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!oV)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function iV(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function S3(e) {
  if (typeof e == "string" && (e = iV(e)), !nV(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
let IS = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function cl(e) {
  const t = (n) => e().update(S3(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function aV(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
let _3 = class extends IS {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = y2(this.buffer);
  }
  update(t) {
    vc.exists(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = S3(t);
    const a = t.length;
    for (let i = 0; i < a; ) {
      const s = Math.min(o - this.pos, a - i);
      if (s === o) {
        const u = y2(t);
        for (; o <= a - i; i += o)
          this.process(u, i);
        continue;
      }
      n.set(t.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    vc.exists(this), vc.output(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: o, isLE: a } = this;
    let { pos: i } = this;
    r[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > o - i && (this.process(n, 0), i = 0);
    for (let f = i; f < o; f++)
      r[f] = 0;
    aV(n, o - 8, BigInt(this.length * 8), a), this.process(n, 0);
    const s = y2(t), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, c = this.get();
    if (l > c.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < l; f++)
      s.setUint32(4 * f, c[f], a);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: a, destroyed: i, pos: s } = this;
    return t.length = o, t.pos = s, t.finished = a, t.destroyed = i, o % r && t.buffer.set(n), t;
  }
};
const sV = (e, t, r) => e & t ^ ~e & r, uV = (e, t, r) => e & t ^ e & r ^ t & r, cV = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Us = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Rs = new Uint32Array(64);
let TS = class extends _3 {
  constructor() {
    super(64, 32, 8, !1), this.A = Us[0] | 0, this.B = Us[1] | 0, this.C = Us[2] | 0, this.D = Us[3] | 0, this.E = Us[4] | 0, this.F = Us[5] | 0, this.G = Us[6] | 0, this.H = Us[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: a, F: i, G: s, H: u } = this;
    return [t, r, n, o, a, i, s, u];
  }
  // prettier-ignore
  set(t, r, n, o, a, i, s, u) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = a | 0, this.F = i | 0, this.G = s | 0, this.H = u | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      Rs[f] = t.getUint32(r, !1);
    for (let f = 16; f < 64; f++) {
      const h = Rs[f - 15], p = Rs[f - 2], y = Ki(h, 7) ^ Ki(h, 18) ^ h >>> 3, m = Ki(p, 17) ^ Ki(p, 19) ^ p >>> 10;
      Rs[f] = m + Rs[f - 7] + y + Rs[f - 16] | 0;
    }
    let { A: n, B: o, C: a, D: i, E: s, F: u, G: l, H: c } = this;
    for (let f = 0; f < 64; f++) {
      const h = Ki(s, 6) ^ Ki(s, 11) ^ Ki(s, 25), p = c + h + sV(s, u, l) + cV[f] + Rs[f] | 0, y = (Ki(n, 2) ^ Ki(n, 13) ^ Ki(n, 22)) + uV(n, o, a) | 0;
      c = l, l = u, u = s, s = i + p | 0, i = a, a = o, o = n, n = p + y | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, c = c + this.H | 0, this.set(n, o, a, i, s, u, l, c);
  }
  roundClean() {
    Rs.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, lV = class extends TS {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const ug = cl(() => new TS());
cl(() => new lV());
const I0 = BigInt(2 ** 32 - 1), tv = BigInt(32);
function PS(e, t = !1) {
  return t ? { h: Number(e & I0), l: Number(e >> tv & I0) } : { h: Number(e >> tv & I0) | 0, l: Number(e & I0) | 0 };
}
function fV(e, t = !1) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: a, l: i } = PS(e[o], t);
    [r[o], n[o]] = [a, i];
  }
  return [r, n];
}
const dV = (e, t) => BigInt(e >>> 0) << tv | BigInt(t >>> 0), hV = (e, t, r) => e >>> r, pV = (e, t, r) => e << 32 - r | t >>> r, gV = (e, t, r) => e >>> r | t << 32 - r, mV = (e, t, r) => e << 32 - r | t >>> r, yV = (e, t, r) => e << 64 - r | t >>> r - 32, bV = (e, t, r) => e >>> r - 32 | t << 64 - r, wV = (e, t) => t, vV = (e, t) => e, EV = (e, t, r) => e << r | t >>> 32 - r, kV = (e, t, r) => t << r | e >>> 32 - r, xV = (e, t, r) => t << r - 32 | e >>> 64 - r, AV = (e, t, r) => e << r - 32 | t >>> 64 - r;
function SV(e, t, r, n) {
  const o = (t >>> 0) + (n >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
const _V = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0), IV = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0, TV = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), PV = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0, OV = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0), $V = (e, t, r, n, o, a) => t + r + n + o + a + (e / 2 ** 32 | 0) | 0, CV = {
  fromBig: PS,
  split: fV,
  toBig: dV,
  shrSH: hV,
  shrSL: pV,
  rotrSH: gV,
  rotrSL: mV,
  rotrBH: yV,
  rotrBL: bV,
  rotr32H: wV,
  rotr32L: vV,
  rotlSH: EV,
  rotlSL: kV,
  rotlBH: xV,
  rotlBL: AV,
  add: SV,
  add3L: _V,
  add3H: IV,
  add4L: TV,
  add4H: PV,
  add5H: $V,
  add5L: OV
};
var mt = CV;
const [BV, NV] = mt.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))), zs = new Uint32Array(80), js = new Uint32Array(80);
let qm = class extends _3 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: o, Ch: a, Cl: i, Dh: s, Dl: u, Eh: l, El: c, Fh: f, Fl: h, Gh: p, Gl: y, Hh: m, Hl: b } = this;
    return [t, r, n, o, a, i, s, u, l, c, f, h, p, y, m, b];
  }
  // prettier-ignore
  set(t, r, n, o, a, i, s, u, l, c, f, h, p, y, m, b) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = o | 0, this.Ch = a | 0, this.Cl = i | 0, this.Dh = s | 0, this.Dl = u | 0, this.Eh = l | 0, this.El = c | 0, this.Fh = f | 0, this.Fl = h | 0, this.Gh = p | 0, this.Gl = y | 0, this.Hh = m | 0, this.Hl = b | 0;
  }
  process(t, r) {
    for (let E = 0; E < 16; E++, r += 4)
      zs[E] = t.getUint32(r), js[E] = t.getUint32(r += 4);
    for (let E = 16; E < 80; E++) {
      const A = zs[E - 15] | 0, S = js[E - 15] | 0, _ = mt.rotrSH(A, S, 1) ^ mt.rotrSH(A, S, 8) ^ mt.shrSH(A, S, 7), I = mt.rotrSL(A, S, 1) ^ mt.rotrSL(A, S, 8) ^ mt.shrSL(A, S, 7), O = zs[E - 2] | 0, z = js[E - 2] | 0, D = mt.rotrSH(O, z, 19) ^ mt.rotrBH(O, z, 61) ^ mt.shrSH(O, z, 6), G = mt.rotrSL(O, z, 19) ^ mt.rotrBL(O, z, 61) ^ mt.shrSL(O, z, 6), U = mt.add4L(I, G, js[E - 7], js[E - 16]), V = mt.add4H(U, _, D, zs[E - 7], zs[E - 16]);
      zs[E] = V | 0, js[E] = U | 0;
    }
    let { Ah: n, Al: o, Bh: a, Bl: i, Ch: s, Cl: u, Dh: l, Dl: c, Eh: f, El: h, Fh: p, Fl: y, Gh: m, Gl: b, Hh: v, Hl: k } = this;
    for (let E = 0; E < 80; E++) {
      const A = mt.rotrSH(f, h, 14) ^ mt.rotrSH(f, h, 18) ^ mt.rotrBH(f, h, 41), S = mt.rotrSL(f, h, 14) ^ mt.rotrSL(f, h, 18) ^ mt.rotrBL(f, h, 41), _ = f & p ^ ~f & m, I = h & y ^ ~h & b, O = mt.add5L(k, S, I, NV[E], js[E]), z = mt.add5H(O, v, A, _, BV[E], zs[E]), D = O | 0, G = mt.rotrSH(n, o, 28) ^ mt.rotrBH(n, o, 34) ^ mt.rotrBH(n, o, 39), U = mt.rotrSL(n, o, 28) ^ mt.rotrBL(n, o, 34) ^ mt.rotrBL(n, o, 39), V = n & a ^ n & s ^ a & s, F = o & i ^ o & u ^ i & u;
      v = m | 0, k = b | 0, m = p | 0, b = y | 0, p = f | 0, y = h | 0, { h: f, l: h } = mt.add(l | 0, c | 0, z | 0, D | 0), l = s | 0, c = u | 0, s = a | 0, u = i | 0, a = n | 0, i = o | 0;
      const C = mt.add3L(D, U, F);
      n = mt.add3H(C, z, G, V), o = C | 0;
    }
    ({ h: n, l: o } = mt.add(this.Ah | 0, this.Al | 0, n | 0, o | 0)), { h: a, l: i } = mt.add(this.Bh | 0, this.Bl | 0, a | 0, i | 0), { h: s, l: u } = mt.add(this.Ch | 0, this.Cl | 0, s | 0, u | 0), { h: l, l: c } = mt.add(this.Dh | 0, this.Dl | 0, l | 0, c | 0), { h: f, l: h } = mt.add(this.Eh | 0, this.El | 0, f | 0, h | 0), { h: p, l: y } = mt.add(this.Fh | 0, this.Fl | 0, p | 0, y | 0), { h: m, l: b } = mt.add(this.Gh | 0, this.Gl | 0, m | 0, b | 0), { h: v, l: k } = mt.add(this.Hh | 0, this.Hl | 0, v | 0, k | 0), this.set(n, o, a, i, s, u, l, c, f, h, p, y, m, b, v, k);
  }
  roundClean() {
    zs.fill(0), js.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}, UV = class extends qm {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}, RV = class extends qm {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}, zV = class extends qm {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
const jV = cl(() => new qm());
cl(() => new UV());
cl(() => new RV());
cl(() => new zV());
const LV = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), OS = Uint8Array.from({ length: 16 }, (e, t) => t), HV = OS.map((e) => (9 * e + 5) % 16);
let I3 = [OS], T3 = [HV];
for (let e = 0; e < 4; e++)
  for (let t of [I3, T3])
    t.push(t[e].map((r) => LV[r]));
const $S = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => new Uint8Array(e)), FV = I3.map((e, t) => e.map((r) => $S[t][r])), DV = T3.map((e, t) => e.map((r) => $S[t][r])), MV = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]), KV = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]), T0 = (e, t) => e << t | e >>> 32 - t;
function AE(e, t, r, n) {
  return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const P0 = new Uint32Array(16);
let qV = class extends _3 {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: t, h1: r, h2: n, h3: o, h4: a } = this;
    return [t, r, n, o, a];
  }
  set(t, r, n, o, a) {
    this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = o | 0, this.h4 = a | 0;
  }
  process(t, r) {
    for (let p = 0; p < 16; p++, r += 4)
      P0[p] = t.getUint32(r, !0);
    let n = this.h0 | 0, o = n, a = this.h1 | 0, i = a, s = this.h2 | 0, u = s, l = this.h3 | 0, c = l, f = this.h4 | 0, h = f;
    for (let p = 0; p < 5; p++) {
      const y = 4 - p, m = MV[p], b = KV[p], v = I3[p], k = T3[p], E = FV[p], A = DV[p];
      for (let S = 0; S < 16; S++) {
        const _ = T0(n + AE(p, a, s, l) + P0[v[S]] + m, E[S]) + f | 0;
        n = f, f = l, l = T0(s, 10) | 0, s = a, a = _;
      }
      for (let S = 0; S < 16; S++) {
        const _ = T0(o + AE(y, i, u, c) + P0[k[S]] + b, A[S]) + h | 0;
        o = h, h = c, c = T0(u, 10) | 0, u = i, i = _;
      }
    }
    this.set(this.h1 + s + c | 0, this.h2 + l + h | 0, this.h3 + f + o | 0, this.h4 + n + i | 0, this.h0 + a + u | 0);
  }
  roundClean() {
    P0.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
};
const VV = cl(() => new qV());
let CS = class extends IS {
  constructor(t, r) {
    super(), this.finished = !1, this.destroyed = !1, vc.hash(t);
    const n = S3(r);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o = this.blockLen, a = new Uint8Array(o);
    a.set(n.length > o ? t.create().update(n).digest() : n);
    for (let i = 0; i < a.length; i++)
      a[i] ^= 54;
    this.iHash.update(a), this.oHash = t.create();
    for (let i = 0; i < a.length; i++)
      a[i] ^= 106;
    this.oHash.update(a), a.fill(0);
  }
  update(t) {
    return vc.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    vc.exists(this), vc.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: o, destroyed: a, blockLen: i, outputLen: s } = this;
    return t = t, t.finished = o, t.destroyed = a, t.blockLen = i, t.outputLen = s, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const BS = (e, t, r) => new CS(e, t).update(r).digest();
BS.create = (e, t) => new CS(e, t);
function GV(e) {
  const t = Qe.bytes(e);
  return Qe.raw(ug(t));
}
function Af(e) {
  const t = Qe.bytes(e);
  return Qe.raw(ug(ug(t)));
}
function P3(e) {
  const t = Qe.bytes(e);
  return Qe.raw(VV(ug(t)));
}
function ZV(e, t) {
  const r = Qe.bytes(e), n = Qe.bytes(t);
  return Qe.raw(BS(jV, r, n));
}
function WV(e) {
  const t = Qe.str(e).digest;
  return Qe.join([t, t]);
}
function XV(e = 32) {
  return O3(AS(e));
}
function O3(e) {
  return Bn.mod(e).buff;
}
function NS(e, t = !1) {
  const r = Bn.mod(e).point;
  return t ? r.x : r.buff;
}
function US(e, t) {
  const r = ul.from_x(t), n = Bn.mod(e);
  return r.mul(n).buff;
}
function YV(e, t, r = "ecdh/code") {
  const n = WV(r), o = O3(e), a = NS(o), i = Qe.bytes(t), s = US(o, i), u = [a.hex, i.hex];
  return u.sort(), ZV(s, Qe.join([n, ...u]));
}
function JV(e) {
  const t = Qe.bytes(e);
  switch (!0) {
    case t.length === 32:
      return !0;
    case (t.length === 33 && t[0] === 2):
      return !0;
    case (t.length === 33 && t[0] === 3):
      return !1;
    default:
      throw new TypeError(`Invalid public key: ${t.hex}`);
  }
}
function QV(e) {
  const t = Qe.bytes(e);
  switch (t.length) {
    case 32:
      return t;
    case 33:
      return t.slice(1, 33);
    default:
      throw new Error(`Invalid key length: ${t.length}`);
  }
}
var eG = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  genSecretKey: XV,
  getPublicKey: NS,
  getSecretKey: O3,
  getSharedCode: YV,
  getSharedKey: US,
  is_even_pub: JV,
  xonly_pub: QV
});
Qe.random(32);
const RS = { secp: ga, schnorr: xK }, rv = { ...eG, ...qq };
function Vm(e) {
  const t = Y.bytes(e);
  return pa(t, 33), P3(t);
}
function zS(e) {
  const t = Hn.fmt.toBytes(e, !1);
  return P3(t);
}
function jS(e) {
  const t = Hn.fmt.toBytes(e, !1);
  return GV(t);
}
function LS(e, t = "main") {
  const r = t === "main" ? ["1"] : ["m", "n"];
  for (const n of r)
    if (e.startsWith(n))
      return !0;
  return !1;
}
function HS(e, t = "main") {
  const r = Y.bytes(e), n = t === "main" ? Y.num(0) : Y.num(111);
  return pa(e, 20), r.prepend(n).tob58chk();
}
function tG(e, t = "main") {
  if (!LS(e, t))
    throw new TypeError("Invalid p2pkh address!");
  return Y.b58chk(e).slice(1);
}
function rG(e) {
  const t = Y.bytes(e);
  return pa(t, 20), ["OP_DUP", "OP_HASH160", t.hex, "OP_EQUALVERIFY", "OP_CHECKSIG"];
}
function nG(e, t) {
  const r = Vm(e);
  return HS(r, t);
}
const FS = { check: LS, encode: HS, decode: tG, hash: Vm, scriptPubKey: rG, fromPubKey: nG };
function DS(e, t = "main") {
  const r = t === "main" ? ["3"] : ["2"];
  for (const n of r)
    if (e.startsWith(n))
      return !0;
  return !1;
}
function MS(e, t = "main") {
  const r = t === "main" ? Y.num(5) : Y.num(196), n = Y.bytes(e);
  return pa(n, 20), n.prepend(r).tob58chk();
}
function oG(e, t = "main") {
  if (!DS(e, t))
    throw new TypeError(`Invalid p2sh address for network ${t}:` + e);
  return Y.b58chk(e).slice(1);
}
function iG(e) {
  return ["OP_HASH160", Y.bytes(e).hex, "OP_EQUAL"];
}
function aG(e, t) {
  const r = zS(e);
  return MS(r, t);
}
const KS = { check: DS, encode: MS, decode: oG, hash: zS, scriptPubKey: iG, fromScript: aG }, $3 = {
  main: "bc",
  testnet: "tb",
  signet: "tb",
  regtest: "bcrt"
}, sG = ["bc1q", "tb1q", "bcrt1q"];
function qS(e) {
  for (const t of sG)
    if (e.startsWith(t))
      return !0;
  return !1;
}
function VS(e, t = "main") {
  const r = $3[t], n = Y.bytes(e);
  return pa(n, 20), n.toBech32(r, 0);
}
function uG(e) {
  if (!qS(e))
    throw new TypeError("Invalid segwit address!");
  return Y.bech32(e);
}
function cG(e) {
  const t = Y.bytes(e);
  return pa(t, 20), ["OP_0", t.hex];
}
function lG(e, t) {
  const r = Vm(e);
  return VS(r, t);
}
const GS = { check: qS, encode: VS, decode: uG, hash: Vm, scriptPubKey: cG, fromPubKey: lG }, fG = ["bc1q", "tb1q", "bcrt1q"];
function ZS(e) {
  for (const t of fG)
    if (e.startsWith(t))
      return !0;
  return !1;
}
function WS(e, t = "main") {
  const r = $3[t], n = Y.bytes(e);
  return pa(n, 32), n.toBech32(r, 0);
}
function dG(e) {
  if (!ZS(e))
    throw new TypeError("Invalid segwit address!");
  return Y.bech32(e);
}
function hG(e) {
  const t = Y.bytes(e);
  return pa(t, 32), ["OP_0", t.hex];
}
function pG(e, t) {
  const r = jS(e);
  return WS(r, t);
}
const XS = { check: ZS, encode: WS, decode: dG, hash: jS, scriptPubKey: hG, fromScript: pG };
function Mc(e) {
  const t = Y.bytes(e);
  return t.length > 32 ? t.slice(1, 33) : t;
}
const gG = ["bc1p", "tb1p", "bcrt1p"];
function YS(e) {
  for (const t of gG)
    if (e.startsWith(t))
      return !0;
  return !1;
}
function JS(e, t = "main") {
  const r = $3[t], n = Y.bytes(e);
  return pa(n, 32), n.toBech32(r, 1);
}
function mG(e) {
  if (!YS(e))
    throw new TypeError("Invalid taproot address!");
  return Y.bech32(e);
}
function yG(e) {
  const t = Y.bytes(e);
  return pa(t, 32), ["OP_1", t.hex];
}
function bG(e, t) {
  const r = Mc(e);
  return JS(r, t);
}
const QS = { check: YS, encode: JS, decode: mG, scriptPubKey: yG, fromPubKey: bG }, wG = {
  version: 2,
  vin: [],
  vout: [],
  locktime: 0
}, vG = {
  scriptSig: [],
  sequence: 4294967293,
  witness: []
}, EG = {
  value: 0n,
  scriptPubKey: []
};
function C3(e) {
  const t = { ...wG, ...e };
  return t.vin = t.vin.map((r) => ({ ...vG, ...r })), t.vout = t.vout.map((r) => ({ ...EG, ...r })), t;
}
function Sf(e, t) {
  const { version: r, vin: n, vout: o, locktime: a } = C3(e), i = t !== !0 && kG(n), s = [B3(r)];
  i && s.push(Y.hex("0001")), s.push(xG(n)), s.push(AG(o));
  for (const u of n)
    i && s.push(_G(u.witness));
  return s.push(N3(a)), Y.join(s);
}
function kG(e) {
  for (const t of e) {
    const { witness: r } = t;
    if (typeof r == "string" || r instanceof Uint8Array || Array.isArray(r) && r.length > 0)
      return !0;
  }
  return !1;
}
function B3(e) {
  return Y.num(e, 4).reverse();
}
function xp(e) {
  return Y.hex(e, 32).reverse();
}
function Ap(e) {
  return Y.num(e, 4).reverse();
}
function Sp(e) {
  if (typeof e == "string")
    return Y.hex(e, 4).reverse();
  if (typeof e == "number")
    return Y.num(e, 4).reverse();
  throw new Error("Unrecognized format: " + String(e));
}
function xG(e) {
  const t = [Y.varInt(e.length, "le")];
  for (const r of e) {
    const { txid: n, vout: o, scriptSig: a, sequence: i } = r;
    t.push(xp(n)), t.push(Ap(o)), t.push(sl(a, !0)), t.push(Sp(i));
  }
  return Y.join(t);
}
function Nu(e) {
  if (typeof e == "number") {
    if (e % 1 !== 0)
      throw new Error("Value must be an integer:" + String(e));
    return Y.num(e, 8).reverse();
  }
  return Y.big(e, 8).reverse();
}
function AG(e) {
  const t = [Y.varInt(e.length, "le")];
  for (const r of e)
    t.push(SG(r));
  return Y.join(t);
}
function SG(e) {
  const { value: t, scriptPubKey: r } = e, n = [];
  return n.push(Nu(t)), n.push(sl(r, !0)), Y.join(n);
}
function _G(e = []) {
  const t = [];
  if (Array.isArray(e)) {
    const r = Y.varInt(e.length);
    t.push(r);
    for (const n of e)
      t.push(IG(n));
    return Y.join(t);
  } else
    return Y.bytes(e);
}
function IG(e) {
  return TG(e) ? new Y(0) : sl(e, !0);
}
function TG(e) {
  if (Array.isArray(e))
    return e.length === 0;
  if (typeof e == "string" && e === "")
    return !0;
  const t = Y.bytes(e);
  return t.length === 1 && t[0] === 0;
}
function N3(e) {
  if (typeof e == "string")
    return Y.hex(e, 4);
  if (typeof e == "number")
    return Y.num(e, 4).reverse();
  throw new Error("Unrecognized format: " + String(e));
}
function U3(e) {
  typeof e == "string" && (e = Y.hex(e).raw);
  const t = new Yf(e), r = PG(t), n = OG(t), o = $G(t), a = BG(t);
  if (n)
    for (const s of o)
      s.witness = UG(t);
  const i = RG(t);
  return { version: r, vin: o, vout: a, locktime: i };
}
function PG(e) {
  return e.read(4).reverse().toNum();
}
function OG(e) {
  const [t, r] = [...e.peek(2)];
  if (t === 0) {
    if (e.read(2), r === 1)
      return !0;
    throw new Error(`Invalid witness flag: ${r}`);
  }
  return !1;
}
function $G(e) {
  const t = [], r = e.readSize("le");
  for (let n = 0; n < r; n++)
    t.push(CG(e));
  return t;
}
function CG(e) {
  return {
    txid: e.read(32).reverse().toHex(),
    vout: e.read(4).reverse().toNum(),
    scriptSig: t_(e),
    sequence: e.read(4).reverse().toHex(),
    witness: []
  };
}
function BG(e) {
  const t = [], r = e.readSize("le");
  for (let n = 0; n < r; n++)
    t.push(NG(e));
  return t;
}
function NG(e) {
  return {
    value: e.read(8).reverse().big,
    scriptPubKey: t_(e)
  };
}
function UG(e) {
  const t = [], r = e.readSize();
  for (let n = 0; n < r; n++) {
    const o = e_(e);
    t.push(o ?? "");
  }
  return t;
}
function e_(e, t) {
  const r = e.readSize("le");
  return r > 0 ? e.read(r).hex : null;
}
function t_(e, t) {
  const r = e_(e);
  return r !== null ? r : [];
}
function RG(e) {
  return e.read(4).reverse().toNum();
}
function zG(e) {
  if (NA(e))
    return U3(e);
  if (typeof e == "object" && !(e instanceof Uint8Array))
    return Sf(e), C3(e);
  throw new Error("Invalid format: " + typeof e);
}
function jG(e) {
  if (NA(e))
    return U3(e), Y.bytes(e);
  if (typeof e == "object")
    return Sf(e);
  throw new Error("Invalid format: " + typeof e);
}
const R3 = {
  toBytes: jG,
  toJson: zG
}, LG = [
  ["p2pkh", /^76a914(?<hash>\w{40})88ac$/],
  ["p2sh", /^a914(?<hash>\w{40})87$/],
  ["p2w-pkh", /^0014(?<hash>\w{40})$/],
  ["p2w-sh", /^0020(?<hash>\w{64})$/],
  ["p2tr", /^5120(?<hash>\w{64})$/]
], HG = [
  192,
  194,
  196,
  198,
  200,
  202,
  204,
  206,
  208,
  210,
  212,
  214,
  216,
  218,
  220,
  222,
  224,
  226,
  228,
  230,
  232,
  234,
  236,
  238,
  240,
  242,
  244,
  246,
  248,
  250,
  252,
  254,
  102,
  126,
  128,
  132,
  150,
  152,
  186,
  188,
  190
];
function FG(e) {
  let t = e.at(-1);
  return ps(t) && (t = Y.hex(t)), e.length > 1 && t instanceof Uint8Array && t[0] === 80 ? (e.pop(), Y.raw(t)) : null;
}
function DG(e) {
  let t = e.at(-1);
  return ps(t) && (t = Y.hex(t)), e.length > 1 && t instanceof Uint8Array && t.length > 32 && HG.includes(t[0] & 254) ? (e.pop(), Y.raw(t)) : null;
}
function MG(e) {
  if (e.length > 1) {
    const t = e.at(-1);
    try {
      const r = Hn.fmt.toBytes(t);
      return e.pop(), r;
    } catch {
      return null;
    }
  }
  return null;
}
function KG(e) {
  const t = [];
  for (const r of e)
    if (ps(r) || r instanceof Uint8Array || typeof r == "number")
      t.push(Y.bytes(r));
    else
      throw new Error("unrecognized value: " + String(r));
  return t;
}
function qG(e = []) {
  const t = [...e], r = FG(t), n = DG(t), o = MG(t), a = KG(t);
  return { annex: r, cblock: n, script: o, params: a };
}
function VG(e) {
  const t = Hn.fmt.toBytes(e, !1).hex;
  for (const [r, n] of LG) {
    const o = r, { groups: a } = n.exec(t) ?? {}, { hash: i } = a ?? {};
    if (ps(i))
      return { type: o, data: Y.hex(i) };
  }
  return { type: "raw", data: Y.hex(t) };
}
function GG(e) {
  const t = R3.toJson(e), r = Sf(t, !0);
  return Af(r).reverse().hex;
}
function ZG(e) {
  const t = R3.toJson(e), r = Sf(t, !0).length, n = Sf(t, !1).length, o = r * 3 + n, a = o % 4 > 0 ? 1 : 0, i = Math.floor(o / 4) + a;
  return { size: n, bsize: r, vsize: i, weight: o };
}
const pi = {
  create: C3,
  encode: Sf,
  decode: U3,
  fmt: R3,
  util: {
    getTxSize: ZG,
    getTxid: GG,
    readScriptPubKey: VG,
    readWitness: qG
  }
}, WG = [
  ["1", "p2pkh", "main", 20, "base58"],
  ["3", "p2sh", "main", 20, "base58"],
  ["m", "p2pkh", "testnet", 20, "base58"],
  ["n", "p2pkh", "testnet", 20, "base58"],
  ["2", "p2sh", "testnet", 20, "base58"],
  ["bc1q", "p2w-pkh", "main", 20, "bech32"],
  ["tb1q", "p2w-pkh", "testnet", 20, "bech32"],
  ["bcrt1q", "p2w-pkh", "regtest", 20, "bech32"],
  ["bc1q", "p2w-sh", "main", 32, "bech32"],
  ["tb1q", "p2w-sh", "testnet", 32, "bech32"],
  ["bcrt1q", "p2w-sh", "regtest", 32, "bech32"],
  ["bc1p", "p2tr", "main", 32, "bech32m"],
  ["tb1p", "p2tr", "testnet", 32, "bech32m"],
  ["bcrt1p", "p2tr", "regtest", 32, "bech32m"]
];
function XG(e, t) {
  switch (t) {
    case "base58":
      return Y.b58chk(e).slice(1);
    case "bech32":
      return Y.bech32(e);
    case "bech32m":
      return Y.bech32(e);
    default:
      throw new Error("Invalid address format: " + t);
  }
}
function YG(e) {
  for (const t of WG) {
    const [r, n, o, a, i] = t;
    if (e.startsWith(r) && XG(e, i).length === a)
      return t;
  }
  throw new Error("Invalid address: " + e);
}
function r_(e) {
  switch (e) {
    case "p2pkh":
      return FS;
    case "p2sh":
      return KS;
    case "p2w-pkh":
      return GS;
    case "p2w-sh":
      return XS;
    case "p2tr":
      return QS;
    default:
      throw new Error("Invalid address type: " + e);
  }
}
function n_(e) {
  const [t, r, n] = YG(e), o = r_(r), a = o.decode(e, n), i = o.scriptPubKey(a);
  return { prefix: t, type: r, network: n, data: a, script: i };
}
function JG(e, t) {
  const { type: r, data: n } = pi.util.readScriptPubKey(e);
  return r_(r).encode(n, t);
}
function QG(e) {
  const { script: t } = n_(e);
  return Hn.fmt.toAsm(t, !1);
}
const o_ = {
  p2pkh: FS,
  p2sh: KS,
  p2wpkh: GS,
  p2wsh: XS,
  p2tr: QS,
  decode: n_,
  fromScriptPubKey: JG,
  toScriptPubKey: QG
}, eZ = [1, 2, 3];
function z3(e, t, r = {}) {
  const { sigflag: n = 1 } = r, o = (n & 128) === 128, a = n % 128;
  if (!eZ.includes(a))
    throw new Error("Invalid hash type: " + String(n));
  const i = pi.fmt.toJson(e), { version: s, vin: u, vout: l, locktime: c } = i, { txid: f, vout: h, prevout: p, sequence: y } = u[t], { value: m } = p ?? {};
  if (m === void 0)
    throw new Error("Prevout value is empty!");
  let b = r.script;
  if (b === void 0 && r.pubkey !== void 0 && (b = `76a914${P3(r.pubkey).hex}88ac`), b === void 0)
    throw new Error("No pubkey / script has been set!");
  if (Hn.fmt.toAsm(b).includes("OP_CODESEPARATOR"))
    throw new Error("This library does not currently support the use of OP_CODESEPARATOR in segwit scripts.");
  const v = [
    B3(s),
    tZ(u, o),
    rZ(u, a, o),
    xp(f),
    Ap(h),
    Hn.encode(b, !0),
    Nu(m),
    Sp(y),
    nZ(l, t, a),
    N3(c),
    Y.num(n, 4).reverse()
  ];
  return Af(Y.join(v));
}
function tZ(e, t) {
  if (t === !0)
    return Y.num(0, 32);
  const r = [];
  for (const { txid: n, vout: o } of e)
    r.push(xp(n)), r.push(Ap(o));
  return Af(Y.join(r));
}
function rZ(e, t, r) {
  if (r || t !== 1)
    return Y.num(0, 32);
  const n = [];
  for (const { sequence: o } of e)
    n.push(Sp(o));
  return Af(Y.join(n));
}
function nZ(e, t, r) {
  const n = [];
  if (r === 1) {
    for (const { value: o, scriptPubKey: a } of e)
      n.push(Nu(o)), n.push(Hn.encode(a, !0));
    return Af(Y.join(n));
  }
  if (r === 3 && t < e.length) {
    const { value: o, scriptPubKey: a } = e[t];
    return n.push(Nu(o)), n.push(Hn.encode(a, !0)), Af(Y.join(n));
  }
  return Y.num(0, 32);
}
function oZ(e, t, r, n = {}) {
  const { sigflag: o = 1 } = n, a = z3(t, r, n), i = RS.secp.sign(a, e).toDERRawBytes(!0);
  return Y.join([i, o]);
}
function iZ(e, t, r = {}) {
  const n = pi.fmt.toJson(e), { throws: o = !1 } = r, { witness: a = [] } = n.vin[t], i = pi.util.readWitness(a), { script: s, params: u } = i;
  let l = null;
  if (u.length < 1)
    return wn("Invalid witness data: " + String(a), o);
  if (r.script === void 0 && s !== null && (r.script = s), r.pubkey !== void 0)
    l = Y.bytes(r.pubkey);
  else if (u.length > 1 && u[1].length === 33)
    l = Y.bytes(u[1]);
  else
    return wn("No pubkey provided!", o);
  const c = Hn.fmt.toParam(u[0]), f = c.slice(0, -1), h = c.slice(-1)[0], p = z3(n, t, { ...r, sigflag: h });
  return RS.secp.verify(f, p, l) ? !0 : wn("Invalid signature!", o);
}
const aZ = {
  hash: z3,
  sign: oZ,
  verify: iZ
}, sZ = [0, 1, 2, 3, 129, 130, 131];
function j3(e, t, r = {}) {
  const { extension: n, sigflag: o = 0, extflag: a = 0, key_version: i = 0, separator_pos: s = 4294967295 } = r, u = pi.fmt.toJson(e), { version: l, vin: c, vout: f, locktime: h } = u;
  if (t >= c.length)
    throw new Error("Index out of bounds: " + String(t));
  if (!sZ.includes(o))
    throw new Error("Invalid hash type: " + String(o));
  if (a < 0 || a > 127)
    throw new Error("Extention flag out of range: " + String(a));
  const { txid: p, vout: y, sequence: m, witness: b = [] } = c[t], v = (o & 128) === 128, k = pZ(b), E = k !== void 0 ? 1 : 0, A = (a + (n !== void 0 ? 1 : 0)) * 2 + E, S = Y.str("TapSighash").digest, _ = [
    S,
    S,
    Y.num(0, 1),
    Y.num(o, 1),
    B3(l),
    N3(h)
  ];
  if (!v) {
    const I = c.map((O) => SE(O));
    _.push(uZ(c), lZ(I), fZ(I), cZ(c));
  }
  if (((o & 3) < 2 || (o & 3) > 3) && _.push(dZ(f)), _.push(Y.num(A, 1)), v) {
    const { value: I, scriptPubKey: O } = SE(c[t]);
    _.push(xp(p), Ap(y), Nu(I), Hn.encode(O, !0), Sp(m));
  } else
    _.push(Y.num(t, 4).reverse());
  return k !== void 0 && _.push(k), (o & 3) === 3 && _.push(hZ(f[t])), n !== void 0 && _.push(Y.bytes(n), Y.num(i), Y.num(s, 4)), Y.join(_).digest;
}
function uZ(e) {
  const t = [];
  for (const { txid: r, vout: n } of e)
    t.push(xp(r)), t.push(Ap(n));
  return Y.join(t).digest;
}
function cZ(e) {
  const t = [];
  for (const { sequence: r } of e)
    t.push(Sp(r));
  return Y.join(t).digest;
}
function lZ(e) {
  const t = [];
  for (const { value: r } of e)
    t.push(Nu(r));
  return Y.join(t).digest;
}
function fZ(e) {
  const t = [];
  for (const { scriptPubKey: r } of e)
    t.push(sl(r, !0));
  return Y.join(t).digest;
}
function dZ(e) {
  const t = [];
  for (const { value: r, scriptPubKey: n } of e)
    t.push(Nu(r)), t.push(Hn.encode(n, !0));
  return Y.join(t).digest;
}
function hZ(e) {
  return Y.join([
    Nu(e.value),
    Hn.encode(e.scriptPubKey, !0)
  ]).digest;
}
function pZ(e) {
  if (e === void 0 || e.length < 2)
    return;
  let t = e.at(-1);
  if (typeof t == "string" && (t = Y.hex(t)), t instanceof Uint8Array && t[0] === 80)
    return Y.raw(t).prefixSize("be").digest;
}
function SE(e) {
  if (e.prevout === void 0)
    throw new Error("Prevout data missing for input: " + String(e.txid));
  return e.prevout;
}
const gZ = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn, mZ = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
function yZ(e, t, r, n = {}) {
  const { sigflag: o = 0 } = n, a = j3(t, r, n), i = bZ(e, a);
  return o === 0 ? Y.raw(i) : Y.join([i, o]);
}
function bZ(e, t, r = Y.random(32)) {
  const n = Y.bytes(t), o = new Bn(e), a = o.point, i = a.hasEvenY ? o.big : o.negated.big, s = w1("BIP0340/aux", Y.bytes(r)), u = i ^ s.big, l = w1("BIP0340/nonce", u, a.x.raw, n), c = new Bn(l), f = c.point, h = f.hasEvenY ? c.big : c.negated.big, p = new Bn(w1("BIP0340/challenge", f.x.raw, a.x.raw, n)), y = new Bn(h + p.big * i);
  return Y.join([f.x.raw, y.raw]);
}
function wZ(e, t, r, n = !1) {
  const o = ul.from_x(Mc(r)), a = Y.bytes(t), i = Y.bytes(e).stream;
  i.size < 64 && wn("Signature length is too small: " + String(i.size), n);
  const s = i.read(32);
  s.big > gZ && wn("Signature r value greater than field size!", n);
  const u = i.read(32);
  u.big > mZ && wn("Signature s value greater than curve order!", n);
  const l = new Bn(w1("BIP0340/challenge", s.raw, o.x.raw, a)), c = new Bn(u).point, f = o.mul(l.big), h = c.sub(f);
  return h.hasOddY && wn("Signature R value has odd Y coordinate!", n), h.x.big === 0n && wn("Signature R value is infinite!", n), h.x.big === s.big;
}
const vZ = 192;
function Gm(e) {
  const t = Y.str(e).digest;
  return Y.join([t, t]);
}
function L3(e, t = vZ) {
  return Y.join([
    Gm("TapLeaf"),
    xZ(t),
    Y.bytes(e)
  ]).digest.hex;
}
function EZ(e, t) {
  return L3(Hn.fmt.toBytes(e), t);
}
function H3(e, t) {
  return t < e && ([e, t] = [t, e]), Y.join([
    Gm("TapBranch"),
    Y.hex(e).raw,
    Y.hex(t).raw
  ]).digest.hex;
}
function kZ(e) {
  return Y.hex(cg(e)[0]);
}
function cg(e, t, r = []) {
  const n = [], o = [];
  if (e.length < 1)
    throw new Error("Tree is empty!");
  for (let a = 0; a < e.length; a++) {
    const i = e[a];
    if (Array.isArray(i)) {
      const [s, u, l] = cg(i, t);
      t = u, n.push(s);
      for (const c of l)
        r.push(c);
    } else
      n.push(i);
  }
  if (n.length === 1)
    return [n[0], t, r];
  n.sort(), n.length % 2 !== 0 && n.push(n[n.length - 1]);
  for (let a = 0; a < n.length - 1; a += 2) {
    const i = H3(n[a], n[a + 1]);
    o.push(i), typeof t == "string" && (t === n[a] ? (r.push(n[a + 1]), t = i) : t === n[a + 1] && (r.push(n[a]), t = i));
  }
  return cg(o, t, r);
}
function xZ(e = 192) {
  return e & 254;
}
function i_(e, t = new Uint8Array(), r = !1) {
  const n = r ? new Bn(e).point.x.raw : Mc(e);
  return Y.join([Gm("TapTweak"), n, Y.bytes(t)]).digest;
}
function of(e, t, r = !1) {
  t === void 0 && (t = new Uint8Array());
  const n = Y.bytes(e), o = i_(e, t, r);
  return r ? a_(n, o) : s_(n, o);
}
function AZ(e, t) {
  return of(e, t);
}
function SZ(e, t) {
  return of(e, t, !0);
}
function a_(e, t) {
  let r = new Bn(e);
  return r.point.hasOddY && (r = r.negate()), Y.raw(r.add(t).raw);
}
function s_(e, t) {
  e = Mc(e);
  const r = ul.from_x(e).add(t);
  return Y.raw(r.raw);
}
function _Z() {
  const e = Y.hex("0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8");
  return ul.from_x(e.digest).x;
}
const IZ = _Z(), TZ = 192;
function PZ(e, t = {}) {
  return u_(e, { ...t, isPrivate: !0 });
}
function OZ(e, t = {}) {
  return u_(e, { ...t, isPrivate: !1 });
}
function u_(e, t = {}) {
  const { isPrivate: r = !1, tree: n = [], version: o = TZ } = t, a = r ? rv.getPublicKey(e, !0) : Mc(e);
  let { target: i } = t;
  i !== void 0 && (i = Y.bytes(i).hex);
  let s, u = [];
  if (n.length > 0) {
    const [h, p, y] = cg(n, i);
    u = y, s = of(e, h, r);
  } else
    i !== void 0 ? s = of(e, i, r) : s = of(e, void 0, r);
  const l = r ? rv.getPublicKey(s)[0] : s[0], c = [Y.num(o + l_(l)), a];
  u.length > 0 && u.forEach((h) => c.push(Y.hex(h)));
  const f = Y.join(c);
  if (i !== void 0 && !F3(s, i, f, t))
    throw new Error("Path checking failed! Unable to generate path.");
  return [Mc(s).hex, f.hex];
}
function F3(e, t, r, n = {}) {
  const { isPrivate: o = !1, throws: a = !1 } = n, { parity: i, paths: s, intkey: u } = c_(r), l = o ? rv.getPublicKey(e, !0) : Mc(e), c = Y.join([i, l]);
  if (c.length !== 33)
    return wn("Invalid tapkey: " + c.hex, a);
  let f = Y.bytes(t).hex;
  for (const p of s)
    f = H3(f, p);
  const h = of(u, f);
  return Y.raw(h).hex === Y.raw(c).hex;
}
function c_(e) {
  const t = new Yf(Y.bytes(e)), r = t.read(1).num, n = t.read(32), [o, a] = r % 2 === 0 ? [r, 2] : [r - 1, 3], i = [];
  for (; t.size >= 32; )
    i.push(t.read(32).hex);
  if (t.size !== 0)
    throw new Error("Non-empty buffer on control block: " + String(t));
  return { intkey: n, paths: i, parity: a, version: o };
}
function l_(e = 2) {
  if (e === 0 || e === 1)
    return e;
  if (e === 2 || e === "02")
    return 0;
  if (e === 3 || e === "03")
    return 1;
  throw new Error("Invalid parity bit: " + String(e));
}
function $Z(e, t, r = {}) {
  const n = pi.fmt.toJson(e), { throws: o = !1 } = r, { prevout: a, witness: i = [] } = n.vin[t], s = pi.util.readWitness(i), { cblock: u, script: l, params: c } = s;
  let f;
  if (c.length < 1)
    return wn("Invalid witness data: " + String(i), o);
  const { scriptPubKey: h } = a ?? {};
  if (h === void 0)
    return wn("Prevout scriptPubKey is empty!", o);
  const { type: p, data: y } = pi.util.readScriptPubKey(h);
  if (p !== "p2tr")
    return wn("Prevout script is not a valid taproot output:" + y.hex, o);
  if (y.length !== 32)
    return wn("Invalid tapkey length: " + String(y.length), o);
  if (u !== null && l !== null) {
    const E = u[0] & 254, A = L3(l, E);
    if (r.extension = A, !F3(y, A, u, { throws: o }))
      return wn("cblock verification failed!", o);
  }
  r.pubkey !== void 0 ? f = Y.bytes(r.pubkey) : c.length > 1 && c[1].length === 32 ? f = Y.bytes(c[1]) : f = Y.bytes(y);
  const m = Hn.fmt.toParam(c[0]), b = new Yf(m), v = b.read(64).raw;
  if (b.size === 1 && (r.sigflag = b.read(1).num, r.sigflag === 0))
    return wn("0x00 is not a valid appended sigflag!", o);
  const k = j3(n, t, r);
  return wZ(v, k, f, o) ? !0 : wn("Invalid signature!", o);
}
const CZ = {
  hash: j3,
  sign: yZ,
  verify: $Z
}, BZ = {
  segwit: aZ,
  taproot: CZ
}, NZ = {
  getTag: Gm,
  getLeaf: L3,
  getBranch: H3,
  getRoot: kZ
}, UZ = {
  readCtrlBlock: c_,
  readParityBit: l_
}, RZ = {
  getPubKey: AZ,
  getSecKey: SZ,
  getTweak: i_,
  tweakSecKey: a_,
  tweakPubKey: s_
}, lg = {
  getPubKey: OZ,
  getSecKey: PZ,
  encodeScript: EZ,
  checkPath: F3,
  tree: NZ,
  tweak: RZ,
  util: UZ,
  SCRIPT_PUBKEY: IZ
};
var Bt;
(function(e) {
  e.assertEqual = (o) => o;
  function t(o) {
  }
  e.assertIs = t;
  function r(o) {
    throw new Error();
  }
  e.assertNever = r, e.arrayToEnum = (o) => {
    const a = {};
    for (const i of o)
      a[i] = i;
    return a;
  }, e.getValidEnumValues = (o) => {
    const a = e.objectKeys(o).filter((s) => typeof o[o[s]] != "number"), i = {};
    for (const s of a)
      i[s] = o[s];
    return e.objectValues(i);
  }, e.objectValues = (o) => e.objectKeys(o).map(function(a) {
    return o[a];
  }), e.objectKeys = typeof Object.keys == "function" ? (o) => Object.keys(o) : (o) => {
    const a = [];
    for (const i in o)
      Object.prototype.hasOwnProperty.call(o, i) && a.push(i);
    return a;
  }, e.find = (o, a) => {
    for (const i of o)
      if (a(i))
        return i;
  }, e.isInteger = typeof Number.isInteger == "function" ? (o) => Number.isInteger(o) : (o) => typeof o == "number" && isFinite(o) && Math.floor(o) === o;
  function n(o, a = " | ") {
    return o.map((i) => typeof i == "string" ? `'${i}'` : i).join(a);
  }
  e.joinValues = n, e.jsonStringifyReplacer = (o, a) => typeof a == "bigint" ? a.toString() : a;
})(Bt || (Bt = {}));
var nv;
(function(e) {
  e.mergeShapes = (t, r) => ({
    ...t,
    ...r
    // second overwrites first
  });
})(nv || (nv = {}));
const ge = Bt.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), xu = (e) => {
  switch (typeof e) {
    case "undefined":
      return ge.undefined;
    case "string":
      return ge.string;
    case "number":
      return isNaN(e) ? ge.nan : ge.number;
    case "boolean":
      return ge.boolean;
    case "function":
      return ge.function;
    case "bigint":
      return ge.bigint;
    case "symbol":
      return ge.symbol;
    case "object":
      return Array.isArray(e) ? ge.array : e === null ? ge.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? ge.promise : typeof Map < "u" && e instanceof Map ? ge.map : typeof Set < "u" && e instanceof Set ? ge.set : typeof Date < "u" && e instanceof Date ? ge.date : ge.object;
    default:
      return ge.unknown;
  }
}, ue = Bt.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), zZ = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
let gi = class extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(a) {
      return a.message;
    }, n = { _errors: [] }, o = (a) => {
      for (const i of a.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(o);
        else if (i.code === "invalid_return_type")
          o(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          o(i.argumentsError);
        else if (i.path.length === 0)
          n._errors.push(r(i));
        else {
          let s = n, u = 0;
          for (; u < i.path.length; ) {
            const l = i.path[u];
            u === i.path.length - 1 ? (s[l] = s[l] || { _errors: [] }, s[l]._errors.push(r(i))) : s[l] = s[l] || { _errors: [] }, s = s[l], u++;
          }
        }
    };
    return o(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Bt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, n = [];
    for (const o of this.issues)
      o.path.length > 0 ? (r[o.path[0]] = r[o.path[0]] || [], r[o.path[0]].push(t(o))) : n.push(t(o));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
};
gi.create = (e) => new gi(e);
const xh = (e, t) => {
  let r;
  switch (e.code) {
    case ue.invalid_type:
      e.received === ge.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case ue.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, Bt.jsonStringifyReplacer)}`;
      break;
    case ue.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Bt.joinValues(e.keys, ", ")}`;
      break;
    case ue.invalid_union:
      r = "Invalid input";
      break;
    case ue.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Bt.joinValues(e.options)}`;
      break;
    case ue.invalid_enum_value:
      r = `Invalid enum value. Expected ${Bt.joinValues(e.options)}, received '${e.received}'`;
      break;
    case ue.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case ue.invalid_return_type:
      r = "Invalid function return type";
      break;
    case ue.invalid_date:
      r = "Invalid date";
      break;
    case ue.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : Bt.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case ue.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case ue.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case ue.custom:
      r = "Invalid input";
      break;
    case ue.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case ue.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case ue.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, Bt.assertNever(e);
  }
  return { message: r };
};
let f_ = xh;
function jZ(e) {
  f_ = e;
}
function fg() {
  return f_;
}
const dg = (e) => {
  const { data: t, path: r, errorMaps: n, issueData: o } = e, a = [...r, ...o.path || []], i = {
    ...o,
    path: a
  };
  let s = "";
  const u = n.filter((l) => !!l).slice().reverse();
  for (const l of u)
    s = l(i, { data: t, defaultError: s }).message;
  return {
    ...o,
    path: a,
    message: o.message || s
  };
}, LZ = [];
function ve(e, t) {
  const r = dg({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      fg(),
      xh
      // then global default map
    ].filter((n) => !!n)
  });
  e.common.issues.push(r);
}
let io = class d_ {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, r) {
    const n = [];
    for (const o of r) {
      if (o.status === "aborted")
        return nt;
      o.status === "dirty" && t.dirty(), n.push(o.value);
    }
    return { status: t.value, value: n };
  }
  static async mergeObjectAsync(t, r) {
    const n = [];
    for (const o of r)
      n.push({
        key: await o.key,
        value: await o.value
      });
    return d_.mergeObjectSync(t, n);
  }
  static mergeObjectSync(t, r) {
    const n = {};
    for (const o of r) {
      const { key: a, value: i } = o;
      if (a.status === "aborted" || i.status === "aborted")
        return nt;
      a.status === "dirty" && t.dirty(), i.status === "dirty" && t.dirty(), (typeof i.value < "u" || o.alwaysSet) && (n[a.value] = i.value);
    }
    return { status: t.value, value: n };
  }
};
const nt = Object.freeze({
  status: "aborted"
}), h_ = (e) => ({ status: "dirty", value: e }), Fn = (e) => ({ status: "valid", value: e }), ov = (e) => e.status === "aborted", iv = (e) => e.status === "dirty", hg = (e) => e.status === "valid", pg = (e) => typeof Promise < "u" && e instanceof Promise;
var Ne;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(Ne || (Ne = {}));
let fa = class {
  constructor(t, r, n, o) {
    this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = o;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
const _E = (e, t) => {
  if (hg(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new gi(e.common.issues);
      return this._error = r, this._error;
    }
  };
};
function ht(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: r, required_error: n, description: o } = e;
  if (t && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: o } : { errorMap: (a, i) => a.code !== "invalid_type" ? { message: i.defaultError } : typeof i.data > "u" ? { message: n ?? i.defaultError } : { message: r ?? i.defaultError }, description: o };
}
let _t = class {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return xu(t.data);
  }
  _getOrReturnCtx(t, r) {
    return r || {
      common: t.parent.common,
      data: t.data,
      parsedType: xu(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new io(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: xu(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const r = this._parse(t);
    if (pg(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(t) {
    const r = this._parse(t);
    return Promise.resolve(r);
  }
  parse(t, r) {
    const n = this.safeParse(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(t, r) {
    var n;
    const o = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: xu(t)
    }, a = this._parseSync({ data: t, path: o.path, parent: o });
    return _E(o, a);
  }
  async parseAsync(t, r) {
    const n = await this.safeParseAsync(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(t, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: !0
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: xu(t)
    }, o = this._parse({ data: t, path: n.path, parent: n }), a = await (pg(o) ? o : Promise.resolve(o));
    return _E(n, a);
  }
  refine(t, r) {
    const n = (o) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(o) : r;
    return this._refinement((o, a) => {
      const i = t(o), s = () => a.addIssue({
        code: ue.custom,
        ...n(o)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((u) => u ? !0 : (s(), !1)) : i ? !0 : (s(), !1);
    });
  }
  refinement(t, r) {
    return this._refinement((n, o) => t(n) ? !0 : (o.addIssue(typeof r == "function" ? r(n, o) : r), !1));
  }
  _refinement(t) {
    return new Ai({
      schema: this,
      typeName: Fe.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Ja.create(this, this._def);
  }
  nullable() {
    return Kc.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return mi.create(this, this._def);
  }
  promise() {
    return Tf.create(this, this._def);
  }
  or(t) {
    return Oh.create([this, t], this._def);
  }
  and(t) {
    return $h.create(this, t, this._def);
  }
  transform(t) {
    return new Ai({
      ...ht(this._def),
      schema: this,
      typeName: Fe.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const r = typeof t == "function" ? t : () => t;
    return new Uh({
      ...ht(this._def),
      innerType: this,
      defaultValue: r,
      typeName: Fe.ZodDefault
    });
  }
  brand() {
    return new E_({
      typeName: Fe.ZodBranded,
      type: this,
      ...ht(this._def)
    });
  }
  catch(t) {
    const r = typeof t == "function" ? t : () => t;
    return new wg({
      ...ht(this._def),
      innerType: this,
      catchValue: r,
      typeName: Fe.ZodCatch
    });
  }
  describe(t) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return D3.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const HZ = /^c[^\s-]{8,}$/i, FZ = /^[a-z][a-z0-9]*$/, DZ = /[0-9A-HJKMNP-TV-Z]{26}/, MZ = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, KZ = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, qZ = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u"), VZ = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, GZ = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, ZZ = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function WZ(e, t) {
  return !!((t === "v4" || !t) && VZ.test(e) || (t === "v6" || !t) && GZ.test(e));
}
let _f = class Jd extends _t {
  constructor() {
    super(...arguments), this._regex = (t, r, n) => this.refinement((o) => t.test(o), {
      validation: r,
      code: ue.invalid_string,
      ...Ne.errToObj(n)
    }), this.nonempty = (t) => this.min(1, Ne.errToObj(t)), this.trim = () => new Jd({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new Jd({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new Jd({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== ge.string) {
      const o = this._getOrReturnCtx(t);
      return ve(
        o,
        {
          code: ue.invalid_type,
          expected: ge.string,
          received: o.parsedType
        }
        //
      ), nt;
    }
    const r = new io();
    let n;
    for (const o of this._def.checks)
      if (o.kind === "min")
        t.data.length < o.value && (n = this._getOrReturnCtx(t, n), ve(n, {
          code: ue.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), r.dirty());
      else if (o.kind === "max")
        t.data.length > o.value && (n = this._getOrReturnCtx(t, n), ve(n, {
          code: ue.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), r.dirty());
      else if (o.kind === "length") {
        const a = t.data.length > o.value, i = t.data.length < o.value;
        (a || i) && (n = this._getOrReturnCtx(t, n), a ? ve(n, {
          code: ue.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }) : i && ve(n, {
          code: ue.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }), r.dirty());
      } else if (o.kind === "email")
        KZ.test(t.data) || (n = this._getOrReturnCtx(t, n), ve(n, {
          validation: "email",
          code: ue.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "emoji")
        qZ.test(t.data) || (n = this._getOrReturnCtx(t, n), ve(n, {
          validation: "emoji",
          code: ue.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "uuid")
        MZ.test(t.data) || (n = this._getOrReturnCtx(t, n), ve(n, {
          validation: "uuid",
          code: ue.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "cuid")
        HZ.test(t.data) || (n = this._getOrReturnCtx(t, n), ve(n, {
          validation: "cuid",
          code: ue.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "cuid2")
        FZ.test(t.data) || (n = this._getOrReturnCtx(t, n), ve(n, {
          validation: "cuid2",
          code: ue.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "ulid")
        DZ.test(t.data) || (n = this._getOrReturnCtx(t, n), ve(n, {
          validation: "ulid",
          code: ue.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "url")
        try {
          new URL(t.data);
        } catch {
          n = this._getOrReturnCtx(t, n), ve(n, {
            validation: "url",
            code: ue.invalid_string,
            message: o.message
          }), r.dirty();
        }
      else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (n = this._getOrReturnCtx(t, n), ve(n, {
        validation: "regex",
        code: ue.invalid_string,
        message: o.message
      }), r.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (n = this._getOrReturnCtx(t, n), ve(n, {
        code: ue.invalid_string,
        validation: { includes: o.value, position: o.position },
        message: o.message
      }), r.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (n = this._getOrReturnCtx(t, n), ve(n, {
        code: ue.invalid_string,
        validation: { startsWith: o.value },
        message: o.message
      }), r.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (n = this._getOrReturnCtx(t, n), ve(n, {
        code: ue.invalid_string,
        validation: { endsWith: o.value },
        message: o.message
      }), r.dirty()) : o.kind === "datetime" ? ZZ(o).test(t.data) || (n = this._getOrReturnCtx(t, n), ve(n, {
        code: ue.invalid_string,
        validation: "datetime",
        message: o.message
      }), r.dirty()) : o.kind === "ip" ? WZ(t.data, o.version) || (n = this._getOrReturnCtx(t, n), ve(n, {
        validation: "ip",
        code: ue.invalid_string,
        message: o.message
      }), r.dirty()) : Bt.assertNever(o);
    return { status: r.value, value: t.data };
  }
  _addCheck(t) {
    return new Jd({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Ne.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Ne.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Ne.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Ne.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Ne.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Ne.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Ne.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Ne.errToObj(t) });
  }
  datetime(t) {
    var r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
      ...Ne.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, r) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...Ne.errToObj(r)
    });
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r == null ? void 0 : r.position,
      ...Ne.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(t, r) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...Ne.errToObj(r)
    });
  }
  endsWith(t, r) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...Ne.errToObj(r)
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...Ne.errToObj(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...Ne.errToObj(r)
    });
  }
  length(t, r) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...Ne.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
};
_f.create = (e) => {
  var t;
  return new _f({
    checks: [],
    typeName: Fe.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...ht(e)
  });
};
function XZ(e, t) {
  const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, o = r > n ? r : n, a = parseInt(e.toFixed(o).replace(".", "")), i = parseInt(t.toFixed(o).replace(".", ""));
  return a % i / Math.pow(10, o);
}
let Ah = class av extends _t {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== ge.number) {
      const o = this._getOrReturnCtx(t);
      return ve(o, {
        code: ue.invalid_type,
        expected: ge.number,
        received: o.parsedType
      }), nt;
    }
    let r;
    const n = new io();
    for (const o of this._def.checks)
      o.kind === "int" ? Bt.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ue.invalid_type,
        expected: "integer",
        received: "float",
        message: o.message
      }), n.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ue.too_small,
        minimum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), n.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ue.too_big,
        maximum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), n.dirty()) : o.kind === "multipleOf" ? XZ(t.data, o.value) !== 0 && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ue.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), n.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ue.not_finite,
        message: o.message
      }), n.dirty()) : Bt.assertNever(o);
    return { status: n.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, Ne.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, Ne.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, Ne.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, Ne.toString(r));
  }
  setLimit(t, r, n, o) {
    return new av({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: Ne.toString(o)
        }
      ]
    });
  }
  _addCheck(t) {
    return new av({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: Ne.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Ne.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Ne.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Ne.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Ne.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Ne.toString(r)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: Ne.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Ne.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Ne.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && Bt.isInteger(t.value));
  }
  get isFinite() {
    let t = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(t);
  }
};
Ah.create = (e) => new Ah({
  checks: [],
  typeName: Fe.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...ht(e)
});
let Sh = class sv extends _t {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== ge.bigint) {
      const o = this._getOrReturnCtx(t);
      return ve(o, {
        code: ue.invalid_type,
        expected: ge.bigint,
        received: o.parsedType
      }), nt;
    }
    let r;
    const n = new io();
    for (const o of this._def.checks)
      o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ue.too_small,
        type: "bigint",
        minimum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), n.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ue.too_big,
        type: "bigint",
        maximum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), n.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ue.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), n.dirty()) : Bt.assertNever(o);
    return { status: n.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, Ne.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, Ne.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, Ne.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, Ne.toString(r));
  }
  setLimit(t, r, n, o) {
    return new sv({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: Ne.toString(o)
        }
      ]
    });
  }
  _addCheck(t) {
    return new sv({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Ne.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Ne.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Ne.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Ne.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Ne.toString(r)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
};
Sh.create = (e) => {
  var t;
  return new Sh({
    checks: [],
    typeName: Fe.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...ht(e)
  });
};
let _h = class extends _t {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== ge.boolean) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: ue.invalid_type,
        expected: ge.boolean,
        received: r.parsedType
      }), nt;
    }
    return Fn(t.data);
  }
};
_h.create = (e) => new _h({
  typeName: Fe.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...ht(e)
});
let Ih = class p_ extends _t {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== ge.date) {
      const o = this._getOrReturnCtx(t);
      return ve(o, {
        code: ue.invalid_type,
        expected: ge.date,
        received: o.parsedType
      }), nt;
    }
    if (isNaN(t.data.getTime())) {
      const o = this._getOrReturnCtx(t);
      return ve(o, {
        code: ue.invalid_date
      }), nt;
    }
    const r = new io();
    let n;
    for (const o of this._def.checks)
      o.kind === "min" ? t.data.getTime() < o.value && (n = this._getOrReturnCtx(t, n), ve(n, {
        code: ue.too_small,
        message: o.message,
        inclusive: !0,
        exact: !1,
        minimum: o.value,
        type: "date"
      }), r.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (n = this._getOrReturnCtx(t, n), ve(n, {
        code: ue.too_big,
        message: o.message,
        inclusive: !0,
        exact: !1,
        maximum: o.value,
        type: "date"
      }), r.dirty()) : Bt.assertNever(o);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new p_({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Ne.toString(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Ne.toString(r)
    });
  }
  get minDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
};
Ih.create = (e) => new Ih({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: Fe.ZodDate,
  ...ht(e)
});
let gg = class extends _t {
  _parse(t) {
    if (this._getType(t) !== ge.symbol) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: ue.invalid_type,
        expected: ge.symbol,
        received: r.parsedType
      }), nt;
    }
    return Fn(t.data);
  }
};
gg.create = (e) => new gg({
  typeName: Fe.ZodSymbol,
  ...ht(e)
});
let Th = class extends _t {
  _parse(t) {
    if (this._getType(t) !== ge.undefined) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: ue.invalid_type,
        expected: ge.undefined,
        received: r.parsedType
      }), nt;
    }
    return Fn(t.data);
  }
};
Th.create = (e) => new Th({
  typeName: Fe.ZodUndefined,
  ...ht(e)
});
let Ph = class extends _t {
  _parse(t) {
    if (this._getType(t) !== ge.null) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: ue.invalid_type,
        expected: ge.null,
        received: r.parsedType
      }), nt;
    }
    return Fn(t.data);
  }
};
Ph.create = (e) => new Ph({
  typeName: Fe.ZodNull,
  ...ht(e)
});
let If = class extends _t {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Fn(t.data);
  }
};
If.create = (e) => new If({
  typeName: Fe.ZodAny,
  ...ht(e)
});
let Cc = class extends _t {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Fn(t.data);
  }
};
Cc.create = (e) => new Cc({
  typeName: Fe.ZodUnknown,
  ...ht(e)
});
let is = class extends _t {
  _parse(t) {
    const r = this._getOrReturnCtx(t);
    return ve(r, {
      code: ue.invalid_type,
      expected: ge.never,
      received: r.parsedType
    }), nt;
  }
};
is.create = (e) => new is({
  typeName: Fe.ZodNever,
  ...ht(e)
});
let mg = class extends _t {
  _parse(t) {
    if (this._getType(t) !== ge.undefined) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: ue.invalid_type,
        expected: ge.void,
        received: r.parsedType
      }), nt;
    }
    return Fn(t.data);
  }
};
mg.create = (e) => new mg({
  typeName: Fe.ZodVoid,
  ...ht(e)
});
class mi extends _t {
  _parse(t) {
    const { ctx: r, status: n } = this._processInputParams(t), o = this._def;
    if (r.parsedType !== ge.array)
      return ve(r, {
        code: ue.invalid_type,
        expected: ge.array,
        received: r.parsedType
      }), nt;
    if (o.exactLength !== null) {
      const i = r.data.length > o.exactLength.value, s = r.data.length < o.exactLength.value;
      (i || s) && (ve(r, {
        code: i ? ue.too_big : ue.too_small,
        minimum: s ? o.exactLength.value : void 0,
        maximum: i ? o.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: o.exactLength.message
      }), n.dirty());
    }
    if (o.minLength !== null && r.data.length < o.minLength.value && (ve(r, {
      code: ue.too_small,
      minimum: o.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: o.minLength.message
    }), n.dirty()), o.maxLength !== null && r.data.length > o.maxLength.value && (ve(r, {
      code: ue.too_big,
      maximum: o.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: o.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((i, s) => o.type._parseAsync(new fa(r, i, r.path, s)))).then((i) => io.mergeArray(n, i));
    const a = [...r.data].map((i, s) => o.type._parseSync(new fa(r, i, r.path, s)));
    return io.mergeArray(n, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, r) {
    return new mi({
      ...this._def,
      minLength: { value: t, message: Ne.toString(r) }
    });
  }
  max(t, r) {
    return new mi({
      ...this._def,
      maxLength: { value: t, message: Ne.toString(r) }
    });
  }
  length(t, r) {
    return new mi({
      ...this._def,
      exactLength: { value: t, message: Ne.toString(r) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
mi.create = (e, t) => new mi({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Fe.ZodArray,
  ...ht(t)
});
function Dl(e) {
  if (e instanceof sr) {
    const t = {};
    for (const r in e.shape) {
      const n = e.shape[r];
      t[r] = Ja.create(Dl(n));
    }
    return new sr({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof mi ? new mi({
    ...e._def,
    type: Dl(e.element)
  }) : e instanceof Ja ? Ja.create(Dl(e.unwrap())) : e instanceof Kc ? Kc.create(Dl(e.unwrap())) : e instanceof Uu ? Uu.create(e.items.map((t) => Dl(t))) : e;
}
class sr extends _t {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), r = Bt.objectKeys(t);
    return this._cached = { shape: t, keys: r };
  }
  _parse(t) {
    if (this._getType(t) !== ge.object) {
      const u = this._getOrReturnCtx(t);
      return ve(u, {
        code: ue.invalid_type,
        expected: ge.object,
        received: u.parsedType
      }), nt;
    }
    const { status: r, ctx: n } = this._processInputParams(t), { shape: o, keys: a } = this._getCached(), i = [];
    if (!(this._def.catchall instanceof is && this._def.unknownKeys === "strip"))
      for (const u in n.data)
        a.includes(u) || i.push(u);
    const s = [];
    for (const u of a) {
      const l = o[u], c = n.data[u];
      s.push({
        key: { status: "valid", value: u },
        value: l._parse(new fa(n, c, n.path, u)),
        alwaysSet: u in n.data
      });
    }
    if (this._def.catchall instanceof is) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of i)
          s.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: n.data[l] }
          });
      else if (u === "strict")
        i.length > 0 && (ve(n, {
          code: ue.unrecognized_keys,
          keys: i
        }), r.dirty());
      else if (u !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of i) {
        const c = n.data[l];
        s.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new fa(n, c, n.path, l)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l in n.data
        });
      }
    }
    return n.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of s) {
        const c = await l.key;
        u.push({
          key: c,
          value: await l.value,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => io.mergeObjectSync(r, u)) : io.mergeObjectSync(r, s);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return new sr({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (r, n) => {
          var o, a, i, s;
          const u = (i = (a = (o = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(o, r, n).message) !== null && i !== void 0 ? i : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (s = Ne.errToObj(t).message) !== null && s !== void 0 ? s : u
          } : {
            message: u
          };
        }
      } : {}
    });
  }
  strip() {
    return new sr({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new sr({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new sr({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new sr({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: Fe.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, r) {
    return this.augment({ [t]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new sr({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const r = {};
    return Bt.objectKeys(t).forEach((n) => {
      t[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new sr({
      ...this._def,
      shape: () => r
    });
  }
  omit(t) {
    const r = {};
    return Bt.objectKeys(this.shape).forEach((n) => {
      t[n] || (r[n] = this.shape[n]);
    }), new sr({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Dl(this);
  }
  partial(t) {
    const r = {};
    return Bt.objectKeys(this.shape).forEach((n) => {
      const o = this.shape[n];
      t && !t[n] ? r[n] = o : r[n] = o.optional();
    }), new sr({
      ...this._def,
      shape: () => r
    });
  }
  required(t) {
    const r = {};
    return Bt.objectKeys(this.shape).forEach((n) => {
      if (t && !t[n])
        r[n] = this.shape[n];
      else {
        let o = this.shape[n];
        for (; o instanceof Ja; )
          o = o._def.innerType;
        r[n] = o;
      }
    }), new sr({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return v_(Bt.objectKeys(this.shape));
  }
}
sr.create = (e, t) => new sr({
  shape: () => e,
  unknownKeys: "strip",
  catchall: is.create(),
  typeName: Fe.ZodObject,
  ...ht(t)
});
sr.strictCreate = (e, t) => new sr({
  shape: () => e,
  unknownKeys: "strict",
  catchall: is.create(),
  typeName: Fe.ZodObject,
  ...ht(t)
});
sr.lazycreate = (e, t) => new sr({
  shape: e,
  unknownKeys: "strip",
  catchall: is.create(),
  typeName: Fe.ZodObject,
  ...ht(t)
});
let Oh = class extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = this._def.options;
    function o(a) {
      for (const s of a)
        if (s.result.status === "valid")
          return s.result;
      for (const s of a)
        if (s.result.status === "dirty")
          return r.common.issues.push(...s.ctx.common.issues), s.result;
      const i = a.map((s) => new gi(s.ctx.common.issues));
      return ve(r, {
        code: ue.invalid_union,
        unionErrors: i
      }), nt;
    }
    if (r.common.async)
      return Promise.all(n.map(async (a) => {
        const i = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: r.data,
            path: r.path,
            parent: i
          }),
          ctx: i
        };
      })).then(o);
    {
      let a;
      const i = [];
      for (const u of n) {
        const l = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, c = u._parseSync({
          data: r.data,
          path: r.path,
          parent: l
        });
        if (c.status === "valid")
          return c;
        c.status === "dirty" && !a && (a = { result: c, ctx: l }), l.common.issues.length && i.push(l.common.issues);
      }
      if (a)
        return r.common.issues.push(...a.ctx.common.issues), a.result;
      const s = i.map((u) => new gi(u));
      return ve(r, {
        code: ue.invalid_union,
        unionErrors: s
      }), nt;
    }
  }
  get options() {
    return this._def.options;
  }
};
Oh.create = (e, t) => new Oh({
  options: e,
  typeName: Fe.ZodUnion,
  ...ht(t)
});
const E1 = (e) => e instanceof Ch ? E1(e.schema) : e instanceof Ai ? E1(e.innerType()) : e instanceof Bh ? [e.value] : e instanceof _p ? e.options : e instanceof Nh ? Object.keys(e.enum) : e instanceof Uh ? E1(e._def.innerType) : e instanceof Th ? [void 0] : e instanceof Ph ? [null] : null;
let g_ = class m_ extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ge.object)
      return ve(r, {
        code: ue.invalid_type,
        expected: ge.object,
        received: r.parsedType
      }), nt;
    const n = this.discriminator, o = r.data[n], a = this.optionsMap.get(o);
    return a ? r.common.async ? a._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : a._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (ve(r, {
      code: ue.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), nt);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, r, n) {
    const o = /* @__PURE__ */ new Map();
    for (const a of r) {
      const i = E1(a.shape[t]);
      if (!i)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const s of i) {
        if (o.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        o.set(s, a);
      }
    }
    return new m_({
      typeName: Fe.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: o,
      ...ht(n)
    });
  }
};
function uv(e, t) {
  const r = xu(e), n = xu(t);
  if (e === t)
    return { valid: !0, data: e };
  if (r === ge.object && n === ge.object) {
    const o = Bt.objectKeys(t), a = Bt.objectKeys(e).filter((s) => o.indexOf(s) !== -1), i = { ...e, ...t };
    for (const s of a) {
      const u = uv(e[s], t[s]);
      if (!u.valid)
        return { valid: !1 };
      i[s] = u.data;
    }
    return { valid: !0, data: i };
  } else if (r === ge.array && n === ge.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const o = [];
    for (let a = 0; a < e.length; a++) {
      const i = e[a], s = t[a], u = uv(i, s);
      if (!u.valid)
        return { valid: !1 };
      o.push(u.data);
    }
    return { valid: !0, data: o };
  } else return r === ge.date && n === ge.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
let $h = class extends _t {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), o = (a, i) => {
      if (ov(a) || ov(i))
        return nt;
      const s = uv(a.value, i.value);
      return s.valid ? ((iv(a) || iv(i)) && r.dirty(), { status: r.value, value: s.data }) : (ve(n, {
        code: ue.invalid_intersection_types
      }), nt);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([a, i]) => o(a, i)) : o(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
};
$h.create = (e, t, r) => new $h({
  left: e,
  right: t,
  typeName: Fe.ZodIntersection,
  ...ht(r)
});
let Uu = class y_ extends _t {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ge.array)
      return ve(n, {
        code: ue.invalid_type,
        expected: ge.array,
        received: n.parsedType
      }), nt;
    if (n.data.length < this._def.items.length)
      return ve(n, {
        code: ue.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), nt;
    !this._def.rest && n.data.length > this._def.items.length && (ve(n, {
      code: ue.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const o = [...n.data].map((a, i) => {
      const s = this._def.items[i] || this._def.rest;
      return s ? s._parse(new fa(n, a, n.path, i)) : null;
    }).filter((a) => !!a);
    return n.common.async ? Promise.all(o).then((a) => io.mergeArray(r, a)) : io.mergeArray(r, o);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new y_({
      ...this._def,
      rest: t
    });
  }
};
Uu.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Uu({
    items: e,
    typeName: Fe.ZodTuple,
    rest: null,
    ...ht(t)
  });
};
let b_ = class cv extends _t {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ge.object)
      return ve(n, {
        code: ue.invalid_type,
        expected: ge.object,
        received: n.parsedType
      }), nt;
    const o = [], a = this._def.keyType, i = this._def.valueType;
    for (const s in n.data)
      o.push({
        key: a._parse(new fa(n, s, n.path, s)),
        value: i._parse(new fa(n, n.data[s], n.path, s))
      });
    return n.common.async ? io.mergeObjectAsync(r, o) : io.mergeObjectSync(r, o);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, r, n) {
    return r instanceof _t ? new cv({
      keyType: t,
      valueType: r,
      typeName: Fe.ZodRecord,
      ...ht(n)
    }) : new cv({
      keyType: _f.create(),
      valueType: t,
      typeName: Fe.ZodRecord,
      ...ht(r)
    });
  }
}, yg = class extends _t {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ge.map)
      return ve(n, {
        code: ue.invalid_type,
        expected: ge.map,
        received: n.parsedType
      }), nt;
    const o = this._def.keyType, a = this._def.valueType, i = [...n.data.entries()].map(([s, u], l) => ({
      key: o._parse(new fa(n, s, n.path, [l, "key"])),
      value: a._parse(new fa(n, u, n.path, [l, "value"]))
    }));
    if (n.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const u of i) {
          const l = await u.key, c = await u.value;
          if (l.status === "aborted" || c.status === "aborted")
            return nt;
          (l.status === "dirty" || c.status === "dirty") && r.dirty(), s.set(l.value, c.value);
        }
        return { status: r.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const u of i) {
        const l = u.key, c = u.value;
        if (l.status === "aborted" || c.status === "aborted")
          return nt;
        (l.status === "dirty" || c.status === "dirty") && r.dirty(), s.set(l.value, c.value);
      }
      return { status: r.value, value: s };
    }
  }
};
yg.create = (e, t, r) => new yg({
  valueType: t,
  keyType: e,
  typeName: Fe.ZodMap,
  ...ht(r)
});
let bg = class lv extends _t {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ge.set)
      return ve(n, {
        code: ue.invalid_type,
        expected: ge.set,
        received: n.parsedType
      }), nt;
    const o = this._def;
    o.minSize !== null && n.data.size < o.minSize.value && (ve(n, {
      code: ue.too_small,
      minimum: o.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: o.minSize.message
    }), r.dirty()), o.maxSize !== null && n.data.size > o.maxSize.value && (ve(n, {
      code: ue.too_big,
      maximum: o.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: o.maxSize.message
    }), r.dirty());
    const a = this._def.valueType;
    function i(u) {
      const l = /* @__PURE__ */ new Set();
      for (const c of u) {
        if (c.status === "aborted")
          return nt;
        c.status === "dirty" && r.dirty(), l.add(c.value);
      }
      return { status: r.value, value: l };
    }
    const s = [...n.data.values()].map((u, l) => a._parse(new fa(n, u, n.path, l)));
    return n.common.async ? Promise.all(s).then((u) => i(u)) : i(s);
  }
  min(t, r) {
    return new lv({
      ...this._def,
      minSize: { value: t, message: Ne.toString(r) }
    });
  }
  max(t, r) {
    return new lv({
      ...this._def,
      maxSize: { value: t, message: Ne.toString(r) }
    });
  }
  size(t, r) {
    return this.min(t, r).max(t, r);
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
bg.create = (e, t) => new bg({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: Fe.ZodSet,
  ...ht(t)
});
let w_ = class k1 extends _t {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ge.function)
      return ve(r, {
        code: ue.invalid_type,
        expected: ge.function,
        received: r.parsedType
      }), nt;
    function n(s, u) {
      return dg({
        data: s,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          fg(),
          xh
        ].filter((l) => !!l),
        issueData: {
          code: ue.invalid_arguments,
          argumentsError: u
        }
      });
    }
    function o(s, u) {
      return dg({
        data: s,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          fg(),
          xh
        ].filter((l) => !!l),
        issueData: {
          code: ue.invalid_return_type,
          returnTypeError: u
        }
      });
    }
    const a = { errorMap: r.common.contextualErrorMap }, i = r.data;
    return this._def.returns instanceof Tf ? Fn(async (...s) => {
      const u = new gi([]), l = await this._def.args.parseAsync(s, a).catch((f) => {
        throw u.addIssue(n(s, f)), u;
      }), c = await i(...l);
      return await this._def.returns._def.type.parseAsync(c, a).catch((f) => {
        throw u.addIssue(o(c, f)), u;
      });
    }) : Fn((...s) => {
      const u = this._def.args.safeParse(s, a);
      if (!u.success)
        throw new gi([n(s, u.error)]);
      const l = i(...u.data), c = this._def.returns.safeParse(l, a);
      if (!c.success)
        throw new gi([o(l, c.error)]);
      return c.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new k1({
      ...this._def,
      args: Uu.create(t).rest(Cc.create())
    });
  }
  returns(t) {
    return new k1({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, r, n) {
    return new k1({
      args: t || Uu.create([]).rest(Cc.create()),
      returns: r || Cc.create(),
      typeName: Fe.ZodFunction,
      ...ht(n)
    });
  }
}, Ch = class extends _t {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
};
Ch.create = (e, t) => new Ch({
  getter: e,
  typeName: Fe.ZodLazy,
  ...ht(t)
});
let Bh = class extends _t {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        received: r.data,
        code: ue.invalid_literal,
        expected: this._def.value
      }), nt;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
};
Bh.create = (e, t) => new Bh({
  value: e,
  typeName: Fe.ZodLiteral,
  ...ht(t)
});
function v_(e, t) {
  return new _p({
    values: e,
    typeName: Fe.ZodEnum,
    ...ht(t)
  });
}
let _p = class fv extends _t {
  _parse(t) {
    if (typeof t.data != "string") {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return ve(r, {
        expected: Bt.joinValues(n),
        received: r.parsedType,
        code: ue.invalid_type
      }), nt;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return ve(r, {
        received: r.data,
        code: ue.invalid_enum_value,
        options: n
      }), nt;
    }
    return Fn(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Values() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  extract(t) {
    return fv.create(t);
  }
  exclude(t) {
    return fv.create(this.options.filter((r) => !t.includes(r)));
  }
};
_p.create = v_;
let Nh = class extends _t {
  _parse(t) {
    const r = Bt.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
    if (n.parsedType !== ge.string && n.parsedType !== ge.number) {
      const o = Bt.objectValues(r);
      return ve(n, {
        expected: Bt.joinValues(o),
        received: n.parsedType,
        code: ue.invalid_type
      }), nt;
    }
    if (r.indexOf(t.data) === -1) {
      const o = Bt.objectValues(r);
      return ve(n, {
        received: n.data,
        code: ue.invalid_enum_value,
        options: o
      }), nt;
    }
    return Fn(t.data);
  }
  get enum() {
    return this._def.values;
  }
};
Nh.create = (e, t) => new Nh({
  values: e,
  typeName: Fe.ZodNativeEnum,
  ...ht(t)
});
let Tf = class extends _t {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ge.promise && r.common.async === !1)
      return ve(r, {
        code: ue.invalid_type,
        expected: ge.promise,
        received: r.parsedType
      }), nt;
    const n = r.parsedType === ge.promise ? r.data : Promise.resolve(r.data);
    return Fn(n.then((o) => this._def.type.parseAsync(o, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
};
Tf.create = (e, t) => new Tf({
  type: e,
  typeName: Fe.ZodPromise,
  ...ht(t)
});
let Ai = class extends _t {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Fe.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), o = this._def.effect || null;
    if (o.type === "preprocess") {
      const i = o.transform(n.data);
      return n.common.async ? Promise.resolve(i).then((s) => this._def.schema._parseAsync({
        data: s,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: i,
        path: n.path,
        parent: n
      });
    }
    const a = {
      addIssue: (i) => {
        ve(n, i), i.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), o.type === "refinement") {
      const i = (s) => {
        const u = o.refinement(s, a);
        if (n.common.async)
          return Promise.resolve(u);
        if (u instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      };
      if (n.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? nt : (s.status === "dirty" && r.dirty(), i(s.value), { status: r.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((s) => s.status === "aborted" ? nt : (s.status === "dirty" && r.dirty(), i(s.value).then(() => ({ status: r.value, value: s.value }))));
    }
    if (o.type === "transform")
      if (n.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!hg(i))
          return i;
        const s = o.transform(i.value, a);
        if (s instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((i) => hg(i) ? Promise.resolve(o.transform(i.value, a)).then((s) => ({ status: r.value, value: s })) : i);
    Bt.assertNever(o);
  }
};
Ai.create = (e, t, r) => new Ai({
  schema: e,
  typeName: Fe.ZodEffects,
  effect: t,
  ...ht(r)
});
Ai.createWithPreprocess = (e, t, r) => new Ai({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: Fe.ZodEffects,
  ...ht(r)
});
let Ja = class extends _t {
  _parse(t) {
    return this._getType(t) === ge.undefined ? Fn(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Ja.create = (e, t) => new Ja({
  innerType: e,
  typeName: Fe.ZodOptional,
  ...ht(t)
});
let Kc = class extends _t {
  _parse(t) {
    return this._getType(t) === ge.null ? Fn(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Kc.create = (e, t) => new Kc({
  innerType: e,
  typeName: Fe.ZodNullable,
  ...ht(t)
});
let Uh = class extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    let n = r.data;
    return r.parsedType === ge.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
Uh.create = (e, t) => new Uh({
  innerType: e,
  typeName: Fe.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...ht(t)
});
let wg = class extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, o = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return pg(o) ? o.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new gi(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: o.status === "valid" ? o.value : this._def.catchValue({
        get error() {
          return new gi(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
wg.create = (e, t) => new wg({
  innerType: e,
  typeName: Fe.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...ht(t)
});
let vg = class extends _t {
  _parse(t) {
    if (this._getType(t) !== ge.nan) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: ue.invalid_type,
        expected: ge.nan,
        received: r.parsedType
      }), nt;
    }
    return { status: "valid", value: t.data };
  }
};
vg.create = (e) => new vg({
  typeName: Fe.ZodNaN,
  ...ht(e)
});
const YZ = Symbol("zod_brand");
let E_ = class extends _t {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}, D3 = class k_ extends _t {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.common.async)
      return (async () => {
        const o = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? nt : o.status === "dirty" ? (r.dirty(), h_(o.value)) : this._def.out._parseAsync({
          data: o.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const o = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return o.status === "aborted" ? nt : o.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: o.value
      }) : this._def.out._parseSync({
        data: o.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(t, r) {
    return new k_({
      in: t,
      out: r,
      typeName: Fe.ZodPipeline
    });
  }
};
const x_ = (e, t = {}, r) => e ? If.create().superRefine((n, o) => {
  var a, i;
  if (!e(n)) {
    const s = typeof t == "function" ? t(n) : typeof t == "string" ? { message: t } : t, u = (i = (a = s.fatal) !== null && a !== void 0 ? a : r) !== null && i !== void 0 ? i : !0, l = typeof s == "string" ? { message: s } : s;
    o.addIssue({ code: "custom", ...l, fatal: u });
  }
}) : If.create(), JZ = {
  object: sr.lazycreate
};
var Fe;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(Fe || (Fe = {}));
const QZ = (e, t = {
  message: `Input not instance of ${e.name}`
}) => x_((r) => r instanceof e, t), A_ = _f.create, S_ = Ah.create, eW = vg.create, tW = Sh.create, __ = _h.create, rW = Ih.create, nW = gg.create, oW = Th.create, iW = Ph.create, aW = If.create, sW = Cc.create, uW = is.create, cW = mg.create, lW = mi.create, fW = sr.create, dW = sr.strictCreate, hW = Oh.create, pW = g_.create, gW = $h.create, mW = Uu.create, yW = b_.create, bW = yg.create, wW = bg.create, vW = w_.create, EW = Ch.create, kW = Bh.create, xW = _p.create, AW = Nh.create, SW = Tf.create, IE = Ai.create, _W = Ja.create, IW = Kc.create, TW = Ai.createWithPreprocess, PW = D3.create, OW = () => A_().optional(), $W = () => S_().optional(), CW = () => __().optional(), BW = {
  string: (e) => _f.create({ ...e, coerce: !0 }),
  number: (e) => Ah.create({ ...e, coerce: !0 }),
  boolean: (e) => _h.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Sh.create({ ...e, coerce: !0 }),
  date: (e) => Ih.create({ ...e, coerce: !0 })
}, NW = nt;
var zn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: xh,
  setErrorMap: jZ,
  getErrorMap: fg,
  makeIssue: dg,
  EMPTY_PATH: LZ,
  addIssueToContext: ve,
  ParseStatus: io,
  INVALID: nt,
  DIRTY: h_,
  OK: Fn,
  isAborted: ov,
  isDirty: iv,
  isValid: hg,
  isAsync: pg,
  get util() {
    return Bt;
  },
  get objectUtil() {
    return nv;
  },
  ZodParsedType: ge,
  getParsedType: xu,
  ZodType: _t,
  ZodString: _f,
  ZodNumber: Ah,
  ZodBigInt: Sh,
  ZodBoolean: _h,
  ZodDate: Ih,
  ZodSymbol: gg,
  ZodUndefined: Th,
  ZodNull: Ph,
  ZodAny: If,
  ZodUnknown: Cc,
  ZodNever: is,
  ZodVoid: mg,
  ZodArray: mi,
  ZodObject: sr,
  ZodUnion: Oh,
  ZodDiscriminatedUnion: g_,
  ZodIntersection: $h,
  ZodTuple: Uu,
  ZodRecord: b_,
  ZodMap: yg,
  ZodSet: bg,
  ZodFunction: w_,
  ZodLazy: Ch,
  ZodLiteral: Bh,
  ZodEnum: _p,
  ZodNativeEnum: Nh,
  ZodPromise: Tf,
  ZodEffects: Ai,
  ZodTransformer: Ai,
  ZodOptional: Ja,
  ZodNullable: Kc,
  ZodDefault: Uh,
  ZodCatch: wg,
  ZodNaN: vg,
  BRAND: YZ,
  ZodBranded: E_,
  ZodPipeline: D3,
  custom: x_,
  Schema: _t,
  ZodSchema: _t,
  late: JZ,
  get ZodFirstPartyTypeKind() {
    return Fe;
  },
  coerce: BW,
  any: aW,
  array: lW,
  bigint: tW,
  boolean: __,
  date: rW,
  discriminatedUnion: pW,
  effect: IE,
  enum: xW,
  function: vW,
  instanceof: QZ,
  intersection: gW,
  lazy: EW,
  literal: kW,
  map: bW,
  nan: eW,
  nativeEnum: AW,
  never: uW,
  null: iW,
  nullable: IW,
  number: S_,
  object: fW,
  oboolean: CW,
  onumber: $W,
  optional: _W,
  ostring: OW,
  pipeline: PW,
  preprocess: TW,
  promise: SW,
  record: yW,
  set: wW,
  strictObject: dW,
  string: A_,
  symbol: nW,
  transformer: IE,
  tuple: mW,
  undefined: oW,
  union: hW,
  unknown: sW,
  void: cW,
  NEVER: NW,
  ZodIssueCode: ue,
  quotelessJson: zZ,
  ZodError: gi
});
const I_ = zn.string().regex(/^[a-fA-F0-9]$/), UW = zn.string().regex(/^[a-fA-F0-9]{64}$/), Pf = zn.number().min(0).max(4294967295), RW = zn.bigint(), T_ = zn.instanceof(Uint8Array), zW = zn.union([I_, Pf, zn.string(), T_]).array(), M3 = zn.union([zW, I_, T_]), jW = zn.array(M3), P_ = zn.object({
  value: zn.union([Pf, RW]),
  scriptPubKey: M3
}), LW = zn.object({
  txid: UW,
  vout: Pf,
  scriptSig: M3,
  sequence: Pf,
  prevout: P_.optional(),
  witness: jW
});
zn.object({
  version: Pf,
  vin: zn.array(LW),
  vout: zn.array(P_),
  locktime: Pf
});
var mr = {}, K3 = {};
const HW = {}, FW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: HW
}, Symbol.toStringTag, { value: "Module" })), O_ = /* @__PURE__ */ jR(FW);
(function(e) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.utils = e.schnorr = e.verify = e.signSync = e.sign = e.getSharedSecret = e.recoverPublicKey = e.getPublicKey = e.Signature = e.Point = e.CURVE = void 0;
  const t = O_, r = BigInt(0), n = BigInt(1), o = BigInt(2), a = BigInt(3), i = BigInt(8), s = Object.freeze({
    a: r,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: n,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  e.CURVE = s;
  const u = (P, x) => (P + x / o) / x, l = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(P) {
      const { n: x } = s, T = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), B = -n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), j = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), q = T, X = BigInt("0x100000000000000000000000000000000"), Q = u(q * P, x), ae = u(-B * P, x);
      let ie = K(P - Q * T - ae * j, x), le = K(-Q * B - ae * q, x);
      const pe = ie > X, we = le > X;
      if (pe && (ie = x - ie), we && (le = x - le), ie > X || le > X)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + P);
      return { k1neg: pe, k1: ie, k2neg: we, k2: le };
    }
  }, c = 32, f = 32, h = 32, p = c + 1, y = 2 * c + 1;
  function m(P) {
    const { a: x, b: T } = s, B = K(P * P), j = K(B * P);
    return K(j + x * P + T);
  }
  const b = s.a === r;
  class v extends Error {
    constructor(x) {
      super(x);
    }
  }
  function k(P) {
    if (!(P instanceof E))
      throw new TypeError("JacobianPoint expected");
  }
  class E {
    constructor(x, T, B) {
      this.x = x, this.y = T, this.z = B;
    }
    static fromAffine(x) {
      if (!(x instanceof _))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return x.equals(_.ZERO) ? E.ZERO : new E(x.x, x.y, n);
    }
    static toAffineBatch(x) {
      const T = Et(x.map((B) => B.z));
      return x.map((B, j) => B.toAffine(T[j]));
    }
    static normalizeZ(x) {
      return E.toAffineBatch(x).map(E.fromAffine);
    }
    equals(x) {
      k(x);
      const { x: T, y: B, z: j } = this, { x: q, y: X, z: Q } = x, ae = K(j * j), ie = K(Q * Q), le = K(T * ie), pe = K(q * ae), we = K(K(B * Q) * ie), kt = K(K(X * j) * ae);
      return le === pe && we === kt;
    }
    negate() {
      return new E(this.x, K(-this.y), this.z);
    }
    double() {
      const { x, y: T, z: B } = this, j = K(x * x), q = K(T * T), X = K(q * q), Q = x + q, ae = K(o * (K(Q * Q) - j - X)), ie = K(a * j), le = K(ie * ie), pe = K(le - o * ae), we = K(ie * (ae - pe) - i * X), kt = K(o * T * B);
      return new E(pe, we, kt);
    }
    add(x) {
      k(x);
      const { x: T, y: B, z: j } = this, { x: q, y: X, z: Q } = x;
      if (q === r || X === r)
        return this;
      if (T === r || B === r)
        return x;
      const ae = K(j * j), ie = K(Q * Q), le = K(T * ie), pe = K(q * ae), we = K(K(B * Q) * ie), kt = K(K(X * j) * ae), xt = K(pe - le), zr = K(kt - we);
      if (xt === r)
        return zr === r ? this.double() : E.ZERO;
      const fo = K(xt * xt), ho = K(xt * fo), po = K(le * fo), _a = K(zr * zr - ho - o * po), nc = K(zr * (po - _a) - we * ho), Qo = K(j * Q * xt);
      return new E(_a, nc, Qo);
    }
    subtract(x) {
      return this.add(x.negate());
    }
    multiplyUnsafe(x) {
      const T = E.ZERO;
      if (typeof x == "bigint" && x === r)
        return T;
      let B = se(x);
      if (B === n)
        return this;
      if (!b) {
        let pe = T, we = this;
        for (; B > r; )
          B & n && (pe = pe.add(we)), we = we.double(), B >>= n;
        return pe;
      }
      let { k1neg: j, k1: q, k2neg: X, k2: Q } = l.splitScalar(B), ae = T, ie = T, le = this;
      for (; q > r || Q > r; )
        q & n && (ae = ae.add(le)), Q & n && (ie = ie.add(le)), le = le.double(), q >>= n, Q >>= n;
      return j && (ae = ae.negate()), X && (ie = ie.negate()), ie = new E(K(ie.x * l.beta), ie.y, ie.z), ae.add(ie);
    }
    precomputeWindow(x) {
      const T = b ? 128 / x + 1 : 256 / x + 1, B = [];
      let j = this, q = j;
      for (let X = 0; X < T; X++) {
        q = j, B.push(q);
        for (let Q = 1; Q < 2 ** (x - 1); Q++)
          q = q.add(j), B.push(q);
        j = q.double();
      }
      return B;
    }
    wNAF(x, T) {
      !T && this.equals(E.BASE) && (T = _.BASE);
      const B = T && T._WINDOW_SIZE || 1;
      if (256 % B)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let j = T && S.get(T);
      j || (j = this.precomputeWindow(B), T && B !== 1 && (j = E.normalizeZ(j), S.set(T, j)));
      let q = E.ZERO, X = E.BASE;
      const Q = 1 + (b ? 128 / B : 256 / B), ae = 2 ** (B - 1), ie = BigInt(2 ** B - 1), le = 2 ** B, pe = BigInt(B);
      for (let we = 0; we < Q; we++) {
        const kt = we * ae;
        let xt = Number(x & ie);
        x >>= pe, xt > ae && (xt -= le, x += n);
        const zr = kt, fo = kt + Math.abs(xt) - 1, ho = we % 2 !== 0, po = xt < 0;
        xt === 0 ? X = X.add(A(ho, j[zr])) : q = q.add(A(po, j[fo]));
      }
      return { p: q, f: X };
    }
    multiply(x, T) {
      let B = se(x), j, q;
      if (b) {
        const { k1neg: X, k1: Q, k2neg: ae, k2: ie } = l.splitScalar(B);
        let { p: le, f: pe } = this.wNAF(Q, T), { p: we, f: kt } = this.wNAF(ie, T);
        le = A(X, le), we = A(ae, we), we = new E(K(we.x * l.beta), we.y, we.z), j = le.add(we), q = pe.add(kt);
      } else {
        const { p: X, f: Q } = this.wNAF(B, T);
        j = X, q = Q;
      }
      return E.normalizeZ([j, q])[0];
    }
    toAffine(x) {
      const { x: T, y: B, z: j } = this, q = this.equals(E.ZERO);
      x == null && (x = q ? i : ye(j));
      const X = x, Q = K(X * X), ae = K(Q * X), ie = K(T * Q), le = K(B * ae), pe = K(j * X);
      if (q)
        return _.ZERO;
      if (pe !== n)
        throw new Error("invZ was invalid");
      return new _(ie, le);
    }
  }
  E.BASE = new E(s.Gx, s.Gy, n), E.ZERO = new E(r, n, r);
  function A(P, x) {
    const T = x.negate();
    return P ? T : x;
  }
  const S = /* @__PURE__ */ new WeakMap();
  class _ {
    constructor(x, T) {
      this.x = x, this.y = T;
    }
    _setWindowSize(x) {
      this._WINDOW_SIZE = x, S.delete(this);
    }
    hasEvenY() {
      return this.y % o === r;
    }
    static fromCompressedHex(x) {
      const T = x.length === 32, B = ne(T ? x : x.subarray(1));
      if (!Tt(B))
        throw new Error("Point is not on curve");
      const j = m(B);
      let q = Ae(j);
      const X = (q & n) === n;
      T ? X && (q = K(-q)) : (x[0] & 1) === 1 !== X && (q = K(-q));
      const Q = new _(B, q);
      return Q.assertValidity(), Q;
    }
    static fromUncompressedHex(x) {
      const T = ne(x.subarray(1, c + 1)), B = ne(x.subarray(c + 1, c * 2 + 1)), j = new _(T, B);
      return j.assertValidity(), j;
    }
    static fromHex(x) {
      const T = oe(x), B = T.length, j = T[0];
      if (B === c)
        return this.fromCompressedHex(T);
      if (B === p && (j === 2 || j === 3))
        return this.fromCompressedHex(T);
      if (B === y && j === 4)
        return this.fromUncompressedHex(T);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${p} compressed bytes or ${y} uncompressed bytes, not ${B}`);
    }
    static fromPrivateKey(x) {
      return _.BASE.multiply(Wt(x));
    }
    static fromSignature(x, T, B) {
      const { r: j, s: q } = ka(T);
      if (![0, 1, 2, 3].includes(B))
        throw new Error("Cannot recover: invalid recovery bit");
      const X = be(oe(x)), { n: Q } = s, ae = B === 2 || B === 3 ? j + Q : j, ie = ye(ae, Q), le = K(-X * ie, Q), pe = K(q * ie, Q), we = B & 1 ? "03" : "02", kt = _.fromHex(we + C(ae)), xt = _.BASE.multiplyAndAddUnsafe(kt, le, pe);
      if (!xt)
        throw new Error("Cannot recover signature: point at infinify");
      return xt.assertValidity(), xt;
    }
    toRawBytes(x = !1) {
      return W(this.toHex(x));
    }
    toHex(x = !1) {
      const T = C(this.x);
      return x ? `${this.hasEvenY() ? "02" : "03"}${T}` : `04${T}${C(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const x = "Point is not on elliptic curve", { x: T, y: B } = this;
      if (!Tt(T) || !Tt(B))
        throw new Error(x);
      const j = K(B * B), q = m(T);
      if (K(j - q) !== r)
        throw new Error(x);
    }
    equals(x) {
      return this.x === x.x && this.y === x.y;
    }
    negate() {
      return new _(this.x, K(-this.y));
    }
    double() {
      return E.fromAffine(this).double().toAffine();
    }
    add(x) {
      return E.fromAffine(this).add(E.fromAffine(x)).toAffine();
    }
    subtract(x) {
      return this.add(x.negate());
    }
    multiply(x) {
      return E.fromAffine(this).multiply(x, this).toAffine();
    }
    multiplyAndAddUnsafe(x, T, B) {
      const j = E.fromAffine(this), q = T === r || T === n || this !== _.BASE ? j.multiplyUnsafe(T) : j.multiply(T), X = E.fromAffine(x).multiplyUnsafe(B), Q = q.add(X);
      return Q.equals(E.ZERO) ? void 0 : Q.toAffine();
    }
  }
  e.Point = _, _.BASE = new _(s.Gx, s.Gy), _.ZERO = new _(r, r);
  function I(P) {
    return Number.parseInt(P[0], 16) >= 8 ? "00" + P : P;
  }
  function O(P) {
    if (P.length < 2 || P[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${V(P)}`);
    const x = P[1], T = P.subarray(2, x + 2);
    if (!x || T.length !== x)
      throw new Error("Invalid signature integer: wrong length");
    if (T[0] === 0 && T[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: ne(T), left: P.subarray(x + 2) };
  }
  function z(P) {
    if (P.length < 2 || P[0] != 48)
      throw new Error(`Invalid signature tag: ${V(P)}`);
    if (P[1] !== P.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: x, left: T } = O(P.subarray(2)), { data: B, left: j } = O(T);
    if (j.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${V(j)}`);
    return { r: x, s: B };
  }
  class D {
    constructor(x, T) {
      this.r = x, this.s = T, this.assertValidity();
    }
    static fromCompact(x) {
      const T = x instanceof Uint8Array, B = "Signature.fromCompact";
      if (typeof x != "string" && !T)
        throw new TypeError(`${B}: Expected string or Uint8Array`);
      const j = T ? V(x) : x;
      if (j.length !== 128)
        throw new Error(`${B}: Expected 64-byte hex`);
      return new D(re(j.slice(0, 64)), re(j.slice(64, 128)));
    }
    static fromDER(x) {
      const T = x instanceof Uint8Array;
      if (typeof x != "string" && !T)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: B, s: j } = z(T ? x : W(x));
      return new D(B, j);
    }
    static fromHex(x) {
      return this.fromDER(x);
    }
    assertValidity() {
      const { r: x, s: T } = this;
      if (!Re(x))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!Re(T))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const x = s.n >> n;
      return this.s > x;
    }
    normalizeS() {
      return this.hasHighS() ? new D(this.r, K(-this.s, s.n)) : this;
    }
    toDERRawBytes() {
      return W(this.toDERHex());
    }
    toDERHex() {
      const x = I(M(this.s)), T = I(M(this.r)), B = x.length / 2, j = T.length / 2, q = M(B), X = M(j);
      return `30${M(j + B + 4)}02${X}${T}02${q}${x}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return W(this.toCompactHex());
    }
    toCompactHex() {
      return C(this.r) + C(this.s);
    }
  }
  e.Signature = D;
  function G(...P) {
    if (!P.every((B) => B instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (P.length === 1)
      return P[0];
    const x = P.reduce((B, j) => B + j.length, 0), T = new Uint8Array(x);
    for (let B = 0, j = 0; B < P.length; B++) {
      const q = P[B];
      T.set(q, j), j += q.length;
    }
    return T;
  }
  const U = Array.from({ length: 256 }, (P, x) => x.toString(16).padStart(2, "0"));
  function V(P) {
    if (!(P instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let x = "";
    for (let T = 0; T < P.length; T++)
      x += U[P[T]];
    return x;
  }
  const F = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function C(P) {
    if (typeof P != "bigint")
      throw new Error("Expected bigint");
    if (!(r <= P && P < F))
      throw new Error("Expected number 0 <= n < 2^256");
    return P.toString(16).padStart(64, "0");
  }
  function R(P) {
    const x = W(C(P));
    if (x.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return x;
  }
  function M(P) {
    const x = P.toString(16);
    return x.length & 1 ? `0${x}` : x;
  }
  function re(P) {
    if (typeof P != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof P);
    return BigInt(`0x${P}`);
  }
  function W(P) {
    if (typeof P != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof P);
    if (P.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + P.length);
    const x = new Uint8Array(P.length / 2);
    for (let T = 0; T < x.length; T++) {
      const B = T * 2, j = P.slice(B, B + 2), q = Number.parseInt(j, 16);
      if (Number.isNaN(q) || q < 0)
        throw new Error("Invalid byte sequence");
      x[T] = q;
    }
    return x;
  }
  function ne(P) {
    return re(V(P));
  }
  function oe(P) {
    return P instanceof Uint8Array ? Uint8Array.from(P) : W(P);
  }
  function se(P) {
    if (typeof P == "number" && Number.isSafeInteger(P) && P > 0)
      return BigInt(P);
    if (typeof P == "bigint" && Re(P))
      return P;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function K(P, x = s.P) {
    const T = P % x;
    return T >= r ? T : x + T;
  }
  function he(P, x) {
    const { P: T } = s;
    let B = P;
    for (; x-- > r; )
      B *= B, B %= T;
    return B;
  }
  function Ae(P) {
    const { P: x } = s, T = BigInt(6), B = BigInt(11), j = BigInt(22), q = BigInt(23), X = BigInt(44), Q = BigInt(88), ae = P * P * P % x, ie = ae * ae * P % x, le = he(ie, a) * ie % x, pe = he(le, a) * ie % x, we = he(pe, o) * ae % x, kt = he(we, B) * we % x, xt = he(kt, j) * kt % x, zr = he(xt, X) * xt % x, fo = he(zr, Q) * zr % x, ho = he(fo, X) * xt % x, po = he(ho, a) * ie % x, _a = he(po, q) * kt % x, nc = he(_a, T) * ae % x, Qo = he(nc, o);
    if (Qo * Qo % x !== P)
      throw new Error("Cannot find square root");
    return Qo;
  }
  function ye(P, x = s.P) {
    if (P === r || x <= r)
      throw new Error(`invert: expected positive integers, got n=${P} mod=${x}`);
    let T = K(P, x), B = x, j = r, q = n;
    for (; T !== r; ) {
      const X = B / T, Q = B % T, ae = j - q * X;
      B = T, T = Q, j = q, q = ae;
    }
    if (B !== n)
      throw new Error("invert: does not exist");
    return K(j, x);
  }
  function Et(P, x = s.P) {
    const T = new Array(P.length), B = P.reduce((q, X, Q) => X === r ? q : (T[Q] = q, K(q * X, x)), n), j = ye(B, x);
    return P.reduceRight((q, X, Q) => X === r ? q : (T[Q] = K(q * T[Q], x), K(q * X, x)), j), T;
  }
  function Ge(P) {
    const x = P.length * 8 - f * 8, T = ne(P);
    return x > 0 ? T >> BigInt(x) : T;
  }
  function be(P, x = !1) {
    const T = Ge(P);
    if (x)
      return T;
    const { n: B } = s;
    return T >= B ? T - B : T;
  }
  let st, Ze;
  class We {
    constructor(x, T) {
      if (this.hashLen = x, this.qByteLen = T, typeof x != "number" || x < 2)
        throw new Error("hashLen must be a number");
      if (typeof T != "number" || T < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(x).fill(1), this.k = new Uint8Array(x).fill(0), this.counter = 0;
    }
    hmac(...x) {
      return e.utils.hmacSha256(this.k, ...x);
    }
    hmacSync(...x) {
      return Ze(this.k, ...x);
    }
    checkSync() {
      if (typeof Ze != "function")
        throw new v("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(x = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), x), this.v = await this.hmac(this.v), x.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), x), this.v = await this.hmac(this.v));
    }
    reseedSync(x = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), x), this.v = this.hmacSync(this.v), x.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), x), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let x = 0;
      const T = [];
      for (; x < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const B = this.v.slice();
        T.push(B), x += this.v.length;
      }
      return G(...T);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let x = 0;
      const T = [];
      for (; x < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const B = this.v.slice();
        T.push(B), x += this.v.length;
      }
      return G(...T);
    }
  }
  function Re(P) {
    return r < P && P < s.n;
  }
  function Tt(P) {
    return r < P && P < s.P;
  }
  function xr(P, x, T, B = !0) {
    const { n: j } = s, q = be(P, !0);
    if (!Re(q))
      return;
    const X = ye(q, j), Q = _.BASE.multiply(q), ae = K(Q.x, j);
    if (ae === r)
      return;
    const ie = K(X * K(x + T * ae, j), j);
    if (ie === r)
      return;
    let le = new D(ae, ie), pe = (Q.x === le.r ? 0 : 2) | Number(Q.y & n);
    return B && le.hasHighS() && (le = le.normalizeS(), pe ^= 1), { sig: le, recovery: pe };
  }
  function Wt(P) {
    let x;
    if (typeof P == "bigint")
      x = P;
    else if (typeof P == "number" && Number.isSafeInteger(P) && P > 0)
      x = BigInt(P);
    else if (typeof P == "string") {
      if (P.length !== 2 * f)
        throw new Error("Expected 32 bytes of private key");
      x = re(P);
    } else if (P instanceof Uint8Array) {
      if (P.length !== f)
        throw new Error("Expected 32 bytes of private key");
      x = ne(P);
    } else
      throw new TypeError("Expected valid private key");
    if (!Re(x))
      throw new Error("Expected private key: 0 < key < n");
    return x;
  }
  function Sn(P) {
    return P instanceof _ ? (P.assertValidity(), P) : _.fromHex(P);
  }
  function ka(P) {
    if (P instanceof D)
      return P.assertValidity(), P;
    try {
      return D.fromDER(P);
    } catch {
      return D.fromCompact(P);
    }
  }
  function tc(P, x = !1) {
    return _.fromPrivateKey(P).toRawBytes(x);
  }
  e.getPublicKey = tc;
  function xa(P, x, T, B = !1) {
    return _.fromSignature(P, x, T).toRawBytes(B);
  }
  e.recoverPublicKey = xa;
  function _n(P) {
    const x = P instanceof Uint8Array, T = typeof P == "string", B = (x || T) && P.length;
    return x ? B === p || B === y : T ? B === p * 2 || B === y * 2 : P instanceof _;
  }
  function Xt(P, x, T = !1) {
    if (_n(P))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!_n(x))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const B = Sn(x);
    return B.assertValidity(), B.multiply(Wt(P)).toRawBytes(T);
  }
  e.getSharedSecret = Xt;
  function lo(P) {
    const x = P.length > c ? P.slice(0, c) : P;
    return ne(x);
  }
  function rc(P) {
    const x = lo(P), T = K(x, s.n);
    return or(T < r ? x : T);
  }
  function or(P) {
    return R(P);
  }
  function Aa(P, x, T) {
    if (P == null)
      throw new Error(`sign: expected valid message hash, not "${P}"`);
    const B = oe(P), j = Wt(x), q = [or(j), rc(B)];
    if (T != null) {
      T === !0 && (T = e.utils.randomBytes(c));
      const ae = oe(T);
      if (ae.length !== c)
        throw new Error(`sign: Expected ${c} bytes of extra data`);
      q.push(ae);
    }
    const X = G(...q), Q = lo(B);
    return { seed: X, m: Q, d: j };
  }
  function d(P, x) {
    const { sig: T, recovery: B } = P, { der: j, recovered: q } = Object.assign({ canonical: !0, der: !0 }, x), X = j ? T.toDERRawBytes() : T.toCompactRawBytes();
    return q ? [X, B] : X;
  }
  async function g(P, x, T = {}) {
    const { seed: B, m: j, d: q } = Aa(P, x, T.extraEntropy), X = new We(h, f);
    await X.reseed(B);
    let Q;
    for (; !(Q = xr(await X.generate(), j, q, T.canonical)); )
      await X.reseed();
    return d(Q, T);
  }
  e.sign = g;
  function w(P, x, T = {}) {
    const { seed: B, m: j, d: q } = Aa(P, x, T.extraEntropy), X = new We(h, f);
    X.reseedSync(B);
    let Q;
    for (; !(Q = xr(X.generateSync(), j, q, T.canonical)); )
      X.reseedSync();
    return d(Q, T);
  }
  e.signSync = w;
  const $ = { strict: !0 };
  function N(P, x, T, B = $) {
    let j;
    try {
      j = ka(P), x = oe(x);
    } catch {
      return !1;
    }
    const { r: q, s: X } = j;
    if (B.strict && j.hasHighS())
      return !1;
    const Q = be(x);
    let ae;
    try {
      ae = Sn(T);
    } catch {
      return !1;
    }
    const { n: ie } = s, le = ye(X, ie), pe = K(Q * le, ie), we = K(q * le, ie), kt = _.BASE.multiplyAndAddUnsafe(ae, pe, we);
    return kt ? K(kt.x, ie) === q : !1;
  }
  e.verify = N;
  function H(P) {
    return K(ne(P), s.n);
  }
  class Z {
    constructor(x, T) {
      this.r = x, this.s = T, this.assertValidity();
    }
    static fromHex(x) {
      const T = oe(x);
      if (T.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${T.length}`);
      const B = ne(T.subarray(0, 32)), j = ne(T.subarray(32, 64));
      return new Z(B, j);
    }
    assertValidity() {
      const { r: x, s: T } = this;
      if (!Tt(x) || !Re(T))
        throw new Error("Invalid signature");
    }
    toHex() {
      return C(this.r) + C(this.s);
    }
    toRawBytes() {
      return W(this.toHex());
    }
  }
  function Te(P) {
    return _.fromPrivateKey(P).toRawX();
  }
  class ut {
    constructor(x, T, B = e.utils.randomBytes()) {
      if (x == null)
        throw new TypeError(`sign: Expected valid message, not "${x}"`);
      this.m = oe(x);
      const { x: j, scalar: q } = this.getScalar(Wt(T));
      if (this.px = j, this.d = q, this.rand = oe(B), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(x) {
      const T = _.fromPrivateKey(x), B = T.hasEvenY() ? x : s.n - x;
      return { point: T, scalar: B, x: T.toRawX() };
    }
    initNonce(x, T) {
      return R(x ^ ne(T));
    }
    finalizeNonce(x) {
      const T = K(ne(x), s.n);
      if (T === r)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: B, x: j, scalar: q } = this.getScalar(T);
      return { R: B, rx: j, k: q };
    }
    finalizeSig(x, T, B, j) {
      return new Z(x.x, K(T + B * j, s.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: x, d: T, px: B, rand: j } = this, q = e.utils.taggedHash, X = this.initNonce(T, await q(un.aux, j)), { R: Q, rx: ae, k: ie } = this.finalizeNonce(await q(un.nonce, X, B, x)), le = H(await q(un.challenge, ae, B, x)), pe = this.finalizeSig(Q, ie, le, T);
      return await Td(pe, x, B) || this.error(), pe;
    }
    calcSync() {
      const { m: x, d: T, px: B, rand: j } = this, q = e.utils.taggedHashSync, X = this.initNonce(T, q(un.aux, j)), { R: Q, rx: ae, k: ie } = this.finalizeNonce(q(un.nonce, X, B, x)), le = H(q(un.challenge, ae, B, x)), pe = this.finalizeSig(Q, ie, le, T);
      return Pd(pe, x, B) || this.error(), pe;
    }
  }
  async function Be(P, x, T) {
    return new ut(P, x, T).calc();
  }
  function Ie(P, x, T) {
    return new ut(P, x, T).calcSync();
  }
  function Xe(P, x, T) {
    const B = P instanceof Z, j = B ? P : Z.fromHex(P);
    return B && j.assertValidity(), {
      ...j,
      m: oe(x),
      P: Sn(T)
    };
  }
  function Id(P, x, T, B) {
    const j = _.BASE.multiplyAndAddUnsafe(x, Wt(T), K(-B, s.n));
    return !(!j || !j.hasEvenY() || j.x !== P);
  }
  async function Td(P, x, T) {
    try {
      const { r: B, s: j, m: q, P: X } = Xe(P, x, T), Q = H(await e.utils.taggedHash(un.challenge, R(B), X.toRawX(), q));
      return Id(B, X, j, Q);
    } catch {
      return !1;
    }
  }
  function Pd(P, x, T) {
    try {
      const { r: B, s: j, m: q, P: X } = Xe(P, x, T), Q = H(e.utils.taggedHashSync(un.challenge, R(B), X.toRawX(), q));
      return Id(B, X, j, Q);
    } catch (B) {
      if (B instanceof v)
        throw B;
      return !1;
    }
  }
  e.schnorr = {
    Signature: Z,
    getPublicKey: Te,
    sign: Be,
    verify: Td,
    signSync: Ie,
    verifySync: Pd
  }, _.BASE._setWindowSize(8);
  const Kt = {
    node: t,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, un = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, Sa = {};
  e.utils = {
    bytesToHex: V,
    hexToBytes: W,
    concatBytes: G,
    mod: K,
    invert: ye,
    isValidPrivateKey(P) {
      try {
        return Wt(P), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: R,
    _normalizePrivateKey: Wt,
    hashToPrivateKey: (P) => {
      P = oe(P);
      const x = f + 8;
      if (P.length < x || P.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const T = K(ne(P), s.n - n) + n;
      return R(T);
    },
    randomBytes: (P = 32) => {
      if (Kt.web)
        return Kt.web.getRandomValues(new Uint8Array(P));
      if (Kt.node) {
        const { randomBytes: x } = Kt.node;
        return Uint8Array.from(x(P));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => e.utils.hashToPrivateKey(e.utils.randomBytes(f + 8)),
    precompute(P = 8, x = _.BASE) {
      const T = x === _.BASE ? x : new _(x.x, x.y);
      return T._setWindowSize(P), T.multiply(a), T;
    },
    sha256: async (...P) => {
      if (Kt.web) {
        const x = await Kt.web.subtle.digest("SHA-256", G(...P));
        return new Uint8Array(x);
      } else if (Kt.node) {
        const { createHash: x } = Kt.node, T = x("sha256");
        return P.forEach((B) => T.update(B)), Uint8Array.from(T.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (P, ...x) => {
      if (Kt.web) {
        const T = await Kt.web.subtle.importKey("raw", P, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), B = G(...x), j = await Kt.web.subtle.sign("HMAC", T, B);
        return new Uint8Array(j);
      } else if (Kt.node) {
        const { createHmac: T } = Kt.node, B = T("sha256", P);
        return x.forEach((j) => B.update(j)), Uint8Array.from(B.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (P, ...x) => {
      let T = Sa[P];
      if (T === void 0) {
        const B = await e.utils.sha256(Uint8Array.from(P, (j) => j.charCodeAt(0)));
        T = G(B, B), Sa[P] = T;
      }
      return e.utils.sha256(T, ...x);
    },
    taggedHashSync: (P, ...x) => {
      if (typeof st != "function")
        throw new v("sha256Sync is undefined, you need to set it");
      let T = Sa[P];
      if (T === void 0) {
        const B = st(Uint8Array.from(P, (j) => j.charCodeAt(0)));
        T = G(B, B), Sa[P] = T;
      }
      return st(T, ...x);
    },
    _JacobianPoint: E
  }, Object.defineProperties(e.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return st;
      },
      set(P) {
        st || (st = P);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Ze;
      },
      set(P) {
        Ze || (Ze = P);
      }
    }
  });
})(K3);
var Zm = {}, Io = {};
Object.defineProperty(Io, "__esModule", { value: !0 });
Io.isBytes = C_;
Io.number = Eg;
Io.bool = $_;
Io.bytes = q3;
Io.hash = B_;
Io.exists = N_;
Io.output = U_;
function Eg(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function $_(e) {
  if (typeof e != "boolean")
    throw new Error(`boolean expected, not ${e}`);
}
function C_(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function q3(e, ...t) {
  if (!C_(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function B_(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Eg(e.outputLen), Eg(e.blockLen);
}
function N_(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function U_(e, t) {
  q3(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const DW = { number: Eg, bool: $_, bytes: q3, hash: B_, exists: N_, output: U_ };
Io.default = DW;
var Gu = {}, Wm = {};
Object.defineProperty(Wm, "__esModule", { value: !0 });
Wm.crypto = void 0;
Wm.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Hash = e.nextTick = e.byteSwapIfBE = e.byteSwap = e.isLE = e.rotl = e.rotr = e.createView = e.u32 = e.u8 = void 0, e.isBytes = n, e.byteSwap32 = c, e.bytesToHex = h, e.hexToBytes = m, e.asyncLoop = v, e.utf8ToBytes = k, e.toBytes = E, e.concatBytes = A, e.checkOpts = I, e.wrapConstructor = O, e.wrapConstructorWithOpts = z, e.wrapXOFConstructorWithOpts = D, e.randomBytes = G;
  const t = Wm, r = Io;
  function n(U) {
    return U instanceof Uint8Array || U != null && typeof U == "object" && U.constructor.name === "Uint8Array";
  }
  const o = (U) => new Uint8Array(U.buffer, U.byteOffset, U.byteLength);
  e.u8 = o;
  const a = (U) => new Uint32Array(U.buffer, U.byteOffset, Math.floor(U.byteLength / 4));
  e.u32 = a;
  const i = (U) => new DataView(U.buffer, U.byteOffset, U.byteLength);
  e.createView = i;
  const s = (U, V) => U << 32 - V | U >>> V;
  e.rotr = s;
  const u = (U, V) => U << V | U >>> 32 - V >>> 0;
  e.rotl = u, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  const l = (U) => U << 24 & 4278190080 | U << 8 & 16711680 | U >>> 8 & 65280 | U >>> 24 & 255;
  e.byteSwap = l, e.byteSwapIfBE = e.isLE ? (U) => U : (U) => (0, e.byteSwap)(U);
  function c(U) {
    for (let V = 0; V < U.length; V++)
      U[V] = (0, e.byteSwap)(U[V]);
  }
  const f = /* @__PURE__ */ Array.from({ length: 256 }, (U, V) => V.toString(16).padStart(2, "0"));
  function h(U) {
    (0, r.bytes)(U);
    let V = "";
    for (let F = 0; F < U.length; F++)
      V += f[U[F]];
    return V;
  }
  const p = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function y(U) {
    if (U >= p._0 && U <= p._9)
      return U - p._0;
    if (U >= p._A && U <= p._F)
      return U - (p._A - 10);
    if (U >= p._a && U <= p._f)
      return U - (p._a - 10);
  }
  function m(U) {
    if (typeof U != "string")
      throw new Error("hex string expected, got " + typeof U);
    const V = U.length, F = V / 2;
    if (V % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + V);
    const C = new Uint8Array(F);
    for (let R = 0, M = 0; R < F; R++, M += 2) {
      const re = y(U.charCodeAt(M)), W = y(U.charCodeAt(M + 1));
      if (re === void 0 || W === void 0) {
        const ne = U[M] + U[M + 1];
        throw new Error('hex string expected, got non-hex character "' + ne + '" at index ' + M);
      }
      C[R] = re * 16 + W;
    }
    return C;
  }
  const b = async () => {
  };
  e.nextTick = b;
  async function v(U, V, F) {
    let C = Date.now();
    for (let R = 0; R < U; R++) {
      F(R);
      const M = Date.now() - C;
      M >= 0 && M < V || (await (0, e.nextTick)(), C += M);
    }
  }
  function k(U) {
    if (typeof U != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof U}`);
    return new Uint8Array(new TextEncoder().encode(U));
  }
  function E(U) {
    return typeof U == "string" && (U = k(U)), (0, r.bytes)(U), U;
  }
  function A(...U) {
    let V = 0;
    for (let C = 0; C < U.length; C++) {
      const R = U[C];
      (0, r.bytes)(R), V += R.length;
    }
    const F = new Uint8Array(V);
    for (let C = 0, R = 0; C < U.length; C++) {
      const M = U[C];
      F.set(M, R), R += M.length;
    }
    return F;
  }
  class S {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = S;
  const _ = {}.toString;
  function I(U, V) {
    if (V !== void 0 && _.call(V) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(U, V);
  }
  function O(U) {
    const V = (C) => U().update(E(C)).digest(), F = U();
    return V.outputLen = F.outputLen, V.blockLen = F.blockLen, V.create = () => U(), V;
  }
  function z(U) {
    const V = (C, R) => U(R).update(E(C)).digest(), F = U({});
    return V.outputLen = F.outputLen, V.blockLen = F.blockLen, V.create = (C) => U(C), V;
  }
  function D(U) {
    const V = (C, R) => U(R).update(E(C)).digest(), F = U({});
    return V.outputLen = F.outputLen, V.blockLen = F.blockLen, V.create = (C) => U(C), V;
  }
  function G(U = 32) {
    if (t.crypto && typeof t.crypto.getRandomValues == "function")
      return t.crypto.getRandomValues(new Uint8Array(U));
    if (t.crypto && typeof t.crypto.randomBytes == "function")
      return t.crypto.randomBytes(U);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(Gu);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.hmac = e.HMAC = void 0;
  const t = Io, r = Gu;
  class n extends r.Hash {
    constructor(i, s) {
      super(), this.finished = !1, this.destroyed = !1, (0, t.hash)(i);
      const u = (0, r.toBytes)(s);
      if (this.iHash = i.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const l = this.blockLen, c = new Uint8Array(l);
      c.set(u.length > l ? i.create().update(u).digest() : u);
      for (let f = 0; f < c.length; f++)
        c[f] ^= 54;
      this.iHash.update(c), this.oHash = i.create();
      for (let f = 0; f < c.length; f++)
        c[f] ^= 106;
      this.oHash.update(c), c.fill(0);
    }
    update(i) {
      return (0, t.exists)(this), this.iHash.update(i), this;
    }
    digestInto(i) {
      (0, t.exists)(this), (0, t.bytes)(i, this.outputLen), this.finished = !0, this.iHash.digestInto(i), this.oHash.update(i), this.oHash.digestInto(i), this.destroy();
    }
    digest() {
      const i = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(i), i;
    }
    _cloneInto(i) {
      i || (i = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: s, iHash: u, finished: l, destroyed: c, blockLen: f, outputLen: h } = this;
      return i = i, i.finished = l, i.destroyed = c, i.blockLen = f, i.outputLen = h, i.oHash = s._cloneInto(i.oHash), i.iHash = u._cloneInto(i.iHash), i;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e.HMAC = n;
  const o = (a, i, s) => new n(a, i).update(s).digest();
  e.hmac = o, e.hmac.create = (a, i) => new n(a, i);
})(Zm);
var yi = {}, Qa = {};
Object.defineProperty(Qa, "__esModule", { value: !0 });
Qa.HashMD = Qa.Maj = Qa.Chi = void 0;
const b2 = Io, Rd = Gu;
function MW(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
const KW = (e, t, r) => e & t ^ ~e & r;
Qa.Chi = KW;
const qW = (e, t, r) => e & t ^ e & r ^ t & r;
Qa.Maj = qW;
let VW = class extends Rd.Hash {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = (0, Rd.createView)(this.buffer);
  }
  update(t) {
    (0, b2.exists)(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = (0, Rd.toBytes)(t);
    const a = t.length;
    for (let i = 0; i < a; ) {
      const s = Math.min(o - this.pos, a - i);
      if (s === o) {
        const u = (0, Rd.createView)(t);
        for (; o <= a - i; i += o)
          this.process(u, i);
        continue;
      }
      n.set(t.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    (0, b2.exists)(this), (0, b2.output)(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: o, isLE: a } = this;
    let { pos: i } = this;
    r[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > o - i && (this.process(n, 0), i = 0);
    for (let f = i; f < o; f++)
      r[f] = 0;
    MW(n, o - 8, BigInt(this.length * 8), a), this.process(n, 0);
    const s = (0, Rd.createView)(t), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, c = this.get();
    if (l > c.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < l; f++)
      s.setUint32(4 * f, c[f], a);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: a, destroyed: i, pos: s } = this;
    return t.length = o, t.pos = s, t.finished = a, t.destroyed = i, o % r && t.buffer.set(n), t;
  }
};
Qa.HashMD = VW;
Object.defineProperty(yi, "__esModule", { value: !0 });
yi.sha224 = yi.sha256 = yi.SHA256 = void 0;
const w2 = Qa, Fo = Gu, GW = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Ls = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Hs = /* @__PURE__ */ new Uint32Array(64);
let V3 = class extends w2.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = Ls[0] | 0, this.B = Ls[1] | 0, this.C = Ls[2] | 0, this.D = Ls[3] | 0, this.E = Ls[4] | 0, this.F = Ls[5] | 0, this.G = Ls[6] | 0, this.H = Ls[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: a, F: i, G: s, H: u } = this;
    return [t, r, n, o, a, i, s, u];
  }
  // prettier-ignore
  set(t, r, n, o, a, i, s, u) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = a | 0, this.F = i | 0, this.G = s | 0, this.H = u | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      Hs[f] = t.getUint32(r, !1);
    for (let f = 16; f < 64; f++) {
      const h = Hs[f - 15], p = Hs[f - 2], y = (0, Fo.rotr)(h, 7) ^ (0, Fo.rotr)(h, 18) ^ h >>> 3, m = (0, Fo.rotr)(p, 17) ^ (0, Fo.rotr)(p, 19) ^ p >>> 10;
      Hs[f] = m + Hs[f - 7] + y + Hs[f - 16] | 0;
    }
    let { A: n, B: o, C: a, D: i, E: s, F: u, G: l, H: c } = this;
    for (let f = 0; f < 64; f++) {
      const h = (0, Fo.rotr)(s, 6) ^ (0, Fo.rotr)(s, 11) ^ (0, Fo.rotr)(s, 25), p = c + h + (0, w2.Chi)(s, u, l) + GW[f] + Hs[f] | 0, y = ((0, Fo.rotr)(n, 2) ^ (0, Fo.rotr)(n, 13) ^ (0, Fo.rotr)(n, 22)) + (0, w2.Maj)(n, o, a) | 0;
      c = l, l = u, u = s, s = i + p | 0, i = a, a = o, o = n, n = p + y | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, c = c + this.H | 0, this.set(n, o, a, i, s, u, l, c);
  }
  roundClean() {
    Hs.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
yi.SHA256 = V3;
let ZW = class extends V3 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
yi.sha256 = (0, Fo.wrapConstructor)(() => new V3());
yi.sha224 = (0, Fo.wrapConstructor)(() => new ZW());
var WW = K3, XW = Zm, R_ = yi;
function YW(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(r) {
    if (r !== "default") {
      var n = Object.getOwnPropertyDescriptor(e, r);
      Object.defineProperty(t, r, n.get ? n : {
        enumerable: !0,
        get: function() {
          return e[r];
        }
      });
    }
  }), t.default = e, Object.freeze(t);
}
var $t = /* @__PURE__ */ YW(WW);
const Zu = "Expected Private", Wu = "Expected Point", Ip = "Expected Tweak", JW = "Expected Hash", kg = "Expected Signature", G3 = "Expected Extra Data (32 bytes)", Tp = "Expected Scalar", QW = "Bad Recovery Id";
$t.utils.hmacSha256Sync = (e, ...t) => XW.hmac(R_.sha256, e, $t.utils.concatBytes(...t));
$t.utils.sha256Sync = (...e) => R_.sha256($t.utils.concatBytes(...e));
const Z3 = $t.utils._normalizePrivateKey, eX = 32, tX = 32, dv = new Uint8Array([
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  186,
  174,
  220,
  230,
  175,
  72,
  160,
  59,
  191,
  210,
  94,
  140,
  208,
  54,
  65,
  65
]), rX = 32, nX = new Uint8Array(32), oX = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  69,
  81,
  35,
  25,
  80,
  183,
  95,
  196,
  64,
  45,
  161,
  114,
  47,
  201,
  186,
  238
]);
function iX(e) {
  return e instanceof Uint8Array;
}
function Rh(e, t) {
  for (let r = 0; r < 32; ++r)
    if (e[r] !== t[r])
      return e[r] < t[r] ? -1 : 1;
  return 0;
}
function TE(e) {
  return Rh(e, nX) === 0;
}
function Pp(e) {
  return !(!(e instanceof Uint8Array) || e.length !== tX || Rh(e, dv) >= 0);
}
function W3(e) {
  return e instanceof Uint8Array && e.length === 64 && Rh(e.subarray(0, 32), dv) < 0 && Rh(e.subarray(32, 64), dv) < 0;
}
function aX(e) {
  return iX(e) && e.length === 64 && Rh(e.subarray(0, 32), oX) < 0;
}
function sX(e) {
  return !(TE(e.subarray(0, 32)) || TE(e.subarray(32, 64)));
}
function Qf(e) {
  return e instanceof Uint8Array && e.length === eX;
}
function X3(e) {
  return e === void 0 || e instanceof Uint8Array && e.length === rX;
}
function z_(e) {
  if (typeof e != "string")
    throw new TypeError("hexToNumber: expected string, got " + typeof e);
  return BigInt(`0x${e}`);
}
function uX(e) {
  return z_($t.utils.bytesToHex(e));
}
function Y3(e) {
  let t;
  if (typeof e == "bigint")
    t = e;
  else if (typeof e == "number" && Number.isSafeInteger(e) && e >= 0)
    t = BigInt(e);
  else if (typeof e == "string") {
    if (e.length !== 64)
      throw new Error("Expected 32 bytes of private scalar");
    t = z_(e);
  } else if (e instanceof Uint8Array) {
    if (e.length !== 32)
      throw new Error("Expected 32 bytes of private scalar");
    t = uX(e);
  } else
    throw new TypeError("Expected valid private scalar");
  if (t < 0) throw new Error("Expected private scalar >= 0");
  return t;
}
const cX = (e, t) => {
  const r = Z3(e), n = Y3(t), o = $t.utils._bigintTo32Bytes($t.utils.mod(r + n, $t.CURVE.n));
  return $t.utils.isValidPrivateKey(o) ? o : null;
}, lX = (e, t) => {
  const r = Z3(e), n = Y3(t), o = $t.utils._bigintTo32Bytes($t.utils.mod(r - n, $t.CURVE.n));
  return $t.utils.isValidPrivateKey(o) ? o : null;
}, fX = (e) => {
  const t = Z3(e), r = $t.utils._bigintTo32Bytes($t.CURVE.n - t);
  return $t.utils.isValidPrivateKey(r) ? r : null;
}, j_ = (e, t, r) => {
  const n = $t.Point.fromHex(e), o = Y3(t), a = $t.Point.BASE.multiplyAndAddUnsafe(n, o, BigInt(1));
  if (!a) throw new Error("Tweaked point at infinity");
  return a.toRawBytes(r);
}, dX = (e, t, r) => {
  const n = $t.Point.fromHex(e), o = typeof t == "string" ? t : $t.utils.bytesToHex(t), a = BigInt(`0x${o}`);
  return n.multiply(a).toRawBytes(r);
};
function ed(e, t) {
  return e === void 0 ? t !== void 0 ? L_(t) : !0 : !!e;
}
function ll(e) {
  try {
    return e();
  } catch {
    return null;
  }
}
function J3(e, t) {
  if (e.length === 32 !== t) return !1;
  try {
    return !!$t.Point.fromHex(e);
  } catch {
    return !1;
  }
}
function Ru(e) {
  return J3(e, !1);
}
function L_(e) {
  return J3(e, !1) && e.length === 33;
}
function gs(e) {
  return $t.utils.isValidPrivateKey(e);
}
function Xm(e) {
  return J3(e, !0);
}
function hX(e, t) {
  if (!Xm(e))
    throw new Error(Wu);
  if (!Pp(t))
    throw new Error(Ip);
  return ll(() => {
    const r = j_(e, t, !0);
    return { parity: r[0] % 2 === 1 ? 1 : 0, xOnlyPubkey: r.slice(1) };
  });
}
function H_(e) {
  if (!Ru(e))
    throw new Error(Wu);
  return e.slice(1, 33);
}
function F_(e, t) {
  if (!gs(e))
    throw new Error(Zu);
  return ll(
    () => $t.getPublicKey(e, ed(t))
  );
}
function pX(e) {
  if (!gs(e))
    throw new Error(Zu);
  return H_(F_(e));
}
function gX(e, t) {
  if (!Ru(e))
    throw new Error(Wu);
  return $t.Point.fromHex(e).toRawBytes(ed(t, e));
}
function mX(e, t, r) {
  if (!Ru(e))
    throw new Error(Wu);
  if (!Pp(t))
    throw new Error(Ip);
  return ll(
    () => dX(e, t, ed(r, e))
  );
}
function yX(e, t, r) {
  if (!Ru(e) || !Ru(t))
    throw new Error(Wu);
  return ll(() => {
    const n = $t.Point.fromHex(e), o = $t.Point.fromHex(t);
    return n.equals(o.negate()) ? null : n.add(o).toRawBytes(ed(r, e));
  });
}
function bX(e, t, r) {
  if (!Ru(e))
    throw new Error(Wu);
  if (!Pp(t))
    throw new Error(Ip);
  return ll(
    () => j_(e, t, ed(r, e))
  );
}
function wX(e, t) {
  if (gs(e) === !1)
    throw new Error(Zu);
  if (Pp(t) === !1)
    throw new Error(Ip);
  return ll(() => cX(e, t));
}
function vX(e, t) {
  if (gs(e) === !1)
    throw new Error(Zu);
  if (Pp(t) === !1)
    throw new Error(Ip);
  return ll(() => lX(e, t));
}
function EX(e) {
  if (gs(e) === !1)
    throw new Error(Zu);
  return fX(e);
}
function kX(e, t, r) {
  if (!gs(t))
    throw new Error(Zu);
  if (!Qf(e))
    throw new Error(Tp);
  if (!X3(r))
    throw new Error(G3);
  return $t.signSync(e, t, { der: !1, extraEntropy: r });
}
function xX(e, t, r) {
  if (!gs(t))
    throw new Error(Zu);
  if (!Qf(e))
    throw new Error(Tp);
  if (!X3(r))
    throw new Error(G3);
  const [n, o] = $t.signSync(e, t, { der: !1, extraEntropy: r, recovered: !0 });
  return { signature: n, recoveryId: o };
}
function AX(e, t, r = Buffer.alloc(32, 0)) {
  if (!gs(t))
    throw new Error(Zu);
  if (!Qf(e))
    throw new Error(Tp);
  if (!X3(r))
    throw new Error(G3);
  return $t.schnorr.signSync(e, t, r);
}
function SX(e, t, r, n) {
  if (!Qf(e))
    throw new Error(JW);
  if (!W3(t) || !sX(t))
    throw new Error(kg);
  if (r & 2 && !aX(t))
    throw new Error(QW);
  if (!Xm(t.subarray(0, 32)))
    throw new Error(kg);
  return $t.recoverPublicKey(e, t, r, ed(n));
}
function _X(e, t, r, n) {
  if (!Ru(t))
    throw new Error(Wu);
  if (!W3(r))
    throw new Error(kg);
  if (!Qf(e))
    throw new Error(Tp);
  return $t.verify(r, e, t, { strict: n });
}
function IX(e, t, r) {
  if (!Xm(t))
    throw new Error(Wu);
  if (!W3(r))
    throw new Error(kg);
  if (!Qf(e))
    throw new Error(Tp);
  return $t.schnorr.verifySync(r, e, t);
}
var TX = mr.isPoint = Ru, PX = mr.isPointCompressed = L_, OX = mr.isPrivate = gs, $X = mr.isXOnlyPoint = Xm, CX = mr.pointAdd = yX, BX = mr.pointAddScalar = bX, NX = mr.pointCompress = gX, UX = mr.pointFromScalar = F_, RX = mr.pointMultiply = mX, zX = mr.privateAdd = wX, jX = mr.privateNegate = EX, LX = mr.privateSub = vX, HX = mr.recover = SX, FX = mr.sign = kX, DX = mr.signRecoverable = xX, MX = mr.signSchnorr = AX, KX = mr.verify = _X, qX = mr.verifySchnorr = IX, VX = mr.xOnlyPointAddTweak = hX, GX = mr.xOnlyPointFromPoint = H_, ZX = mr.xOnlyPointFromScalar = pX;
const Ym = /* @__PURE__ */ IU({
  __proto__: null,
  default: mr,
  isPoint: TX,
  isPointCompressed: PX,
  isPrivate: OX,
  isXOnlyPoint: $X,
  pointAdd: CX,
  pointAddScalar: BX,
  pointCompress: NX,
  pointFromScalar: UX,
  pointMultiply: RX,
  privateAdd: zX,
  privateNegate: jX,
  privateSub: LX,
  recover: HX,
  sign: FX,
  signRecoverable: DX,
  signSchnorr: MX,
  verify: KX,
  verifySchnorr: qX,
  xOnlyPointAddTweak: VX,
  xOnlyPointFromPoint: GX,
  xOnlyPointFromScalar: ZX
}, [mr]), $3e = "Mainnet", hv = "BITCOIN_MAINNET", D_ = "BITCOIN_TESTNET", M_ = "BITCOIN_TESTNET4", K_ = "BITCOIN_SIGNET", q_ = "FRACTAL_BITCOIN_MAINNET", V_ = "FRACTAL_BITCOIN_TESTNET", C3e = "livenet", B3e = "testnet", pv = "Mainnet", G_ = "Testnet", WX = "Signet", XX = "livenet", YX = "testnet", xg = "livenet", gv = "testnet", Z_ = "testnet4", W_ = "signet", PE = "Mainnet", JX = "Testnet", mv = "mainnet", X_ = "testnet", OE = "main", QX = "testnet", eY = "signet", Ot = "mainnet", pn = "signet", Yt = "testnet", on = "testnet4", fl = "fractal mainnet", Nn = "fractal testnet", N3e = "regtest", x1 = (e) => e === Ot ? pv : e === Yt || e === on ? G_ : e === pn ? WX : pv, U3e = (e) => e === Ot ? mv : e === Yt ? X_ : mv, Y_ = (e) => e === Ot ? hv : e === Yt ? D_ : e === on ? M_ : e === pn ? K_ : e === fl ? q_ : e === Nn ? V_ : hv, R3e = (e) => e === Ot ? xg : e === Yt ? gv : e === on ? Z_ : e === pn ? W_ : e === Nn ? gv : xg, v2 = (e) => e === Ot ? PE : e === Yt || e === on || e === pn ? JX : PE, tY = (e) => e === Ot ? OE : e === on || e === Yt ? QX : e === pn ? eY : OE, Ag = (e) => e === hv ? Ot : e === D_ ? Yt : e === M_ ? on : e === K_ ? pn : e === q_ ? fl : e === V_ ? Nn : Ot, z3e = (e) => e === pv ? Ot : e === G_ ? Yt : Ot, j3e = (e) => e === mv ? Ot : e === X_ ? Yt : Ot, rY = (e) => e === XX ? Ot : e === YX ? Yt : Ot, $E = (e) => e === xg ? Ot : e === gv ? Yt : e === Z_ ? on : e === W_ ? pn : e === Nn ? Yt : Ot;
function J_(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: nY } = Object.prototype, { getPrototypeOf: Q3 } = Object, Jm = /* @__PURE__ */ ((e) => (t) => {
  const r = nY.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Ci = (e) => (e = e.toLowerCase(), (t) => Jm(t) === e), Qm = (e) => (t) => typeof t === e, { isArray: td } = Array, zh = Qm("undefined");
function oY(e) {
  return e !== null && !zh(e) && e.constructor !== null && !zh(e.constructor) && xo(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const Q_ = Ci("ArrayBuffer");
function iY(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && Q_(e.buffer), t;
}
const aY = Qm("string"), xo = Qm("function"), eI = Qm("number"), ey = (e) => e !== null && typeof e == "object", sY = (e) => e === !0 || e === !1, A1 = (e) => {
  if (Jm(e) !== "object")
    return !1;
  const t = Q3(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, uY = Ci("Date"), cY = Ci("File"), lY = Ci("Blob"), fY = Ci("FileList"), dY = (e) => ey(e) && xo(e.pipe), hY = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || xo(e.append) && ((t = Jm(e)) === "formdata" || // detect form-data instance
  t === "object" && xo(e.toString) && e.toString() === "[object FormData]"));
}, pY = Ci("URLSearchParams"), [gY, mY, yY, bY] = ["ReadableStream", "Request", "Response", "Headers"].map(Ci), wY = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Op(e, t, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, o;
  if (typeof e != "object" && (e = [e]), td(e))
    for (n = 0, o = e.length; n < o; n++)
      t.call(null, e[n], n, e);
  else {
    const a = r ? Object.getOwnPropertyNames(e) : Object.keys(e), i = a.length;
    let s;
    for (n = 0; n < i; n++)
      s = a[n], t.call(null, e[s], s, e);
  }
}
function tI(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, o;
  for (; n-- > 0; )
    if (o = r[n], t === o.toLowerCase())
      return o;
  return null;
}
const Ec = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, rI = (e) => !zh(e) && e !== Ec;
function yv() {
  const { caseless: e } = rI(this) && this || {}, t = {}, r = (n, o) => {
    const a = e && tI(t, o) || o;
    A1(t[a]) && A1(n) ? t[a] = yv(t[a], n) : A1(n) ? t[a] = yv({}, n) : td(n) ? t[a] = n.slice() : t[a] = n;
  };
  for (let n = 0, o = arguments.length; n < o; n++)
    arguments[n] && Op(arguments[n], r);
  return t;
}
const vY = (e, t, r, { allOwnKeys: n } = {}) => (Op(t, (o, a) => {
  r && xo(o) ? e[a] = J_(o, r) : e[a] = o;
}, { allOwnKeys: n }), e), EY = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), kY = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
}, xY = (e, t, r, n) => {
  let o, a, i;
  const s = {};
  if (t = t || {}, e == null) return t;
  do {
    for (o = Object.getOwnPropertyNames(e), a = o.length; a-- > 0; )
      i = o[a], (!n || n(i, e, t)) && !s[i] && (t[i] = e[i], s[i] = !0);
    e = r !== !1 && Q3(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
}, AY = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
}, SY = (e) => {
  if (!e) return null;
  if (td(e)) return e;
  let t = e.length;
  if (!eI(t)) return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
}, _Y = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Q3(Uint8Array)), IY = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let n;
  for (; (n = r.next()) && !n.done; ) {
    const o = n.value;
    t.call(e, o[0], o[1]);
  }
}, TY = (e, t) => {
  let r;
  const n = [];
  for (; (r = e.exec(t)) !== null; )
    n.push(r);
  return n;
}, PY = Ci("HTMLFormElement"), OY = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, r, n) {
    return r.toUpperCase() + n;
  }
), CE = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), $Y = Ci("RegExp"), nI = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  Op(r, (o, a) => {
    let i;
    (i = t(o, a, e)) !== !1 && (n[a] = i || o);
  }), Object.defineProperties(e, n);
}, CY = (e) => {
  nI(e, (t, r) => {
    if (xo(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = e[r];
    if (xo(n)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, BY = (e, t) => {
  const r = {}, n = (o) => {
    o.forEach((a) => {
      r[a] = !0;
    });
  };
  return td(e) ? n(e) : n(String(e).split(t)), r;
}, NY = () => {
}, UY = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, E2 = "abcdefghijklmnopqrstuvwxyz", BE = "0123456789", oI = {
  DIGIT: BE,
  ALPHA: E2,
  ALPHA_DIGIT: E2 + E2.toUpperCase() + BE
}, RY = (e = 16, t = oI.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = t;
  for (; e--; )
    r += t[Math.random() * n | 0];
  return r;
};
function zY(e) {
  return !!(e && xo(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const jY = (e) => {
  const t = new Array(10), r = (n, o) => {
    if (ey(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        t[o] = n;
        const a = td(n) ? [] : {};
        return Op(n, (i, s) => {
          const u = r(i, o + 1);
          !zh(u) && (a[s] = u);
        }), t[o] = void 0, a;
      }
    }
    return n;
  };
  return r(e, 0);
}, LY = Ci("AsyncFunction"), HY = (e) => e && (ey(e) || xo(e)) && xo(e.then) && xo(e.catch), iI = ((e, t) => e ? setImmediate : t ? ((r, n) => (Ec.addEventListener("message", ({ source: o, data: a }) => {
  o === Ec && a === r && n.length && n.shift()();
}, !1), (o) => {
  n.push(o), Ec.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  xo(Ec.postMessage)
), FY = typeof queueMicrotask < "u" ? queueMicrotask.bind(Ec) : typeof process < "u" && process.nextTick || iI, ee = {
  isArray: td,
  isArrayBuffer: Q_,
  isBuffer: oY,
  isFormData: hY,
  isArrayBufferView: iY,
  isString: aY,
  isNumber: eI,
  isBoolean: sY,
  isObject: ey,
  isPlainObject: A1,
  isReadableStream: gY,
  isRequest: mY,
  isResponse: yY,
  isHeaders: bY,
  isUndefined: zh,
  isDate: uY,
  isFile: cY,
  isBlob: lY,
  isRegExp: $Y,
  isFunction: xo,
  isStream: dY,
  isURLSearchParams: pY,
  isTypedArray: _Y,
  isFileList: fY,
  forEach: Op,
  merge: yv,
  extend: vY,
  trim: wY,
  stripBOM: EY,
  inherits: kY,
  toFlatObject: xY,
  kindOf: Jm,
  kindOfTest: Ci,
  endsWith: AY,
  toArray: SY,
  forEachEntry: IY,
  matchAll: TY,
  isHTMLForm: PY,
  hasOwnProperty: CE,
  hasOwnProp: CE,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: nI,
  freezeMethods: CY,
  toObjectSet: BY,
  toCamelCase: OY,
  noop: NY,
  toFiniteNumber: UY,
  findKey: tI,
  global: Ec,
  isContextDefined: rI,
  ALPHABET: oI,
  generateString: RY,
  isSpecCompliantForm: zY,
  toJSONObject: jY,
  isAsyncFn: LY,
  isThenable: HY,
  setImmediate: iI,
  asap: FY
};
function it(e, t, r, n, o) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), o && (this.response = o, this.status = o.status ? o.status : null);
}
ee.inherits(it, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ee.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const aI = it.prototype, sI = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  sI[e] = { value: e };
});
Object.defineProperties(it, sI);
Object.defineProperty(aI, "isAxiosError", { value: !0 });
it.from = (e, t, r, n, o, a) => {
  const i = Object.create(aI);
  return ee.toFlatObject(e, i, function(s) {
    return s !== Error.prototype;
  }, (s) => s !== "isAxiosError"), it.call(i, e.message, t, r, n, o), i.cause = e, i.name = e.name, a && Object.assign(i, a), i;
};
const DY = null;
function bv(e) {
  return ee.isPlainObject(e) || ee.isArray(e);
}
function uI(e) {
  return ee.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function NE(e, t, r) {
  return e ? e.concat(t).map(function(n, o) {
    return n = uI(n), !r && o ? "[" + n + "]" : n;
  }).join(r ? "." : "") : t;
}
function MY(e) {
  return ee.isArray(e) && !e.some(bv);
}
const KY = ee.toFlatObject(ee, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function ty(e, t, r) {
  if (!ee.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), r = ee.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(p, y) {
    return !ee.isUndefined(y[p]);
  });
  const n = r.metaTokens, o = r.visitor || l, a = r.dots, i = r.indexes, s = (r.Blob || typeof Blob < "u" && Blob) && ee.isSpecCompliantForm(t);
  if (!ee.isFunction(o))
    throw new TypeError("visitor must be a function");
  function u(p) {
    if (p === null) return "";
    if (ee.isDate(p))
      return p.toISOString();
    if (!s && ee.isBlob(p))
      throw new it("Blob is not supported. Use a Buffer instead.");
    return ee.isArrayBuffer(p) || ee.isTypedArray(p) ? s && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p;
  }
  function l(p, y, m) {
    let b = p;
    if (p && !m && typeof p == "object") {
      if (ee.endsWith(y, "{}"))
        y = n ? y : y.slice(0, -2), p = JSON.stringify(p);
      else if (ee.isArray(p) && MY(p) || (ee.isFileList(p) || ee.endsWith(y, "[]")) && (b = ee.toArray(p)))
        return y = uI(y), b.forEach(function(v, k) {
          !(ee.isUndefined(v) || v === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            i === !0 ? NE([y], k, a) : i === null ? y : y + "[]",
            u(v)
          );
        }), !1;
    }
    return bv(p) ? !0 : (t.append(NE(m, y, a), u(p)), !1);
  }
  const c = [], f = Object.assign(KY, {
    defaultVisitor: l,
    convertValue: u,
    isVisitable: bv
  });
  function h(p, y) {
    if (!ee.isUndefined(p)) {
      if (c.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      c.push(p), ee.forEach(p, function(m, b) {
        (!(ee.isUndefined(m) || m === null) && o.call(
          t,
          m,
          ee.isString(b) ? b.trim() : b,
          y,
          f
        )) === !0 && h(m, y ? y.concat(b) : [b]);
      }), c.pop();
    }
  }
  if (!ee.isObject(e))
    throw new TypeError("data must be an object");
  return h(e), t;
}
function UE(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function e5(e, t) {
  this._pairs = [], e && ty(e, this, t);
}
const cI = e5.prototype;
cI.append = function(e, t) {
  this._pairs.push([e, t]);
};
cI.toString = function(e) {
  const t = e ? function(r) {
    return e.call(this, r, UE);
  } : UE;
  return this._pairs.map(function(r) {
    return t(r[0]) + "=" + t(r[1]);
  }, "").join("&");
};
function qY(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function lI(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || qY, o = r && r.serialize;
  let a;
  if (o ? a = o(t, r) : a = ee.isURLSearchParams(t) ? t.toString() : new e5(t, r).toString(n), a) {
    const i = e.indexOf("#");
    i !== -1 && (e = e.slice(0, i)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return e;
}
let RE = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, n) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    ee.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
};
const fI = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, VY = typeof URLSearchParams < "u" ? URLSearchParams : e5, GY = typeof FormData < "u" ? FormData : null, ZY = typeof Blob < "u" ? Blob : null, WY = {
  isBrowser: !0,
  classes: {
    URLSearchParams: VY,
    FormData: GY,
    Blob: ZY
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, t5 = typeof window < "u" && typeof document < "u", wv = typeof navigator == "object" && navigator || void 0, XY = t5 && (!wv || ["ReactNative", "NativeScript", "NS"].indexOf(wv.product) < 0), YY = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", JY = t5 && window.location.href || "http://localhost", QY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: t5,
  hasStandardBrowserEnv: XY,
  hasStandardBrowserWebWorkerEnv: YY,
  navigator: wv,
  origin: JY
}, Symbol.toStringTag, { value: "Module" })), Qn = {
  ...QY,
  ...WY
};
function eJ(e, t) {
  return ty(e, new Qn.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, o, a) {
      return Qn.isNode && ee.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function tJ(e) {
  return ee.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function rJ(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const o = r.length;
  let a;
  for (n = 0; n < o; n++)
    a = r[n], t[a] = e[a];
  return t;
}
function dI(e) {
  function t(r, n, o, a) {
    let i = r[a++];
    if (i === "__proto__") return !0;
    const s = Number.isFinite(+i), u = a >= r.length;
    return i = !i && ee.isArray(o) ? o.length : i, u ? (ee.hasOwnProp(o, i) ? o[i] = [o[i], n] : o[i] = n, !s) : ((!o[i] || !ee.isObject(o[i])) && (o[i] = []), t(r, n, o[i], a) && ee.isArray(o[i]) && (o[i] = rJ(o[i])), !s);
  }
  if (ee.isFormData(e) && ee.isFunction(e.entries)) {
    const r = {};
    return ee.forEachEntry(e, (n, o) => {
      t(tJ(n), o, r, 0);
    }), r;
  }
  return null;
}
function nJ(e, t, r) {
  if (ee.isString(e))
    try {
      return (t || JSON.parse)(e), ee.trim(e);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (0, JSON.stringify)(e);
}
const $p = {
  transitional: fI,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const r = t.getContentType() || "", n = r.indexOf("application/json") > -1, o = ee.isObject(e);
    if (o && ee.isHTMLForm(e) && (e = new FormData(e)), ee.isFormData(e))
      return n ? JSON.stringify(dI(e)) : e;
    if (ee.isArrayBuffer(e) || ee.isBuffer(e) || ee.isStream(e) || ee.isFile(e) || ee.isBlob(e) || ee.isReadableStream(e))
      return e;
    if (ee.isArrayBufferView(e))
      return e.buffer;
    if (ee.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (o) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return eJ(e, this.formSerializer).toString();
      if ((a = ee.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const i = this.env && this.env.FormData;
        return ty(
          a ? { "files[]": e } : e,
          i && new i(),
          this.formSerializer
        );
      }
    }
    return o || n ? (t.setContentType("application/json", !1), nJ(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || $p.transitional, r = t && t.forcedJSONParsing, n = this.responseType === "json";
    if (ee.isResponse(e) || ee.isReadableStream(e))
      return e;
    if (e && ee.isString(e) && (r && !this.responseType || n)) {
      const o = !(t && t.silentJSONParsing) && n;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? it.from(a, it.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Qn.classes.FormData,
    Blob: Qn.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
ee.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  $p.headers[e] = {};
});
const oJ = ee.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), iJ = (e) => {
  const t = {};
  let r, n, o;
  return e && e.split(`
`).forEach(function(a) {
    o = a.indexOf(":"), r = a.substring(0, o).trim().toLowerCase(), n = a.substring(o + 1).trim(), !(!r || t[r] && oJ[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
}, zE = Symbol("internals");
function zd(e) {
  return e && String(e).trim().toLowerCase();
}
function S1(e) {
  return e === !1 || e == null ? e : ee.isArray(e) ? e.map(S1) : String(e);
}
function aJ(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(e); )
    t[n[1]] = n[2];
  return t;
}
const sJ = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function k2(e, t, r, n, o) {
  if (ee.isFunction(n))
    return n.call(this, t, r);
  if (o && (t = r), !!ee.isString(t)) {
    if (ee.isString(n))
      return t.indexOf(n) !== -1;
    if (ee.isRegExp(n))
      return n.test(t);
  }
}
function uJ(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function cJ(e, t) {
  const r = ee.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(o, a, i) {
        return this[n].call(this, t, o, a, i);
      },
      configurable: !0
    });
  });
}
let eo = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, n) {
    const o = this;
    function a(s, u, l) {
      const c = zd(u);
      if (!c)
        throw new Error("header name must be a non-empty string");
      const f = ee.findKey(o, c);
      (!f || o[f] === void 0 || l === !0 || l === void 0 && o[f] !== !1) && (o[f || u] = S1(s));
    }
    const i = (s, u) => ee.forEach(s, (l, c) => a(l, c, u));
    if (ee.isPlainObject(t) || t instanceof this.constructor)
      i(t, r);
    else if (ee.isString(t) && (t = t.trim()) && !sJ(t))
      i(iJ(t), r);
    else if (ee.isHeaders(t))
      for (const [s, u] of t.entries())
        a(u, s, n);
    else
      t != null && a(r, t, n);
    return this;
  }
  get(t, r) {
    if (t = zd(t), t) {
      const n = ee.findKey(this, t);
      if (n) {
        const o = this[n];
        if (!r)
          return o;
        if (r === !0)
          return aJ(o);
        if (ee.isFunction(r))
          return r.call(this, o, n);
        if (ee.isRegExp(r))
          return r.exec(o);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = zd(t), t) {
      const n = ee.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || k2(this, this[n], n, r)));
    }
    return !1;
  }
  delete(t, r) {
    const n = this;
    let o = !1;
    function a(i) {
      if (i = zd(i), i) {
        const s = ee.findKey(n, i);
        s && (!r || k2(n, n[s], s, r)) && (delete n[s], o = !0);
      }
    }
    return ee.isArray(t) ? t.forEach(a) : a(t), o;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, o = !1;
    for (; n--; ) {
      const a = r[n];
      (!t || k2(this, this[a], a, t, !0)) && (delete this[a], o = !0);
    }
    return o;
  }
  normalize(t) {
    const r = this, n = {};
    return ee.forEach(this, (o, a) => {
      const i = ee.findKey(n, a);
      if (i) {
        r[i] = S1(o), delete r[a];
        return;
      }
      const s = t ? uJ(a) : String(a).trim();
      s !== a && delete r[a], r[s] = S1(o), n[s] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return ee.forEach(this, (n, o) => {
      n != null && n !== !1 && (r[o] = t && ee.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const n = new this(t);
    return r.forEach((o) => n.set(o)), n;
  }
  static accessor(t) {
    const r = (this[zE] = this[zE] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function o(a) {
      const i = zd(a);
      r[i] || (cJ(n, a), r[i] = !0);
    }
    return ee.isArray(t) ? t.forEach(o) : o(t), this;
  }
};
eo.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ee.reduceDescriptors(eo.prototype, ({ value: e }, t) => {
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(n) {
      this[r] = n;
    }
  };
});
ee.freezeMethods(eo);
function x2(e, t) {
  const r = this || $p, n = t || r, o = eo.from(n.headers);
  let a = n.data;
  return ee.forEach(e, function(i) {
    a = i.call(r, a, o.normalize(), t ? t.status : void 0);
  }), o.normalize(), a;
}
function hI(e) {
  return !!(e && e.__CANCEL__);
}
function rd(e, t, r) {
  it.call(this, e ?? "canceled", it.ERR_CANCELED, t, r), this.name = "CanceledError";
}
ee.inherits(rd, it, {
  __CANCEL__: !0
});
function pI(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new it(
    "Request failed with status code " + r.status,
    [it.ERR_BAD_REQUEST, it.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function lJ(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function fJ(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let o = 0, a = 0, i;
  return t = t !== void 0 ? t : 1e3, function(s) {
    const u = Date.now(), l = n[a];
    i || (i = u), r[o] = s, n[o] = u;
    let c = a, f = 0;
    for (; c !== o; )
      f += r[c++], c = c % e;
    if (o = (o + 1) % e, o === a && (a = (a + 1) % e), u - i < t)
      return;
    const h = l && u - l;
    return h ? Math.round(f * 1e3 / h) : void 0;
  };
}
function dJ(e, t) {
  let r = 0, n = 1e3 / t, o, a;
  const i = (s, u = Date.now()) => {
    r = u, o = null, a && (clearTimeout(a), a = null), e.apply(null, s);
  };
  return [(...s) => {
    const u = Date.now(), l = u - r;
    l >= n ? i(s, u) : (o = s, a || (a = setTimeout(() => {
      a = null, i(o);
    }, n - l)));
  }, () => o && i(o)];
}
const Sg = (e, t, r = 3) => {
  let n = 0;
  const o = fJ(50, 250);
  return dJ((a) => {
    const i = a.loaded, s = a.lengthComputable ? a.total : void 0, u = i - n, l = o(u), c = i <= s;
    n = i;
    const f = {
      loaded: i,
      total: s,
      progress: s ? i / s : void 0,
      bytes: u,
      rate: l || void 0,
      estimated: l && s && c ? (s - i) / l : void 0,
      event: a,
      lengthComputable: s != null,
      [t ? "download" : "upload"]: !0
    };
    e(f);
  }, r);
}, jE = (e, t) => {
  const r = e != null;
  return [(n) => t[0]({
    lengthComputable: r,
    total: e,
    loaded: n
  }), t[1]];
}, LE = (e) => (...t) => ee.asap(() => e(...t)), hJ = Qn.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const e = Qn.navigator && /(msie|trident)/i.test(Qn.navigator.userAgent), t = document.createElement("a");
    let r;
    function n(o) {
      let a = o;
      return e && (t.setAttribute("href", a), a = t.href), t.setAttribute("href", a), {
        href: t.href,
        protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
        host: t.host,
        search: t.search ? t.search.replace(/^\?/, "") : "",
        hash: t.hash ? t.hash.replace(/^#/, "") : "",
        hostname: t.hostname,
        port: t.port,
        pathname: t.pathname.charAt(0) === "/" ? t.pathname : "/" + t.pathname
      };
    }
    return r = n(window.location.href), function(o) {
      const a = ee.isString(o) ? n(o) : o;
      return a.protocol === r.protocol && a.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
), pJ = Qn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, n, o, a) {
      const i = [e + "=" + encodeURIComponent(t)];
      ee.isNumber(r) && i.push("expires=" + new Date(r).toGMTString()), ee.isString(n) && i.push("path=" + n), ee.isString(o) && i.push("domain=" + o), a === !0 && i.push("secure"), document.cookie = i.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function gJ(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function mJ(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function gI(e, t) {
  return e && !gJ(t) ? mJ(e, t) : t;
}
const HE = (e) => e instanceof eo ? { ...e } : e;
function qc(e, t) {
  t = t || {};
  const r = {};
  function n(l, c, f) {
    return ee.isPlainObject(l) && ee.isPlainObject(c) ? ee.merge.call({ caseless: f }, l, c) : ee.isPlainObject(c) ? ee.merge({}, c) : ee.isArray(c) ? c.slice() : c;
  }
  function o(l, c, f) {
    if (ee.isUndefined(c)) {
      if (!ee.isUndefined(l))
        return n(void 0, l, f);
    } else return n(l, c, f);
  }
  function a(l, c) {
    if (!ee.isUndefined(c))
      return n(void 0, c);
  }
  function i(l, c) {
    if (ee.isUndefined(c)) {
      if (!ee.isUndefined(l))
        return n(void 0, l);
    } else return n(void 0, c);
  }
  function s(l, c, f) {
    if (f in t)
      return n(l, c);
    if (f in e)
      return n(void 0, l);
  }
  const u = {
    url: a,
    method: a,
    data: a,
    baseURL: i,
    transformRequest: i,
    transformResponse: i,
    paramsSerializer: i,
    timeout: i,
    timeoutMessage: i,
    withCredentials: i,
    withXSRFToken: i,
    adapter: i,
    responseType: i,
    xsrfCookieName: i,
    xsrfHeaderName: i,
    onUploadProgress: i,
    onDownloadProgress: i,
    decompress: i,
    maxContentLength: i,
    maxBodyLength: i,
    beforeRedirect: i,
    transport: i,
    httpAgent: i,
    httpsAgent: i,
    cancelToken: i,
    socketPath: i,
    responseEncoding: i,
    validateStatus: s,
    headers: (l, c) => o(HE(l), HE(c), !0)
  };
  return ee.forEach(Object.keys(Object.assign({}, e, t)), function(l) {
    const c = u[l] || o, f = c(e[l], t[l], l);
    ee.isUndefined(f) && c !== s || (r[l] = f);
  }), r;
}
const mI = (e) => {
  const t = qc({}, e);
  let { data: r, withXSRFToken: n, xsrfHeaderName: o, xsrfCookieName: a, headers: i, auth: s } = t;
  t.headers = i = eo.from(i), t.url = lI(gI(t.baseURL, t.url), e.params, e.paramsSerializer), s && i.set(
    "Authorization",
    "Basic " + btoa((s.username || "") + ":" + (s.password ? unescape(encodeURIComponent(s.password)) : ""))
  );
  let u;
  if (ee.isFormData(r)) {
    if (Qn.hasStandardBrowserEnv || Qn.hasStandardBrowserWebWorkerEnv)
      i.setContentType(void 0);
    else if ((u = i.getContentType()) !== !1) {
      const [l, ...c] = u ? u.split(";").map((f) => f.trim()).filter(Boolean) : [];
      i.setContentType([l || "multipart/form-data", ...c].join("; "));
    }
  }
  if (Qn.hasStandardBrowserEnv && (n && ee.isFunction(n) && (n = n(t)), n || n !== !1 && hJ(t.url))) {
    const l = o && a && pJ.read(a);
    l && i.set(o, l);
  }
  return t;
}, yJ = typeof XMLHttpRequest < "u", bJ = yJ && function(e) {
  return new Promise(function(t, r) {
    const n = mI(e);
    let o = n.data;
    const a = eo.from(n.headers).normalize();
    let { responseType: i, onUploadProgress: s, onDownloadProgress: u } = n, l, c, f, h, p;
    function y() {
      h && h(), p && p(), n.cancelToken && n.cancelToken.unsubscribe(l), n.signal && n.signal.removeEventListener("abort", l);
    }
    let m = new XMLHttpRequest();
    m.open(n.method.toUpperCase(), n.url, !0), m.timeout = n.timeout;
    function b() {
      if (!m)
        return;
      const k = eo.from(
        "getAllResponseHeaders" in m && m.getAllResponseHeaders()
      ), E = {
        data: !i || i === "text" || i === "json" ? m.responseText : m.response,
        status: m.status,
        statusText: m.statusText,
        headers: k,
        config: e,
        request: m
      };
      pI(function(A) {
        t(A), y();
      }, function(A) {
        r(A), y();
      }, E), m = null;
    }
    "onloadend" in m ? m.onloadend = b : m.onreadystatechange = function() {
      !m || m.readyState !== 4 || m.status === 0 && !(m.responseURL && m.responseURL.indexOf("file:") === 0) || setTimeout(b);
    }, m.onabort = function() {
      m && (r(new it("Request aborted", it.ECONNABORTED, e, m)), m = null);
    }, m.onerror = function() {
      r(new it("Network Error", it.ERR_NETWORK, e, m)), m = null;
    }, m.ontimeout = function() {
      let k = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
      const E = n.transitional || fI;
      n.timeoutErrorMessage && (k = n.timeoutErrorMessage), r(new it(
        k,
        E.clarifyTimeoutError ? it.ETIMEDOUT : it.ECONNABORTED,
        e,
        m
      )), m = null;
    }, o === void 0 && a.setContentType(null), "setRequestHeader" in m && ee.forEach(a.toJSON(), function(k, E) {
      m.setRequestHeader(E, k);
    }), ee.isUndefined(n.withCredentials) || (m.withCredentials = !!n.withCredentials), i && i !== "json" && (m.responseType = n.responseType), u && ([f, p] = Sg(u, !0), m.addEventListener("progress", f)), s && m.upload && ([c, h] = Sg(s), m.upload.addEventListener("progress", c), m.upload.addEventListener("loadend", h)), (n.cancelToken || n.signal) && (l = (k) => {
      m && (r(!k || k.type ? new rd(null, e, m) : k), m.abort(), m = null);
    }, n.cancelToken && n.cancelToken.subscribe(l), n.signal && (n.signal.aborted ? l() : n.signal.addEventListener("abort", l)));
    const v = lJ(n.url);
    if (v && Qn.protocols.indexOf(v) === -1) {
      r(new it("Unsupported protocol " + v + ":", it.ERR_BAD_REQUEST, e));
      return;
    }
    m.send(o || null);
  });
}, wJ = (e, t) => {
  const { length: r } = e = e ? e.filter(Boolean) : [];
  if (t || r) {
    let n = new AbortController(), o;
    const a = function(l) {
      if (!o) {
        o = !0, s();
        const c = l instanceof Error ? l : this.reason;
        n.abort(c instanceof it ? c : new rd(c instanceof Error ? c.message : c));
      }
    };
    let i = t && setTimeout(() => {
      i = null, a(new it(`timeout ${t} of ms exceeded`, it.ETIMEDOUT));
    }, t);
    const s = () => {
      e && (i && clearTimeout(i), i = null, e.forEach((l) => {
        l.unsubscribe ? l.unsubscribe(a) : l.removeEventListener("abort", a);
      }), e = null);
    };
    e.forEach((l) => l.addEventListener("abort", a));
    const { signal: u } = n;
    return u.unsubscribe = () => ee.asap(s), u;
  }
}, vJ = function* (e, t) {
  let r = e.byteLength;
  if (r < t) {
    yield e;
    return;
  }
  let n = 0, o;
  for (; n < r; )
    o = n + t, yield e.slice(n, o), n = o;
}, EJ = async function* (e, t) {
  for await (const r of kJ(e))
    yield* vJ(r, t);
}, kJ = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await t.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await t.cancel();
  }
}, FE = (e, t, r, n) => {
  const o = EJ(e, t);
  let a = 0, i, s = (u) => {
    i || (i = !0, n && n(u));
  };
  return new ReadableStream({
    async pull(u) {
      try {
        const { done: l, value: c } = await o.next();
        if (l) {
          s(), u.close();
          return;
        }
        let f = c.byteLength;
        if (r) {
          let h = a += f;
          r(h);
        }
        u.enqueue(new Uint8Array(c));
      } catch (l) {
        throw s(l), l;
      }
    },
    cancel(u) {
      return s(u), o.return();
    }
  }, {
    highWaterMark: 2
  });
}, ry = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", yI = ry && typeof ReadableStream == "function", xJ = ry && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), bI = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, AJ = yI && bI(() => {
  let e = !1;
  const t = new Request(Qn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), DE = 64 * 1024, vv = yI && bI(() => ee.isReadableStream(new Response("").body)), _g = {
  stream: vv && ((e) => e.body)
};
ry && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !_g[t] && (_g[t] = ee.isFunction(e[t]) ? (r) => r[t]() : (r, n) => {
      throw new it(`Response type '${t}' is not supported`, it.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const SJ = async (e) => {
  if (e == null)
    return 0;
  if (ee.isBlob(e))
    return e.size;
  if (ee.isSpecCompliantForm(e))
    return (await new Request(Qn.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (ee.isArrayBufferView(e) || ee.isArrayBuffer(e))
    return e.byteLength;
  if (ee.isURLSearchParams(e) && (e = e + ""), ee.isString(e))
    return (await xJ(e)).byteLength;
}, _J = async (e, t) => ee.toFiniteNumber(e.getContentLength()) ?? SJ(t), IJ = ry && (async (e) => {
  let {
    url: t,
    method: r,
    data: n,
    signal: o,
    cancelToken: a,
    timeout: i,
    onDownloadProgress: s,
    onUploadProgress: u,
    responseType: l,
    headers: c,
    withCredentials: f = "same-origin",
    fetchOptions: h
  } = mI(e);
  l = l ? (l + "").toLowerCase() : "text";
  let p = wJ([o, a && a.toAbortSignal()], i), y;
  const m = p && p.unsubscribe && (() => {
    p.unsubscribe();
  });
  let b;
  try {
    if (u && AJ && r !== "get" && r !== "head" && (b = await _J(c, n)) !== 0) {
      let S = new Request(t, {
        method: "POST",
        body: n,
        duplex: "half"
      }), _;
      if (ee.isFormData(n) && (_ = S.headers.get("content-type")) && c.setContentType(_), S.body) {
        const [I, O] = jE(
          b,
          Sg(LE(u))
        );
        n = FE(S.body, DE, I, O);
      }
    }
    ee.isString(f) || (f = f ? "include" : "omit");
    const v = "credentials" in Request.prototype;
    y = new Request(t, {
      ...h,
      signal: p,
      method: r.toUpperCase(),
      headers: c.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: v ? f : void 0
    });
    let k = await fetch(y);
    const E = vv && (l === "stream" || l === "response");
    if (vv && (s || E && m)) {
      const S = {};
      ["status", "statusText", "headers"].forEach((z) => {
        S[z] = k[z];
      });
      const _ = ee.toFiniteNumber(k.headers.get("content-length")), [I, O] = s && jE(
        _,
        Sg(LE(s), !0)
      ) || [];
      k = new Response(
        FE(k.body, DE, I, () => {
          O && O(), m && m();
        }),
        S
      );
    }
    l = l || "text";
    let A = await _g[ee.findKey(_g, l) || "text"](k, e);
    return !E && m && m(), await new Promise((S, _) => {
      pI(S, _, {
        data: A,
        headers: eo.from(k.headers),
        status: k.status,
        statusText: k.statusText,
        config: e,
        request: y
      });
    });
  } catch (v) {
    throw m && m(), v && v.name === "TypeError" && /fetch/i.test(v.message) ? Object.assign(
      new it("Network Error", it.ERR_NETWORK, e, y),
      {
        cause: v.cause || v
      }
    ) : it.from(v, v && v.code, e, y);
  }
}), Ev = {
  http: DY,
  xhr: bJ,
  fetch: IJ
};
ee.forEach(Ev, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const ME = (e) => `- ${e}`, TJ = (e) => ee.isFunction(e) || e === null || e === !1, wI = {
  getAdapter: (e) => {
    e = ee.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    const o = {};
    for (let a = 0; a < t; a++) {
      r = e[a];
      let i;
      if (n = r, !TJ(r) && (n = Ev[(i = String(r)).toLowerCase()], n === void 0))
        throw new it(`Unknown adapter '${i}'`);
      if (n)
        break;
      o[i || "#" + a] = n;
    }
    if (!n) {
      const a = Object.entries(o).map(
        ([s, u]) => `adapter ${s} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let i = t ? a.length > 1 ? `since :
` + a.map(ME).join(`
`) : " " + ME(a[0]) : "as no adapter specified";
      throw new it(
        "There is no suitable adapter to dispatch the request " + i,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: Ev
};
function A2(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new rd(null, e);
}
function KE(e) {
  return A2(e), e.headers = eo.from(e.headers), e.data = x2.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), wI.getAdapter(e.adapter || $p.adapter)(e).then(function(t) {
    return A2(e), t.data = x2.call(
      e,
      e.transformResponse,
      t
    ), t.headers = eo.from(t.headers), t;
  }, function(t) {
    return hI(t) || (A2(e), t && t.response && (t.response.data = x2.call(
      e,
      e.transformResponse,
      t.response
    ), t.response.headers = eo.from(t.response.headers))), Promise.reject(t);
  });
}
const vI = "1.7.7", r5 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  r5[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const qE = {};
r5.transitional = function(e, t, r) {
  function n(o, a) {
    return "[Axios v" + vI + "] Transitional option '" + o + "'" + a + (r ? ". " + r : "");
  }
  return (o, a, i) => {
    if (e === !1)
      throw new it(
        n(a, " has been removed" + (t ? " in " + t : "")),
        it.ERR_DEPRECATED
      );
    return t && !qE[a] && (qE[a] = !0, console.warn(
      n(
        a,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(o, a, i) : !0;
  };
};
function PJ(e, t, r) {
  if (typeof e != "object")
    throw new it("options must be an object", it.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let o = n.length;
  for (; o-- > 0; ) {
    const a = n[o], i = t[a];
    if (i) {
      const s = e[a], u = s === void 0 || i(s, a, e);
      if (u !== !0)
        throw new it("option " + a + " must be " + u, it.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new it("Unknown option " + a, it.ERR_BAD_OPTION);
  }
}
const kv = {
  assertOptions: PJ,
  validators: r5
}, Fs = kv.validators;
let Bc = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new RE(),
      response: new RE()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, r) {
    try {
      return await this._request(t, r);
    } catch (n) {
      if (n instanceof Error) {
        let o;
        Error.captureStackTrace ? Error.captureStackTrace(o = {}) : o = new Error();
        const a = o.stack ? o.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? a && !String(n.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + a) : n.stack = a;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = qc(this.defaults, r);
    const { transitional: n, paramsSerializer: o, headers: a } = r;
    n !== void 0 && kv.assertOptions(n, {
      silentJSONParsing: Fs.transitional(Fs.boolean),
      forcedJSONParsing: Fs.transitional(Fs.boolean),
      clarifyTimeoutError: Fs.transitional(Fs.boolean)
    }, !1), o != null && (ee.isFunction(o) ? r.paramsSerializer = {
      serialize: o
    } : kv.assertOptions(o, {
      encode: Fs.function,
      serialize: Fs.function
    }, !0)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let i = a && ee.merge(
      a.common,
      a[r.method]
    );
    a && ee.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (y) => {
        delete a[y];
      }
    ), r.headers = eo.concat(i, a);
    const s = [];
    let u = !0;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(r) === !1 || (u = u && y.synchronous, s.unshift(y.fulfilled, y.rejected));
    });
    const l = [];
    this.interceptors.response.forEach(function(y) {
      l.push(y.fulfilled, y.rejected);
    });
    let c, f = 0, h;
    if (!u) {
      const y = [KE.bind(this), void 0];
      for (y.unshift.apply(y, s), y.push.apply(y, l), h = y.length, c = Promise.resolve(r); f < h; )
        c = c.then(y[f++], y[f++]);
      return c;
    }
    h = s.length;
    let p = r;
    for (f = 0; f < h; ) {
      const y = s[f++], m = s[f++];
      try {
        p = y(p);
      } catch (b) {
        m.call(this, b);
        break;
      }
    }
    try {
      c = KE.call(this, p);
    } catch (y) {
      return Promise.reject(y);
    }
    for (f = 0, h = l.length; f < h; )
      c = c.then(l[f++], l[f++]);
    return c;
  }
  getUri(t) {
    t = qc(this.defaults, t);
    const r = gI(t.baseURL, t.url);
    return lI(r, t.params, t.paramsSerializer);
  }
};
ee.forEach(["delete", "get", "head", "options"], function(e) {
  Bc.prototype[e] = function(t, r) {
    return this.request(qc(r || {}, {
      method: e,
      url: t,
      data: (r || {}).data
    }));
  };
});
ee.forEach(["post", "put", "patch"], function(e) {
  function t(r) {
    return function(n, o, a) {
      return this.request(qc(a || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: n,
        data: o
      }));
    };
  }
  Bc.prototype[e] = t(), Bc.prototype[e + "Form"] = t(!0);
});
let OJ = class EI {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(o) {
      r = o;
    });
    const n = this;
    this.promise.then((o) => {
      if (!n._listeners) return;
      let a = n._listeners.length;
      for (; a-- > 0; )
        n._listeners[a](o);
      n._listeners = null;
    }), this.promise.then = (o) => {
      let a;
      const i = new Promise((s) => {
        n.subscribe(s), a = s;
      }).then(o);
      return i.cancel = function() {
        n.unsubscribe(a);
      }, i;
    }, t(function(o, a, i) {
      n.reason || (n.reason = new rd(o, a, i), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), r = (n) => {
      t.abort(n);
    };
    return this.subscribe(r), t.signal.unsubscribe = () => this.unsubscribe(r), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new EI(function(r) {
        t = r;
      }),
      cancel: t
    };
  }
};
function $J(e) {
  return function(t) {
    return e.apply(null, t);
  };
}
function CJ(e) {
  return ee.isObject(e) && e.isAxiosError === !0;
}
const xv = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(xv).forEach(([e, t]) => {
  xv[t] = e;
});
function kI(e) {
  const t = new Bc(e), r = J_(Bc.prototype.request, t);
  return ee.extend(r, Bc.prototype, t, { allOwnKeys: !0 }), ee.extend(r, t, null, { allOwnKeys: !0 }), r.create = function(n) {
    return kI(qc(e, n));
  }, r;
}
const rr = kI($p);
rr.Axios = Bc;
rr.CanceledError = rd;
rr.CancelToken = OJ;
rr.isCancel = hI;
rr.VERSION = vI;
rr.toFormData = ty;
rr.AxiosError = it;
rr.Cancel = rr.CanceledError;
rr.all = function(e) {
  return Promise.all(e);
};
rr.spread = $J;
rr.isAxiosError = CJ;
rr.mergeConfig = qc;
rr.AxiosHeaders = eo;
rr.formToJSON = (e) => dI(ee.isHTMLForm(e) ? new FormData(e) : e);
rr.getAdapter = wI.getAdapter;
rr.HttpStatusCode = xv;
rr.default = rr;
const BJ = "https://mempool.space", NJ = "https://mempool.space/testnet", UJ = "https://mempool.space/testnet4", RJ = "https://mempool.space/signet", zJ = "https://mempool.fractalbitcoin.io", jJ = "https://mempool-testnet.fractalbitcoin.io", ny = (e) => e === Yt ? NJ : e === on ? UJ : e === pn ? RJ : e === fl ? zJ : e === Nn ? jJ : BJ;
var ma = {}, Jr = {}, tt = {};
Object.defineProperty(tt, "__esModule", { value: !0 });
tt.add5L = tt.add5H = tt.add4H = tt.add4L = tt.add3H = tt.add3L = tt.rotlBL = tt.rotlBH = tt.rotlSL = tt.rotlSH = tt.rotr32L = tt.rotr32H = tt.rotrBL = tt.rotrBH = tt.rotrSL = tt.rotrSH = tt.shrSL = tt.shrSH = tt.toBig = void 0;
tt.fromBig = n5;
tt.split = xI;
tt.add = zI;
const O0 = /* @__PURE__ */ BigInt(2 ** 32 - 1), Av = /* @__PURE__ */ BigInt(32);
function n5(e, t = !1) {
  return t ? { h: Number(e & O0), l: Number(e >> Av & O0) } : { h: Number(e >> Av & O0) | 0, l: Number(e & O0) | 0 };
}
function xI(e, t = !1) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: a, l: i } = n5(e[o], t);
    [r[o], n[o]] = [a, i];
  }
  return [r, n];
}
const AI = (e, t) => BigInt(e >>> 0) << Av | BigInt(t >>> 0);
tt.toBig = AI;
const SI = (e, t, r) => e >>> r;
tt.shrSH = SI;
const _I = (e, t, r) => e << 32 - r | t >>> r;
tt.shrSL = _I;
const II = (e, t, r) => e >>> r | t << 32 - r;
tt.rotrSH = II;
const TI = (e, t, r) => e << 32 - r | t >>> r;
tt.rotrSL = TI;
const PI = (e, t, r) => e << 64 - r | t >>> r - 32;
tt.rotrBH = PI;
const OI = (e, t, r) => e >>> r - 32 | t << 64 - r;
tt.rotrBL = OI;
const $I = (e, t) => t;
tt.rotr32H = $I;
const CI = (e, t) => e;
tt.rotr32L = CI;
const BI = (e, t, r) => e << r | t >>> 32 - r;
tt.rotlSH = BI;
const NI = (e, t, r) => t << r | e >>> 32 - r;
tt.rotlSL = NI;
const UI = (e, t, r) => t << r - 32 | e >>> 64 - r;
tt.rotlBH = UI;
const RI = (e, t, r) => e << r - 32 | t >>> 64 - r;
tt.rotlBL = RI;
function zI(e, t, r, n) {
  const o = (t >>> 0) + (n >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
const jI = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
tt.add3L = jI;
const LI = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0;
tt.add3H = LI;
const HI = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
tt.add4L = HI;
const FI = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0;
tt.add4H = FI;
const DI = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0);
tt.add5L = DI;
const MI = (e, t, r, n, o, a) => t + r + n + o + a + (e / 2 ** 32 | 0) | 0;
tt.add5H = MI;
const LJ = {
  fromBig: n5,
  split: xI,
  toBig: AI,
  shrSH: SI,
  shrSL: _I,
  rotrSH: II,
  rotrSL: TI,
  rotrBH: PI,
  rotrBL: OI,
  rotr32H: $I,
  rotr32L: CI,
  rotlSH: BI,
  rotlSL: NI,
  rotlBH: UI,
  rotlBL: RI,
  add: zI,
  add3L: jI,
  add3H: LI,
  add4L: HI,
  add4H: FI,
  add5H: MI,
  add5L: DI
};
tt.default = LJ;
Object.defineProperty(Jr, "__esModule", { value: !0 });
Jr.sha384 = Jr.sha512_256 = Jr.sha512_224 = Jr.sha512 = Jr.SHA384 = Jr.SHA512_256 = Jr.SHA512_224 = Jr.SHA512 = void 0;
const HJ = Qa, yt = tt, oy = Gu, [FJ, DJ] = yt.default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))), Ds = /* @__PURE__ */ new Uint32Array(80), Ms = /* @__PURE__ */ new Uint32Array(80);
let Cp = class extends HJ.HashMD {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: o, Ch: a, Cl: i, Dh: s, Dl: u, Eh: l, El: c, Fh: f, Fl: h, Gh: p, Gl: y, Hh: m, Hl: b } = this;
    return [t, r, n, o, a, i, s, u, l, c, f, h, p, y, m, b];
  }
  // prettier-ignore
  set(t, r, n, o, a, i, s, u, l, c, f, h, p, y, m, b) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = o | 0, this.Ch = a | 0, this.Cl = i | 0, this.Dh = s | 0, this.Dl = u | 0, this.Eh = l | 0, this.El = c | 0, this.Fh = f | 0, this.Fl = h | 0, this.Gh = p | 0, this.Gl = y | 0, this.Hh = m | 0, this.Hl = b | 0;
  }
  process(t, r) {
    for (let E = 0; E < 16; E++, r += 4)
      Ds[E] = t.getUint32(r), Ms[E] = t.getUint32(r += 4);
    for (let E = 16; E < 80; E++) {
      const A = Ds[E - 15] | 0, S = Ms[E - 15] | 0, _ = yt.default.rotrSH(A, S, 1) ^ yt.default.rotrSH(A, S, 8) ^ yt.default.shrSH(A, S, 7), I = yt.default.rotrSL(A, S, 1) ^ yt.default.rotrSL(A, S, 8) ^ yt.default.shrSL(A, S, 7), O = Ds[E - 2] | 0, z = Ms[E - 2] | 0, D = yt.default.rotrSH(O, z, 19) ^ yt.default.rotrBH(O, z, 61) ^ yt.default.shrSH(O, z, 6), G = yt.default.rotrSL(O, z, 19) ^ yt.default.rotrBL(O, z, 61) ^ yt.default.shrSL(O, z, 6), U = yt.default.add4L(I, G, Ms[E - 7], Ms[E - 16]), V = yt.default.add4H(U, _, D, Ds[E - 7], Ds[E - 16]);
      Ds[E] = V | 0, Ms[E] = U | 0;
    }
    let { Ah: n, Al: o, Bh: a, Bl: i, Ch: s, Cl: u, Dh: l, Dl: c, Eh: f, El: h, Fh: p, Fl: y, Gh: m, Gl: b, Hh: v, Hl: k } = this;
    for (let E = 0; E < 80; E++) {
      const A = yt.default.rotrSH(f, h, 14) ^ yt.default.rotrSH(f, h, 18) ^ yt.default.rotrBH(f, h, 41), S = yt.default.rotrSL(f, h, 14) ^ yt.default.rotrSL(f, h, 18) ^ yt.default.rotrBL(f, h, 41), _ = f & p ^ ~f & m, I = h & y ^ ~h & b, O = yt.default.add5L(k, S, I, DJ[E], Ms[E]), z = yt.default.add5H(O, v, A, _, FJ[E], Ds[E]), D = O | 0, G = yt.default.rotrSH(n, o, 28) ^ yt.default.rotrBH(n, o, 34) ^ yt.default.rotrBH(n, o, 39), U = yt.default.rotrSL(n, o, 28) ^ yt.default.rotrBL(n, o, 34) ^ yt.default.rotrBL(n, o, 39), V = n & a ^ n & s ^ a & s, F = o & i ^ o & u ^ i & u;
      v = m | 0, k = b | 0, m = p | 0, b = y | 0, p = f | 0, y = h | 0, { h: f, l: h } = yt.default.add(l | 0, c | 0, z | 0, D | 0), l = s | 0, c = u | 0, s = a | 0, u = i | 0, a = n | 0, i = o | 0;
      const C = yt.default.add3L(D, U, F);
      n = yt.default.add3H(C, z, G, V), o = C | 0;
    }
    ({ h: n, l: o } = yt.default.add(this.Ah | 0, this.Al | 0, n | 0, o | 0)), { h: a, l: i } = yt.default.add(this.Bh | 0, this.Bl | 0, a | 0, i | 0), { h: s, l: u } = yt.default.add(this.Ch | 0, this.Cl | 0, s | 0, u | 0), { h: l, l: c } = yt.default.add(this.Dh | 0, this.Dl | 0, l | 0, c | 0), { h: f, l: h } = yt.default.add(this.Eh | 0, this.El | 0, f | 0, h | 0), { h: p, l: y } = yt.default.add(this.Fh | 0, this.Fl | 0, p | 0, y | 0), { h: m, l: b } = yt.default.add(this.Gh | 0, this.Gl | 0, m | 0, b | 0), { h: v, l: k } = yt.default.add(this.Hh | 0, this.Hl | 0, v | 0, k | 0), this.set(n, o, a, i, s, u, l, c, f, h, p, y, m, b, v, k);
  }
  roundClean() {
    Ds.fill(0), Ms.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
Jr.SHA512 = Cp;
let KI = class extends Cp {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
};
Jr.SHA512_224 = KI;
let qI = class extends Cp {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
};
Jr.SHA512_256 = qI;
let VI = class extends Cp {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
Jr.SHA384 = VI;
Jr.sha512 = (0, oy.wrapConstructor)(() => new Cp());
Jr.sha512_224 = (0, oy.wrapConstructor)(() => new KI());
Jr.sha512_256 = (0, oy.wrapConstructor)(() => new qI());
Jr.sha384 = (0, oy.wrapConstructor)(() => new VI());
var iy = {};
Object.defineProperty(iy, "__esModule", { value: !0 });
iy.pbkdf2 = KJ;
iy.pbkdf2Async = qJ;
const $0 = Io, MJ = Zm, af = Gu;
function GI(e, t, r, n) {
  (0, $0.hash)(e);
  const o = (0, af.checkOpts)({ dkLen: 32, asyncTick: 10 }, n), { c: a, dkLen: i, asyncTick: s } = o;
  if ((0, $0.number)(a), (0, $0.number)(i), (0, $0.number)(s), a < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const u = (0, af.toBytes)(t), l = (0, af.toBytes)(r), c = new Uint8Array(i), f = MJ.hmac.create(e, u), h = f._cloneInto().update(l);
  return { c: a, dkLen: i, asyncTick: s, DK: c, PRF: f, PRFSalt: h };
}
function ZI(e, t, r, n, o) {
  return e.destroy(), t.destroy(), n && n.destroy(), o.fill(0), r;
}
function KJ(e, t, r, n) {
  const { c: o, dkLen: a, DK: i, PRF: s, PRFSalt: u } = GI(e, t, r, n);
  let l;
  const c = new Uint8Array(4), f = (0, af.createView)(c), h = new Uint8Array(s.outputLen);
  for (let p = 1, y = 0; y < a; p++, y += s.outputLen) {
    const m = i.subarray(y, y + s.outputLen);
    f.setInt32(0, p, !1), (l = u._cloneInto(l)).update(c).digestInto(h), m.set(h.subarray(0, m.length));
    for (let b = 1; b < o; b++) {
      s._cloneInto(l).update(h).digestInto(h);
      for (let v = 0; v < m.length; v++)
        m[v] ^= h[v];
    }
  }
  return ZI(s, u, i, l, h);
}
async function qJ(e, t, r, n) {
  const { c: o, dkLen: a, asyncTick: i, DK: s, PRF: u, PRFSalt: l } = GI(e, t, r, n);
  let c;
  const f = new Uint8Array(4), h = (0, af.createView)(f), p = new Uint8Array(u.outputLen);
  for (let y = 1, m = 0; m < a; y++, m += u.outputLen) {
    const b = s.subarray(m, m + u.outputLen);
    h.setInt32(0, y, !1), (c = l._cloneInto(c)).update(f).digestInto(p), b.set(p.subarray(0, b.length)), await (0, af.asyncLoop)(o - 1, i, () => {
      u._cloneInto(c).update(p).digestInto(p);
      for (let v = 0; v < b.length; v++)
        b[v] ^= p[v];
    });
  }
  return ZI(u, l, s, c, p);
}
var Kn = {};
const VJ = [
  "abdikace",
  "abeceda",
  "adresa",
  "agrese",
  "akce",
  "aktovka",
  "alej",
  "alkohol",
  "amputace",
  "ananas",
  "andulka",
  "anekdota",
  "anketa",
  "antika",
  "anulovat",
  "archa",
  "arogance",
  "asfalt",
  "asistent",
  "aspirace",
  "astma",
  "astronom",
  "atlas",
  "atletika",
  "atol",
  "autobus",
  "azyl",
  "babka",
  "bachor",
  "bacil",
  "baculka",
  "badatel",
  "bageta",
  "bagr",
  "bahno",
  "bakterie",
  "balada",
  "baletka",
  "balkon",
  "balonek",
  "balvan",
  "balza",
  "bambus",
  "bankomat",
  "barbar",
  "baret",
  "barman",
  "baroko",
  "barva",
  "baterka",
  "batoh",
  "bavlna",
  "bazalka",
  "bazilika",
  "bazuka",
  "bedna",
  "beran",
  "beseda",
  "bestie",
  "beton",
  "bezinka",
  "bezmoc",
  "beztak",
  "bicykl",
  "bidlo",
  "biftek",
  "bikiny",
  "bilance",
  "biograf",
  "biolog",
  "bitva",
  "bizon",
  "blahobyt",
  "blatouch",
  "blecha",
  "bledule",
  "blesk",
  "blikat",
  "blizna",
  "blokovat",
  "bloudit",
  "blud",
  "bobek",
  "bobr",
  "bodlina",
  "bodnout",
  "bohatost",
  "bojkot",
  "bojovat",
  "bokorys",
  "bolest",
  "borec",
  "borovice",
  "bota",
  "boubel",
  "bouchat",
  "bouda",
  "boule",
  "bourat",
  "boxer",
  "bradavka",
  "brambora",
  "branka",
  "bratr",
  "brepta",
  "briketa",
  "brko",
  "brloh",
  "bronz",
  "broskev",
  "brunetka",
  "brusinka",
  "brzda",
  "brzy",
  "bublina",
  "bubnovat",
  "buchta",
  "buditel",
  "budka",
  "budova",
  "bufet",
  "bujarost",
  "bukvice",
  "buldok",
  "bulva",
  "bunda",
  "bunkr",
  "burza",
  "butik",
  "buvol",
  "buzola",
  "bydlet",
  "bylina",
  "bytovka",
  "bzukot",
  "capart",
  "carevna",
  "cedr",
  "cedule",
  "cejch",
  "cejn",
  "cela",
  "celer",
  "celkem",
  "celnice",
  "cenina",
  "cennost",
  "cenovka",
  "centrum",
  "cenzor",
  "cestopis",
  "cetka",
  "chalupa",
  "chapadlo",
  "charita",
  "chata",
  "chechtat",
  "chemie",
  "chichot",
  "chirurg",
  "chlad",
  "chleba",
  "chlubit",
  "chmel",
  "chmura",
  "chobot",
  "chochol",
  "chodba",
  "cholera",
  "chomout",
  "chopit",
  "choroba",
  "chov",
  "chrapot",
  "chrlit",
  "chrt",
  "chrup",
  "chtivost",
  "chudina",
  "chutnat",
  "chvat",
  "chvilka",
  "chvost",
  "chyba",
  "chystat",
  "chytit",
  "cibule",
  "cigareta",
  "cihelna",
  "cihla",
  "cinkot",
  "cirkus",
  "cisterna",
  "citace",
  "citrus",
  "cizinec",
  "cizost",
  "clona",
  "cokoliv",
  "couvat",
  "ctitel",
  "ctnost",
  "cudnost",
  "cuketa",
  "cukr",
  "cupot",
  "cvaknout",
  "cval",
  "cvik",
  "cvrkot",
  "cyklista",
  "daleko",
  "dareba",
  "datel",
  "datum",
  "dcera",
  "debata",
  "dechovka",
  "decibel",
  "deficit",
  "deflace",
  "dekl",
  "dekret",
  "demokrat",
  "deprese",
  "derby",
  "deska",
  "detektiv",
  "dikobraz",
  "diktovat",
  "dioda",
  "diplom",
  "disk",
  "displej",
  "divadlo",
  "divoch",
  "dlaha",
  "dlouho",
  "dluhopis",
  "dnes",
  "dobro",
  "dobytek",
  "docent",
  "dochutit",
  "dodnes",
  "dohled",
  "dohoda",
  "dohra",
  "dojem",
  "dojnice",
  "doklad",
  "dokola",
  "doktor",
  "dokument",
  "dolar",
  "doleva",
  "dolina",
  "doma",
  "dominant",
  "domluvit",
  "domov",
  "donutit",
  "dopad",
  "dopis",
  "doplnit",
  "doposud",
  "doprovod",
  "dopustit",
  "dorazit",
  "dorost",
  "dort",
  "dosah",
  "doslov",
  "dostatek",
  "dosud",
  "dosyta",
  "dotaz",
  "dotek",
  "dotknout",
  "doufat",
  "doutnat",
  "dovozce",
  "dozadu",
  "doznat",
  "dozorce",
  "drahota",
  "drak",
  "dramatik",
  "dravec",
  "draze",
  "drdol",
  "drobnost",
  "drogerie",
  "drozd",
  "drsnost",
  "drtit",
  "drzost",
  "duben",
  "duchovno",
  "dudek",
  "duha",
  "duhovka",
  "dusit",
  "dusno",
  "dutost",
  "dvojice",
  "dvorec",
  "dynamit",
  "ekolog",
  "ekonomie",
  "elektron",
  "elipsa",
  "email",
  "emise",
  "emoce",
  "empatie",
  "epizoda",
  "epocha",
  "epopej",
  "epos",
  "esej",
  "esence",
  "eskorta",
  "eskymo",
  "etiketa",
  "euforie",
  "evoluce",
  "exekuce",
  "exkurze",
  "expedice",
  "exploze",
  "export",
  "extrakt",
  "facka",
  "fajfka",
  "fakulta",
  "fanatik",
  "fantazie",
  "farmacie",
  "favorit",
  "fazole",
  "federace",
  "fejeton",
  "fenka",
  "fialka",
  "figurant",
  "filozof",
  "filtr",
  "finance",
  "finta",
  "fixace",
  "fjord",
  "flanel",
  "flirt",
  "flotila",
  "fond",
  "fosfor",
  "fotbal",
  "fotka",
  "foton",
  "frakce",
  "freska",
  "fronta",
  "fukar",
  "funkce",
  "fyzika",
  "galeje",
  "garant",
  "genetika",
  "geolog",
  "gilotina",
  "glazura",
  "glejt",
  "golem",
  "golfista",
  "gotika",
  "graf",
  "gramofon",
  "granule",
  "grep",
  "gril",
  "grog",
  "groteska",
  "guma",
  "hadice",
  "hadr",
  "hala",
  "halenka",
  "hanba",
  "hanopis",
  "harfa",
  "harpuna",
  "havran",
  "hebkost",
  "hejkal",
  "hejno",
  "hejtman",
  "hektar",
  "helma",
  "hematom",
  "herec",
  "herna",
  "heslo",
  "hezky",
  "historik",
  "hladovka",
  "hlasivky",
  "hlava",
  "hledat",
  "hlen",
  "hlodavec",
  "hloh",
  "hloupost",
  "hltat",
  "hlubina",
  "hluchota",
  "hmat",
  "hmota",
  "hmyz",
  "hnis",
  "hnojivo",
  "hnout",
  "hoblina",
  "hoboj",
  "hoch",
  "hodiny",
  "hodlat",
  "hodnota",
  "hodovat",
  "hojnost",
  "hokej",
  "holinka",
  "holka",
  "holub",
  "homole",
  "honitba",
  "honorace",
  "horal",
  "horda",
  "horizont",
  "horko",
  "horlivec",
  "hormon",
  "hornina",
  "horoskop",
  "horstvo",
  "hospoda",
  "hostina",
  "hotovost",
  "houba",
  "houf",
  "houpat",
  "houska",
  "hovor",
  "hradba",
  "hranice",
  "hravost",
  "hrazda",
  "hrbolek",
  "hrdina",
  "hrdlo",
  "hrdost",
  "hrnek",
  "hrobka",
  "hromada",
  "hrot",
  "hrouda",
  "hrozen",
  "hrstka",
  "hrubost",
  "hryzat",
  "hubenost",
  "hubnout",
  "hudba",
  "hukot",
  "humr",
  "husita",
  "hustota",
  "hvozd",
  "hybnost",
  "hydrant",
  "hygiena",
  "hymna",
  "hysterik",
  "idylka",
  "ihned",
  "ikona",
  "iluze",
  "imunita",
  "infekce",
  "inflace",
  "inkaso",
  "inovace",
  "inspekce",
  "internet",
  "invalida",
  "investor",
  "inzerce",
  "ironie",
  "jablko",
  "jachta",
  "jahoda",
  "jakmile",
  "jakost",
  "jalovec",
  "jantar",
  "jarmark",
  "jaro",
  "jasan",
  "jasno",
  "jatka",
  "javor",
  "jazyk",
  "jedinec",
  "jedle",
  "jednatel",
  "jehlan",
  "jekot",
  "jelen",
  "jelito",
  "jemnost",
  "jenom",
  "jepice",
  "jeseter",
  "jevit",
  "jezdec",
  "jezero",
  "jinak",
  "jindy",
  "jinoch",
  "jiskra",
  "jistota",
  "jitrnice",
  "jizva",
  "jmenovat",
  "jogurt",
  "jurta",
  "kabaret",
  "kabel",
  "kabinet",
  "kachna",
  "kadet",
  "kadidlo",
  "kahan",
  "kajak",
  "kajuta",
  "kakao",
  "kaktus",
  "kalamita",
  "kalhoty",
  "kalibr",
  "kalnost",
  "kamera",
  "kamkoliv",
  "kamna",
  "kanibal",
  "kanoe",
  "kantor",
  "kapalina",
  "kapela",
  "kapitola",
  "kapka",
  "kaple",
  "kapota",
  "kapr",
  "kapusta",
  "kapybara",
  "karamel",
  "karotka",
  "karton",
  "kasa",
  "katalog",
  "katedra",
  "kauce",
  "kauza",
  "kavalec",
  "kazajka",
  "kazeta",
  "kazivost",
  "kdekoliv",
  "kdesi",
  "kedluben",
  "kemp",
  "keramika",
  "kino",
  "klacek",
  "kladivo",
  "klam",
  "klapot",
  "klasika",
  "klaun",
  "klec",
  "klenba",
  "klepat",
  "klesnout",
  "klid",
  "klima",
  "klisna",
  "klobouk",
  "klokan",
  "klopa",
  "kloub",
  "klubovna",
  "klusat",
  "kluzkost",
  "kmen",
  "kmitat",
  "kmotr",
  "kniha",
  "knot",
  "koalice",
  "koberec",
  "kobka",
  "kobliha",
  "kobyla",
  "kocour",
  "kohout",
  "kojenec",
  "kokos",
  "koktejl",
  "kolaps",
  "koleda",
  "kolize",
  "kolo",
  "komando",
  "kometa",
  "komik",
  "komnata",
  "komora",
  "kompas",
  "komunita",
  "konat",
  "koncept",
  "kondice",
  "konec",
  "konfese",
  "kongres",
  "konina",
  "konkurs",
  "kontakt",
  "konzerva",
  "kopanec",
  "kopie",
  "kopnout",
  "koprovka",
  "korbel",
  "korektor",
  "kormidlo",
  "koroptev",
  "korpus",
  "koruna",
  "koryto",
  "korzet",
  "kosatec",
  "kostka",
  "kotel",
  "kotleta",
  "kotoul",
  "koukat",
  "koupelna",
  "kousek",
  "kouzlo",
  "kovboj",
  "koza",
  "kozoroh",
  "krabice",
  "krach",
  "krajina",
  "kralovat",
  "krasopis",
  "kravata",
  "kredit",
  "krejcar",
  "kresba",
  "kreveta",
  "kriket",
  "kritik",
  "krize",
  "krkavec",
  "krmelec",
  "krmivo",
  "krocan",
  "krok",
  "kronika",
  "kropit",
  "kroupa",
  "krovka",
  "krtek",
  "kruhadlo",
  "krupice",
  "krutost",
  "krvinka",
  "krychle",
  "krypta",
  "krystal",
  "kryt",
  "kudlanka",
  "kufr",
  "kujnost",
  "kukla",
  "kulajda",
  "kulich",
  "kulka",
  "kulomet",
  "kultura",
  "kuna",
  "kupodivu",
  "kurt",
  "kurzor",
  "kutil",
  "kvalita",
  "kvasinka",
  "kvestor",
  "kynolog",
  "kyselina",
  "kytara",
  "kytice",
  "kytka",
  "kytovec",
  "kyvadlo",
  "labrador",
  "lachtan",
  "ladnost",
  "laik",
  "lakomec",
  "lamela",
  "lampa",
  "lanovka",
  "lasice",
  "laso",
  "lastura",
  "latinka",
  "lavina",
  "lebka",
  "leckdy",
  "leden",
  "lednice",
  "ledovka",
  "ledvina",
  "legenda",
  "legie",
  "legrace",
  "lehce",
  "lehkost",
  "lehnout",
  "lektvar",
  "lenochod",
  "lentilka",
  "lepenka",
  "lepidlo",
  "letadlo",
  "letec",
  "letmo",
  "letokruh",
  "levhart",
  "levitace",
  "levobok",
  "libra",
  "lichotka",
  "lidojed",
  "lidskost",
  "lihovina",
  "lijavec",
  "lilek",
  "limetka",
  "linie",
  "linka",
  "linoleum",
  "listopad",
  "litina",
  "litovat",
  "lobista",
  "lodivod",
  "logika",
  "logoped",
  "lokalita",
  "loket",
  "lomcovat",
  "lopata",
  "lopuch",
  "lord",
  "losos",
  "lotr",
  "loudal",
  "louh",
  "louka",
  "louskat",
  "lovec",
  "lstivost",
  "lucerna",
  "lucifer",
  "lump",
  "lusk",
  "lustrace",
  "lvice",
  "lyra",
  "lyrika",
  "lysina",
  "madam",
  "madlo",
  "magistr",
  "mahagon",
  "majetek",
  "majitel",
  "majorita",
  "makak",
  "makovice",
  "makrela",
  "malba",
  "malina",
  "malovat",
  "malvice",
  "maminka",
  "mandle",
  "manko",
  "marnost",
  "masakr",
  "maskot",
  "masopust",
  "matice",
  "matrika",
  "maturita",
  "mazanec",
  "mazivo",
  "mazlit",
  "mazurka",
  "mdloba",
  "mechanik",
  "meditace",
  "medovina",
  "melasa",
  "meloun",
  "mentolka",
  "metla",
  "metoda",
  "metr",
  "mezera",
  "migrace",
  "mihnout",
  "mihule",
  "mikina",
  "mikrofon",
  "milenec",
  "milimetr",
  "milost",
  "mimika",
  "mincovna",
  "minibar",
  "minomet",
  "minulost",
  "miska",
  "mistr",
  "mixovat",
  "mladost",
  "mlha",
  "mlhovina",
  "mlok",
  "mlsat",
  "mluvit",
  "mnich",
  "mnohem",
  "mobil",
  "mocnost",
  "modelka",
  "modlitba",
  "mohyla",
  "mokro",
  "molekula",
  "momentka",
  "monarcha",
  "monokl",
  "monstrum",
  "montovat",
  "monzun",
  "mosaz",
  "moskyt",
  "most",
  "motivace",
  "motorka",
  "motyka",
  "moucha",
  "moudrost",
  "mozaika",
  "mozek",
  "mozol",
  "mramor",
  "mravenec",
  "mrkev",
  "mrtvola",
  "mrzet",
  "mrzutost",
  "mstitel",
  "mudrc",
  "muflon",
  "mulat",
  "mumie",
  "munice",
  "muset",
  "mutace",
  "muzeum",
  "muzikant",
  "myslivec",
  "mzda",
  "nabourat",
  "nachytat",
  "nadace",
  "nadbytek",
  "nadhoz",
  "nadobro",
  "nadpis",
  "nahlas",
  "nahnat",
  "nahodile",
  "nahradit",
  "naivita",
  "najednou",
  "najisto",
  "najmout",
  "naklonit",
  "nakonec",
  "nakrmit",
  "nalevo",
  "namazat",
  "namluvit",
  "nanometr",
  "naoko",
  "naopak",
  "naostro",
  "napadat",
  "napevno",
  "naplnit",
  "napnout",
  "naposled",
  "naprosto",
  "narodit",
  "naruby",
  "narychlo",
  "nasadit",
  "nasekat",
  "naslepo",
  "nastat",
  "natolik",
  "navenek",
  "navrch",
  "navzdory",
  "nazvat",
  "nebe",
  "nechat",
  "necky",
  "nedaleko",
  "nedbat",
  "neduh",
  "negace",
  "nehet",
  "nehoda",
  "nejen",
  "nejprve",
  "neklid",
  "nelibost",
  "nemilost",
  "nemoc",
  "neochota",
  "neonka",
  "nepokoj",
  "nerost",
  "nerv",
  "nesmysl",
  "nesoulad",
  "netvor",
  "neuron",
  "nevina",
  "nezvykle",
  "nicota",
  "nijak",
  "nikam",
  "nikdy",
  "nikl",
  "nikterak",
  "nitro",
  "nocleh",
  "nohavice",
  "nominace",
  "nora",
  "norek",
  "nositel",
  "nosnost",
  "nouze",
  "noviny",
  "novota",
  "nozdra",
  "nuda",
  "nudle",
  "nuget",
  "nutit",
  "nutnost",
  "nutrie",
  "nymfa",
  "obal",
  "obarvit",
  "obava",
  "obdiv",
  "obec",
  "obehnat",
  "obejmout",
  "obezita",
  "obhajoba",
  "obilnice",
  "objasnit",
  "objekt",
  "obklopit",
  "oblast",
  "oblek",
  "obliba",
  "obloha",
  "obluda",
  "obnos",
  "obohatit",
  "obojek",
  "obout",
  "obrazec",
  "obrna",
  "obruba",
  "obrys",
  "obsah",
  "obsluha",
  "obstarat",
  "obuv",
  "obvaz",
  "obvinit",
  "obvod",
  "obvykle",
  "obyvatel",
  "obzor",
  "ocas",
  "ocel",
  "ocenit",
  "ochladit",
  "ochota",
  "ochrana",
  "ocitnout",
  "odboj",
  "odbyt",
  "odchod",
  "odcizit",
  "odebrat",
  "odeslat",
  "odevzdat",
  "odezva",
  "odhadce",
  "odhodit",
  "odjet",
  "odjinud",
  "odkaz",
  "odkoupit",
  "odliv",
  "odluka",
  "odmlka",
  "odolnost",
  "odpad",
  "odpis",
  "odplout",
  "odpor",
  "odpustit",
  "odpykat",
  "odrazka",
  "odsoudit",
  "odstup",
  "odsun",
  "odtok",
  "odtud",
  "odvaha",
  "odveta",
  "odvolat",
  "odvracet",
  "odznak",
  "ofina",
  "ofsajd",
  "ohlas",
  "ohnisko",
  "ohrada",
  "ohrozit",
  "ohryzek",
  "okap",
  "okenice",
  "oklika",
  "okno",
  "okouzlit",
  "okovy",
  "okrasa",
  "okres",
  "okrsek",
  "okruh",
  "okupant",
  "okurka",
  "okusit",
  "olejnina",
  "olizovat",
  "omak",
  "omeleta",
  "omezit",
  "omladina",
  "omlouvat",
  "omluva",
  "omyl",
  "onehdy",
  "opakovat",
  "opasek",
  "operace",
  "opice",
  "opilost",
  "opisovat",
  "opora",
  "opozice",
  "opravdu",
  "oproti",
  "orbital",
  "orchestr",
  "orgie",
  "orlice",
  "orloj",
  "ortel",
  "osada",
  "oschnout",
  "osika",
  "osivo",
  "oslava",
  "oslepit",
  "oslnit",
  "oslovit",
  "osnova",
  "osoba",
  "osolit",
  "ospalec",
  "osten",
  "ostraha",
  "ostuda",
  "ostych",
  "osvojit",
  "oteplit",
  "otisk",
  "otop",
  "otrhat",
  "otrlost",
  "otrok",
  "otruby",
  "otvor",
  "ovanout",
  "ovar",
  "oves",
  "ovlivnit",
  "ovoce",
  "oxid",
  "ozdoba",
  "pachatel",
  "pacient",
  "padouch",
  "pahorek",
  "pakt",
  "palanda",
  "palec",
  "palivo",
  "paluba",
  "pamflet",
  "pamlsek",
  "panenka",
  "panika",
  "panna",
  "panovat",
  "panstvo",
  "pantofle",
  "paprika",
  "parketa",
  "parodie",
  "parta",
  "paruka",
  "paryba",
  "paseka",
  "pasivita",
  "pastelka",
  "patent",
  "patrona",
  "pavouk",
  "pazneht",
  "pazourek",
  "pecka",
  "pedagog",
  "pejsek",
  "peklo",
  "peloton",
  "penalta",
  "pendrek",
  "penze",
  "periskop",
  "pero",
  "pestrost",
  "petarda",
  "petice",
  "petrolej",
  "pevnina",
  "pexeso",
  "pianista",
  "piha",
  "pijavice",
  "pikle",
  "piknik",
  "pilina",
  "pilnost",
  "pilulka",
  "pinzeta",
  "pipeta",
  "pisatel",
  "pistole",
  "pitevna",
  "pivnice",
  "pivovar",
  "placenta",
  "plakat",
  "plamen",
  "planeta",
  "plastika",
  "platit",
  "plavidlo",
  "plaz",
  "plech",
  "plemeno",
  "plenta",
  "ples",
  "pletivo",
  "plevel",
  "plivat",
  "plnit",
  "plno",
  "plocha",
  "plodina",
  "plomba",
  "plout",
  "pluk",
  "plyn",
  "pobavit",
  "pobyt",
  "pochod",
  "pocit",
  "poctivec",
  "podat",
  "podcenit",
  "podepsat",
  "podhled",
  "podivit",
  "podklad",
  "podmanit",
  "podnik",
  "podoba",
  "podpora",
  "podraz",
  "podstata",
  "podvod",
  "podzim",
  "poezie",
  "pohanka",
  "pohnutka",
  "pohovor",
  "pohroma",
  "pohyb",
  "pointa",
  "pojistka",
  "pojmout",
  "pokazit",
  "pokles",
  "pokoj",
  "pokrok",
  "pokuta",
  "pokyn",
  "poledne",
  "polibek",
  "polknout",
  "poloha",
  "polynom",
  "pomalu",
  "pominout",
  "pomlka",
  "pomoc",
  "pomsta",
  "pomyslet",
  "ponechat",
  "ponorka",
  "ponurost",
  "popadat",
  "popel",
  "popisek",
  "poplach",
  "poprosit",
  "popsat",
  "popud",
  "poradce",
  "porce",
  "porod",
  "porucha",
  "poryv",
  "posadit",
  "posed",
  "posila",
  "poskok",
  "poslanec",
  "posoudit",
  "pospolu",
  "postava",
  "posudek",
  "posyp",
  "potah",
  "potkan",
  "potlesk",
  "potomek",
  "potrava",
  "potupa",
  "potvora",
  "poukaz",
  "pouto",
  "pouzdro",
  "povaha",
  "povidla",
  "povlak",
  "povoz",
  "povrch",
  "povstat",
  "povyk",
  "povzdech",
  "pozdrav",
  "pozemek",
  "poznatek",
  "pozor",
  "pozvat",
  "pracovat",
  "prahory",
  "praktika",
  "prales",
  "praotec",
  "praporek",
  "prase",
  "pravda",
  "princip",
  "prkno",
  "probudit",
  "procento",
  "prodej",
  "profese",
  "prohra",
  "projekt",
  "prolomit",
  "promile",
  "pronikat",
  "propad",
  "prorok",
  "prosba",
  "proton",
  "proutek",
  "provaz",
  "prskavka",
  "prsten",
  "prudkost",
  "prut",
  "prvek",
  "prvohory",
  "psanec",
  "psovod",
  "pstruh",
  "ptactvo",
  "puberta",
  "puch",
  "pudl",
  "pukavec",
  "puklina",
  "pukrle",
  "pult",
  "pumpa",
  "punc",
  "pupen",
  "pusa",
  "pusinka",
  "pustina",
  "putovat",
  "putyka",
  "pyramida",
  "pysk",
  "pytel",
  "racek",
  "rachot",
  "radiace",
  "radnice",
  "radon",
  "raft",
  "ragby",
  "raketa",
  "rakovina",
  "rameno",
  "rampouch",
  "rande",
  "rarach",
  "rarita",
  "rasovna",
  "rastr",
  "ratolest",
  "razance",
  "razidlo",
  "reagovat",
  "reakce",
  "recept",
  "redaktor",
  "referent",
  "reflex",
  "rejnok",
  "reklama",
  "rekord",
  "rekrut",
  "rektor",
  "reputace",
  "revize",
  "revma",
  "revolver",
  "rezerva",
  "riskovat",
  "riziko",
  "robotika",
  "rodokmen",
  "rohovka",
  "rokle",
  "rokoko",
  "romaneto",
  "ropovod",
  "ropucha",
  "rorejs",
  "rosol",
  "rostlina",
  "rotmistr",
  "rotoped",
  "rotunda",
  "roubenka",
  "roucho",
  "roup",
  "roura",
  "rovina",
  "rovnice",
  "rozbor",
  "rozchod",
  "rozdat",
  "rozeznat",
  "rozhodce",
  "rozinka",
  "rozjezd",
  "rozkaz",
  "rozloha",
  "rozmar",
  "rozpad",
  "rozruch",
  "rozsah",
  "roztok",
  "rozum",
  "rozvod",
  "rubrika",
  "ruchadlo",
  "rukavice",
  "rukopis",
  "ryba",
  "rybolov",
  "rychlost",
  "rydlo",
  "rypadlo",
  "rytina",
  "ryzost",
  "sadista",
  "sahat",
  "sako",
  "samec",
  "samizdat",
  "samota",
  "sanitka",
  "sardinka",
  "sasanka",
  "satelit",
  "sazba",
  "sazenice",
  "sbor",
  "schovat",
  "sebranka",
  "secese",
  "sedadlo",
  "sediment",
  "sedlo",
  "sehnat",
  "sejmout",
  "sekera",
  "sekta",
  "sekunda",
  "sekvoje",
  "semeno",
  "seno",
  "servis",
  "sesadit",
  "seshora",
  "seskok",
  "seslat",
  "sestra",
  "sesuv",
  "sesypat",
  "setba",
  "setina",
  "setkat",
  "setnout",
  "setrvat",
  "sever",
  "seznam",
  "shoda",
  "shrnout",
  "sifon",
  "silnice",
  "sirka",
  "sirotek",
  "sirup",
  "situace",
  "skafandr",
  "skalisko",
  "skanzen",
  "skaut",
  "skeptik",
  "skica",
  "skladba",
  "sklenice",
  "sklo",
  "skluz",
  "skoba",
  "skokan",
  "skoro",
  "skripta",
  "skrz",
  "skupina",
  "skvost",
  "skvrna",
  "slabika",
  "sladidlo",
  "slanina",
  "slast",
  "slavnost",
  "sledovat",
  "slepec",
  "sleva",
  "slezina",
  "slib",
  "slina",
  "sliznice",
  "slon",
  "sloupek",
  "slovo",
  "sluch",
  "sluha",
  "slunce",
  "slupka",
  "slza",
  "smaragd",
  "smetana",
  "smilstvo",
  "smlouva",
  "smog",
  "smrad",
  "smrk",
  "smrtka",
  "smutek",
  "smysl",
  "snad",
  "snaha",
  "snob",
  "sobota",
  "socha",
  "sodovka",
  "sokol",
  "sopka",
  "sotva",
  "souboj",
  "soucit",
  "soudce",
  "souhlas",
  "soulad",
  "soumrak",
  "souprava",
  "soused",
  "soutok",
  "souviset",
  "spalovna",
  "spasitel",
  "spis",
  "splav",
  "spodek",
  "spojenec",
  "spolu",
  "sponzor",
  "spornost",
  "spousta",
  "sprcha",
  "spustit",
  "sranda",
  "sraz",
  "srdce",
  "srna",
  "srnec",
  "srovnat",
  "srpen",
  "srst",
  "srub",
  "stanice",
  "starosta",
  "statika",
  "stavba",
  "stehno",
  "stezka",
  "stodola",
  "stolek",
  "stopa",
  "storno",
  "stoupat",
  "strach",
  "stres",
  "strhnout",
  "strom",
  "struna",
  "studna",
  "stupnice",
  "stvol",
  "styk",
  "subjekt",
  "subtropy",
  "suchar",
  "sudost",
  "sukno",
  "sundat",
  "sunout",
  "surikata",
  "surovina",
  "svah",
  "svalstvo",
  "svetr",
  "svatba",
  "svazek",
  "svisle",
  "svitek",
  "svoboda",
  "svodidlo",
  "svorka",
  "svrab",
  "sykavka",
  "sykot",
  "synek",
  "synovec",
  "sypat",
  "sypkost",
  "syrovost",
  "sysel",
  "sytost",
  "tabletka",
  "tabule",
  "tahoun",
  "tajemno",
  "tajfun",
  "tajga",
  "tajit",
  "tajnost",
  "taktika",
  "tamhle",
  "tampon",
  "tancovat",
  "tanec",
  "tanker",
  "tapeta",
  "tavenina",
  "tazatel",
  "technika",
  "tehdy",
  "tekutina",
  "telefon",
  "temnota",
  "tendence",
  "tenista",
  "tenor",
  "teplota",
  "tepna",
  "teprve",
  "terapie",
  "termoska",
  "textil",
  "ticho",
  "tiskopis",
  "titulek",
  "tkadlec",
  "tkanina",
  "tlapka",
  "tleskat",
  "tlukot",
  "tlupa",
  "tmel",
  "toaleta",
  "topinka",
  "topol",
  "torzo",
  "touha",
  "toulec",
  "tradice",
  "traktor",
  "tramp",
  "trasa",
  "traverza",
  "trefit",
  "trest",
  "trezor",
  "trhavina",
  "trhlina",
  "trochu",
  "trojice",
  "troska",
  "trouba",
  "trpce",
  "trpitel",
  "trpkost",
  "trubec",
  "truchlit",
  "truhlice",
  "trus",
  "trvat",
  "tudy",
  "tuhnout",
  "tuhost",
  "tundra",
  "turista",
  "turnaj",
  "tuzemsko",
  "tvaroh",
  "tvorba",
  "tvrdost",
  "tvrz",
  "tygr",
  "tykev",
  "ubohost",
  "uboze",
  "ubrat",
  "ubrousek",
  "ubrus",
  "ubytovna",
  "ucho",
  "uctivost",
  "udivit",
  "uhradit",
  "ujednat",
  "ujistit",
  "ujmout",
  "ukazatel",
  "uklidnit",
  "uklonit",
  "ukotvit",
  "ukrojit",
  "ulice",
  "ulita",
  "ulovit",
  "umyvadlo",
  "unavit",
  "uniforma",
  "uniknout",
  "upadnout",
  "uplatnit",
  "uplynout",
  "upoutat",
  "upravit",
  "uran",
  "urazit",
  "usednout",
  "usilovat",
  "usmrtit",
  "usnadnit",
  "usnout",
  "usoudit",
  "ustlat",
  "ustrnout",
  "utahovat",
  "utkat",
  "utlumit",
  "utonout",
  "utopenec",
  "utrousit",
  "uvalit",
  "uvolnit",
  "uvozovka",
  "uzdravit",
  "uzel",
  "uzenina",
  "uzlina",
  "uznat",
  "vagon",
  "valcha",
  "valoun",
  "vana",
  "vandal",
  "vanilka",
  "varan",
  "varhany",
  "varovat",
  "vcelku",
  "vchod",
  "vdova",
  "vedro",
  "vegetace",
  "vejce",
  "velbloud",
  "veletrh",
  "velitel",
  "velmoc",
  "velryba",
  "venkov",
  "veranda",
  "verze",
  "veselka",
  "veskrze",
  "vesnice",
  "vespodu",
  "vesta",
  "veterina",
  "veverka",
  "vibrace",
  "vichr",
  "videohra",
  "vidina",
  "vidle",
  "vila",
  "vinice",
  "viset",
  "vitalita",
  "vize",
  "vizitka",
  "vjezd",
  "vklad",
  "vkus",
  "vlajka",
  "vlak",
  "vlasec",
  "vlevo",
  "vlhkost",
  "vliv",
  "vlnovka",
  "vloupat",
  "vnucovat",
  "vnuk",
  "voda",
  "vodivost",
  "vodoznak",
  "vodstvo",
  "vojensky",
  "vojna",
  "vojsko",
  "volant",
  "volba",
  "volit",
  "volno",
  "voskovka",
  "vozidlo",
  "vozovna",
  "vpravo",
  "vrabec",
  "vracet",
  "vrah",
  "vrata",
  "vrba",
  "vrcholek",
  "vrhat",
  "vrstva",
  "vrtule",
  "vsadit",
  "vstoupit",
  "vstup",
  "vtip",
  "vybavit",
  "vybrat",
  "vychovat",
  "vydat",
  "vydra",
  "vyfotit",
  "vyhledat",
  "vyhnout",
  "vyhodit",
  "vyhradit",
  "vyhubit",
  "vyjasnit",
  "vyjet",
  "vyjmout",
  "vyklopit",
  "vykonat",
  "vylekat",
  "vymazat",
  "vymezit",
  "vymizet",
  "vymyslet",
  "vynechat",
  "vynikat",
  "vynutit",
  "vypadat",
  "vyplatit",
  "vypravit",
  "vypustit",
  "vyrazit",
  "vyrovnat",
  "vyrvat",
  "vyslovit",
  "vysoko",
  "vystavit",
  "vysunout",
  "vysypat",
  "vytasit",
  "vytesat",
  "vytratit",
  "vyvinout",
  "vyvolat",
  "vyvrhel",
  "vyzdobit",
  "vyznat",
  "vzadu",
  "vzbudit",
  "vzchopit",
  "vzdor",
  "vzduch",
  "vzdychat",
  "vzestup",
  "vzhledem",
  "vzkaz",
  "vzlykat",
  "vznik",
  "vzorek",
  "vzpoura",
  "vztah",
  "vztek",
  "xylofon",
  "zabrat",
  "zabydlet",
  "zachovat",
  "zadarmo",
  "zadusit",
  "zafoukat",
  "zahltit",
  "zahodit",
  "zahrada",
  "zahynout",
  "zajatec",
  "zajet",
  "zajistit",
  "zaklepat",
  "zakoupit",
  "zalepit",
  "zamezit",
  "zamotat",
  "zamyslet",
  "zanechat",
  "zanikat",
  "zaplatit",
  "zapojit",
  "zapsat",
  "zarazit",
  "zastavit",
  "zasunout",
  "zatajit",
  "zatemnit",
  "zatknout",
  "zaujmout",
  "zavalit",
  "zavelet",
  "zavinit",
  "zavolat",
  "zavrtat",
  "zazvonit",
  "zbavit",
  "zbrusu",
  "zbudovat",
  "zbytek",
  "zdaleka",
  "zdarma",
  "zdatnost",
  "zdivo",
  "zdobit",
  "zdroj",
  "zdvih",
  "zdymadlo",
  "zelenina",
  "zeman",
  "zemina",
  "zeptat",
  "zezadu",
  "zezdola",
  "zhatit",
  "zhltnout",
  "zhluboka",
  "zhotovit",
  "zhruba",
  "zima",
  "zimnice",
  "zjemnit",
  "zklamat",
  "zkoumat",
  "zkratka",
  "zkumavka",
  "zlato",
  "zlehka",
  "zloba",
  "zlom",
  "zlost",
  "zlozvyk",
  "zmapovat",
  "zmar",
  "zmatek",
  "zmije",
  "zmizet",
  "zmocnit",
  "zmodrat",
  "zmrzlina",
  "zmutovat",
  "znak",
  "znalost",
  "znamenat",
  "znovu",
  "zobrazit",
  "zotavit",
  "zoubek",
  "zoufale",
  "zplodit",
  "zpomalit",
  "zprava",
  "zprostit",
  "zprudka",
  "zprvu",
  "zrada",
  "zranit",
  "zrcadlo",
  "zrnitost",
  "zrno",
  "zrovna",
  "zrychlit",
  "zrzavost",
  "zticha",
  "ztratit",
  "zubovina",
  "zubr",
  "zvednout",
  "zvenku",
  "zvesela",
  "zvon",
  "zvrat",
  "zvukovod",
  "zvyk"
], GJ = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], ZJ = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], WJ = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], XJ = [
  "abaisser",
  "abandon",
  "abdiquer",
  "abeille",
  "abolir",
  "aborder",
  "aboutir",
  "aboyer",
  "abrasif",
  "abreuver",
  "abriter",
  "abroger",
  "abrupt",
  "absence",
  "absolu",
  "absurde",
  "abusif",
  "abyssal",
  "academie",
  "acajou",
  "acarien",
  "accabler",
  "accepter",
  "acclamer",
  "accolade",
  "accroche",
  "accuser",
  "acerbe",
  "achat",
  "acheter",
  "aciduler",
  "acier",
  "acompte",
  "acquerir",
  "acronyme",
  "acteur",
  "actif",
  "actuel",
  "adepte",
  "adequat",
  "adhesif",
  "adjectif",
  "adjuger",
  "admettre",
  "admirer",
  "adopter",
  "adorer",
  "adoucir",
  "adresse",
  "adroit",
  "adulte",
  "adverbe",
  "aerer",
  "aeronef",
  "affaire",
  "affecter",
  "affiche",
  "affreux",
  "affubler",
  "agacer",
  "agencer",
  "agile",
  "agiter",
  "agrafer",
  "agreable",
  "agrume",
  "aider",
  "aiguille",
  "ailier",
  "aimable",
  "aisance",
  "ajouter",
  "ajuster",
  "alarmer",
  "alchimie",
  "alerte",
  "algebre",
  "algue",
  "aliener",
  "aliment",
  "alleger",
  "alliage",
  "allouer",
  "allumer",
  "alourdir",
  "alpaga",
  "altesse",
  "alveole",
  "amateur",
  "ambigu",
  "ambre",
  "amenager",
  "amertume",
  "amidon",
  "amiral",
  "amorcer",
  "amour",
  "amovible",
  "amphibie",
  "ampleur",
  "amusant",
  "analyse",
  "anaphore",
  "anarchie",
  "anatomie",
  "ancien",
  "aneantir",
  "angle",
  "angoisse",
  "anguleux",
  "animal",
  "annexer",
  "annonce",
  "annuel",
  "anodin",
  "anomalie",
  "anonyme",
  "anormal",
  "antenne",
  "antidote",
  "anxieux",
  "apaiser",
  "aperitif",
  "aplanir",
  "apologie",
  "appareil",
  "appeler",
  "apporter",
  "appuyer",
  "aquarium",
  "aqueduc",
  "arbitre",
  "arbuste",
  "ardeur",
  "ardoise",
  "argent",
  "arlequin",
  "armature",
  "armement",
  "armoire",
  "armure",
  "arpenter",
  "arracher",
  "arriver",
  "arroser",
  "arsenic",
  "arteriel",
  "article",
  "aspect",
  "asphalte",
  "aspirer",
  "assaut",
  "asservir",
  "assiette",
  "associer",
  "assurer",
  "asticot",
  "astre",
  "astuce",
  "atelier",
  "atome",
  "atrium",
  "atroce",
  "attaque",
  "attentif",
  "attirer",
  "attraper",
  "aubaine",
  "auberge",
  "audace",
  "audible",
  "augurer",
  "aurore",
  "automne",
  "autruche",
  "avaler",
  "avancer",
  "avarice",
  "avenir",
  "averse",
  "aveugle",
  "aviateur",
  "avide",
  "avion",
  "aviser",
  "avoine",
  "avouer",
  "avril",
  "axial",
  "axiome",
  "badge",
  "bafouer",
  "bagage",
  "baguette",
  "baignade",
  "balancer",
  "balcon",
  "baleine",
  "balisage",
  "bambin",
  "bancaire",
  "bandage",
  "banlieue",
  "banniere",
  "banquier",
  "barbier",
  "baril",
  "baron",
  "barque",
  "barrage",
  "bassin",
  "bastion",
  "bataille",
  "bateau",
  "batterie",
  "baudrier",
  "bavarder",
  "belette",
  "belier",
  "belote",
  "benefice",
  "berceau",
  "berger",
  "berline",
  "bermuda",
  "besace",
  "besogne",
  "betail",
  "beurre",
  "biberon",
  "bicycle",
  "bidule",
  "bijou",
  "bilan",
  "bilingue",
  "billard",
  "binaire",
  "biologie",
  "biopsie",
  "biotype",
  "biscuit",
  "bison",
  "bistouri",
  "bitume",
  "bizarre",
  "blafard",
  "blague",
  "blanchir",
  "blessant",
  "blinder",
  "blond",
  "bloquer",
  "blouson",
  "bobard",
  "bobine",
  "boire",
  "boiser",
  "bolide",
  "bonbon",
  "bondir",
  "bonheur",
  "bonifier",
  "bonus",
  "bordure",
  "borne",
  "botte",
  "boucle",
  "boueux",
  "bougie",
  "boulon",
  "bouquin",
  "bourse",
  "boussole",
  "boutique",
  "boxeur",
  "branche",
  "brasier",
  "brave",
  "brebis",
  "breche",
  "breuvage",
  "bricoler",
  "brigade",
  "brillant",
  "brioche",
  "brique",
  "brochure",
  "broder",
  "bronzer",
  "brousse",
  "broyeur",
  "brume",
  "brusque",
  "brutal",
  "bruyant",
  "buffle",
  "buisson",
  "bulletin",
  "bureau",
  "burin",
  "bustier",
  "butiner",
  "butoir",
  "buvable",
  "buvette",
  "cabanon",
  "cabine",
  "cachette",
  "cadeau",
  "cadre",
  "cafeine",
  "caillou",
  "caisson",
  "calculer",
  "calepin",
  "calibre",
  "calmer",
  "calomnie",
  "calvaire",
  "camarade",
  "camera",
  "camion",
  "campagne",
  "canal",
  "caneton",
  "canon",
  "cantine",
  "canular",
  "capable",
  "caporal",
  "caprice",
  "capsule",
  "capter",
  "capuche",
  "carabine",
  "carbone",
  "caresser",
  "caribou",
  "carnage",
  "carotte",
  "carreau",
  "carton",
  "cascade",
  "casier",
  "casque",
  "cassure",
  "causer",
  "caution",
  "cavalier",
  "caverne",
  "caviar",
  "cedille",
  "ceinture",
  "celeste",
  "cellule",
  "cendrier",
  "censurer",
  "central",
  "cercle",
  "cerebral",
  "cerise",
  "cerner",
  "cerveau",
  "cesser",
  "chagrin",
  "chaise",
  "chaleur",
  "chambre",
  "chance",
  "chapitre",
  "charbon",
  "chasseur",
  "chaton",
  "chausson",
  "chavirer",
  "chemise",
  "chenille",
  "chequier",
  "chercher",
  "cheval",
  "chien",
  "chiffre",
  "chignon",
  "chimere",
  "chiot",
  "chlorure",
  "chocolat",
  "choisir",
  "chose",
  "chouette",
  "chrome",
  "chute",
  "cigare",
  "cigogne",
  "cimenter",
  "cinema",
  "cintrer",
  "circuler",
  "cirer",
  "cirque",
  "citerne",
  "citoyen",
  "citron",
  "civil",
  "clairon",
  "clameur",
  "claquer",
  "classe",
  "clavier",
  "client",
  "cligner",
  "climat",
  "clivage",
  "cloche",
  "clonage",
  "cloporte",
  "cobalt",
  "cobra",
  "cocasse",
  "cocotier",
  "coder",
  "codifier",
  "coffre",
  "cogner",
  "cohesion",
  "coiffer",
  "coincer",
  "colere",
  "colibri",
  "colline",
  "colmater",
  "colonel",
  "combat",
  "comedie",
  "commande",
  "compact",
  "concert",
  "conduire",
  "confier",
  "congeler",
  "connoter",
  "consonne",
  "contact",
  "convexe",
  "copain",
  "copie",
  "corail",
  "corbeau",
  "cordage",
  "corniche",
  "corpus",
  "correct",
  "cortege",
  "cosmique",
  "costume",
  "coton",
  "coude",
  "coupure",
  "courage",
  "couteau",
  "couvrir",
  "coyote",
  "crabe",
  "crainte",
  "cravate",
  "crayon",
  "creature",
  "crediter",
  "cremeux",
  "creuser",
  "crevette",
  "cribler",
  "crier",
  "cristal",
  "critere",
  "croire",
  "croquer",
  "crotale",
  "crucial",
  "cruel",
  "crypter",
  "cubique",
  "cueillir",
  "cuillere",
  "cuisine",
  "cuivre",
  "culminer",
  "cultiver",
  "cumuler",
  "cupide",
  "curatif",
  "curseur",
  "cyanure",
  "cycle",
  "cylindre",
  "cynique",
  "daigner",
  "damier",
  "danger",
  "danseur",
  "dauphin",
  "debattre",
  "debiter",
  "deborder",
  "debrider",
  "debutant",
  "decaler",
  "decembre",
  "dechirer",
  "decider",
  "declarer",
  "decorer",
  "decrire",
  "decupler",
  "dedale",
  "deductif",
  "deesse",
  "defensif",
  "defiler",
  "defrayer",
  "degager",
  "degivrer",
  "deglutir",
  "degrafer",
  "dejeuner",
  "delice",
  "deloger",
  "demander",
  "demeurer",
  "demolir",
  "denicher",
  "denouer",
  "dentelle",
  "denuder",
  "depart",
  "depenser",
  "dephaser",
  "deplacer",
  "deposer",
  "deranger",
  "derober",
  "desastre",
  "descente",
  "desert",
  "designer",
  "desobeir",
  "dessiner",
  "destrier",
  "detacher",
  "detester",
  "detourer",
  "detresse",
  "devancer",
  "devenir",
  "deviner",
  "devoir",
  "diable",
  "dialogue",
  "diamant",
  "dicter",
  "differer",
  "digerer",
  "digital",
  "digne",
  "diluer",
  "dimanche",
  "diminuer",
  "dioxyde",
  "directif",
  "diriger",
  "discuter",
  "disposer",
  "dissiper",
  "distance",
  "divertir",
  "diviser",
  "docile",
  "docteur",
  "dogme",
  "doigt",
  "domaine",
  "domicile",
  "dompter",
  "donateur",
  "donjon",
  "donner",
  "dopamine",
  "dortoir",
  "dorure",
  "dosage",
  "doseur",
  "dossier",
  "dotation",
  "douanier",
  "double",
  "douceur",
  "douter",
  "doyen",
  "dragon",
  "draper",
  "dresser",
  "dribbler",
  "droiture",
  "duperie",
  "duplexe",
  "durable",
  "durcir",
  "dynastie",
  "eblouir",
  "ecarter",
  "echarpe",
  "echelle",
  "eclairer",
  "eclipse",
  "eclore",
  "ecluse",
  "ecole",
  "economie",
  "ecorce",
  "ecouter",
  "ecraser",
  "ecremer",
  "ecrivain",
  "ecrou",
  "ecume",
  "ecureuil",
  "edifier",
  "eduquer",
  "effacer",
  "effectif",
  "effigie",
  "effort",
  "effrayer",
  "effusion",
  "egaliser",
  "egarer",
  "ejecter",
  "elaborer",
  "elargir",
  "electron",
  "elegant",
  "elephant",
  "eleve",
  "eligible",
  "elitisme",
  "eloge",
  "elucider",
  "eluder",
  "emballer",
  "embellir",
  "embryon",
  "emeraude",
  "emission",
  "emmener",
  "emotion",
  "emouvoir",
  "empereur",
  "employer",
  "emporter",
  "emprise",
  "emulsion",
  "encadrer",
  "enchere",
  "enclave",
  "encoche",
  "endiguer",
  "endosser",
  "endroit",
  "enduire",
  "energie",
  "enfance",
  "enfermer",
  "enfouir",
  "engager",
  "engin",
  "englober",
  "enigme",
  "enjamber",
  "enjeu",
  "enlever",
  "ennemi",
  "ennuyeux",
  "enrichir",
  "enrobage",
  "enseigne",
  "entasser",
  "entendre",
  "entier",
  "entourer",
  "entraver",
  "enumerer",
  "envahir",
  "enviable",
  "envoyer",
  "enzyme",
  "eolien",
  "epaissir",
  "epargne",
  "epatant",
  "epaule",
  "epicerie",
  "epidemie",
  "epier",
  "epilogue",
  "epine",
  "episode",
  "epitaphe",
  "epoque",
  "epreuve",
  "eprouver",
  "epuisant",
  "equerre",
  "equipe",
  "eriger",
  "erosion",
  "erreur",
  "eruption",
  "escalier",
  "espadon",
  "espece",
  "espiegle",
  "espoir",
  "esprit",
  "esquiver",
  "essayer",
  "essence",
  "essieu",
  "essorer",
  "estime",
  "estomac",
  "estrade",
  "etagere",
  "etaler",
  "etanche",
  "etatique",
  "eteindre",
  "etendoir",
  "eternel",
  "ethanol",
  "ethique",
  "ethnie",
  "etirer",
  "etoffer",
  "etoile",
  "etonnant",
  "etourdir",
  "etrange",
  "etroit",
  "etude",
  "euphorie",
  "evaluer",
  "evasion",
  "eventail",
  "evidence",
  "eviter",
  "evolutif",
  "evoquer",
  "exact",
  "exagerer",
  "exaucer",
  "exceller",
  "excitant",
  "exclusif",
  "excuse",
  "executer",
  "exemple",
  "exercer",
  "exhaler",
  "exhorter",
  "exigence",
  "exiler",
  "exister",
  "exotique",
  "expedier",
  "explorer",
  "exposer",
  "exprimer",
  "exquis",
  "extensif",
  "extraire",
  "exulter",
  "fable",
  "fabuleux",
  "facette",
  "facile",
  "facture",
  "faiblir",
  "falaise",
  "fameux",
  "famille",
  "farceur",
  "farfelu",
  "farine",
  "farouche",
  "fasciner",
  "fatal",
  "fatigue",
  "faucon",
  "fautif",
  "faveur",
  "favori",
  "febrile",
  "feconder",
  "federer",
  "felin",
  "femme",
  "femur",
  "fendoir",
  "feodal",
  "fermer",
  "feroce",
  "ferveur",
  "festival",
  "feuille",
  "feutre",
  "fevrier",
  "fiasco",
  "ficeler",
  "fictif",
  "fidele",
  "figure",
  "filature",
  "filetage",
  "filiere",
  "filleul",
  "filmer",
  "filou",
  "filtrer",
  "financer",
  "finir",
  "fiole",
  "firme",
  "fissure",
  "fixer",
  "flairer",
  "flamme",
  "flasque",
  "flatteur",
  "fleau",
  "fleche",
  "fleur",
  "flexion",
  "flocon",
  "flore",
  "fluctuer",
  "fluide",
  "fluvial",
  "folie",
  "fonderie",
  "fongible",
  "fontaine",
  "forcer",
  "forgeron",
  "formuler",
  "fortune",
  "fossile",
  "foudre",
  "fougere",
  "fouiller",
  "foulure",
  "fourmi",
  "fragile",
  "fraise",
  "franchir",
  "frapper",
  "frayeur",
  "fregate",
  "freiner",
  "frelon",
  "fremir",
  "frenesie",
  "frere",
  "friable",
  "friction",
  "frisson",
  "frivole",
  "froid",
  "fromage",
  "frontal",
  "frotter",
  "fruit",
  "fugitif",
  "fuite",
  "fureur",
  "furieux",
  "furtif",
  "fusion",
  "futur",
  "gagner",
  "galaxie",
  "galerie",
  "gambader",
  "garantir",
  "gardien",
  "garnir",
  "garrigue",
  "gazelle",
  "gazon",
  "geant",
  "gelatine",
  "gelule",
  "gendarme",
  "general",
  "genie",
  "genou",
  "gentil",
  "geologie",
  "geometre",
  "geranium",
  "germe",
  "gestuel",
  "geyser",
  "gibier",
  "gicler",
  "girafe",
  "givre",
  "glace",
  "glaive",
  "glisser",
  "globe",
  "gloire",
  "glorieux",
  "golfeur",
  "gomme",
  "gonfler",
  "gorge",
  "gorille",
  "goudron",
  "gouffre",
  "goulot",
  "goupille",
  "gourmand",
  "goutte",
  "graduel",
  "graffiti",
  "graine",
  "grand",
  "grappin",
  "gratuit",
  "gravir",
  "grenat",
  "griffure",
  "griller",
  "grimper",
  "grogner",
  "gronder",
  "grotte",
  "groupe",
  "gruger",
  "grutier",
  "gruyere",
  "guepard",
  "guerrier",
  "guide",
  "guimauve",
  "guitare",
  "gustatif",
  "gymnaste",
  "gyrostat",
  "habitude",
  "hachoir",
  "halte",
  "hameau",
  "hangar",
  "hanneton",
  "haricot",
  "harmonie",
  "harpon",
  "hasard",
  "helium",
  "hematome",
  "herbe",
  "herisson",
  "hermine",
  "heron",
  "hesiter",
  "heureux",
  "hiberner",
  "hibou",
  "hilarant",
  "histoire",
  "hiver",
  "homard",
  "hommage",
  "homogene",
  "honneur",
  "honorer",
  "honteux",
  "horde",
  "horizon",
  "horloge",
  "hormone",
  "horrible",
  "houleux",
  "housse",
  "hublot",
  "huileux",
  "humain",
  "humble",
  "humide",
  "humour",
  "hurler",
  "hydromel",
  "hygiene",
  "hymne",
  "hypnose",
  "idylle",
  "ignorer",
  "iguane",
  "illicite",
  "illusion",
  "image",
  "imbiber",
  "imiter",
  "immense",
  "immobile",
  "immuable",
  "impact",
  "imperial",
  "implorer",
  "imposer",
  "imprimer",
  "imputer",
  "incarner",
  "incendie",
  "incident",
  "incliner",
  "incolore",
  "indexer",
  "indice",
  "inductif",
  "inedit",
  "ineptie",
  "inexact",
  "infini",
  "infliger",
  "informer",
  "infusion",
  "ingerer",
  "inhaler",
  "inhiber",
  "injecter",
  "injure",
  "innocent",
  "inoculer",
  "inonder",
  "inscrire",
  "insecte",
  "insigne",
  "insolite",
  "inspirer",
  "instinct",
  "insulter",
  "intact",
  "intense",
  "intime",
  "intrigue",
  "intuitif",
  "inutile",
  "invasion",
  "inventer",
  "inviter",
  "invoquer",
  "ironique",
  "irradier",
  "irreel",
  "irriter",
  "isoler",
  "ivoire",
  "ivresse",
  "jaguar",
  "jaillir",
  "jambe",
  "janvier",
  "jardin",
  "jauger",
  "jaune",
  "javelot",
  "jetable",
  "jeton",
  "jeudi",
  "jeunesse",
  "joindre",
  "joncher",
  "jongler",
  "joueur",
  "jouissif",
  "journal",
  "jovial",
  "joyau",
  "joyeux",
  "jubiler",
  "jugement",
  "junior",
  "jupon",
  "juriste",
  "justice",
  "juteux",
  "juvenile",
  "kayak",
  "kimono",
  "kiosque",
  "label",
  "labial",
  "labourer",
  "lacerer",
  "lactose",
  "lagune",
  "laine",
  "laisser",
  "laitier",
  "lambeau",
  "lamelle",
  "lampe",
  "lanceur",
  "langage",
  "lanterne",
  "lapin",
  "largeur",
  "larme",
  "laurier",
  "lavabo",
  "lavoir",
  "lecture",
  "legal",
  "leger",
  "legume",
  "lessive",
  "lettre",
  "levier",
  "lexique",
  "lezard",
  "liasse",
  "liberer",
  "libre",
  "licence",
  "licorne",
  "liege",
  "lievre",
  "ligature",
  "ligoter",
  "ligue",
  "limer",
  "limite",
  "limonade",
  "limpide",
  "lineaire",
  "lingot",
  "lionceau",
  "liquide",
  "lisiere",
  "lister",
  "lithium",
  "litige",
  "littoral",
  "livreur",
  "logique",
  "lointain",
  "loisir",
  "lombric",
  "loterie",
  "louer",
  "lourd",
  "loutre",
  "louve",
  "loyal",
  "lubie",
  "lucide",
  "lucratif",
  "lueur",
  "lugubre",
  "luisant",
  "lumiere",
  "lunaire",
  "lundi",
  "luron",
  "lutter",
  "luxueux",
  "machine",
  "magasin",
  "magenta",
  "magique",
  "maigre",
  "maillon",
  "maintien",
  "mairie",
  "maison",
  "majorer",
  "malaxer",
  "malefice",
  "malheur",
  "malice",
  "mallette",
  "mammouth",
  "mandater",
  "maniable",
  "manquant",
  "manteau",
  "manuel",
  "marathon",
  "marbre",
  "marchand",
  "mardi",
  "maritime",
  "marqueur",
  "marron",
  "marteler",
  "mascotte",
  "massif",
  "materiel",
  "matiere",
  "matraque",
  "maudire",
  "maussade",
  "mauve",
  "maximal",
  "mechant",
  "meconnu",
  "medaille",
  "medecin",
  "mediter",
  "meduse",
  "meilleur",
  "melange",
  "melodie",
  "membre",
  "memoire",
  "menacer",
  "mener",
  "menhir",
  "mensonge",
  "mentor",
  "mercredi",
  "merite",
  "merle",
  "messager",
  "mesure",
  "metal",
  "meteore",
  "methode",
  "metier",
  "meuble",
  "miauler",
  "microbe",
  "miette",
  "mignon",
  "migrer",
  "milieu",
  "million",
  "mimique",
  "mince",
  "mineral",
  "minimal",
  "minorer",
  "minute",
  "miracle",
  "miroiter",
  "missile",
  "mixte",
  "mobile",
  "moderne",
  "moelleux",
  "mondial",
  "moniteur",
  "monnaie",
  "monotone",
  "monstre",
  "montagne",
  "monument",
  "moqueur",
  "morceau",
  "morsure",
  "mortier",
  "moteur",
  "motif",
  "mouche",
  "moufle",
  "moulin",
  "mousson",
  "mouton",
  "mouvant",
  "multiple",
  "munition",
  "muraille",
  "murene",
  "murmure",
  "muscle",
  "museum",
  "musicien",
  "mutation",
  "muter",
  "mutuel",
  "myriade",
  "myrtille",
  "mystere",
  "mythique",
  "nageur",
  "nappe",
  "narquois",
  "narrer",
  "natation",
  "nation",
  "nature",
  "naufrage",
  "nautique",
  "navire",
  "nebuleux",
  "nectar",
  "nefaste",
  "negation",
  "negliger",
  "negocier",
  "neige",
  "nerveux",
  "nettoyer",
  "neurone",
  "neutron",
  "neveu",
  "niche",
  "nickel",
  "nitrate",
  "niveau",
  "noble",
  "nocif",
  "nocturne",
  "noirceur",
  "noisette",
  "nomade",
  "nombreux",
  "nommer",
  "normatif",
  "notable",
  "notifier",
  "notoire",
  "nourrir",
  "nouveau",
  "novateur",
  "novembre",
  "novice",
  "nuage",
  "nuancer",
  "nuire",
  "nuisible",
  "numero",
  "nuptial",
  "nuque",
  "nutritif",
  "obeir",
  "objectif",
  "obliger",
  "obscur",
  "observer",
  "obstacle",
  "obtenir",
  "obturer",
  "occasion",
  "occuper",
  "ocean",
  "octobre",
  "octroyer",
  "octupler",
  "oculaire",
  "odeur",
  "odorant",
  "offenser",
  "officier",
  "offrir",
  "ogive",
  "oiseau",
  "oisillon",
  "olfactif",
  "olivier",
  "ombrage",
  "omettre",
  "onctueux",
  "onduler",
  "onereux",
  "onirique",
  "opale",
  "opaque",
  "operer",
  "opinion",
  "opportun",
  "opprimer",
  "opter",
  "optique",
  "orageux",
  "orange",
  "orbite",
  "ordonner",
  "oreille",
  "organe",
  "orgueil",
  "orifice",
  "ornement",
  "orque",
  "ortie",
  "osciller",
  "osmose",
  "ossature",
  "otarie",
  "ouragan",
  "ourson",
  "outil",
  "outrager",
  "ouvrage",
  "ovation",
  "oxyde",
  "oxygene",
  "ozone",
  "paisible",
  "palace",
  "palmares",
  "palourde",
  "palper",
  "panache",
  "panda",
  "pangolin",
  "paniquer",
  "panneau",
  "panorama",
  "pantalon",
  "papaye",
  "papier",
  "papoter",
  "papyrus",
  "paradoxe",
  "parcelle",
  "paresse",
  "parfumer",
  "parler",
  "parole",
  "parrain",
  "parsemer",
  "partager",
  "parure",
  "parvenir",
  "passion",
  "pasteque",
  "paternel",
  "patience",
  "patron",
  "pavillon",
  "pavoiser",
  "payer",
  "paysage",
  "peigne",
  "peintre",
  "pelage",
  "pelican",
  "pelle",
  "pelouse",
  "peluche",
  "pendule",
  "penetrer",
  "penible",
  "pensif",
  "penurie",
  "pepite",
  "peplum",
  "perdrix",
  "perforer",
  "periode",
  "permuter",
  "perplexe",
  "persil",
  "perte",
  "peser",
  "petale",
  "petit",
  "petrir",
  "peuple",
  "pharaon",
  "phobie",
  "phoque",
  "photon",
  "phrase",
  "physique",
  "piano",
  "pictural",
  "piece",
  "pierre",
  "pieuvre",
  "pilote",
  "pinceau",
  "pipette",
  "piquer",
  "pirogue",
  "piscine",
  "piston",
  "pivoter",
  "pixel",
  "pizza",
  "placard",
  "plafond",
  "plaisir",
  "planer",
  "plaque",
  "plastron",
  "plateau",
  "pleurer",
  "plexus",
  "pliage",
  "plomb",
  "plonger",
  "pluie",
  "plumage",
  "pochette",
  "poesie",
  "poete",
  "pointe",
  "poirier",
  "poisson",
  "poivre",
  "polaire",
  "policier",
  "pollen",
  "polygone",
  "pommade",
  "pompier",
  "ponctuel",
  "ponderer",
  "poney",
  "portique",
  "position",
  "posseder",
  "posture",
  "potager",
  "poteau",
  "potion",
  "pouce",
  "poulain",
  "poumon",
  "pourpre",
  "poussin",
  "pouvoir",
  "prairie",
  "pratique",
  "precieux",
  "predire",
  "prefixe",
  "prelude",
  "prenom",
  "presence",
  "pretexte",
  "prevoir",
  "primitif",
  "prince",
  "prison",
  "priver",
  "probleme",
  "proceder",
  "prodige",
  "profond",
  "progres",
  "proie",
  "projeter",
  "prologue",
  "promener",
  "propre",
  "prospere",
  "proteger",
  "prouesse",
  "proverbe",
  "prudence",
  "pruneau",
  "psychose",
  "public",
  "puceron",
  "puiser",
  "pulpe",
  "pulsar",
  "punaise",
  "punitif",
  "pupitre",
  "purifier",
  "puzzle",
  "pyramide",
  "quasar",
  "querelle",
  "question",
  "quietude",
  "quitter",
  "quotient",
  "racine",
  "raconter",
  "radieux",
  "ragondin",
  "raideur",
  "raisin",
  "ralentir",
  "rallonge",
  "ramasser",
  "rapide",
  "rasage",
  "ratisser",
  "ravager",
  "ravin",
  "rayonner",
  "reactif",
  "reagir",
  "realiser",
  "reanimer",
  "recevoir",
  "reciter",
  "reclamer",
  "recolter",
  "recruter",
  "reculer",
  "recycler",
  "rediger",
  "redouter",
  "refaire",
  "reflexe",
  "reformer",
  "refrain",
  "refuge",
  "regalien",
  "region",
  "reglage",
  "regulier",
  "reiterer",
  "rejeter",
  "rejouer",
  "relatif",
  "relever",
  "relief",
  "remarque",
  "remede",
  "remise",
  "remonter",
  "remplir",
  "remuer",
  "renard",
  "renfort",
  "renifler",
  "renoncer",
  "rentrer",
  "renvoi",
  "replier",
  "reporter",
  "reprise",
  "reptile",
  "requin",
  "reserve",
  "resineux",
  "resoudre",
  "respect",
  "rester",
  "resultat",
  "retablir",
  "retenir",
  "reticule",
  "retomber",
  "retracer",
  "reunion",
  "reussir",
  "revanche",
  "revivre",
  "revolte",
  "revulsif",
  "richesse",
  "rideau",
  "rieur",
  "rigide",
  "rigoler",
  "rincer",
  "riposter",
  "risible",
  "risque",
  "rituel",
  "rival",
  "riviere",
  "rocheux",
  "romance",
  "rompre",
  "ronce",
  "rondin",
  "roseau",
  "rosier",
  "rotatif",
  "rotor",
  "rotule",
  "rouge",
  "rouille",
  "rouleau",
  "routine",
  "royaume",
  "ruban",
  "rubis",
  "ruche",
  "ruelle",
  "rugueux",
  "ruiner",
  "ruisseau",
  "ruser",
  "rustique",
  "rythme",
  "sabler",
  "saboter",
  "sabre",
  "sacoche",
  "safari",
  "sagesse",
  "saisir",
  "salade",
  "salive",
  "salon",
  "saluer",
  "samedi",
  "sanction",
  "sanglier",
  "sarcasme",
  "sardine",
  "saturer",
  "saugrenu",
  "saumon",
  "sauter",
  "sauvage",
  "savant",
  "savonner",
  "scalpel",
  "scandale",
  "scelerat",
  "scenario",
  "sceptre",
  "schema",
  "science",
  "scinder",
  "score",
  "scrutin",
  "sculpter",
  "seance",
  "secable",
  "secher",
  "secouer",
  "secreter",
  "sedatif",
  "seduire",
  "seigneur",
  "sejour",
  "selectif",
  "semaine",
  "sembler",
  "semence",
  "seminal",
  "senateur",
  "sensible",
  "sentence",
  "separer",
  "sequence",
  "serein",
  "sergent",
  "serieux",
  "serrure",
  "serum",
  "service",
  "sesame",
  "sevir",
  "sevrage",
  "sextuple",
  "sideral",
  "siecle",
  "sieger",
  "siffler",
  "sigle",
  "signal",
  "silence",
  "silicium",
  "simple",
  "sincere",
  "sinistre",
  "siphon",
  "sirop",
  "sismique",
  "situer",
  "skier",
  "social",
  "socle",
  "sodium",
  "soigneux",
  "soldat",
  "soleil",
  "solitude",
  "soluble",
  "sombre",
  "sommeil",
  "somnoler",
  "sonde",
  "songeur",
  "sonnette",
  "sonore",
  "sorcier",
  "sortir",
  "sosie",
  "sottise",
  "soucieux",
  "soudure",
  "souffle",
  "soulever",
  "soupape",
  "source",
  "soutirer",
  "souvenir",
  "spacieux",
  "spatial",
  "special",
  "sphere",
  "spiral",
  "stable",
  "station",
  "sternum",
  "stimulus",
  "stipuler",
  "strict",
  "studieux",
  "stupeur",
  "styliste",
  "sublime",
  "substrat",
  "subtil",
  "subvenir",
  "succes",
  "sucre",
  "suffixe",
  "suggerer",
  "suiveur",
  "sulfate",
  "superbe",
  "supplier",
  "surface",
  "suricate",
  "surmener",
  "surprise",
  "sursaut",
  "survie",
  "suspect",
  "syllabe",
  "symbole",
  "symetrie",
  "synapse",
  "syntaxe",
  "systeme",
  "tabac",
  "tablier",
  "tactile",
  "tailler",
  "talent",
  "talisman",
  "talonner",
  "tambour",
  "tamiser",
  "tangible",
  "tapis",
  "taquiner",
  "tarder",
  "tarif",
  "tartine",
  "tasse",
  "tatami",
  "tatouage",
  "taupe",
  "taureau",
  "taxer",
  "temoin",
  "temporel",
  "tenaille",
  "tendre",
  "teneur",
  "tenir",
  "tension",
  "terminer",
  "terne",
  "terrible",
  "tetine",
  "texte",
  "theme",
  "theorie",
  "therapie",
  "thorax",
  "tibia",
  "tiede",
  "timide",
  "tirelire",
  "tiroir",
  "tissu",
  "titane",
  "titre",
  "tituber",
  "toboggan",
  "tolerant",
  "tomate",
  "tonique",
  "tonneau",
  "toponyme",
  "torche",
  "tordre",
  "tornade",
  "torpille",
  "torrent",
  "torse",
  "tortue",
  "totem",
  "toucher",
  "tournage",
  "tousser",
  "toxine",
  "traction",
  "trafic",
  "tragique",
  "trahir",
  "train",
  "trancher",
  "travail",
  "trefle",
  "tremper",
  "tresor",
  "treuil",
  "triage",
  "tribunal",
  "tricoter",
  "trilogie",
  "triomphe",
  "tripler",
  "triturer",
  "trivial",
  "trombone",
  "tronc",
  "tropical",
  "troupeau",
  "tuile",
  "tulipe",
  "tumulte",
  "tunnel",
  "turbine",
  "tuteur",
  "tutoyer",
  "tuyau",
  "tympan",
  "typhon",
  "typique",
  "tyran",
  "ubuesque",
  "ultime",
  "ultrason",
  "unanime",
  "unifier",
  "union",
  "unique",
  "unitaire",
  "univers",
  "uranium",
  "urbain",
  "urticant",
  "usage",
  "usine",
  "usuel",
  "usure",
  "utile",
  "utopie",
  "vacarme",
  "vaccin",
  "vagabond",
  "vague",
  "vaillant",
  "vaincre",
  "vaisseau",
  "valable",
  "valise",
  "vallon",
  "valve",
  "vampire",
  "vanille",
  "vapeur",
  "varier",
  "vaseux",
  "vassal",
  "vaste",
  "vecteur",
  "vedette",
  "vegetal",
  "vehicule",
  "veinard",
  "veloce",
  "vendredi",
  "venerer",
  "venger",
  "venimeux",
  "ventouse",
  "verdure",
  "verin",
  "vernir",
  "verrou",
  "verser",
  "vertu",
  "veston",
  "veteran",
  "vetuste",
  "vexant",
  "vexer",
  "viaduc",
  "viande",
  "victoire",
  "vidange",
  "video",
  "vignette",
  "vigueur",
  "vilain",
  "village",
  "vinaigre",
  "violon",
  "vipere",
  "virement",
  "virtuose",
  "virus",
  "visage",
  "viseur",
  "vision",
  "visqueux",
  "visuel",
  "vital",
  "vitesse",
  "viticole",
  "vitrine",
  "vivace",
  "vivipare",
  "vocation",
  "voguer",
  "voile",
  "voisin",
  "voiture",
  "volaille",
  "volcan",
  "voltiger",
  "volume",
  "vorace",
  "vortex",
  "voter",
  "vouloir",
  "voyage",
  "voyelle",
  "wagon",
  "xenon",
  "yacht",
  "zebre",
  "zenith",
  "zeste",
  "zoologie"
], YJ = [
  "abaco",
  "abbaglio",
  "abbinato",
  "abete",
  "abisso",
  "abolire",
  "abrasivo",
  "abrogato",
  "accadere",
  "accenno",
  "accusato",
  "acetone",
  "achille",
  "acido",
  "acqua",
  "acre",
  "acrilico",
  "acrobata",
  "acuto",
  "adagio",
  "addebito",
  "addome",
  "adeguato",
  "aderire",
  "adipe",
  "adottare",
  "adulare",
  "affabile",
  "affetto",
  "affisso",
  "affranto",
  "aforisma",
  "afoso",
  "africano",
  "agave",
  "agente",
  "agevole",
  "aggancio",
  "agire",
  "agitare",
  "agonismo",
  "agricolo",
  "agrumeto",
  "aguzzo",
  "alabarda",
  "alato",
  "albatro",
  "alberato",
  "albo",
  "albume",
  "alce",
  "alcolico",
  "alettone",
  "alfa",
  "algebra",
  "aliante",
  "alibi",
  "alimento",
  "allagato",
  "allegro",
  "allievo",
  "allodola",
  "allusivo",
  "almeno",
  "alogeno",
  "alpaca",
  "alpestre",
  "altalena",
  "alterno",
  "alticcio",
  "altrove",
  "alunno",
  "alveolo",
  "alzare",
  "amalgama",
  "amanita",
  "amarena",
  "ambito",
  "ambrato",
  "ameba",
  "america",
  "ametista",
  "amico",
  "ammasso",
  "ammenda",
  "ammirare",
  "ammonito",
  "amore",
  "ampio",
  "ampliare",
  "amuleto",
  "anacardo",
  "anagrafe",
  "analista",
  "anarchia",
  "anatra",
  "anca",
  "ancella",
  "ancora",
  "andare",
  "andrea",
  "anello",
  "angelo",
  "angolare",
  "angusto",
  "anima",
  "annegare",
  "annidato",
  "anno",
  "annuncio",
  "anonimo",
  "anticipo",
  "anzi",
  "apatico",
  "apertura",
  "apode",
  "apparire",
  "appetito",
  "appoggio",
  "approdo",
  "appunto",
  "aprile",
  "arabica",
  "arachide",
  "aragosta",
  "araldica",
  "arancio",
  "aratura",
  "arazzo",
  "arbitro",
  "archivio",
  "ardito",
  "arenile",
  "argento",
  "argine",
  "arguto",
  "aria",
  "armonia",
  "arnese",
  "arredato",
  "arringa",
  "arrosto",
  "arsenico",
  "arso",
  "artefice",
  "arzillo",
  "asciutto",
  "ascolto",
  "asepsi",
  "asettico",
  "asfalto",
  "asino",
  "asola",
  "aspirato",
  "aspro",
  "assaggio",
  "asse",
  "assoluto",
  "assurdo",
  "asta",
  "astenuto",
  "astice",
  "astratto",
  "atavico",
  "ateismo",
  "atomico",
  "atono",
  "attesa",
  "attivare",
  "attorno",
  "attrito",
  "attuale",
  "ausilio",
  "austria",
  "autista",
  "autonomo",
  "autunno",
  "avanzato",
  "avere",
  "avvenire",
  "avviso",
  "avvolgere",
  "azione",
  "azoto",
  "azzimo",
  "azzurro",
  "babele",
  "baccano",
  "bacino",
  "baco",
  "badessa",
  "badilata",
  "bagnato",
  "baita",
  "balcone",
  "baldo",
  "balena",
  "ballata",
  "balzano",
  "bambino",
  "bandire",
  "baraonda",
  "barbaro",
  "barca",
  "baritono",
  "barlume",
  "barocco",
  "basilico",
  "basso",
  "batosta",
  "battuto",
  "baule",
  "bava",
  "bavosa",
  "becco",
  "beffa",
  "belgio",
  "belva",
  "benda",
  "benevole",
  "benigno",
  "benzina",
  "bere",
  "berlina",
  "beta",
  "bibita",
  "bici",
  "bidone",
  "bifido",
  "biga",
  "bilancia",
  "bimbo",
  "binocolo",
  "biologo",
  "bipede",
  "bipolare",
  "birbante",
  "birra",
  "biscotto",
  "bisesto",
  "bisnonno",
  "bisonte",
  "bisturi",
  "bizzarro",
  "blando",
  "blatta",
  "bollito",
  "bonifico",
  "bordo",
  "bosco",
  "botanico",
  "bottino",
  "bozzolo",
  "braccio",
  "bradipo",
  "brama",
  "branca",
  "bravura",
  "bretella",
  "brevetto",
  "brezza",
  "briglia",
  "brillante",
  "brindare",
  "broccolo",
  "brodo",
  "bronzina",
  "brullo",
  "bruno",
  "bubbone",
  "buca",
  "budino",
  "buffone",
  "buio",
  "bulbo",
  "buono",
  "burlone",
  "burrasca",
  "bussola",
  "busta",
  "cadetto",
  "caduco",
  "calamaro",
  "calcolo",
  "calesse",
  "calibro",
  "calmo",
  "caloria",
  "cambusa",
  "camerata",
  "camicia",
  "cammino",
  "camola",
  "campale",
  "canapa",
  "candela",
  "cane",
  "canino",
  "canotto",
  "cantina",
  "capace",
  "capello",
  "capitolo",
  "capogiro",
  "cappero",
  "capra",
  "capsula",
  "carapace",
  "carcassa",
  "cardo",
  "carisma",
  "carovana",
  "carretto",
  "cartolina",
  "casaccio",
  "cascata",
  "caserma",
  "caso",
  "cassone",
  "castello",
  "casuale",
  "catasta",
  "catena",
  "catrame",
  "cauto",
  "cavillo",
  "cedibile",
  "cedrata",
  "cefalo",
  "celebre",
  "cellulare",
  "cena",
  "cenone",
  "centesimo",
  "ceramica",
  "cercare",
  "certo",
  "cerume",
  "cervello",
  "cesoia",
  "cespo",
  "ceto",
  "chela",
  "chiaro",
  "chicca",
  "chiedere",
  "chimera",
  "china",
  "chirurgo",
  "chitarra",
  "ciao",
  "ciclismo",
  "cifrare",
  "cigno",
  "cilindro",
  "ciottolo",
  "circa",
  "cirrosi",
  "citrico",
  "cittadino",
  "ciuffo",
  "civetta",
  "civile",
  "classico",
  "clinica",
  "cloro",
  "cocco",
  "codardo",
  "codice",
  "coerente",
  "cognome",
  "collare",
  "colmato",
  "colore",
  "colposo",
  "coltivato",
  "colza",
  "coma",
  "cometa",
  "commando",
  "comodo",
  "computer",
  "comune",
  "conciso",
  "condurre",
  "conferma",
  "congelare",
  "coniuge",
  "connesso",
  "conoscere",
  "consumo",
  "continuo",
  "convegno",
  "coperto",
  "copione",
  "coppia",
  "copricapo",
  "corazza",
  "cordata",
  "coricato",
  "cornice",
  "corolla",
  "corpo",
  "corredo",
  "corsia",
  "cortese",
  "cosmico",
  "costante",
  "cottura",
  "covato",
  "cratere",
  "cravatta",
  "creato",
  "credere",
  "cremoso",
  "crescita",
  "creta",
  "criceto",
  "crinale",
  "crisi",
  "critico",
  "croce",
  "cronaca",
  "crostata",
  "cruciale",
  "crusca",
  "cucire",
  "cuculo",
  "cugino",
  "cullato",
  "cupola",
  "curatore",
  "cursore",
  "curvo",
  "cuscino",
  "custode",
  "dado",
  "daino",
  "dalmata",
  "damerino",
  "daniela",
  "dannoso",
  "danzare",
  "datato",
  "davanti",
  "davvero",
  "debutto",
  "decennio",
  "deciso",
  "declino",
  "decollo",
  "decreto",
  "dedicato",
  "definito",
  "deforme",
  "degno",
  "delegare",
  "delfino",
  "delirio",
  "delta",
  "demenza",
  "denotato",
  "dentro",
  "deposito",
  "derapata",
  "derivare",
  "deroga",
  "descritto",
  "deserto",
  "desiderio",
  "desumere",
  "detersivo",
  "devoto",
  "diametro",
  "dicembre",
  "diedro",
  "difeso",
  "diffuso",
  "digerire",
  "digitale",
  "diluvio",
  "dinamico",
  "dinnanzi",
  "dipinto",
  "diploma",
  "dipolo",
  "diradare",
  "dire",
  "dirotto",
  "dirupo",
  "disagio",
  "discreto",
  "disfare",
  "disgelo",
  "disposto",
  "distanza",
  "disumano",
  "dito",
  "divano",
  "divelto",
  "dividere",
  "divorato",
  "doblone",
  "docente",
  "doganale",
  "dogma",
  "dolce",
  "domato",
  "domenica",
  "dominare",
  "dondolo",
  "dono",
  "dormire",
  "dote",
  "dottore",
  "dovuto",
  "dozzina",
  "drago",
  "druido",
  "dubbio",
  "dubitare",
  "ducale",
  "duna",
  "duomo",
  "duplice",
  "duraturo",
  "ebano",
  "eccesso",
  "ecco",
  "eclissi",
  "economia",
  "edera",
  "edicola",
  "edile",
  "editoria",
  "educare",
  "egemonia",
  "egli",
  "egoismo",
  "egregio",
  "elaborato",
  "elargire",
  "elegante",
  "elencato",
  "eletto",
  "elevare",
  "elfico",
  "elica",
  "elmo",
  "elsa",
  "eluso",
  "emanato",
  "emblema",
  "emesso",
  "emiro",
  "emotivo",
  "emozione",
  "empirico",
  "emulo",
  "endemico",
  "enduro",
  "energia",
  "enfasi",
  "enoteca",
  "entrare",
  "enzima",
  "epatite",
  "epilogo",
  "episodio",
  "epocale",
  "eppure",
  "equatore",
  "erario",
  "erba",
  "erboso",
  "erede",
  "eremita",
  "erigere",
  "ermetico",
  "eroe",
  "erosivo",
  "errante",
  "esagono",
  "esame",
  "esanime",
  "esaudire",
  "esca",
  "esempio",
  "esercito",
  "esibito",
  "esigente",
  "esistere",
  "esito",
  "esofago",
  "esortato",
  "esoso",
  "espanso",
  "espresso",
  "essenza",
  "esso",
  "esteso",
  "estimare",
  "estonia",
  "estroso",
  "esultare",
  "etilico",
  "etnico",
  "etrusco",
  "etto",
  "euclideo",
  "europa",
  "evaso",
  "evidenza",
  "evitato",
  "evoluto",
  "evviva",
  "fabbrica",
  "faccenda",
  "fachiro",
  "falco",
  "famiglia",
  "fanale",
  "fanfara",
  "fango",
  "fantasma",
  "fare",
  "farfalla",
  "farinoso",
  "farmaco",
  "fascia",
  "fastoso",
  "fasullo",
  "faticare",
  "fato",
  "favoloso",
  "febbre",
  "fecola",
  "fede",
  "fegato",
  "felpa",
  "feltro",
  "femmina",
  "fendere",
  "fenomeno",
  "fermento",
  "ferro",
  "fertile",
  "fessura",
  "festivo",
  "fetta",
  "feudo",
  "fiaba",
  "fiducia",
  "fifa",
  "figurato",
  "filo",
  "finanza",
  "finestra",
  "finire",
  "fiore",
  "fiscale",
  "fisico",
  "fiume",
  "flacone",
  "flamenco",
  "flebo",
  "flemma",
  "florido",
  "fluente",
  "fluoro",
  "fobico",
  "focaccia",
  "focoso",
  "foderato",
  "foglio",
  "folata",
  "folclore",
  "folgore",
  "fondente",
  "fonetico",
  "fonia",
  "fontana",
  "forbito",
  "forchetta",
  "foresta",
  "formica",
  "fornaio",
  "foro",
  "fortezza",
  "forzare",
  "fosfato",
  "fosso",
  "fracasso",
  "frana",
  "frassino",
  "fratello",
  "freccetta",
  "frenata",
  "fresco",
  "frigo",
  "frollino",
  "fronde",
  "frugale",
  "frutta",
  "fucilata",
  "fucsia",
  "fuggente",
  "fulmine",
  "fulvo",
  "fumante",
  "fumetto",
  "fumoso",
  "fune",
  "funzione",
  "fuoco",
  "furbo",
  "furgone",
  "furore",
  "fuso",
  "futile",
  "gabbiano",
  "gaffe",
  "galateo",
  "gallina",
  "galoppo",
  "gambero",
  "gamma",
  "garanzia",
  "garbo",
  "garofano",
  "garzone",
  "gasdotto",
  "gasolio",
  "gastrico",
  "gatto",
  "gaudio",
  "gazebo",
  "gazzella",
  "geco",
  "gelatina",
  "gelso",
  "gemello",
  "gemmato",
  "gene",
  "genitore",
  "gennaio",
  "genotipo",
  "gergo",
  "ghepardo",
  "ghiaccio",
  "ghisa",
  "giallo",
  "gilda",
  "ginepro",
  "giocare",
  "gioiello",
  "giorno",
  "giove",
  "girato",
  "girone",
  "gittata",
  "giudizio",
  "giurato",
  "giusto",
  "globulo",
  "glutine",
  "gnomo",
  "gobba",
  "golf",
  "gomito",
  "gommone",
  "gonfio",
  "gonna",
  "governo",
  "gracile",
  "grado",
  "grafico",
  "grammo",
  "grande",
  "grattare",
  "gravoso",
  "grazia",
  "greca",
  "gregge",
  "grifone",
  "grigio",
  "grinza",
  "grotta",
  "gruppo",
  "guadagno",
  "guaio",
  "guanto",
  "guardare",
  "gufo",
  "guidare",
  "ibernato",
  "icona",
  "identico",
  "idillio",
  "idolo",
  "idra",
  "idrico",
  "idrogeno",
  "igiene",
  "ignaro",
  "ignorato",
  "ilare",
  "illeso",
  "illogico",
  "illudere",
  "imballo",
  "imbevuto",
  "imbocco",
  "imbuto",
  "immane",
  "immerso",
  "immolato",
  "impacco",
  "impeto",
  "impiego",
  "importo",
  "impronta",
  "inalare",
  "inarcare",
  "inattivo",
  "incanto",
  "incendio",
  "inchino",
  "incisivo",
  "incluso",
  "incontro",
  "incrocio",
  "incubo",
  "indagine",
  "india",
  "indole",
  "inedito",
  "infatti",
  "infilare",
  "inflitto",
  "ingaggio",
  "ingegno",
  "inglese",
  "ingordo",
  "ingrosso",
  "innesco",
  "inodore",
  "inoltrare",
  "inondato",
  "insano",
  "insetto",
  "insieme",
  "insonnia",
  "insulina",
  "intasato",
  "intero",
  "intonaco",
  "intuito",
  "inumidire",
  "invalido",
  "invece",
  "invito",
  "iperbole",
  "ipnotico",
  "ipotesi",
  "ippica",
  "iride",
  "irlanda",
  "ironico",
  "irrigato",
  "irrorare",
  "isolato",
  "isotopo",
  "isterico",
  "istituto",
  "istrice",
  "italia",
  "iterare",
  "labbro",
  "labirinto",
  "lacca",
  "lacerato",
  "lacrima",
  "lacuna",
  "laddove",
  "lago",
  "lampo",
  "lancetta",
  "lanterna",
  "lardoso",
  "larga",
  "laringe",
  "lastra",
  "latenza",
  "latino",
  "lattuga",
  "lavagna",
  "lavoro",
  "legale",
  "leggero",
  "lembo",
  "lentezza",
  "lenza",
  "leone",
  "lepre",
  "lesivo",
  "lessato",
  "lesto",
  "letterale",
  "leva",
  "levigato",
  "libero",
  "lido",
  "lievito",
  "lilla",
  "limatura",
  "limitare",
  "limpido",
  "lineare",
  "lingua",
  "liquido",
  "lira",
  "lirica",
  "lisca",
  "lite",
  "litigio",
  "livrea",
  "locanda",
  "lode",
  "logica",
  "lombare",
  "londra",
  "longevo",
  "loquace",
  "lorenzo",
  "loto",
  "lotteria",
  "luce",
  "lucidato",
  "lumaca",
  "luminoso",
  "lungo",
  "lupo",
  "luppolo",
  "lusinga",
  "lusso",
  "lutto",
  "macabro",
  "macchina",
  "macero",
  "macinato",
  "madama",
  "magico",
  "maglia",
  "magnete",
  "magro",
  "maiolica",
  "malafede",
  "malgrado",
  "malinteso",
  "malsano",
  "malto",
  "malumore",
  "mana",
  "mancia",
  "mandorla",
  "mangiare",
  "manifesto",
  "mannaro",
  "manovra",
  "mansarda",
  "mantide",
  "manubrio",
  "mappa",
  "maratona",
  "marcire",
  "maretta",
  "marmo",
  "marsupio",
  "maschera",
  "massaia",
  "mastino",
  "materasso",
  "matricola",
  "mattone",
  "maturo",
  "mazurca",
  "meandro",
  "meccanico",
  "mecenate",
  "medesimo",
  "meditare",
  "mega",
  "melassa",
  "melis",
  "melodia",
  "meninge",
  "meno",
  "mensola",
  "mercurio",
  "merenda",
  "merlo",
  "meschino",
  "mese",
  "messere",
  "mestolo",
  "metallo",
  "metodo",
  "mettere",
  "miagolare",
  "mica",
  "micelio",
  "michele",
  "microbo",
  "midollo",
  "miele",
  "migliore",
  "milano",
  "milite",
  "mimosa",
  "minerale",
  "mini",
  "minore",
  "mirino",
  "mirtillo",
  "miscela",
  "missiva",
  "misto",
  "misurare",
  "mitezza",
  "mitigare",
  "mitra",
  "mittente",
  "mnemonico",
  "modello",
  "modifica",
  "modulo",
  "mogano",
  "mogio",
  "mole",
  "molosso",
  "monastero",
  "monco",
  "mondina",
  "monetario",
  "monile",
  "monotono",
  "monsone",
  "montato",
  "monviso",
  "mora",
  "mordere",
  "morsicato",
  "mostro",
  "motivato",
  "motosega",
  "motto",
  "movenza",
  "movimento",
  "mozzo",
  "mucca",
  "mucosa",
  "muffa",
  "mughetto",
  "mugnaio",
  "mulatto",
  "mulinello",
  "multiplo",
  "mummia",
  "munto",
  "muovere",
  "murale",
  "musa",
  "muscolo",
  "musica",
  "mutevole",
  "muto",
  "nababbo",
  "nafta",
  "nanometro",
  "narciso",
  "narice",
  "narrato",
  "nascere",
  "nastrare",
  "naturale",
  "nautica",
  "naviglio",
  "nebulosa",
  "necrosi",
  "negativo",
  "negozio",
  "nemmeno",
  "neofita",
  "neretto",
  "nervo",
  "nessuno",
  "nettuno",
  "neutrale",
  "neve",
  "nevrotico",
  "nicchia",
  "ninfa",
  "nitido",
  "nobile",
  "nocivo",
  "nodo",
  "nome",
  "nomina",
  "nordico",
  "normale",
  "norvegese",
  "nostrano",
  "notare",
  "notizia",
  "notturno",
  "novella",
  "nucleo",
  "nulla",
  "numero",
  "nuovo",
  "nutrire",
  "nuvola",
  "nuziale",
  "oasi",
  "obbedire",
  "obbligo",
  "obelisco",
  "oblio",
  "obolo",
  "obsoleto",
  "occasione",
  "occhio",
  "occidente",
  "occorrere",
  "occultare",
  "ocra",
  "oculato",
  "odierno",
  "odorare",
  "offerta",
  "offrire",
  "offuscato",
  "oggetto",
  "oggi",
  "ognuno",
  "olandese",
  "olfatto",
  "oliato",
  "oliva",
  "ologramma",
  "oltre",
  "omaggio",
  "ombelico",
  "ombra",
  "omega",
  "omissione",
  "ondoso",
  "onere",
  "onice",
  "onnivoro",
  "onorevole",
  "onta",
  "operato",
  "opinione",
  "opposto",
  "oracolo",
  "orafo",
  "ordine",
  "orecchino",
  "orefice",
  "orfano",
  "organico",
  "origine",
  "orizzonte",
  "orma",
  "ormeggio",
  "ornativo",
  "orologio",
  "orrendo",
  "orribile",
  "ortensia",
  "ortica",
  "orzata",
  "orzo",
  "osare",
  "oscurare",
  "osmosi",
  "ospedale",
  "ospite",
  "ossa",
  "ossidare",
  "ostacolo",
  "oste",
  "otite",
  "otre",
  "ottagono",
  "ottimo",
  "ottobre",
  "ovale",
  "ovest",
  "ovino",
  "oviparo",
  "ovocito",
  "ovunque",
  "ovviare",
  "ozio",
  "pacchetto",
  "pace",
  "pacifico",
  "padella",
  "padrone",
  "paese",
  "paga",
  "pagina",
  "palazzina",
  "palesare",
  "pallido",
  "palo",
  "palude",
  "pandoro",
  "pannello",
  "paolo",
  "paonazzo",
  "paprica",
  "parabola",
  "parcella",
  "parere",
  "pargolo",
  "pari",
  "parlato",
  "parola",
  "partire",
  "parvenza",
  "parziale",
  "passivo",
  "pasticca",
  "patacca",
  "patologia",
  "pattume",
  "pavone",
  "peccato",
  "pedalare",
  "pedonale",
  "peggio",
  "peloso",
  "penare",
  "pendice",
  "penisola",
  "pennuto",
  "penombra",
  "pensare",
  "pentola",
  "pepe",
  "pepita",
  "perbene",
  "percorso",
  "perdonato",
  "perforare",
  "pergamena",
  "periodo",
  "permesso",
  "perno",
  "perplesso",
  "persuaso",
  "pertugio",
  "pervaso",
  "pesatore",
  "pesista",
  "peso",
  "pestifero",
  "petalo",
  "pettine",
  "petulante",
  "pezzo",
  "piacere",
  "pianta",
  "piattino",
  "piccino",
  "picozza",
  "piega",
  "pietra",
  "piffero",
  "pigiama",
  "pigolio",
  "pigro",
  "pila",
  "pilifero",
  "pillola",
  "pilota",
  "pimpante",
  "pineta",
  "pinna",
  "pinolo",
  "pioggia",
  "piombo",
  "piramide",
  "piretico",
  "pirite",
  "pirolisi",
  "pitone",
  "pizzico",
  "placebo",
  "planare",
  "plasma",
  "platano",
  "plenario",
  "pochezza",
  "poderoso",
  "podismo",
  "poesia",
  "poggiare",
  "polenta",
  "poligono",
  "pollice",
  "polmonite",
  "polpetta",
  "polso",
  "poltrona",
  "polvere",
  "pomice",
  "pomodoro",
  "ponte",
  "popoloso",
  "porfido",
  "poroso",
  "porpora",
  "porre",
  "portata",
  "posa",
  "positivo",
  "possesso",
  "postulato",
  "potassio",
  "potere",
  "pranzo",
  "prassi",
  "pratica",
  "precluso",
  "predica",
  "prefisso",
  "pregiato",
  "prelievo",
  "premere",
  "prenotare",
  "preparato",
  "presenza",
  "pretesto",
  "prevalso",
  "prima",
  "principe",
  "privato",
  "problema",
  "procura",
  "produrre",
  "profumo",
  "progetto",
  "prolunga",
  "promessa",
  "pronome",
  "proposta",
  "proroga",
  "proteso",
  "prova",
  "prudente",
  "prugna",
  "prurito",
  "psiche",
  "pubblico",
  "pudica",
  "pugilato",
  "pugno",
  "pulce",
  "pulito",
  "pulsante",
  "puntare",
  "pupazzo",
  "pupilla",
  "puro",
  "quadro",
  "qualcosa",
  "quasi",
  "querela",
  "quota",
  "raccolto",
  "raddoppio",
  "radicale",
  "radunato",
  "raffica",
  "ragazzo",
  "ragione",
  "ragno",
  "ramarro",
  "ramingo",
  "ramo",
  "randagio",
  "rantolare",
  "rapato",
  "rapina",
  "rappreso",
  "rasatura",
  "raschiato",
  "rasente",
  "rassegna",
  "rastrello",
  "rata",
  "ravveduto",
  "reale",
  "recepire",
  "recinto",
  "recluta",
  "recondito",
  "recupero",
  "reddito",
  "redimere",
  "regalato",
  "registro",
  "regola",
  "regresso",
  "relazione",
  "remare",
  "remoto",
  "renna",
  "replica",
  "reprimere",
  "reputare",
  "resa",
  "residente",
  "responso",
  "restauro",
  "rete",
  "retina",
  "retorica",
  "rettifica",
  "revocato",
  "riassunto",
  "ribadire",
  "ribelle",
  "ribrezzo",
  "ricarica",
  "ricco",
  "ricevere",
  "riciclato",
  "ricordo",
  "ricreduto",
  "ridicolo",
  "ridurre",
  "rifasare",
  "riflesso",
  "riforma",
  "rifugio",
  "rigare",
  "rigettato",
  "righello",
  "rilassato",
  "rilevato",
  "rimanere",
  "rimbalzo",
  "rimedio",
  "rimorchio",
  "rinascita",
  "rincaro",
  "rinforzo",
  "rinnovo",
  "rinomato",
  "rinsavito",
  "rintocco",
  "rinuncia",
  "rinvenire",
  "riparato",
  "ripetuto",
  "ripieno",
  "riportare",
  "ripresa",
  "ripulire",
  "risata",
  "rischio",
  "riserva",
  "risibile",
  "riso",
  "rispetto",
  "ristoro",
  "risultato",
  "risvolto",
  "ritardo",
  "ritegno",
  "ritmico",
  "ritrovo",
  "riunione",
  "riva",
  "riverso",
  "rivincita",
  "rivolto",
  "rizoma",
  "roba",
  "robotico",
  "robusto",
  "roccia",
  "roco",
  "rodaggio",
  "rodere",
  "roditore",
  "rogito",
  "rollio",
  "romantico",
  "rompere",
  "ronzio",
  "rosolare",
  "rospo",
  "rotante",
  "rotondo",
  "rotula",
  "rovescio",
  "rubizzo",
  "rubrica",
  "ruga",
  "rullino",
  "rumine",
  "rumoroso",
  "ruolo",
  "rupe",
  "russare",
  "rustico",
  "sabato",
  "sabbiare",
  "sabotato",
  "sagoma",
  "salasso",
  "saldatura",
  "salgemma",
  "salivare",
  "salmone",
  "salone",
  "saltare",
  "saluto",
  "salvo",
  "sapere",
  "sapido",
  "saporito",
  "saraceno",
  "sarcasmo",
  "sarto",
  "sassoso",
  "satellite",
  "satira",
  "satollo",
  "saturno",
  "savana",
  "savio",
  "saziato",
  "sbadiglio",
  "sbalzo",
  "sbancato",
  "sbarra",
  "sbattere",
  "sbavare",
  "sbendare",
  "sbirciare",
  "sbloccato",
  "sbocciato",
  "sbrinare",
  "sbruffone",
  "sbuffare",
  "scabroso",
  "scadenza",
  "scala",
  "scambiare",
  "scandalo",
  "scapola",
  "scarso",
  "scatenare",
  "scavato",
  "scelto",
  "scenico",
  "scettro",
  "scheda",
  "schiena",
  "sciarpa",
  "scienza",
  "scindere",
  "scippo",
  "sciroppo",
  "scivolo",
  "sclerare",
  "scodella",
  "scolpito",
  "scomparto",
  "sconforto",
  "scoprire",
  "scorta",
  "scossone",
  "scozzese",
  "scriba",
  "scrollare",
  "scrutinio",
  "scuderia",
  "scultore",
  "scuola",
  "scuro",
  "scusare",
  "sdebitare",
  "sdoganare",
  "seccatura",
  "secondo",
  "sedano",
  "seggiola",
  "segnalato",
  "segregato",
  "seguito",
  "selciato",
  "selettivo",
  "sella",
  "selvaggio",
  "semaforo",
  "sembrare",
  "seme",
  "seminato",
  "sempre",
  "senso",
  "sentire",
  "sepolto",
  "sequenza",
  "serata",
  "serbato",
  "sereno",
  "serio",
  "serpente",
  "serraglio",
  "servire",
  "sestina",
  "setola",
  "settimana",
  "sfacelo",
  "sfaldare",
  "sfamato",
  "sfarzoso",
  "sfaticato",
  "sfera",
  "sfida",
  "sfilato",
  "sfinge",
  "sfocato",
  "sfoderare",
  "sfogo",
  "sfoltire",
  "sforzato",
  "sfratto",
  "sfruttato",
  "sfuggito",
  "sfumare",
  "sfuso",
  "sgabello",
  "sgarbato",
  "sgonfiare",
  "sgorbio",
  "sgrassato",
  "sguardo",
  "sibilo",
  "siccome",
  "sierra",
  "sigla",
  "signore",
  "silenzio",
  "sillaba",
  "simbolo",
  "simpatico",
  "simulato",
  "sinfonia",
  "singolo",
  "sinistro",
  "sino",
  "sintesi",
  "sinusoide",
  "sipario",
  "sisma",
  "sistole",
  "situato",
  "slitta",
  "slogatura",
  "sloveno",
  "smarrito",
  "smemorato",
  "smentito",
  "smeraldo",
  "smilzo",
  "smontare",
  "smottato",
  "smussato",
  "snellire",
  "snervato",
  "snodo",
  "sobbalzo",
  "sobrio",
  "soccorso",
  "sociale",
  "sodale",
  "soffitto",
  "sogno",
  "soldato",
  "solenne",
  "solido",
  "sollazzo",
  "solo",
  "solubile",
  "solvente",
  "somatico",
  "somma",
  "sonda",
  "sonetto",
  "sonnifero",
  "sopire",
  "soppeso",
  "sopra",
  "sorgere",
  "sorpasso",
  "sorriso",
  "sorso",
  "sorteggio",
  "sorvolato",
  "sospiro",
  "sosta",
  "sottile",
  "spada",
  "spalla",
  "spargere",
  "spatola",
  "spavento",
  "spazzola",
  "specie",
  "spedire",
  "spegnere",
  "spelatura",
  "speranza",
  "spessore",
  "spettrale",
  "spezzato",
  "spia",
  "spigoloso",
  "spillato",
  "spinoso",
  "spirale",
  "splendido",
  "sportivo",
  "sposo",
  "spranga",
  "sprecare",
  "spronato",
  "spruzzo",
  "spuntino",
  "squillo",
  "sradicare",
  "srotolato",
  "stabile",
  "stacco",
  "staffa",
  "stagnare",
  "stampato",
  "stantio",
  "starnuto",
  "stasera",
  "statuto",
  "stelo",
  "steppa",
  "sterzo",
  "stiletto",
  "stima",
  "stirpe",
  "stivale",
  "stizzoso",
  "stonato",
  "storico",
  "strappo",
  "stregato",
  "stridulo",
  "strozzare",
  "strutto",
  "stuccare",
  "stufo",
  "stupendo",
  "subentro",
  "succoso",
  "sudore",
  "suggerito",
  "sugo",
  "sultano",
  "suonare",
  "superbo",
  "supporto",
  "surgelato",
  "surrogato",
  "sussurro",
  "sutura",
  "svagare",
  "svedese",
  "sveglio",
  "svelare",
  "svenuto",
  "svezia",
  "sviluppo",
  "svista",
  "svizzera",
  "svolta",
  "svuotare",
  "tabacco",
  "tabulato",
  "tacciare",
  "taciturno",
  "tale",
  "talismano",
  "tampone",
  "tannino",
  "tara",
  "tardivo",
  "targato",
  "tariffa",
  "tarpare",
  "tartaruga",
  "tasto",
  "tattico",
  "taverna",
  "tavolata",
  "tazza",
  "teca",
  "tecnico",
  "telefono",
  "temerario",
  "tempo",
  "temuto",
  "tendone",
  "tenero",
  "tensione",
  "tentacolo",
  "teorema",
  "terme",
  "terrazzo",
  "terzetto",
  "tesi",
  "tesserato",
  "testato",
  "tetro",
  "tettoia",
  "tifare",
  "tigella",
  "timbro",
  "tinto",
  "tipico",
  "tipografo",
  "tiraggio",
  "tiro",
  "titanio",
  "titolo",
  "titubante",
  "tizio",
  "tizzone",
  "toccare",
  "tollerare",
  "tolto",
  "tombola",
  "tomo",
  "tonfo",
  "tonsilla",
  "topazio",
  "topologia",
  "toppa",
  "torba",
  "tornare",
  "torrone",
  "tortora",
  "toscano",
  "tossire",
  "tostatura",
  "totano",
  "trabocco",
  "trachea",
  "trafila",
  "tragedia",
  "tralcio",
  "tramonto",
  "transito",
  "trapano",
  "trarre",
  "trasloco",
  "trattato",
  "trave",
  "treccia",
  "tremolio",
  "trespolo",
  "tributo",
  "tricheco",
  "trifoglio",
  "trillo",
  "trincea",
  "trio",
  "tristezza",
  "triturato",
  "trivella",
  "tromba",
  "trono",
  "troppo",
  "trottola",
  "trovare",
  "truccato",
  "tubatura",
  "tuffato",
  "tulipano",
  "tumulto",
  "tunisia",
  "turbare",
  "turchino",
  "tuta",
  "tutela",
  "ubicato",
  "uccello",
  "uccisore",
  "udire",
  "uditivo",
  "uffa",
  "ufficio",
  "uguale",
  "ulisse",
  "ultimato",
  "umano",
  "umile",
  "umorismo",
  "uncinetto",
  "ungere",
  "ungherese",
  "unicorno",
  "unificato",
  "unisono",
  "unitario",
  "unte",
  "uovo",
  "upupa",
  "uragano",
  "urgenza",
  "urlo",
  "usanza",
  "usato",
  "uscito",
  "usignolo",
  "usuraio",
  "utensile",
  "utilizzo",
  "utopia",
  "vacante",
  "vaccinato",
  "vagabondo",
  "vagliato",
  "valanga",
  "valgo",
  "valico",
  "valletta",
  "valoroso",
  "valutare",
  "valvola",
  "vampata",
  "vangare",
  "vanitoso",
  "vano",
  "vantaggio",
  "vanvera",
  "vapore",
  "varano",
  "varcato",
  "variante",
  "vasca",
  "vedetta",
  "vedova",
  "veduto",
  "vegetale",
  "veicolo",
  "velcro",
  "velina",
  "velluto",
  "veloce",
  "venato",
  "vendemmia",
  "vento",
  "verace",
  "verbale",
  "vergogna",
  "verifica",
  "vero",
  "verruca",
  "verticale",
  "vescica",
  "vessillo",
  "vestale",
  "veterano",
  "vetrina",
  "vetusto",
  "viandante",
  "vibrante",
  "vicenda",
  "vichingo",
  "vicinanza",
  "vidimare",
  "vigilia",
  "vigneto",
  "vigore",
  "vile",
  "villano",
  "vimini",
  "vincitore",
  "viola",
  "vipera",
  "virgola",
  "virologo",
  "virulento",
  "viscoso",
  "visione",
  "vispo",
  "vissuto",
  "visura",
  "vita",
  "vitello",
  "vittima",
  "vivanda",
  "vivido",
  "viziare",
  "voce",
  "voga",
  "volatile",
  "volere",
  "volpe",
  "voragine",
  "vulcano",
  "zampogna",
  "zanna",
  "zappato",
  "zattera",
  "zavorra",
  "zefiro",
  "zelante",
  "zelo",
  "zenzero",
  "zerbino",
  "zibetto",
  "zinco",
  "zircone",
  "zitto",
  "zolla",
  "zotico",
  "zucchero",
  "zufolo",
  "zulu",
  "zuppa"
], JJ = [
  "abaco",
  "abdomen",
  "abeja",
  "abierto",
  "abogado",
  "abono",
  "aborto",
  "abrazo",
  "abrir",
  "abuelo",
  "abuso",
  "acabar",
  "academia",
  "acceso",
  "accion",
  "aceite",
  "acelga",
  "acento",
  "aceptar",
  "acido",
  "aclarar",
  "acne",
  "acoger",
  "acoso",
  "activo",
  "acto",
  "actriz",
  "actuar",
  "acudir",
  "acuerdo",
  "acusar",
  "adicto",
  "admitir",
  "adoptar",
  "adorno",
  "aduana",
  "adulto",
  "aereo",
  "afectar",
  "aficion",
  "afinar",
  "afirmar",
  "agil",
  "agitar",
  "agonia",
  "agosto",
  "agotar",
  "agregar",
  "agrio",
  "agua",
  "agudo",
  "aguila",
  "aguja",
  "ahogo",
  "ahorro",
  "aire",
  "aislar",
  "ajedrez",
  "ajeno",
  "ajuste",
  "alacran",
  "alambre",
  "alarma",
  "alba",
  "album",
  "alcalde",
  "aldea",
  "alegre",
  "alejar",
  "alerta",
  "aleta",
  "alfiler",
  "alga",
  "algodon",
  "aliado",
  "aliento",
  "alivio",
  "alma",
  "almeja",
  "almibar",
  "altar",
  "alteza",
  "altivo",
  "alto",
  "altura",
  "alumno",
  "alzar",
  "amable",
  "amante",
  "amapola",
  "amargo",
  "amasar",
  "ambar",
  "ambito",
  "ameno",
  "amigo",
  "amistad",
  "amor",
  "amparo",
  "amplio",
  "ancho",
  "anciano",
  "ancla",
  "andar",
  "anden",
  "anemia",
  "angulo",
  "anillo",
  "animo",
  "anis",
  "anotar",
  "antena",
  "antiguo",
  "antojo",
  "anual",
  "anular",
  "anuncio",
  "anadir",
  "anejo",
  "ano",
  "apagar",
  "aparato",
  "apetito",
  "apio",
  "aplicar",
  "apodo",
  "aporte",
  "apoyo",
  "aprender",
  "aprobar",
  "apuesta",
  "apuro",
  "arado",
  "arana",
  "arar",
  "arbitro",
  "arbol",
  "arbusto",
  "archivo",
  "arco",
  "arder",
  "ardilla",
  "arduo",
  "area",
  "arido",
  "aries",
  "armonia",
  "arnes",
  "aroma",
  "arpa",
  "arpon",
  "arreglo",
  "arroz",
  "arruga",
  "arte",
  "artista",
  "asa",
  "asado",
  "asalto",
  "ascenso",
  "asegurar",
  "aseo",
  "asesor",
  "asiento",
  "asilo",
  "asistir",
  "asno",
  "asombro",
  "aspero",
  "astilla",
  "astro",
  "astuto",
  "asumir",
  "asunto",
  "atajo",
  "ataque",
  "atar",
  "atento",
  "ateo",
  "atico",
  "atleta",
  "atomo",
  "atraer",
  "atroz",
  "atun",
  "audaz",
  "audio",
  "auge",
  "aula",
  "aumento",
  "ausente",
  "autor",
  "aval",
  "avance",
  "avaro",
  "ave",
  "avellana",
  "avena",
  "avestruz",
  "avion",
  "aviso",
  "ayer",
  "ayuda",
  "ayuno",
  "azafran",
  "azar",
  "azote",
  "azucar",
  "azufre",
  "azul",
  "baba",
  "babor",
  "bache",
  "bahia",
  "baile",
  "bajar",
  "balanza",
  "balcon",
  "balde",
  "bambu",
  "banco",
  "banda",
  "bano",
  "barba",
  "barco",
  "barniz",
  "barro",
  "bascula",
  "baston",
  "basura",
  "batalla",
  "bateria",
  "batir",
  "batuta",
  "baul",
  "bazar",
  "bebe",
  "bebida",
  "bello",
  "besar",
  "beso",
  "bestia",
  "bicho",
  "bien",
  "bingo",
  "blanco",
  "bloque",
  "blusa",
  "boa",
  "bobina",
  "bobo",
  "boca",
  "bocina",
  "boda",
  "bodega",
  "boina",
  "bola",
  "bolero",
  "bolsa",
  "bomba",
  "bondad",
  "bonito",
  "bono",
  "bonsai",
  "borde",
  "borrar",
  "bosque",
  "bote",
  "botin",
  "boveda",
  "bozal",
  "bravo",
  "brazo",
  "brecha",
  "breve",
  "brillo",
  "brinco",
  "brisa",
  "broca",
  "broma",
  "bronce",
  "brote",
  "bruja",
  "brusco",
  "bruto",
  "buceo",
  "bucle",
  "bueno",
  "buey",
  "bufanda",
  "bufon",
  "buho",
  "buitre",
  "bulto",
  "burbuja",
  "burla",
  "burro",
  "buscar",
  "butaca",
  "buzon",
  "caballo",
  "cabeza",
  "cabina",
  "cabra",
  "cacao",
  "cadaver",
  "cadena",
  "caer",
  "cafe",
  "caida",
  "caiman",
  "caja",
  "cajon",
  "cal",
  "calamar",
  "calcio",
  "caldo",
  "calidad",
  "calle",
  "calma",
  "calor",
  "calvo",
  "cama",
  "cambio",
  "camello",
  "camino",
  "campo",
  "cancer",
  "candil",
  "canela",
  "canguro",
  "canica",
  "canto",
  "cana",
  "canon",
  "caoba",
  "caos",
  "capaz",
  "capitan",
  "capote",
  "captar",
  "capucha",
  "cara",
  "carbon",
  "carcel",
  "careta",
  "carga",
  "carino",
  "carne",
  "carpeta",
  "carro",
  "carta",
  "casa",
  "casco",
  "casero",
  "caspa",
  "castor",
  "catorce",
  "catre",
  "caudal",
  "causa",
  "cazo",
  "cebolla",
  "ceder",
  "cedro",
  "celda",
  "celebre",
  "celoso",
  "celula",
  "cemento",
  "ceniza",
  "centro",
  "cerca",
  "cerdo",
  "cereza",
  "cero",
  "cerrar",
  "certeza",
  "cesped",
  "cetro",
  "chacal",
  "chaleco",
  "champu",
  "chancla",
  "chapa",
  "charla",
  "chico",
  "chiste",
  "chivo",
  "choque",
  "choza",
  "chuleta",
  "chupar",
  "ciclon",
  "ciego",
  "cielo",
  "cien",
  "cierto",
  "cifra",
  "cigarro",
  "cima",
  "cinco",
  "cine",
  "cinta",
  "cipres",
  "circo",
  "ciruela",
  "cisne",
  "cita",
  "ciudad",
  "clamor",
  "clan",
  "claro",
  "clase",
  "clave",
  "cliente",
  "clima",
  "clinica",
  "cobre",
  "coccion",
  "cochino",
  "cocina",
  "coco",
  "codigo",
  "codo",
  "cofre",
  "coger",
  "cohete",
  "cojin",
  "cojo",
  "cola",
  "colcha",
  "colegio",
  "colgar",
  "colina",
  "collar",
  "colmo",
  "columna",
  "combate",
  "comer",
  "comida",
  "comodo",
  "compra",
  "conde",
  "conejo",
  "conga",
  "conocer",
  "consejo",
  "contar",
  "copa",
  "copia",
  "corazon",
  "corbata",
  "corcho",
  "cordon",
  "corona",
  "correr",
  "coser",
  "cosmos",
  "costa",
  "craneo",
  "crater",
  "crear",
  "crecer",
  "creido",
  "crema",
  "cria",
  "crimen",
  "cripta",
  "crisis",
  "cromo",
  "cronica",
  "croqueta",
  "crudo",
  "cruz",
  "cuadro",
  "cuarto",
  "cuatro",
  "cubo",
  "cubrir",
  "cuchara",
  "cuello",
  "cuento",
  "cuerda",
  "cuesta",
  "cueva",
  "cuidar",
  "culebra",
  "culpa",
  "culto",
  "cumbre",
  "cumplir",
  "cuna",
  "cuneta",
  "cuota",
  "cupon",
  "cupula",
  "curar",
  "curioso",
  "curso",
  "curva",
  "cutis",
  "dama",
  "danza",
  "dar",
  "dardo",
  "datil",
  "deber",
  "debil",
  "decada",
  "decir",
  "dedo",
  "defensa",
  "definir",
  "dejar",
  "delfin",
  "delgado",
  "delito",
  "demora",
  "denso",
  "dental",
  "deporte",
  "derecho",
  "derrota",
  "desayuno",
  "deseo",
  "desfile",
  "desnudo",
  "destino",
  "desvio",
  "detalle",
  "detener",
  "deuda",
  "dia",
  "diablo",
  "diadema",
  "diamante",
  "diana",
  "diario",
  "dibujo",
  "dictar",
  "diente",
  "dieta",
  "diez",
  "dificil",
  "digno",
  "dilema",
  "diluir",
  "dinero",
  "directo",
  "dirigir",
  "disco",
  "diseno",
  "disfraz",
  "diva",
  "divino",
  "doble",
  "doce",
  "dolor",
  "domingo",
  "don",
  "donar",
  "dorado",
  "dormir",
  "dorso",
  "dos",
  "dosis",
  "dragon",
  "droga",
  "ducha",
  "duda",
  "duelo",
  "dueno",
  "dulce",
  "duo",
  "duque",
  "durar",
  "dureza",
  "duro",
  "ebano",
  "ebrio",
  "echar",
  "eco",
  "ecuador",
  "edad",
  "edicion",
  "edificio",
  "editor",
  "educar",
  "efecto",
  "eficaz",
  "eje",
  "ejemplo",
  "elefante",
  "elegir",
  "elemento",
  "elevar",
  "elipse",
  "elite",
  "elixir",
  "elogio",
  "eludir",
  "embudo",
  "emitir",
  "emocion",
  "empate",
  "empeno",
  "empleo",
  "empresa",
  "enano",
  "encargo",
  "enchufe",
  "encia",
  "enemigo",
  "enero",
  "enfado",
  "enfermo",
  "engano",
  "enigma",
  "enlace",
  "enorme",
  "enredo",
  "ensayo",
  "ensenar",
  "entero",
  "entrar",
  "envase",
  "envio",
  "epoca",
  "equipo",
  "erizo",
  "escala",
  "escena",
  "escolar",
  "escribir",
  "escudo",
  "esencia",
  "esfera",
  "esfuerzo",
  "espada",
  "espejo",
  "espia",
  "esposa",
  "espuma",
  "esqui",
  "estar",
  "este",
  "estilo",
  "estufa",
  "etapa",
  "eterno",
  "etica",
  "etnia",
  "evadir",
  "evaluar",
  "evento",
  "evitar",
  "exacto",
  "examen",
  "exceso",
  "excusa",
  "exento",
  "exigir",
  "exilio",
  "existir",
  "exito",
  "experto",
  "explicar",
  "exponer",
  "extremo",
  "fabrica",
  "fabula",
  "fachada",
  "facil",
  "factor",
  "faena",
  "faja",
  "falda",
  "fallo",
  "falso",
  "faltar",
  "fama",
  "familia",
  "famoso",
  "faraon",
  "farmacia",
  "farol",
  "farsa",
  "fase",
  "fatiga",
  "fauna",
  "favor",
  "fax",
  "febrero",
  "fecha",
  "feliz",
  "feo",
  "feria",
  "feroz",
  "fertil",
  "fervor",
  "festin",
  "fiable",
  "fianza",
  "fiar",
  "fibra",
  "ficcion",
  "ficha",
  "fideo",
  "fiebre",
  "fiel",
  "fiera",
  "fiesta",
  "figura",
  "fijar",
  "fijo",
  "fila",
  "filete",
  "filial",
  "filtro",
  "fin",
  "finca",
  "fingir",
  "finito",
  "firma",
  "flaco",
  "flauta",
  "flecha",
  "flor",
  "flota",
  "fluir",
  "flujo",
  "fluor",
  "fobia",
  "foca",
  "fogata",
  "fogon",
  "folio",
  "folleto",
  "fondo",
  "forma",
  "forro",
  "fortuna",
  "forzar",
  "fosa",
  "foto",
  "fracaso",
  "fragil",
  "franja",
  "frase",
  "fraude",
  "freir",
  "freno",
  "fresa",
  "frio",
  "frito",
  "fruta",
  "fuego",
  "fuente",
  "fuerza",
  "fuga",
  "fumar",
  "funcion",
  "funda",
  "furgon",
  "furia",
  "fusil",
  "futbol",
  "futuro",
  "gacela",
  "gafas",
  "gaita",
  "gajo",
  "gala",
  "galeria",
  "gallo",
  "gamba",
  "ganar",
  "gancho",
  "ganga",
  "ganso",
  "garaje",
  "garza",
  "gasolina",
  "gastar",
  "gato",
  "gavilan",
  "gemelo",
  "gemir",
  "gen",
  "genero",
  "genio",
  "gente",
  "geranio",
  "gerente",
  "germen",
  "gesto",
  "gigante",
  "gimnasio",
  "girar",
  "giro",
  "glaciar",
  "globo",
  "gloria",
  "gol",
  "golfo",
  "goloso",
  "golpe",
  "goma",
  "gordo",
  "gorila",
  "gorra",
  "gota",
  "goteo",
  "gozar",
  "grada",
  "grafico",
  "grano",
  "grasa",
  "gratis",
  "grave",
  "grieta",
  "grillo",
  "gripe",
  "gris",
  "grito",
  "grosor",
  "grua",
  "grueso",
  "grumo",
  "grupo",
  "guante",
  "guapo",
  "guardia",
  "guerra",
  "guia",
  "guino",
  "guion",
  "guiso",
  "guitarra",
  "gusano",
  "gustar",
  "haber",
  "habil",
  "hablar",
  "hacer",
  "hacha",
  "hada",
  "hallar",
  "hamaca",
  "harina",
  "haz",
  "hazana",
  "hebilla",
  "hebra",
  "hecho",
  "helado",
  "helio",
  "hembra",
  "herir",
  "hermano",
  "heroe",
  "hervir",
  "hielo",
  "hierro",
  "higado",
  "higiene",
  "hijo",
  "himno",
  "historia",
  "hocico",
  "hogar",
  "hoguera",
  "hoja",
  "hombre",
  "hongo",
  "honor",
  "honra",
  "hora",
  "hormiga",
  "horno",
  "hostil",
  "hoyo",
  "hueco",
  "huelga",
  "huerta",
  "hueso",
  "huevo",
  "huida",
  "huir",
  "humano",
  "humedo",
  "humilde",
  "humo",
  "hundir",
  "huracan",
  "hurto",
  "icono",
  "ideal",
  "idioma",
  "idolo",
  "iglesia",
  "iglu",
  "igual",
  "ilegal",
  "ilusion",
  "imagen",
  "iman",
  "imitar",
  "impar",
  "imperio",
  "imponer",
  "impulso",
  "incapaz",
  "indice",
  "inerte",
  "infiel",
  "informe",
  "ingenio",
  "inicio",
  "inmenso",
  "inmune",
  "innato",
  "insecto",
  "instante",
  "interes",
  "intimo",
  "intuir",
  "inutil",
  "invierno",
  "ira",
  "iris",
  "ironia",
  "isla",
  "islote",
  "jabali",
  "jabon",
  "jamon",
  "jarabe",
  "jardin",
  "jarra",
  "jaula",
  "jazmin",
  "jefe",
  "jeringa",
  "jinete",
  "jornada",
  "joroba",
  "joven",
  "joya",
  "juerga",
  "jueves",
  "juez",
  "jugador",
  "jugo",
  "juguete",
  "juicio",
  "junco",
  "jungla",
  "junio",
  "juntar",
  "jupiter",
  "jurar",
  "justo",
  "juvenil",
  "juzgar",
  "kilo",
  "koala",
  "labio",
  "lacio",
  "lacra",
  "lado",
  "ladron",
  "lagarto",
  "lagrima",
  "laguna",
  "laico",
  "lamer",
  "lamina",
  "lampara",
  "lana",
  "lancha",
  "langosta",
  "lanza",
  "lapiz",
  "largo",
  "larva",
  "lastima",
  "lata",
  "latex",
  "latir",
  "laurel",
  "lavar",
  "lazo",
  "leal",
  "leccion",
  "leche",
  "lector",
  "leer",
  "legion",
  "legumbre",
  "lejano",
  "lengua",
  "lento",
  "lena",
  "leon",
  "leopardo",
  "lesion",
  "letal",
  "letra",
  "leve",
  "leyenda",
  "libertad",
  "libro",
  "licor",
  "lider",
  "lidiar",
  "lienzo",
  "liga",
  "ligero",
  "lima",
  "limite",
  "limon",
  "limpio",
  "lince",
  "lindo",
  "linea",
  "lingote",
  "lino",
  "linterna",
  "liquido",
  "liso",
  "lista",
  "litera",
  "litio",
  "litro",
  "llaga",
  "llama",
  "llanto",
  "llave",
  "llegar",
  "llenar",
  "llevar",
  "llorar",
  "llover",
  "lluvia",
  "lobo",
  "locion",
  "loco",
  "locura",
  "logica",
  "logro",
  "lombriz",
  "lomo",
  "lonja",
  "lote",
  "lucha",
  "lucir",
  "lugar",
  "lujo",
  "luna",
  "lunes",
  "lupa",
  "lustro",
  "luto",
  "luz",
  "maceta",
  "macho",
  "madera",
  "madre",
  "maduro",
  "maestro",
  "mafia",
  "magia",
  "mago",
  "maiz",
  "maldad",
  "maleta",
  "malla",
  "malo",
  "mama",
  "mambo",
  "mamut",
  "manco",
  "mando",
  "manejar",
  "manga",
  "maniqui",
  "manjar",
  "mano",
  "manso",
  "manta",
  "manana",
  "mapa",
  "maquina",
  "mar",
  "marco",
  "marea",
  "marfil",
  "margen",
  "marido",
  "marmol",
  "marron",
  "martes",
  "marzo",
  "masa",
  "mascara",
  "masivo",
  "matar",
  "materia",
  "matiz",
  "matriz",
  "maximo",
  "mayor",
  "mazorca",
  "mecha",
  "medalla",
  "medio",
  "medula",
  "mejilla",
  "mejor",
  "melena",
  "melon",
  "memoria",
  "menor",
  "mensaje",
  "mente",
  "menu",
  "mercado",
  "merengue",
  "merito",
  "mes",
  "meson",
  "meta",
  "meter",
  "metodo",
  "metro",
  "mezcla",
  "miedo",
  "miel",
  "miembro",
  "miga",
  "mil",
  "milagro",
  "militar",
  "millon",
  "mimo",
  "mina",
  "minero",
  "minimo",
  "minuto",
  "miope",
  "mirar",
  "misa",
  "miseria",
  "misil",
  "mismo",
  "mitad",
  "mito",
  "mochila",
  "mocion",
  "moda",
  "modelo",
  "moho",
  "mojar",
  "molde",
  "moler",
  "molino",
  "momento",
  "momia",
  "monarca",
  "moneda",
  "monja",
  "monto",
  "mono",
  "morada",
  "morder",
  "moreno",
  "morir",
  "morro",
  "morsa",
  "mortal",
  "mosca",
  "mostrar",
  "motivo",
  "mover",
  "movil",
  "mozo",
  "mucho",
  "mudar",
  "mueble",
  "muela",
  "muerte",
  "muestra",
  "mugre",
  "mujer",
  "mula",
  "muleta",
  "multa",
  "mundo",
  "muneca",
  "mural",
  "muro",
  "musculo",
  "museo",
  "musgo",
  "musica",
  "muslo",
  "nacar",
  "nacion",
  "nadar",
  "naipe",
  "naranja",
  "nariz",
  "narrar",
  "nasal",
  "natal",
  "nativo",
  "natural",
  "nausea",
  "naval",
  "nave",
  "navidad",
  "necio",
  "nectar",
  "negar",
  "negocio",
  "negro",
  "neon",
  "nervio",
  "neto",
  "neutro",
  "nevar",
  "nevera",
  "nicho",
  "nido",
  "niebla",
  "nieto",
  "ninez",
  "nino",
  "nitido",
  "nivel",
  "nobleza",
  "noche",
  "nomina",
  "noria",
  "norma",
  "norte",
  "nota",
  "noticia",
  "novato",
  "novela",
  "novio",
  "nube",
  "nuca",
  "nucleo",
  "nudillo",
  "nudo",
  "nuera",
  "nueve",
  "nuez",
  "nulo",
  "numero",
  "nutria",
  "oasis",
  "obeso",
  "obispo",
  "objeto",
  "obra",
  "obrero",
  "observar",
  "obtener",
  "obvio",
  "oca",
  "ocaso",
  "oceano",
  "ochenta",
  "ocho",
  "ocio",
  "ocre",
  "octavo",
  "octubre",
  "oculto",
  "ocupar",
  "ocurrir",
  "odiar",
  "odio",
  "odisea",
  "oeste",
  "ofensa",
  "oferta",
  "oficio",
  "ofrecer",
  "ogro",
  "oido",
  "oir",
  "ojo",
  "ola",
  "oleada",
  "olfato",
  "olivo",
  "olla",
  "olmo",
  "olor",
  "olvido",
  "ombligo",
  "onda",
  "onza",
  "opaco",
  "opcion",
  "opera",
  "opinar",
  "oponer",
  "optar",
  "optica",
  "opuesto",
  "oracion",
  "orador",
  "oral",
  "orbita",
  "orca",
  "orden",
  "oreja",
  "organo",
  "orgia",
  "orgullo",
  "oriente",
  "origen",
  "orilla",
  "oro",
  "orquesta",
  "oruga",
  "osadia",
  "oscuro",
  "osezno",
  "oso",
  "ostra",
  "otono",
  "otro",
  "oveja",
  "ovulo",
  "oxido",
  "oxigeno",
  "oyente",
  "ozono",
  "pacto",
  "padre",
  "paella",
  "pagina",
  "pago",
  "pais",
  "pajaro",
  "palabra",
  "palco",
  "paleta",
  "palido",
  "palma",
  "paloma",
  "palpar",
  "pan",
  "panal",
  "panico",
  "pantera",
  "panuelo",
  "papa",
  "papel",
  "papilla",
  "paquete",
  "parar",
  "parcela",
  "pared",
  "parir",
  "paro",
  "parpado",
  "parque",
  "parrafo",
  "parte",
  "pasar",
  "paseo",
  "pasion",
  "paso",
  "pasta",
  "pata",
  "patio",
  "patria",
  "pausa",
  "pauta",
  "pavo",
  "payaso",
  "peaton",
  "pecado",
  "pecera",
  "pecho",
  "pedal",
  "pedir",
  "pegar",
  "peine",
  "pelar",
  "peldano",
  "pelea",
  "peligro",
  "pellejo",
  "pelo",
  "peluca",
  "pena",
  "pensar",
  "penon",
  "peon",
  "peor",
  "pepino",
  "pequeno",
  "pera",
  "percha",
  "perder",
  "pereza",
  "perfil",
  "perico",
  "perla",
  "permiso",
  "perro",
  "persona",
  "pesa",
  "pesca",
  "pesimo",
  "pestana",
  "petalo",
  "petroleo",
  "pez",
  "pezuna",
  "picar",
  "pichon",
  "pie",
  "piedra",
  "pierna",
  "pieza",
  "pijama",
  "pilar",
  "piloto",
  "pimienta",
  "pino",
  "pintor",
  "pinza",
  "pina",
  "piojo",
  "pipa",
  "pirata",
  "pisar",
  "piscina",
  "piso",
  "pista",
  "piton",
  "pizca",
  "placa",
  "plan",
  "plata",
  "playa",
  "plaza",
  "pleito",
  "pleno",
  "plomo",
  "pluma",
  "plural",
  "pobre",
  "poco",
  "poder",
  "podio",
  "poema",
  "poesia",
  "poeta",
  "polen",
  "policia",
  "pollo",
  "polvo",
  "pomada",
  "pomelo",
  "pomo",
  "pompa",
  "poner",
  "porcion",
  "portal",
  "posada",
  "poseer",
  "posible",
  "poste",
  "potencia",
  "potro",
  "pozo",
  "prado",
  "precoz",
  "pregunta",
  "premio",
  "prensa",
  "preso",
  "previo",
  "primo",
  "principe",
  "prision",
  "privar",
  "proa",
  "probar",
  "proceso",
  "producto",
  "proeza",
  "profesor",
  "programa",
  "prole",
  "promesa",
  "pronto",
  "propio",
  "proximo",
  "prueba",
  "publico",
  "puchero",
  "pudor",
  "pueblo",
  "puerta",
  "puesto",
  "pulga",
  "pulir",
  "pulmon",
  "pulpo",
  "pulso",
  "puma",
  "punto",
  "punal",
  "puno",
  "pupa",
  "pupila",
  "pure",
  "quedar",
  "queja",
  "quemar",
  "querer",
  "queso",
  "quieto",
  "quimica",
  "quince",
  "quitar",
  "rabano",
  "rabia",
  "rabo",
  "racion",
  "radical",
  "raiz",
  "rama",
  "rampa",
  "rancho",
  "rango",
  "rapaz",
  "rapido",
  "rapto",
  "rasgo",
  "raspa",
  "rato",
  "rayo",
  "raza",
  "razon",
  "reaccion",
  "realidad",
  "rebano",
  "rebote",
  "recaer",
  "receta",
  "rechazo",
  "recoger",
  "recreo",
  "recto",
  "recurso",
  "red",
  "redondo",
  "reducir",
  "reflejo",
  "reforma",
  "refran",
  "refugio",
  "regalo",
  "regir",
  "regla",
  "regreso",
  "rehen",
  "reino",
  "reir",
  "reja",
  "relato",
  "relevo",
  "relieve",
  "relleno",
  "reloj",
  "remar",
  "remedio",
  "remo",
  "rencor",
  "rendir",
  "renta",
  "reparto",
  "repetir",
  "reposo",
  "reptil",
  "res",
  "rescate",
  "resina",
  "respeto",
  "resto",
  "resumen",
  "retiro",
  "retorno",
  "retrato",
  "reunir",
  "reves",
  "revista",
  "rey",
  "rezar",
  "rico",
  "riego",
  "rienda",
  "riesgo",
  "rifa",
  "rigido",
  "rigor",
  "rincon",
  "rinon",
  "rio",
  "riqueza",
  "risa",
  "ritmo",
  "rito",
  "rizo",
  "roble",
  "roce",
  "rociar",
  "rodar",
  "rodeo",
  "rodilla",
  "roer",
  "rojizo",
  "rojo",
  "romero",
  "romper",
  "ron",
  "ronco",
  "ronda",
  "ropa",
  "ropero",
  "rosa",
  "rosca",
  "rostro",
  "rotar",
  "rubi",
  "rubor",
  "rudo",
  "rueda",
  "rugir",
  "ruido",
  "ruina",
  "ruleta",
  "rulo",
  "rumbo",
  "rumor",
  "ruptura",
  "ruta",
  "rutina",
  "sabado",
  "saber",
  "sabio",
  "sable",
  "sacar",
  "sagaz",
  "sagrado",
  "sala",
  "saldo",
  "salero",
  "salir",
  "salmon",
  "salon",
  "salsa",
  "salto",
  "salud",
  "salvar",
  "samba",
  "sancion",
  "sandia",
  "sanear",
  "sangre",
  "sanidad",
  "sano",
  "santo",
  "sapo",
  "saque",
  "sardina",
  "sarten",
  "sastre",
  "satan",
  "sauna",
  "saxofon",
  "seccion",
  "seco",
  "secreto",
  "secta",
  "sed",
  "seguir",
  "seis",
  "sello",
  "selva",
  "semana",
  "semilla",
  "senda",
  "sensor",
  "senal",
  "senor",
  "separar",
  "sepia",
  "sequia",
  "ser",
  "serie",
  "sermon",
  "servir",
  "sesenta",
  "sesion",
  "seta",
  "setenta",
  "severo",
  "sexo",
  "sexto",
  "sidra",
  "siesta",
  "siete",
  "siglo",
  "signo",
  "silaba",
  "silbar",
  "silencio",
  "silla",
  "simbolo",
  "simio",
  "sirena",
  "sistema",
  "sitio",
  "situar",
  "sobre",
  "socio",
  "sodio",
  "sol",
  "solapa",
  "soldado",
  "soledad",
  "solido",
  "soltar",
  "solucion",
  "sombra",
  "sondeo",
  "sonido",
  "sonoro",
  "sonrisa",
  "sopa",
  "soplar",
  "soporte",
  "sordo",
  "sorpresa",
  "sorteo",
  "sosten",
  "sotano",
  "suave",
  "subir",
  "suceso",
  "sudor",
  "suegra",
  "suelo",
  "sueno",
  "suerte",
  "sufrir",
  "sujeto",
  "sultan",
  "sumar",
  "superar",
  "suplir",
  "suponer",
  "supremo",
  "sur",
  "surco",
  "sureno",
  "surgir",
  "susto",
  "sutil",
  "tabaco",
  "tabique",
  "tabla",
  "tabu",
  "taco",
  "tacto",
  "tajo",
  "talar",
  "talco",
  "talento",
  "talla",
  "talon",
  "tamano",
  "tambor",
  "tango",
  "tanque",
  "tapa",
  "tapete",
  "tapia",
  "tapon",
  "taquilla",
  "tarde",
  "tarea",
  "tarifa",
  "tarjeta",
  "tarot",
  "tarro",
  "tarta",
  "tatuaje",
  "tauro",
  "taza",
  "tazon",
  "teatro",
  "techo",
  "tecla",
  "tecnica",
  "tejado",
  "tejer",
  "tejido",
  "tela",
  "telefono",
  "tema",
  "temor",
  "templo",
  "tenaz",
  "tender",
  "tener",
  "tenis",
  "tenso",
  "teoria",
  "terapia",
  "terco",
  "termino",
  "ternura",
  "terror",
  "tesis",
  "tesoro",
  "testigo",
  "tetera",
  "texto",
  "tez",
  "tibio",
  "tiburon",
  "tiempo",
  "tienda",
  "tierra",
  "tieso",
  "tigre",
  "tijera",
  "tilde",
  "timbre",
  "timido",
  "timo",
  "tinta",
  "tio",
  "tipico",
  "tipo",
  "tira",
  "tiron",
  "titan",
  "titere",
  "titulo",
  "tiza",
  "toalla",
  "tobillo",
  "tocar",
  "tocino",
  "todo",
  "toga",
  "toldo",
  "tomar",
  "tono",
  "tonto",
  "topar",
  "tope",
  "toque",
  "torax",
  "torero",
  "tormenta",
  "torneo",
  "toro",
  "torpedo",
  "torre",
  "torso",
  "tortuga",
  "tos",
  "tosco",
  "toser",
  "toxico",
  "trabajo",
  "tractor",
  "traer",
  "trafico",
  "trago",
  "traje",
  "tramo",
  "trance",
  "trato",
  "trauma",
  "trazar",
  "trebol",
  "tregua",
  "treinta",
  "tren",
  "trepar",
  "tres",
  "tribu",
  "trigo",
  "tripa",
  "triste",
  "triunfo",
  "trofeo",
  "trompa",
  "tronco",
  "tropa",
  "trote",
  "trozo",
  "truco",
  "trueno",
  "trufa",
  "tuberia",
  "tubo",
  "tuerto",
  "tumba",
  "tumor",
  "tunel",
  "tunica",
  "turbina",
  "turismo",
  "turno",
  "tutor",
  "ubicar",
  "ulcera",
  "umbral",
  "unidad",
  "unir",
  "universo",
  "uno",
  "untar",
  "una",
  "urbano",
  "urbe",
  "urgente",
  "urna",
  "usar",
  "usuario",
  "util",
  "utopia",
  "uva",
  "vaca",
  "vacio",
  "vacuna",
  "vagar",
  "vago",
  "vaina",
  "vajilla",
  "vale",
  "valido",
  "valle",
  "valor",
  "valvula",
  "vampiro",
  "vara",
  "variar",
  "varon",
  "vaso",
  "vecino",
  "vector",
  "vehiculo",
  "veinte",
  "vejez",
  "vela",
  "velero",
  "veloz",
  "vena",
  "vencer",
  "venda",
  "veneno",
  "vengar",
  "venir",
  "venta",
  "venus",
  "ver",
  "verano",
  "verbo",
  "verde",
  "vereda",
  "verja",
  "verso",
  "verter",
  "via",
  "viaje",
  "vibrar",
  "vicio",
  "victima",
  "vida",
  "video",
  "vidrio",
  "viejo",
  "viernes",
  "vigor",
  "vil",
  "villa",
  "vinagre",
  "vino",
  "vinedo",
  "violin",
  "viral",
  "virgo",
  "virtud",
  "visor",
  "vispera",
  "vista",
  "vitamina",
  "viudo",
  "vivaz",
  "vivero",
  "vivir",
  "vivo",
  "volcan",
  "volumen",
  "volver",
  "voraz",
  "votar",
  "voto",
  "voz",
  "vuelo",
  "vulgar",
  "yacer",
  "yate",
  "yegua",
  "yema",
  "yerno",
  "yeso",
  "yodo",
  "yoga",
  "yogur",
  "zafiro",
  "zanja",
  "zapato",
  "zarza",
  "zona",
  "zorro",
  "zumo",
  "zurdo"
], QJ = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], eQ = [
  "abacate",
  "abaixo",
  "abalar",
  "abater",
  "abduzir",
  "abelha",
  "aberto",
  "abismo",
  "abotoar",
  "abranger",
  "abreviar",
  "abrigar",
  "abrupto",
  "absinto",
  "absoluto",
  "absurdo",
  "abutre",
  "acabado",
  "acalmar",
  "acampar",
  "acanhar",
  "acaso",
  "aceitar",
  "acelerar",
  "acenar",
  "acervo",
  "acessar",
  "acetona",
  "achatar",
  "acidez",
  "acima",
  "acionado",
  "acirrar",
  "aclamar",
  "aclive",
  "acolhida",
  "acomodar",
  "acoplar",
  "acordar",
  "acumular",
  "acusador",
  "adaptar",
  "adega",
  "adentro",
  "adepto",
  "adequar",
  "aderente",
  "adesivo",
  "adeus",
  "adiante",
  "aditivo",
  "adjetivo",
  "adjunto",
  "admirar",
  "adorar",
  "adquirir",
  "adubo",
  "adverso",
  "advogado",
  "aeronave",
  "afastar",
  "aferir",
  "afetivo",
  "afinador",
  "afivelar",
  "aflito",
  "afluente",
  "afrontar",
  "agachar",
  "agarrar",
  "agasalho",
  "agenciar",
  "agilizar",
  "agiota",
  "agitado",
  "agora",
  "agradar",
  "agreste",
  "agrupar",
  "aguardar",
  "agulha",
  "ajoelhar",
  "ajudar",
  "ajustar",
  "alameda",
  "alarme",
  "alastrar",
  "alavanca",
  "albergue",
  "albino",
  "alcatra",
  "aldeia",
  "alecrim",
  "alegria",
  "alertar",
  "alface",
  "alfinete",
  "algum",
  "alheio",
  "aliar",
  "alicate",
  "alienar",
  "alinhar",
  "aliviar",
  "almofada",
  "alocar",
  "alpiste",
  "alterar",
  "altitude",
  "alucinar",
  "alugar",
  "aluno",
  "alusivo",
  "alvo",
  "amaciar",
  "amador",
  "amarelo",
  "amassar",
  "ambas",
  "ambiente",
  "ameixa",
  "amenizar",
  "amido",
  "amistoso",
  "amizade",
  "amolador",
  "amontoar",
  "amoroso",
  "amostra",
  "amparar",
  "ampliar",
  "ampola",
  "anagrama",
  "analisar",
  "anarquia",
  "anatomia",
  "andaime",
  "anel",
  "anexo",
  "angular",
  "animar",
  "anjo",
  "anomalia",
  "anotado",
  "ansioso",
  "anterior",
  "anuidade",
  "anunciar",
  "anzol",
  "apagador",
  "apalpar",
  "apanhado",
  "apego",
  "apelido",
  "apertada",
  "apesar",
  "apetite",
  "apito",
  "aplauso",
  "aplicada",
  "apoio",
  "apontar",
  "aposta",
  "aprendiz",
  "aprovar",
  "aquecer",
  "arame",
  "aranha",
  "arara",
  "arcada",
  "ardente",
  "areia",
  "arejar",
  "arenito",
  "aresta",
  "argiloso",
  "argola",
  "arma",
  "arquivo",
  "arraial",
  "arrebate",
  "arriscar",
  "arroba",
  "arrumar",
  "arsenal",
  "arterial",
  "artigo",
  "arvoredo",
  "asfaltar",
  "asilado",
  "aspirar",
  "assador",
  "assinar",
  "assoalho",
  "assunto",
  "astral",
  "atacado",
  "atadura",
  "atalho",
  "atarefar",
  "atear",
  "atender",
  "aterro",
  "ateu",
  "atingir",
  "atirador",
  "ativo",
  "atoleiro",
  "atracar",
  "atrevido",
  "atriz",
  "atual",
  "atum",
  "auditor",
  "aumentar",
  "aura",
  "aurora",
  "autismo",
  "autoria",
  "autuar",
  "avaliar",
  "avante",
  "avaria",
  "avental",
  "avesso",
  "aviador",
  "avisar",
  "avulso",
  "axila",
  "azarar",
  "azedo",
  "azeite",
  "azulejo",
  "babar",
  "babosa",
  "bacalhau",
  "bacharel",
  "bacia",
  "bagagem",
  "baiano",
  "bailar",
  "baioneta",
  "bairro",
  "baixista",
  "bajular",
  "baleia",
  "baliza",
  "balsa",
  "banal",
  "bandeira",
  "banho",
  "banir",
  "banquete",
  "barato",
  "barbado",
  "baronesa",
  "barraca",
  "barulho",
  "baseado",
  "bastante",
  "batata",
  "batedor",
  "batida",
  "batom",
  "batucar",
  "baunilha",
  "beber",
  "beijo",
  "beirada",
  "beisebol",
  "beldade",
  "beleza",
  "belga",
  "beliscar",
  "bendito",
  "bengala",
  "benzer",
  "berimbau",
  "berlinda",
  "berro",
  "besouro",
  "bexiga",
  "bezerro",
  "bico",
  "bicudo",
  "bienal",
  "bifocal",
  "bifurcar",
  "bigorna",
  "bilhete",
  "bimestre",
  "bimotor",
  "biologia",
  "biombo",
  "biosfera",
  "bipolar",
  "birrento",
  "biscoito",
  "bisneto",
  "bispo",
  "bissexto",
  "bitola",
  "bizarro",
  "blindado",
  "bloco",
  "bloquear",
  "boato",
  "bobagem",
  "bocado",
  "bocejo",
  "bochecha",
  "boicotar",
  "bolada",
  "boletim",
  "bolha",
  "bolo",
  "bombeiro",
  "bonde",
  "boneco",
  "bonita",
  "borbulha",
  "borda",
  "boreal",
  "borracha",
  "bovino",
  "boxeador",
  "branco",
  "brasa",
  "braveza",
  "breu",
  "briga",
  "brilho",
  "brincar",
  "broa",
  "brochura",
  "bronzear",
  "broto",
  "bruxo",
  "bucha",
  "budismo",
  "bufar",
  "bule",
  "buraco",
  "busca",
  "busto",
  "buzina",
  "cabana",
  "cabelo",
  "cabide",
  "cabo",
  "cabrito",
  "cacau",
  "cacetada",
  "cachorro",
  "cacique",
  "cadastro",
  "cadeado",
  "cafezal",
  "caiaque",
  "caipira",
  "caixote",
  "cajado",
  "caju",
  "calafrio",
  "calcular",
  "caldeira",
  "calibrar",
  "calmante",
  "calota",
  "camada",
  "cambista",
  "camisa",
  "camomila",
  "campanha",
  "camuflar",
  "canavial",
  "cancelar",
  "caneta",
  "canguru",
  "canhoto",
  "canivete",
  "canoa",
  "cansado",
  "cantar",
  "canudo",
  "capacho",
  "capela",
  "capinar",
  "capotar",
  "capricho",
  "captador",
  "capuz",
  "caracol",
  "carbono",
  "cardeal",
  "careca",
  "carimbar",
  "carneiro",
  "carpete",
  "carreira",
  "cartaz",
  "carvalho",
  "casaco",
  "casca",
  "casebre",
  "castelo",
  "casulo",
  "catarata",
  "cativar",
  "caule",
  "causador",
  "cautelar",
  "cavalo",
  "caverna",
  "cebola",
  "cedilha",
  "cegonha",
  "celebrar",
  "celular",
  "cenoura",
  "censo",
  "centeio",
  "cercar",
  "cerrado",
  "certeiro",
  "cerveja",
  "cetim",
  "cevada",
  "chacota",
  "chaleira",
  "chamado",
  "chapada",
  "charme",
  "chatice",
  "chave",
  "chefe",
  "chegada",
  "cheiro",
  "cheque",
  "chicote",
  "chifre",
  "chinelo",
  "chocalho",
  "chover",
  "chumbo",
  "chutar",
  "chuva",
  "cicatriz",
  "ciclone",
  "cidade",
  "cidreira",
  "ciente",
  "cigana",
  "cimento",
  "cinto",
  "cinza",
  "ciranda",
  "circuito",
  "cirurgia",
  "citar",
  "clareza",
  "clero",
  "clicar",
  "clone",
  "clube",
  "coado",
  "coagir",
  "cobaia",
  "cobertor",
  "cobrar",
  "cocada",
  "coelho",
  "coentro",
  "coeso",
  "cogumelo",
  "coibir",
  "coifa",
  "coiote",
  "colar",
  "coleira",
  "colher",
  "colidir",
  "colmeia",
  "colono",
  "coluna",
  "comando",
  "combinar",
  "comentar",
  "comitiva",
  "comover",
  "complexo",
  "comum",
  "concha",
  "condor",
  "conectar",
  "confuso",
  "congelar",
  "conhecer",
  "conjugar",
  "consumir",
  "contrato",
  "convite",
  "cooperar",
  "copeiro",
  "copiador",
  "copo",
  "coquetel",
  "coragem",
  "cordial",
  "corneta",
  "coronha",
  "corporal",
  "correio",
  "cortejo",
  "coruja",
  "corvo",
  "cosseno",
  "costela",
  "cotonete",
  "couro",
  "couve",
  "covil",
  "cozinha",
  "cratera",
  "cravo",
  "creche",
  "credor",
  "creme",
  "crer",
  "crespo",
  "criada",
  "criminal",
  "crioulo",
  "crise",
  "criticar",
  "crosta",
  "crua",
  "cruzeiro",
  "cubano",
  "cueca",
  "cuidado",
  "cujo",
  "culatra",
  "culminar",
  "culpar",
  "cultura",
  "cumprir",
  "cunhado",
  "cupido",
  "curativo",
  "curral",
  "cursar",
  "curto",
  "cuspir",
  "custear",
  "cutelo",
  "damasco",
  "datar",
  "debater",
  "debitar",
  "deboche",
  "debulhar",
  "decalque",
  "decimal",
  "declive",
  "decote",
  "decretar",
  "dedal",
  "dedicado",
  "deduzir",
  "defesa",
  "defumar",
  "degelo",
  "degrau",
  "degustar",
  "deitado",
  "deixar",
  "delator",
  "delegado",
  "delinear",
  "delonga",
  "demanda",
  "demitir",
  "demolido",
  "dentista",
  "depenado",
  "depilar",
  "depois",
  "depressa",
  "depurar",
  "deriva",
  "derramar",
  "desafio",
  "desbotar",
  "descanso",
  "desenho",
  "desfiado",
  "desgaste",
  "desigual",
  "deslize",
  "desmamar",
  "desova",
  "despesa",
  "destaque",
  "desviar",
  "detalhar",
  "detentor",
  "detonar",
  "detrito",
  "deusa",
  "dever",
  "devido",
  "devotado",
  "dezena",
  "diagrama",
  "dialeto",
  "didata",
  "difuso",
  "digitar",
  "dilatado",
  "diluente",
  "diminuir",
  "dinastia",
  "dinheiro",
  "diocese",
  "direto",
  "discreta",
  "disfarce",
  "disparo",
  "disquete",
  "dissipar",
  "distante",
  "ditador",
  "diurno",
  "diverso",
  "divisor",
  "divulgar",
  "dizer",
  "dobrador",
  "dolorido",
  "domador",
  "dominado",
  "donativo",
  "donzela",
  "dormente",
  "dorsal",
  "dosagem",
  "dourado",
  "doutor",
  "drenagem",
  "drible",
  "drogaria",
  "duelar",
  "duende",
  "dueto",
  "duplo",
  "duquesa",
  "durante",
  "duvidoso",
  "eclodir",
  "ecoar",
  "ecologia",
  "edificar",
  "edital",
  "educado",
  "efeito",
  "efetivar",
  "ejetar",
  "elaborar",
  "eleger",
  "eleitor",
  "elenco",
  "elevador",
  "eliminar",
  "elogiar",
  "embargo",
  "embolado",
  "embrulho",
  "embutido",
  "emenda",
  "emergir",
  "emissor",
  "empatia",
  "empenho",
  "empinado",
  "empolgar",
  "emprego",
  "empurrar",
  "emulador",
  "encaixe",
  "encenado",
  "enchente",
  "encontro",
  "endeusar",
  "endossar",
  "enfaixar",
  "enfeite",
  "enfim",
  "engajado",
  "engenho",
  "englobar",
  "engomado",
  "engraxar",
  "enguia",
  "enjoar",
  "enlatar",
  "enquanto",
  "enraizar",
  "enrolado",
  "enrugar",
  "ensaio",
  "enseada",
  "ensino",
  "ensopado",
  "entanto",
  "enteado",
  "entidade",
  "entortar",
  "entrada",
  "entulho",
  "envergar",
  "enviado",
  "envolver",
  "enxame",
  "enxerto",
  "enxofre",
  "enxuto",
  "epiderme",
  "equipar",
  "ereto",
  "erguido",
  "errata",
  "erva",
  "ervilha",
  "esbanjar",
  "esbelto",
  "escama",
  "escola",
  "escrita",
  "escuta",
  "esfinge",
  "esfolar",
  "esfregar",
  "esfumado",
  "esgrima",
  "esmalte",
  "espanto",
  "espelho",
  "espiga",
  "esponja",
  "espreita",
  "espumar",
  "esquerda",
  "estaca",
  "esteira",
  "esticar",
  "estofado",
  "estrela",
  "estudo",
  "esvaziar",
  "etanol",
  "etiqueta",
  "euforia",
  "europeu",
  "evacuar",
  "evaporar",
  "evasivo",
  "eventual",
  "evidente",
  "evoluir",
  "exagero",
  "exalar",
  "examinar",
  "exato",
  "exausto",
  "excesso",
  "excitar",
  "exclamar",
  "executar",
  "exemplo",
  "exibir",
  "exigente",
  "exonerar",
  "expandir",
  "expelir",
  "expirar",
  "explanar",
  "exposto",
  "expresso",
  "expulsar",
  "externo",
  "extinto",
  "extrato",
  "fabricar",
  "fabuloso",
  "faceta",
  "facial",
  "fada",
  "fadiga",
  "faixa",
  "falar",
  "falta",
  "familiar",
  "fandango",
  "fanfarra",
  "fantoche",
  "fardado",
  "farelo",
  "farinha",
  "farofa",
  "farpa",
  "fartura",
  "fatia",
  "fator",
  "favorita",
  "faxina",
  "fazenda",
  "fechado",
  "feijoada",
  "feirante",
  "felino",
  "feminino",
  "fenda",
  "feno",
  "fera",
  "feriado",
  "ferrugem",
  "ferver",
  "festejar",
  "fetal",
  "feudal",
  "fiapo",
  "fibrose",
  "ficar",
  "ficheiro",
  "figurado",
  "fileira",
  "filho",
  "filme",
  "filtrar",
  "firmeza",
  "fisgada",
  "fissura",
  "fita",
  "fivela",
  "fixador",
  "fixo",
  "flacidez",
  "flamingo",
  "flanela",
  "flechada",
  "flora",
  "flutuar",
  "fluxo",
  "focal",
  "focinho",
  "fofocar",
  "fogo",
  "foguete",
  "foice",
  "folgado",
  "folheto",
  "forjar",
  "formiga",
  "forno",
  "forte",
  "fosco",
  "fossa",
  "fragata",
  "fralda",
  "frango",
  "frasco",
  "fraterno",
  "freira",
  "frente",
  "fretar",
  "frieza",
  "friso",
  "fritura",
  "fronha",
  "frustrar",
  "fruteira",
  "fugir",
  "fulano",
  "fuligem",
  "fundar",
  "fungo",
  "funil",
  "furador",
  "furioso",
  "futebol",
  "gabarito",
  "gabinete",
  "gado",
  "gaiato",
  "gaiola",
  "gaivota",
  "galega",
  "galho",
  "galinha",
  "galocha",
  "ganhar",
  "garagem",
  "garfo",
  "gargalo",
  "garimpo",
  "garoupa",
  "garrafa",
  "gasoduto",
  "gasto",
  "gata",
  "gatilho",
  "gaveta",
  "gazela",
  "gelado",
  "geleia",
  "gelo",
  "gemada",
  "gemer",
  "gemido",
  "generoso",
  "gengiva",
  "genial",
  "genoma",
  "genro",
  "geologia",
  "gerador",
  "germinar",
  "gesso",
  "gestor",
  "ginasta",
  "gincana",
  "gingado",
  "girafa",
  "girino",
  "glacial",
  "glicose",
  "global",
  "glorioso",
  "goela",
  "goiaba",
  "golfe",
  "golpear",
  "gordura",
  "gorjeta",
  "gorro",
  "gostoso",
  "goteira",
  "governar",
  "gracejo",
  "gradual",
  "grafite",
  "gralha",
  "grampo",
  "granada",
  "gratuito",
  "graveto",
  "graxa",
  "grego",
  "grelhar",
  "greve",
  "grilo",
  "grisalho",
  "gritaria",
  "grosso",
  "grotesco",
  "grudado",
  "grunhido",
  "gruta",
  "guache",
  "guarani",
  "guaxinim",
  "guerrear",
  "guiar",
  "guincho",
  "guisado",
  "gula",
  "guloso",
  "guru",
  "habitar",
  "harmonia",
  "haste",
  "haver",
  "hectare",
  "herdar",
  "heresia",
  "hesitar",
  "hiato",
  "hibernar",
  "hidratar",
  "hiena",
  "hino",
  "hipismo",
  "hipnose",
  "hipoteca",
  "hoje",
  "holofote",
  "homem",
  "honesto",
  "honrado",
  "hormonal",
  "hospedar",
  "humorado",
  "iate",
  "ideia",
  "idoso",
  "ignorado",
  "igreja",
  "iguana",
  "ileso",
  "ilha",
  "iludido",
  "iluminar",
  "ilustrar",
  "imagem",
  "imediato",
  "imenso",
  "imersivo",
  "iminente",
  "imitador",
  "imortal",
  "impacto",
  "impedir",
  "implante",
  "impor",
  "imprensa",
  "impune",
  "imunizar",
  "inalador",
  "inapto",
  "inativo",
  "incenso",
  "inchar",
  "incidir",
  "incluir",
  "incolor",
  "indeciso",
  "indireto",
  "indutor",
  "ineficaz",
  "inerente",
  "infantil",
  "infestar",
  "infinito",
  "inflamar",
  "informal",
  "infrator",
  "ingerir",
  "inibido",
  "inicial",
  "inimigo",
  "injetar",
  "inocente",
  "inodoro",
  "inovador",
  "inox",
  "inquieto",
  "inscrito",
  "inseto",
  "insistir",
  "inspetor",
  "instalar",
  "insulto",
  "intacto",
  "integral",
  "intimar",
  "intocado",
  "intriga",
  "invasor",
  "inverno",
  "invicto",
  "invocar",
  "iogurte",
  "iraniano",
  "ironizar",
  "irreal",
  "irritado",
  "isca",
  "isento",
  "isolado",
  "isqueiro",
  "italiano",
  "janeiro",
  "jangada",
  "janta",
  "jararaca",
  "jardim",
  "jarro",
  "jasmim",
  "jato",
  "javali",
  "jazida",
  "jejum",
  "joaninha",
  "joelhada",
  "jogador",
  "joia",
  "jornal",
  "jorrar",
  "jovem",
  "juba",
  "judeu",
  "judoca",
  "juiz",
  "julgador",
  "julho",
  "jurado",
  "jurista",
  "juro",
  "justa",
  "labareda",
  "laboral",
  "lacre",
  "lactante",
  "ladrilho",
  "lagarta",
  "lagoa",
  "laje",
  "lamber",
  "lamentar",
  "laminar",
  "lampejo",
  "lanche",
  "lapidar",
  "lapso",
  "laranja",
  "lareira",
  "largura",
  "lasanha",
  "lastro",
  "lateral",
  "latido",
  "lavanda",
  "lavoura",
  "lavrador",
  "laxante",
  "lazer",
  "lealdade",
  "lebre",
  "legado",
  "legendar",
  "legista",
  "leigo",
  "leiloar",
  "leitura",
  "lembrete",
  "leme",
  "lenhador",
  "lentilha",
  "leoa",
  "lesma",
  "leste",
  "letivo",
  "letreiro",
  "levar",
  "leveza",
  "levitar",
  "liberal",
  "libido",
  "liderar",
  "ligar",
  "ligeiro",
  "limitar",
  "limoeiro",
  "limpador",
  "linda",
  "linear",
  "linhagem",
  "liquidez",
  "listagem",
  "lisura",
  "litoral",
  "livro",
  "lixa",
  "lixeira",
  "locador",
  "locutor",
  "lojista",
  "lombo",
  "lona",
  "longe",
  "lontra",
  "lorde",
  "lotado",
  "loteria",
  "loucura",
  "lousa",
  "louvar",
  "luar",
  "lucidez",
  "lucro",
  "luneta",
  "lustre",
  "lutador",
  "luva",
  "macaco",
  "macete",
  "machado",
  "macio",
  "madeira",
  "madrinha",
  "magnata",
  "magreza",
  "maior",
  "mais",
  "malandro",
  "malha",
  "malote",
  "maluco",
  "mamilo",
  "mamoeiro",
  "mamute",
  "manada",
  "mancha",
  "mandato",
  "manequim",
  "manhoso",
  "manivela",
  "manobrar",
  "mansa",
  "manter",
  "manusear",
  "mapeado",
  "maquinar",
  "marcador",
  "maresia",
  "marfim",
  "margem",
  "marinho",
  "marmita",
  "maroto",
  "marquise",
  "marreco",
  "martelo",
  "marujo",
  "mascote",
  "masmorra",
  "massagem",
  "mastigar",
  "matagal",
  "materno",
  "matinal",
  "matutar",
  "maxilar",
  "medalha",
  "medida",
  "medusa",
  "megafone",
  "meiga",
  "melancia",
  "melhor",
  "membro",
  "memorial",
  "menino",
  "menos",
  "mensagem",
  "mental",
  "merecer",
  "mergulho",
  "mesada",
  "mesclar",
  "mesmo",
  "mesquita",
  "mestre",
  "metade",
  "meteoro",
  "metragem",
  "mexer",
  "mexicano",
  "micro",
  "migalha",
  "migrar",
  "milagre",
  "milenar",
  "milhar",
  "mimado",
  "minerar",
  "minhoca",
  "ministro",
  "minoria",
  "miolo",
  "mirante",
  "mirtilo",
  "misturar",
  "mocidade",
  "moderno",
  "modular",
  "moeda",
  "moer",
  "moinho",
  "moita",
  "moldura",
  "moleza",
  "molho",
  "molinete",
  "molusco",
  "montanha",
  "moqueca",
  "morango",
  "morcego",
  "mordomo",
  "morena",
  "mosaico",
  "mosquete",
  "mostarda",
  "motel",
  "motim",
  "moto",
  "motriz",
  "muda",
  "muito",
  "mulata",
  "mulher",
  "multar",
  "mundial",
  "munido",
  "muralha",
  "murcho",
  "muscular",
  "museu",
  "musical",
  "nacional",
  "nadador",
  "naja",
  "namoro",
  "narina",
  "narrado",
  "nascer",
  "nativa",
  "natureza",
  "navalha",
  "navegar",
  "navio",
  "neblina",
  "nebuloso",
  "negativa",
  "negociar",
  "negrito",
  "nervoso",
  "neta",
  "neural",
  "nevasca",
  "nevoeiro",
  "ninar",
  "ninho",
  "nitidez",
  "nivelar",
  "nobreza",
  "noite",
  "noiva",
  "nomear",
  "nominal",
  "nordeste",
  "nortear",
  "notar",
  "noticiar",
  "noturno",
  "novelo",
  "novilho",
  "novo",
  "nublado",
  "nudez",
  "numeral",
  "nupcial",
  "nutrir",
  "nuvem",
  "obcecado",
  "obedecer",
  "objetivo",
  "obrigado",
  "obscuro",
  "obstetra",
  "obter",
  "obturar",
  "ocidente",
  "ocioso",
  "ocorrer",
  "oculista",
  "ocupado",
  "ofegante",
  "ofensiva",
  "oferenda",
  "oficina",
  "ofuscado",
  "ogiva",
  "olaria",
  "oleoso",
  "olhar",
  "oliveira",
  "ombro",
  "omelete",
  "omisso",
  "omitir",
  "ondulado",
  "oneroso",
  "ontem",
  "opcional",
  "operador",
  "oponente",
  "oportuno",
  "oposto",
  "orar",
  "orbitar",
  "ordem",
  "ordinal",
  "orfanato",
  "orgasmo",
  "orgulho",
  "oriental",
  "origem",
  "oriundo",
  "orla",
  "ortodoxo",
  "orvalho",
  "oscilar",
  "ossada",
  "osso",
  "ostentar",
  "otimismo",
  "ousadia",
  "outono",
  "outubro",
  "ouvido",
  "ovelha",
  "ovular",
  "oxidar",
  "oxigenar",
  "pacato",
  "paciente",
  "pacote",
  "pactuar",
  "padaria",
  "padrinho",
  "pagar",
  "pagode",
  "painel",
  "pairar",
  "paisagem",
  "palavra",
  "palestra",
  "palheta",
  "palito",
  "palmada",
  "palpitar",
  "pancada",
  "panela",
  "panfleto",
  "panqueca",
  "pantanal",
  "papagaio",
  "papelada",
  "papiro",
  "parafina",
  "parcial",
  "pardal",
  "parede",
  "partida",
  "pasmo",
  "passado",
  "pastel",
  "patamar",
  "patente",
  "patinar",
  "patrono",
  "paulada",
  "pausar",
  "peculiar",
  "pedalar",
  "pedestre",
  "pediatra",
  "pedra",
  "pegada",
  "peitoral",
  "peixe",
  "pele",
  "pelicano",
  "penca",
  "pendurar",
  "peneira",
  "penhasco",
  "pensador",
  "pente",
  "perceber",
  "perfeito",
  "pergunta",
  "perito",
  "permitir",
  "perna",
  "perplexo",
  "persiana",
  "pertence",
  "peruca",
  "pescado",
  "pesquisa",
  "pessoa",
  "petiscar",
  "piada",
  "picado",
  "piedade",
  "pigmento",
  "pilastra",
  "pilhado",
  "pilotar",
  "pimenta",
  "pincel",
  "pinguim",
  "pinha",
  "pinote",
  "pintar",
  "pioneiro",
  "pipoca",
  "piquete",
  "piranha",
  "pires",
  "pirueta",
  "piscar",
  "pistola",
  "pitanga",
  "pivete",
  "planta",
  "plaqueta",
  "platina",
  "plebeu",
  "plumagem",
  "pluvial",
  "pneu",
  "poda",
  "poeira",
  "poetisa",
  "polegada",
  "policiar",
  "poluente",
  "polvilho",
  "pomar",
  "pomba",
  "ponderar",
  "pontaria",
  "populoso",
  "porta",
  "possuir",
  "postal",
  "pote",
  "poupar",
  "pouso",
  "povoar",
  "praia",
  "prancha",
  "prato",
  "praxe",
  "prece",
  "predador",
  "prefeito",
  "premiar",
  "prensar",
  "preparar",
  "presilha",
  "pretexto",
  "prevenir",
  "prezar",
  "primata",
  "princesa",
  "prisma",
  "privado",
  "processo",
  "produto",
  "profeta",
  "proibido",
  "projeto",
  "prometer",
  "propagar",
  "prosa",
  "protetor",
  "provador",
  "publicar",
  "pudim",
  "pular",
  "pulmonar",
  "pulseira",
  "punhal",
  "punir",
  "pupilo",
  "pureza",
  "puxador",
  "quadra",
  "quantia",
  "quarto",
  "quase",
  "quebrar",
  "queda",
  "queijo",
  "quente",
  "querido",
  "quimono",
  "quina",
  "quiosque",
  "rabanada",
  "rabisco",
  "rachar",
  "racionar",
  "radial",
  "raiar",
  "rainha",
  "raio",
  "raiva",
  "rajada",
  "ralado",
  "ramal",
  "ranger",
  "ranhura",
  "rapadura",
  "rapel",
  "rapidez",
  "raposa",
  "raquete",
  "raridade",
  "rasante",
  "rascunho",
  "rasgar",
  "raspador",
  "rasteira",
  "rasurar",
  "ratazana",
  "ratoeira",
  "realeza",
  "reanimar",
  "reaver",
  "rebaixar",
  "rebelde",
  "rebolar",
  "recado",
  "recente",
  "recheio",
  "recibo",
  "recordar",
  "recrutar",
  "recuar",
  "rede",
  "redimir",
  "redonda",
  "reduzida",
  "reenvio",
  "refinar",
  "refletir",
  "refogar",
  "refresco",
  "refugiar",
  "regalia",
  "regime",
  "regra",
  "reinado",
  "reitor",
  "rejeitar",
  "relativo",
  "remador",
  "remendo",
  "remorso",
  "renovado",
  "reparo",
  "repelir",
  "repleto",
  "repolho",
  "represa",
  "repudiar",
  "requerer",
  "resenha",
  "resfriar",
  "resgatar",
  "residir",
  "resolver",
  "respeito",
  "ressaca",
  "restante",
  "resumir",
  "retalho",
  "reter",
  "retirar",
  "retomada",
  "retratar",
  "revelar",
  "revisor",
  "revolta",
  "riacho",
  "rica",
  "rigidez",
  "rigoroso",
  "rimar",
  "ringue",
  "risada",
  "risco",
  "risonho",
  "robalo",
  "rochedo",
  "rodada",
  "rodeio",
  "rodovia",
  "roedor",
  "roleta",
  "romano",
  "roncar",
  "rosado",
  "roseira",
  "rosto",
  "rota",
  "roteiro",
  "rotina",
  "rotular",
  "rouco",
  "roupa",
  "roxo",
  "rubro",
  "rugido",
  "rugoso",
  "ruivo",
  "rumo",
  "rupestre",
  "russo",
  "sabor",
  "saciar",
  "sacola",
  "sacudir",
  "sadio",
  "safira",
  "saga",
  "sagrada",
  "saibro",
  "salada",
  "saleiro",
  "salgado",
  "saliva",
  "salpicar",
  "salsicha",
  "saltar",
  "salvador",
  "sambar",
  "samurai",
  "sanar",
  "sanfona",
  "sangue",
  "sanidade",
  "sapato",
  "sarda",
  "sargento",
  "sarjeta",
  "saturar",
  "saudade",
  "saxofone",
  "sazonal",
  "secar",
  "secular",
  "seda",
  "sedento",
  "sediado",
  "sedoso",
  "sedutor",
  "segmento",
  "segredo",
  "segundo",
  "seiva",
  "seleto",
  "selvagem",
  "semanal",
  "semente",
  "senador",
  "senhor",
  "sensual",
  "sentado",
  "separado",
  "sereia",
  "seringa",
  "serra",
  "servo",
  "setembro",
  "setor",
  "sigilo",
  "silhueta",
  "silicone",
  "simetria",
  "simpatia",
  "simular",
  "sinal",
  "sincero",
  "singular",
  "sinopse",
  "sintonia",
  "sirene",
  "siri",
  "situado",
  "soberano",
  "sobra",
  "socorro",
  "sogro",
  "soja",
  "solda",
  "soletrar",
  "solteiro",
  "sombrio",
  "sonata",
  "sondar",
  "sonegar",
  "sonhador",
  "sono",
  "soprano",
  "soquete",
  "sorrir",
  "sorteio",
  "sossego",
  "sotaque",
  "soterrar",
  "sovado",
  "sozinho",
  "suavizar",
  "subida",
  "submerso",
  "subsolo",
  "subtrair",
  "sucata",
  "sucesso",
  "suco",
  "sudeste",
  "sufixo",
  "sugador",
  "sugerir",
  "sujeito",
  "sulfato",
  "sumir",
  "suor",
  "superior",
  "suplicar",
  "suposto",
  "suprimir",
  "surdina",
  "surfista",
  "surpresa",
  "surreal",
  "surtir",
  "suspiro",
  "sustento",
  "tabela",
  "tablete",
  "tabuada",
  "tacho",
  "tagarela",
  "talher",
  "talo",
  "talvez",
  "tamanho",
  "tamborim",
  "tampa",
  "tangente",
  "tanto",
  "tapar",
  "tapioca",
  "tardio",
  "tarefa",
  "tarja",
  "tarraxa",
  "tatuagem",
  "taurino",
  "taxativo",
  "taxista",
  "teatral",
  "tecer",
  "tecido",
  "teclado",
  "tedioso",
  "teia",
  "teimar",
  "telefone",
  "telhado",
  "tempero",
  "tenente",
  "tensor",
  "tentar",
  "termal",
  "terno",
  "terreno",
  "tese",
  "tesoura",
  "testado",
  "teto",
  "textura",
  "texugo",
  "tiara",
  "tigela",
  "tijolo",
  "timbrar",
  "timidez",
  "tingido",
  "tinteiro",
  "tiragem",
  "titular",
  "toalha",
  "tocha",
  "tolerar",
  "tolice",
  "tomada",
  "tomilho",
  "tonel",
  "tontura",
  "topete",
  "tora",
  "torcido",
  "torneio",
  "torque",
  "torrada",
  "torto",
  "tostar",
  "touca",
  "toupeira",
  "toxina",
  "trabalho",
  "tracejar",
  "tradutor",
  "trafegar",
  "trajeto",
  "trama",
  "trancar",
  "trapo",
  "traseiro",
  "tratador",
  "travar",
  "treino",
  "tremer",
  "trepidar",
  "trevo",
  "triagem",
  "tribo",
  "triciclo",
  "tridente",
  "trilogia",
  "trindade",
  "triplo",
  "triturar",
  "triunfal",
  "trocar",
  "trombeta",
  "trova",
  "trunfo",
  "truque",
  "tubular",
  "tucano",
  "tudo",
  "tulipa",
  "tupi",
  "turbo",
  "turma",
  "turquesa",
  "tutelar",
  "tutorial",
  "uivar",
  "umbigo",
  "unha",
  "unidade",
  "uniforme",
  "urologia",
  "urso",
  "urtiga",
  "urubu",
  "usado",
  "usina",
  "usufruir",
  "vacina",
  "vadiar",
  "vagaroso",
  "vaidoso",
  "vala",
  "valente",
  "validade",
  "valores",
  "vantagem",
  "vaqueiro",
  "varanda",
  "vareta",
  "varrer",
  "vascular",
  "vasilha",
  "vassoura",
  "vazar",
  "vazio",
  "veado",
  "vedar",
  "vegetar",
  "veicular",
  "veleiro",
  "velhice",
  "veludo",
  "vencedor",
  "vendaval",
  "venerar",
  "ventre",
  "verbal",
  "verdade",
  "vereador",
  "vergonha",
  "vermelho",
  "verniz",
  "versar",
  "vertente",
  "vespa",
  "vestido",
  "vetorial",
  "viaduto",
  "viagem",
  "viajar",
  "viatura",
  "vibrador",
  "videira",
  "vidraria",
  "viela",
  "viga",
  "vigente",
  "vigiar",
  "vigorar",
  "vilarejo",
  "vinco",
  "vinheta",
  "vinil",
  "violeta",
  "virada",
  "virtude",
  "visitar",
  "visto",
  "vitral",
  "viveiro",
  "vizinho",
  "voador",
  "voar",
  "vogal",
  "volante",
  "voleibol",
  "voltagem",
  "volumoso",
  "vontade",
  "vulto",
  "vuvuzela",
  "xadrez",
  "xarope",
  "xeque",
  "xeretar",
  "xerife",
  "xingar",
  "zangado",
  "zarpar",
  "zebu",
  "zelador",
  "zombar",
  "zoologia",
  "zumbido"
], tQ = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
Object.defineProperty(Kn, "__esModule", { value: !0 });
const So = {};
Kn.wordlists = So;
let hr;
var ya = Kn._default = hr;
try {
  ya = Kn._default = hr = VJ, So.czech = hr;
} catch {
}
try {
  ya = Kn._default = hr = GJ, So.chinese_simplified = hr;
} catch {
}
try {
  ya = Kn._default = hr = ZJ, So.chinese_traditional = hr;
} catch {
}
try {
  ya = Kn._default = hr = WJ, So.korean = hr;
} catch {
}
try {
  ya = Kn._default = hr = XJ, So.french = hr;
} catch {
}
try {
  ya = Kn._default = hr = YJ, So.italian = hr;
} catch {
}
try {
  ya = Kn._default = hr = JJ, So.spanish = hr;
} catch {
}
try {
  ya = Kn._default = hr = QJ, So.japanese = hr, So.JA = hr;
} catch {
}
try {
  ya = Kn._default = hr = eQ, So.portuguese = hr;
} catch {
}
try {
  ya = Kn._default = hr = tQ, So.english = hr, So.EN = hr;
} catch {
}
Object.defineProperty(ma, "__esModule", { value: !0 });
const rQ = yi, WI = Jr, XI = iy, nQ = Gu, Ig = Kn;
let jh = Ig._default;
const VE = "Invalid mnemonic", Nc = "Invalid entropy", oQ = "Invalid mnemonic checksum", YI = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
function Lh(e) {
  return (e || "").normalize("NFKD");
}
function JI(e, t, r) {
  for (; e.length < r; )
    e = t + e;
  return e;
}
function QI(e) {
  return parseInt(e, 2);
}
function eT(e) {
  return e.map((t) => JI(t.toString(2), "0", 8)).join("");
}
function tT(e) {
  const t = e.length * 8 / 32, r = rQ.sha256(Uint8Array.from(e));
  return eT(Array.from(r)).slice(0, t);
}
function rT(e) {
  return "mnemonic" + (e || "");
}
function iQ(e, t) {
  const r = Uint8Array.from(Buffer.from(Lh(e), "utf8")), n = Uint8Array.from(Buffer.from(rT(Lh(t)), "utf8")), o = XI.pbkdf2(WI.sha512, r, n, {
    c: 2048,
    dkLen: 64
  });
  return Buffer.from(o);
}
ma.mnemonicToSeedSync = iQ;
function aQ(e, t) {
  const r = Uint8Array.from(Buffer.from(Lh(e), "utf8")), n = Uint8Array.from(Buffer.from(rT(Lh(t)), "utf8"));
  return XI.pbkdf2Async(WI.sha512, r, n, {
    c: 2048,
    dkLen: 64
  }).then((o) => Buffer.from(o));
}
var sQ = ma.mnemonicToSeed = aQ;
function nT(e, t) {
  if (t = t || jh, !t)
    throw new Error(YI);
  const r = Lh(e).split(" ");
  if (r.length % 3 !== 0)
    throw new Error(VE);
  const n = r.map((l) => {
    const c = t.indexOf(l);
    if (c === -1)
      throw new Error(VE);
    return JI(c.toString(2), "0", 11);
  }).join(""), o = Math.floor(n.length / 33) * 32, a = n.slice(0, o), i = n.slice(o), s = a.match(/(.{1,8})/g).map(QI);
  if (s.length < 16)
    throw new Error(Nc);
  if (s.length > 32)
    throw new Error(Nc);
  if (s.length % 4 !== 0)
    throw new Error(Nc);
  const u = Buffer.from(s);
  if (tT(u) !== i)
    throw new Error(oQ);
  return u.toString("hex");
}
ma.mnemonicToEntropy = nT;
function oT(e, t) {
  if (Buffer.isBuffer(e) || (e = Buffer.from(e, "hex")), t = t || jh, !t)
    throw new Error(YI);
  if (e.length < 16)
    throw new TypeError(Nc);
  if (e.length > 32)
    throw new TypeError(Nc);
  if (e.length % 4 !== 0)
    throw new TypeError(Nc);
  const r = eT(Array.from(e)), n = tT(e), o = (r + n).match(/(.{1,11})/g).map((a) => {
    const i = QI(a);
    return t[i];
  });
  return t[0] === "" ? o.join("") : o.join(" ");
}
var uQ = ma.entropyToMnemonic = oT;
function cQ(e, t, r) {
  if (e = e || 128, e % 32 !== 0)
    throw new TypeError(Nc);
  return t = t || ((n) => Buffer.from(nQ.randomBytes(n))), oT(t(e / 8), r);
}
ma.generateMnemonic = cQ;
function lQ(e, t) {
  try {
    nT(e, t);
  } catch {
    return !1;
  }
  return !0;
}
ma.validateMnemonic = lQ;
function fQ(e) {
  const t = Ig.wordlists[e];
  if (t)
    jh = t;
  else
    throw new Error('Could not find wordlist for language "' + e + '"');
}
ma.setDefaultWordlist = fQ;
function dQ() {
  if (!jh)
    throw new Error("No Default Wordlist set");
  return Object.keys(Ig.wordlists).filter((e) => e === "JA" || e === "EN" ? !1 : Ig.wordlists[e].every((t, r) => t === jh[r]))[0];
}
ma.getDefaultWordlist = dQ;
var hQ = Kn;
ma.wordlists = hQ.wordlists;
function pQ(e) {
  return ix(en(e));
}
function GE(e, t) {
  return e3(JF, e, t);
}
const ct = (e) => GR(e);
function gQ(e) {
  if (jr(e.isPoint(ct("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), jr(!e.isPoint(ct("030000000000000000000000000000000000000000000000000000000000000005"))), jr(e.isPrivate(ct("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), jr(e.isPrivate(ct("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), jr(!e.isPrivate(ct("0000000000000000000000000000000000000000000000000000000000000000"))), jr(!e.isPrivate(ct("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), jr(!e.isPrivate(ct("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), jr(Ta(e.pointFromScalar(ct("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), ct("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0), e.xOnlyPointAddTweak) {
    jr(e.xOnlyPointAddTweak(ct("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), ct("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
    let t = e.xOnlyPointAddTweak(ct("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), ct("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
    jr(Ta(t.xOnlyPubkey, ct("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && t.parity === 1), t = e.xOnlyPointAddTweak(ct("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), ct("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
  }
  jr(Ta(e.pointAddScalar(ct("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), ct("0000000000000000000000000000000000000000000000000000000000000003")), ct("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0), jr(Ta(e.privateAdd(ct("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), ct("0000000000000000000000000000000000000000000000000000000000000002")), ct("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), e.privateNegate && (jr(Ta(e.privateNegate(ct("0000000000000000000000000000000000000000000000000000000000000001")), ct("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), jr(Ta(e.privateNegate(ct("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), ct("0000000000000000000000000000000000000000000000000000000000000003")) === 0), jr(Ta(e.privateNegate(ct("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), ct("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0)), jr(Ta(e.sign(ct("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), ct("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), ct("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0), jr(e.verify(ct("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), ct("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), ct("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), e.signSchnorr && jr(Ta(e.signSchnorr(ct("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), ct("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), ct("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), ct("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0), e.verifySchnorr && jr(e.verifySchnorr(ct("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), ct("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), ct("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
}
function jr(e) {
  if (!e)
    throw new Error("ecc library invalid");
}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Sv(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
// @__NO_SIDE_EFFECTS__
function iT(...e) {
  const t = (a) => a, r = (a, i) => (s) => a(i(s)), n = e.map((a) => a.encode).reduceRight(r, t), o = e.map((a) => a.decode).reduce(r, t);
  return { encode: n, decode: o };
}
// @__NO_SIDE_EFFECTS__
function mQ(e) {
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return t.map((r) => {
        if (r < 0 || r >= e.length)
          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
        return e[r];
      });
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return t.map((r) => {
        if (typeof r != "string")
          throw new Error(`alphabet.decode: not string element=${r}`);
        const n = e.indexOf(r);
        if (n === -1)
          throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
        return n;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function yQ(e = "") {
  if (typeof e != "string")
    throw new Error("join separator should be string");
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let r of t)
        if (typeof r != "string")
          throw new Error(`join.encode: non-string input=${r}`);
      return t.join(e);
    },
    decode: (t) => {
      if (typeof t != "string")
        throw new Error("join.decode input should be string");
      return t.split(e);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function ZE(e, t, r) {
  if (t < 2)
    throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
  if (!Array.isArray(e))
    throw new Error("convertRadix: data should be array");
  if (!e.length)
    return [];
  let n = 0;
  const o = [], a = Array.from(e);
  for (a.forEach((i) => {
    if (i < 0 || i >= t)
      throw new Error(`Wrong integer: ${i}`);
  }); ; ) {
    let i = 0, s = !0;
    for (let u = n; u < a.length; u++) {
      const l = a[u], c = t * i + l;
      if (!Number.isSafeInteger(c) || t * i / t !== i || c - l !== t * i)
        throw new Error("convertRadix: carry overflow");
      i = c % r;
      const f = Math.floor(c / r);
      if (a[u] = f, !Number.isSafeInteger(f) || f * r + i !== c)
        throw new Error("convertRadix: carry overflow");
      if (s)
        f ? s = !1 : n = u;
      else continue;
    }
    if (o.push(i), s)
      break;
  }
  for (let i = 0; i < e.length - 1 && e[i] === 0; i++)
    o.push(0);
  return o.reverse();
}
// @__NO_SIDE_EFFECTS__
function bQ(e) {
  return {
    encode: (t) => {
      if (!Sv(t))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ ZE(Array.from(t), 2 ** 8, e);
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(/* @__PURE__ */ ZE(t, e, 2 ** 8));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function wQ(e, t) {
  if (typeof t != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(r) {
      if (!Sv(r))
        throw new Error("checksum.encode: input should be Uint8Array");
      const n = t(r).slice(0, e), o = new Uint8Array(r.length + e);
      return o.set(r), o.set(n, r.length), o;
    },
    decode(r) {
      if (!Sv(r))
        throw new Error("checksum.decode: input should be Uint8Array");
      const n = r.slice(0, -e), o = t(n).slice(0, e), a = r.slice(-e);
      for (let i = 0; i < e; i++)
        if (o[i] !== a[i])
          throw new Error("Invalid checksum");
      return n;
    }
  };
}
const vQ = (e) => /* @__PURE__ */ iT(/* @__PURE__ */ bQ(58), /* @__PURE__ */ mQ(e), /* @__PURE__ */ yQ("")), EQ = /* @__PURE__ */ vQ("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), kQ = (e) => /* @__PURE__ */ iT(/* @__PURE__ */ wQ(4, (t) => e(e(t))), EQ), xQ = kQ;
function AQ(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? void 0,
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? void 0,
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? void 0
  };
}
function SQ(e, t) {
  var r;
  return (r = void 0) == null ? void 0 : r.get(t);
}
function Hh(e) {
  var t, r;
  const n = typeof e;
  return n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n === "object" || n === "function" ? (e && ((r = (t = Object.getPrototypeOf(e)) == null ? void 0 : t.constructor) == null ? void 0 : r.name)) ?? "null" : n;
}
function ms(e, t, r, n, o) {
  const a = o && "input" in o ? o.input : r.value, i = (o == null ? void 0 : o.expected) ?? e.expects ?? null, s = (o == null ? void 0 : o.received) ?? Hh(a), u = {
    kind: e.kind,
    type: e.type,
    input: a,
    expected: i,
    received: s,
    message: `Invalid ${t}: ${i ? `Expected ${i} but r` : "R"}eceived ${s}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, l = e.kind === "schema", c = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? SQ(e.reference, u.lang) ?? (l ? (u.lang, void 0) : null) ?? n.message ?? (u.lang, void 0);
  c && (u.message = typeof c == "function" ? c(u) : c), l && (r.typed = !1), r.issues ? r.issues.push(u) : r.issues = [u];
}
var _Q = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e) {
    super(e[0].message), ke(this, "issues"), this.name = "ValiError", this.issues = e;
  }
};
function ay(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: ay,
    async: !1,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && ms(this, "integer", t, r), t;
    }
  };
}
function o5(e, t) {
  return {
    kind: "validation",
    type: "length",
    reference: o5,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length !== this.requirement && ms(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function sy(e, t) {
  return {
    kind: "validation",
    type: "max_value",
    reference: sy,
    async: !1,
    expects: `<=${e instanceof Date ? e.toJSON() : Hh(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value > this.requirement && ms(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : Hh(r.value)
      }), r;
    }
  };
}
function uy(e, t) {
  return {
    kind: "validation",
    type: "min_value",
    reference: uy,
    async: !1,
    expects: `>=${e instanceof Date ? e.toJSON() : Hh(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value < this.requirement && ms(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : Hh(r.value)
      }), r;
    }
  };
}
function aT(e, t) {
  return {
    kind: "validation",
    type: "regex",
    reference: aT,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.test(r.value) && ms(this, "format", r, n), r;
    }
  };
}
function cy(e, t) {
  return {
    kind: "schema",
    type: "instance",
    reference: cy,
    expects: e.name,
    async: !1,
    class: e,
    message: t,
    _run(r, n) {
      return r.value instanceof this.class ? r.typed = !0 : ms(this, "type", r, n), r;
    }
  };
}
function ly(e) {
  return {
    kind: "schema",
    type: "number",
    reference: ly,
    expects: "number",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : ms(this, "type", t, r), t;
    }
  };
}
function _v(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: _v,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (a && typeof a == "object") {
        r.typed = !0, r.value = {};
        for (const i in this.entries) {
          const s = a[i], u = this.entries[i]._run(
            { typed: !1, value: s },
            n
          );
          if (u.issues) {
            const l = {
              type: "object",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), (u.value !== void 0 || i in a) && (r.value[i] = u.value);
        }
      } else
        ms(this, "type", r, n);
      return r;
    }
  };
}
function sT(e) {
  return {
    kind: "schema",
    type: "string",
    reference: sT,
    expects: "string",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = !0 : ms(this, "type", t, r), t;
    }
  };
}
function $a(e, t, r) {
  const n = e._run(
    { typed: !1, value: t },
    AQ(r)
  );
  if (n.issues)
    throw new _Q(n.issues);
  return n.value;
}
function nd(...e) {
  return {
    ...e[0],
    pipe: e,
    _run(t, r) {
      for (const n of e)
        if (n.kind !== "metadata") {
          if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
            t.typed = !1;
            break;
          }
          (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
        }
      return t;
    }
  };
}
const Iv = nd(ly(), ay(), uy(0), sy(4294967295)), IQ = nd(ly(), ay(), uy(0), sy(2147483647)), TQ = nd(ly(), ay(), uy(0), sy(255)), S2 = nd(cy(Uint8Array), o5(32)), PQ = nd(cy(Uint8Array), o5(33)), OQ = _v({
  wif: TQ,
  bip32: _v({
    public: Iv,
    private: Iv
  })
}), $Q = nd(sT(), aT(/^(m\/)?(\d+'?\/)*\d+'?$/));
function CQ(e, t, r) {
  if (t.length !== 32)
    throw new TypeError("Invalid privateKey length");
  var n = new Uint8Array(34), o = new DataView(n.buffer);
  return o.setUint8(0, e), n.set(t, 1), n[33] = 1, n;
}
function BQ(e) {
  return mf.encode(CQ(e.version, e.privateKey));
}
const WE = xQ(en), XE = {
  encode: (e) => WE.encode(e),
  decode: (e) => WE.decode(e)
};
function NQ(e) {
  gQ(e);
  const t = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  }, r = 2147483648;
  function n(h) {
    return h.length === 32 ? h : h.slice(1, 33);
  }
  class o {
    constructor(p, y) {
      ke(this, "__D"), ke(this, "__Q"), ke(this, "lowR", !1), this.__D = p, this.__Q = y;
    }
    get publicKey() {
      return this.__Q === void 0 && (this.__Q = e.pointFromScalar(this.__D, !0)), this.__Q;
    }
    get privateKey() {
      return this.__D;
    }
    sign(p, y) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (y === void 0 && (y = this.lowR), y === !1)
        return e.sign(p, this.privateKey);
      {
        let m = e.sign(p, this.privateKey);
        const b = new Uint8Array(32);
        let v = 0;
        for (; m[0] > 127; )
          v++, uc(b, 0, v, "LE"), m = e.sign(p, this.privateKey, b);
        return m;
      }
    }
    signSchnorr(p) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (!e.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return e.signSchnorr(p, this.privateKey);
    }
    verify(p, y) {
      return e.verify(p, this.publicKey, y);
    }
    verifySchnorr(p, y) {
      if (!e.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return e.verifySchnorr(p, this.publicKey.subarray(1, 33), y);
    }
  }
  class a extends o {
    constructor(p, y, m, b, v = 0, k = 0, E = 0) {
      super(p, y), ke(this, "chainCode"), ke(this, "network"), ke(this, "__DEPTH"), ke(this, "__INDEX"), ke(this, "__PARENT_FINGERPRINT"), this.chainCode = m, this.network = b, this.__DEPTH = v, this.__INDEX = k, this.__PARENT_FINGERPRINT = E, $a(OQ, b);
    }
    get depth() {
      return this.__DEPTH;
    }
    get index() {
      return this.__INDEX;
    }
    get parentFingerprint() {
      return this.__PARENT_FINGERPRINT;
    }
    get identifier() {
      return pQ(this.publicKey);
    }
    get fingerprint() {
      return this.identifier.slice(0, 4);
    }
    get compressed() {
      return !0;
    }
    // Private === not neutered
    // Public === neutered
    isNeutered() {
      return this.__D === void 0;
    }
    neutered() {
      return c(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const p = this.network, y = this.isNeutered() ? p.bip32.public : p.bip32.private, m = new Uint8Array(78);
      return uc(m, 0, y, "BE"), _6(m, 4, this.depth), uc(m, 5, this.parentFingerprint, "BE"), uc(m, 9, this.index, "BE"), m.set(this.chainCode, 13), this.isNeutered() ? m.set(this.publicKey, 45) : (_6(m, 45, 0), m.set(this.privateKey, 46)), XE.encode(m);
    }
    toWIF() {
      if (!this.privateKey)
        throw new TypeError("Missing private key");
      return BQ({
        version: this.network.wif,
        privateKey: this.privateKey,
        compressed: !0
      });
    }
    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    derive(p) {
      $a(Iv, p);
      const y = p >= r, m = new Uint8Array(37);
      if (y) {
        if (this.isNeutered())
          throw new TypeError("Missing private key for hardened child key");
        m[0] = 0, m.set(this.privateKey, 1), uc(m, 33, p, "BE");
      } else
        m.set(this.publicKey, 0), uc(m, 33, p, "BE");
      const b = GE(this.chainCode, m), v = b.slice(0, 32), k = b.slice(32);
      if (!e.isPrivate(v))
        return this.derive(p + 1);
      let E;
      if (this.isNeutered()) {
        const A = e.pointAddScalar(this.publicKey, v, !0);
        if (A === null)
          return this.derive(p + 1);
        E = c(A, k, this.network, this.depth + 1, p, Fl(this.fingerprint, 0, "BE"));
      } else {
        const A = e.privateAdd(this.privateKey, v);
        if (A == null)
          return this.derive(p + 1);
        E = u(A, k, this.network, this.depth + 1, p, Fl(this.fingerprint, 0, "BE"));
      }
      return E;
    }
    deriveHardened(p) {
      if (typeof $a(IQ, p) == "number")
        return this.derive(p + r);
      throw new TypeError("Expected UInt31, got " + p);
    }
    derivePath(p) {
      $a($Q, p);
      let y = p.split("/");
      if (y[0] === "m") {
        if (this.parentFingerprint)
          throw new TypeError("Expected master, got child");
        y = y.slice(1);
      }
      return y.reduce((m, b) => {
        let v;
        return b.slice(-1) === "'" ? (v = parseInt(b.slice(0, -1), 10), m.deriveHardened(v)) : (v = parseInt(b, 10), m.derive(v));
      }, this);
    }
    tweak(p) {
      return this.privateKey ? this.tweakFromPrivateKey(p) : this.tweakFromPublicKey(p);
    }
    tweakFromPublicKey(p) {
      const y = n(this.publicKey);
      if (!e.xOnlyPointAddTweak)
        throw new Error("xOnlyPointAddTweak not supported by ecc library");
      const m = e.xOnlyPointAddTweak(y, p);
      if (!m || m.xOnlyPubkey === null)
        throw new Error("Cannot tweak public key!");
      const b = Uint8Array.from([
        m.parity === 0 ? 2 : 3
      ]), v = VR([
        b,
        m.xOnlyPubkey
      ]);
      return new o(void 0, v);
    }
    tweakFromPrivateKey(p) {
      const y = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, m = (() => {
        if (y) {
          if (e.privateNegate)
            return e.privateNegate(this.privateKey);
          throw new Error("privateNegate not supported by ecc library");
        } else return this.privateKey;
      })(), b = e.privateAdd(m, p);
      if (!b)
        throw new Error("Invalid tweaked private key!");
      return new o(b, void 0);
    }
  }
  function i(h, p) {
    const y = XE.decode(h);
    if (y.length !== 78)
      throw new TypeError("Invalid buffer length");
    p = p || t;
    const m = Fl(y, 0, "BE");
    if (m !== p.bip32.private && m !== p.bip32.public)
      throw new TypeError("Invalid network version");
    const b = y[4], v = Fl(y, 5, "BE");
    if (b === 0 && v !== 0)
      throw new TypeError("Invalid parent fingerprint");
    const k = Fl(y, 9, "BE");
    if (b === 0 && k !== 0)
      throw new TypeError("Invalid index");
    const E = y.slice(13, 45);
    let A;
    if (m === p.bip32.private) {
      if (y[45] !== 0)
        throw new TypeError("Invalid private key");
      const S = y.slice(46, 78);
      A = u(S, E, p, b, k, v);
    } else {
      const S = y.slice(45, 78);
      A = c(S, E, p, b, k, v);
    }
    return A;
  }
  function s(h, p, y) {
    return u(h, p, y);
  }
  function u(h, p, y, m, b, v) {
    if ($a(S2, h), $a(S2, p), y = y || t, !e.isPrivate(h))
      throw new TypeError("Private key not in range [1, n)");
    return new a(h, void 0, p, y, m, b, v);
  }
  function l(h, p, y) {
    return c(h, p, y);
  }
  function c(h, p, y, m, b, v) {
    if ($a(PQ, h), $a(S2, p), y = y || t, !e.isPoint(h))
      throw new TypeError("Point is not on the curve");
    return new a(void 0, h, p, y, m, b, v);
  }
  function f(h, p) {
    if ($a(cy(Uint8Array), h), h.length < 16)
      throw new TypeError("Seed should be at least 128 bits");
    if (h.length > 64)
      throw new TypeError("Seed should be at most 512 bits");
    p = p || t;
    const y = GE(qR("Bitcoin seed"), h), m = y.slice(0, 32), b = y.slice(32);
    return s(m, b, p);
  }
  return {
    fromSeed: f,
    fromBase58: i,
    fromPublicKey: l,
    fromPrivateKey: s
  };
}
const V3e = "text/html", G3e = "text/css", UQ = "text/plain", Z3e = "text/javascript", W3e = "text/markdown", X3e = "application/json", Y3e = "application/javascript", J3e = "application/xml", Q3e = "application/pdf", e5e = "application/zip", t5e = "application/gzip", r5e = "application/xhtml+xml", n5e = "application/rss+xml", o5e = "application/atom+xml", i5e = "application/x-www-form-urlencoded", a5e = "application/octet-stream", s5e = "image/jpeg", u5e = "image/png", c5e = "image/gif", l5e = "image/svg+xml", f5e = "image/webp", d5e = "image/x-icon", h5e = "video/mp4", p5e = "video/webm", g5e = "video/ogg", m5e = "audio/mpeg", y5e = "audio/wav", b5e = "audio/ogg", w5e = "multipart/form-data", YE = "btc", v5e = "brc20", JE = "runes", E5e = "alkanes", i5 = "bip322", Bp = "ecdsa", fy = "bip322-simple";
async function uT(e, t = Ot) {
  try {
    return await rr.get(`${ny(t)}/api/tx/${e}`).then((r) => r.data);
  } catch (r) {
    throw r;
  }
}
const cT = async (e) => await rr.get(`${ny(e)}/api/v1/fees/recommended`, {
  headers: {
    "Content-Type": "application/json"
  }
}).then((t) => t.data), RQ = NQ(Ym);
V8(Ym);
async function zQ(e) {
  const t = crypto.getRandomValues(new Uint8Array(32)), r = uQ(Buffer.from(t)), n = await sQ(r), o = RQ.fromSeed(n, Er(e));
  return o == null ? void 0 : o.derivePath("m/44'/0'/0'/0/0").privateKey;
}
const lT = (e, t) => {
  try {
    const r = Er(t), n = wx(e);
    if (n.version === r.pubKeyHash) return BU;
    if (n.version === r.scriptHash) {
      const o = fr(n.hash);
      return o && o.length === 2 && o[0] === jt.OP_0 ? NU : B8;
    }
  } catch {
    try {
      const r = Z8(e);
      if (r.version === 0 && r.data.length === 20) return Aw;
      if (r.version === 0 && r.data.length === 32) return UU;
      if (r.version === 1 && r.data.length === 32) return tf;
    } catch {
      return "unknown";
    }
  }
  return "unknown";
};
function jQ(e, t) {
  const r = Er(t);
  return wp(e, r);
}
function a5(e, t) {
  var r;
  const n = gp({
    pubkey: Buffer.from(e, "hex"),
    network: Er(t)
  }), o = Wf({
    redeem: n,
    network: Er(t)
  });
  return (r = o == null ? void 0 : o.redeem) == null ? void 0 : r.output;
}
async function LQ(e, t) {
  const r = Date.now();
  for (; ; )
    try {
      if (await uT(e, t))
        return console.log("Transaction found in mempool:", e), !0;
      if (Date.now() - r > 6e4)
        return !1;
      await new Promise((n) => setTimeout(n, 5e3));
    } catch {
      if (Date.now() - r > 6e4)
        return !1;
      await new Promise((n) => setTimeout(n, 5e3));
    }
}
async function HQ(e, t, r) {
  const n = Date.now();
  for (; ; )
    try {
      const o = await uT(e, r);
      if (o && o.vout && o.vout.length > 0)
        return Math.floor(o.vout[t].value);
      if (Date.now() - n > 6e4)
        return null;
      await new Promise((a) => setTimeout(a, 5e3));
    } catch (o) {
      if (console.error("Error fetching transaction output value:", o), Date.now() - n > 6e4)
        return null;
      await new Promise((a) => setTimeout(a, 5e3));
    }
}
V8(Ym);
const Er = (e) => e === Yt || e === on || e === pn ? RU : $i, s5 = (e) => e.find(
  ({ purpose: t }) => t === "ordinals"
), u5 = (e) => e.find(
  ({ purpose: t }) => t === "payment"
), as = async (e, t) => {
  try {
    const r = await dy(
      e,
      t
    );
    return r ? r.reduce((n, o) => n + BigInt(o.value), 0n) : 0n;
  } catch (r) {
    throw console.error("Error fetching BTC balance:", r), new Error("Failed to fetch BTC balance");
  }
};
function fT(e, t, r) {
  const n = e * 57 + t * 41, o = r * 34;
  return 10 + n + o;
}
async function dy(e, t) {
  if (e.startsWith("t")) {
    if (t === Ot)
      return [];
    if (t === fl)
      return [];
    if (t === Nn)
      return [];
  }
  return await rr.get(`${ny(t)}/api/address/${e}/utxo`).then((r) => r.data);
}
async function c5(e, t, r, n, o, a, i = 7) {
  const s = e === t, u = await dy(
    t,
    a
  );
  if (!u)
    throw new Error("No UTXOs found");
  const l = u.sort(
    (m, b) => b.value - m.value
  ), c = new Gt({ network: Er(a) }), f = fT(1, 0, 2), h = Math.floor(f * i) + n;
  let p = 0, y = 0;
  for await (let m of l) {
    const { txid: b, vout: v, value: k } = m, E = wp(
      t,
      Er(a)
    );
    if (c.addInput({
      hash: b,
      index: v,
      witnessUtxo: {
        script: E,
        value: BigInt(k)
      }
    }), !s) {
      const A = a5(o, a);
      c.updateInput(y, { redeemScript: A });
    }
    if (p += k, p >= h)
      break;
  }
  if (p < h)
    throw new Error("Insufficient funds");
  return c.addOutput({
    address: r,
    value: BigInt(n)
  }), p > h && c.addOutput({
    address: t,
    value: BigInt(p - h)
  }), {
    psbtBase64: c.toBase64(),
    psbtHex: c.toHex()
  };
}
function dT(e) {
  return e == null ? void 0 : e.reduce((t, r) => t + r.value, 0);
}
async function hy(e, t) {
  return (await rr.post(
    `${ny(t)}/api/tx`,
    e,
    {
      headers: {
        "Content-Type": "text/plain"
      }
    }
  )).data;
}
const l5 = (e) => e === Yt || e === on || e === pn, od = (e) => e === Ot || e === fl || e === Nn;
V8(Ym);
const FQ = async ({
  contentBase64: e,
  mimeType: t,
  quantity: r = 1,
  inscriptions: n,
  ordinalAddress: o,
  paymentAddress: a,
  paymentPublicKey: i,
  signPsbt: s,
  network: u = Ot
}) => {
  try {
    if (!e && !n)
      throw new Error("contentBase64 or inscriptions is required");
    const l = await zQ(u), c = Buffer.from(l).toString("hex"), f = n || Array(r).fill({
      content: e,
      mimeType: t
    }), h = await DQ({
      inscriptions: f,
      paymentAddress: a,
      paymentPublicKey: i,
      privKey: c,
      network: u
    });
    if (!h || !(h != null && h.psbtHex))
      throw new Error("couldn't get commit tx");
    const p = String(h == null ? void 0 : h.psbtHex), y = String(h == null ? void 0 : h.psbtBase64), m = await s(
      "",
      p,
      y,
      !0,
      !1,
      u
    );
    if (!m) throw new Error("sign psbt failed");
    const b = Gt.fromHex((m == null ? void 0 : m.signedPsbtHex) || "").extractTransaction(), v = await hy(b.toHex(), u);
    if (!v) throw new Error("commit tx failed");
    return await MQ({
      inscriptions: f,
      ordinalAddress: o,
      privKey: c,
      commitTxId: v,
      network: u
    });
  } catch (l) {
    throw l;
  }
}, DQ = async ({
  inscriptions: e,
  paymentAddress: t,
  paymentPublicKey: r,
  privKey: n,
  network: o
}) => {
  try {
    const a = e.length, i = e.reduce(
      (S, _) => S + Buffer.from(_.content).length,
      0
    );
    if (i > 39e4)
      throw new Error("Content size is too large, must be less than 390kb");
    const { fastestFee: s } = await cT(o), u = lA(String(n), !0), l = new Gt({
      network: Er(o)
    }), { inscriberAddress: c } = KQ(
      u,
      e,
      o
    ), f = 5 * 34 * a, h = Math.floor(f * s * a), p = Math.floor(i * s / 3) + 1e3 + 546 * a, y = Math.floor(h + p), m = (await dy(
      t,
      o
    )).filter((S) => S.value > 3e3).sort((S, _) => _.value - S.value), b = dT(m);
    if (b === 0)
      throw new Error("insufficient funds");
    if (b < y)
      throw new Error("insufficient funds");
    let v = 0;
    const k = wp(
      t,
      Er(o)
    );
    let E = 0;
    for await (const S of m) {
      const _ = lT(t, o);
      if (l.addInput({
        hash: S.txid,
        index: S.vout,
        witnessUtxo: { value: BigInt(S.value), script: k }
      }), _ === tf && l.updateInput(E, {
        tapInternalKey: Pc(Buffer.from(r, "hex"))
      }), _ === B8) {
        let I = a5(r, o);
        l.updateInput(E, { redeemScript: I });
      }
      if (E++, v += S.value, v > y)
        break;
    }
    const A = v - y;
    return l.addOutput({
      value: BigInt(p),
      address: c
    }), A > 546 && l.addOutput({
      value: BigInt(A),
      address: t
    }), {
      psbtHex: l.toHex(),
      psbtBase64: l.toBase64()
    };
  } catch (a) {
    throw a;
  }
}, MQ = async ({
  inscriptions: e,
  ordinalAddress: t,
  commitTxId: r,
  privKey: n,
  network: o,
  isDry: a
}) => {
  try {
    const i = QF(n), s = lA(n, !0), u = hT(s, e), l = lg.encodeScript(u), [c, f] = lg.getPubKey(s, { target: l });
    if (!await LQ(String(r), o))
      throw new Error("ERROR WAITING FOR COMMIT TX");
    const h = await HQ(
      r,
      0,
      o
    );
    if (h === 0 || !h)
      throw new Error("ERROR GETTING FIRST INPUT VALUE");
    const p = pi.create({
      vin: [
        {
          txid: r,
          vout: 0,
          prevout: {
            value: h,
            scriptPubKey: ["OP_1", c]
          }
        }
      ],
      vout: [
        ...Array(e.length).fill({
          value: 546,
          scriptPubKey: o_.toScriptPubKey(t)
        })
      ]
    }), y = BZ.taproot.sign(i, p, 0, { extension: l });
    return p.vin[0].witness = [y, u, f], a ? pi.util.getTxid(p) : await hy(pi.encode(p).hex, o);
  } catch (i) {
    throw i;
  }
}, hT = (e, t) => {
  const r = new TextEncoder(), n = r.encode("ord"), o = 546, a = (s, u) => {
    let l;
    if (u === UQ) {
      const f = Buffer.from(s, "base64").toString("utf-8");
      l = Buffer.from(f, "utf-8");
    } else
      l = Buffer.from(s, "base64");
    const c = [];
    for (let f = 0; f < l.length; f += 520)
      c.push(l.slice(f, f + 520));
    return c;
  }, i = [e, "OP_CHECKSIG"];
  return t.forEach((s, u) => {
    const { content: l, mimeType: c } = s, f = a(l, c);
    if (i.push("OP_0", "OP_IF", n, "01", r.encode(c), "OP_0"), u > 0) {
      const h = o * (u + 1), p = Buffer.from([h]);
      i.push(Buffer.from([2])), i.push(p);
    }
    i.push(...f.map((h) => h), "OP_ENDIF");
  }), i;
}, KQ = (e, t, r = Ot) => {
  const n = hT(e, t), o = lg.encodeScript(n), [a] = lg.getPubKey(e, { target: o });
  return {
    inscriberAddress: o_.p2tr.fromPubKey(
      a,
      tY(r)
    ),
    tpubkey: a,
    tapleaf: o
  };
};
var qQ = {}, Np = {};
Object.defineProperty(Np, "__esModule", { value: !0 });
Np.isRunestone = void 0;
function VQ(e) {
  return !("flaws" in e);
}
Np.isRunestone = VQ;
var er = {}, To = {}, f5 = {}, Po = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isNone = e.isSome = e.None = e.Some = e.OptionType = void 0, e.OptionType = {
    Some: Symbol(":some"),
    None: Symbol(":none")
  };
  class t {
    constructor(s) {
      this.val = s;
    }
    get type() {
      return e.OptionType.Some;
    }
    isSome() {
      return !0;
    }
    isNone() {
      return !1;
    }
    match(s) {
      return s.some(this.val);
    }
    map(s) {
      return n(s(this.val));
    }
    inspect(s) {
      return s(this.val), this;
    }
    andThen(s) {
      return s(this.val);
    }
    or(s) {
      return this;
    }
    orElse(s) {
      return this;
    }
    and(s) {
      return s;
    }
    unwrapOr(s) {
      return this.val;
    }
    unwrap() {
      return this.val;
    }
  }
  class r {
    get type() {
      return e.OptionType.None;
    }
    isSome() {
      return !1;
    }
    isNone() {
      return !0;
    }
    match({ none: s }) {
      return typeof s == "function" ? s() : s;
    }
    map(s) {
      return new r();
    }
    inspect(s) {
      return this;
    }
    andThen(s) {
      return new r();
    }
    or(s) {
      return s;
    }
    orElse(s) {
      return s();
    }
    and(s) {
      return new r();
    }
    unwrapOr(s) {
      return s;
    }
    unwrap() {
      throw new ReferenceError("Trying to unwrap None.");
    }
  }
  function n(i) {
    return new t(i);
  }
  e.Some = n, e.None = new r();
  function o(i) {
    return i.isSome();
  }
  e.isSome = o;
  function a(i) {
    return i.isNone();
  }
  e.isNone = a;
})(Po);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.u8 = e.U8_MAX_BIGINT = void 0;
  const t = Po;
  e.U8_MAX_BIGINT = 0xffn;
  function r(n) {
    return (typeof n == "bigint" ? n : BigInt(n)) & e.U8_MAX_BIGINT;
  }
  e.u8 = r, function(n) {
    n.MAX = n(e.U8_MAX_BIGINT);
    function o(i, s) {
      const u = i + s;
      return u > n.MAX ? t.None : (0, t.Some)(n(u));
    }
    n.checkedAdd = o;
    function a(i, s) {
      const u = i - s;
      return u < 0n ? t.None : (0, t.Some)(n(u));
    }
    n.checkedSub = a;
  }(r || (e.u8 = r = {}));
})(f5);
var d5 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.u32 = e.U32_MAX_BIGINT = void 0;
  const t = Po;
  e.U32_MAX_BIGINT = 0xffffffffn;
  function r(n) {
    return (typeof n == "bigint" ? n : BigInt(n)) & e.U32_MAX_BIGINT;
  }
  e.u32 = r, function(n) {
    n.MAX = n(e.U32_MAX_BIGINT);
    function o(i, s) {
      const u = i + s;
      return u > n.MAX ? t.None : (0, t.Some)(n(u));
    }
    n.checkedAdd = o;
    function a(i, s) {
      const u = i - s;
      return u < 0n ? t.None : (0, t.Some)(n(u));
    }
    n.checkedSub = a;
  }(r || (e.u32 = r = {}));
})(d5);
var h5 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.u64 = e.U64_MAX_BIGINT = void 0;
  const t = Po;
  e.U64_MAX_BIGINT = 0xffffffffffffffffn;
  function r(n) {
    return (typeof n == "bigint" ? n : BigInt(n)) & e.U64_MAX_BIGINT;
  }
  e.u64 = r, function(n) {
    n.MAX = n(e.U64_MAX_BIGINT);
    function o(i, s) {
      const u = i + s;
      return u > n.MAX ? t.None : (0, t.Some)(n(u));
    }
    n.checkedAdd = o;
    function a(i, s) {
      const u = i - s;
      return u < 0n ? t.None : (0, t.Some)(n(u));
    }
    n.checkedSub = a;
  }(r || (e.u64 = r = {}));
})(h5);
var pT = {}, Up = {};
Object.defineProperty(Up, "__esModule", { value: !0 });
Up.SeekBuffer = void 0;
class GQ {
  constructor(t) {
    this.buffer = t, this.seekIndex = 0;
  }
  readUInt8() {
    if (!this.isFinished())
      return this.buffer.readUInt8(this.seekIndex++);
  }
  isFinished() {
    return this.seekIndex >= this.buffer.length;
  }
}
Up.SeekBuffer = GQ;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getAllU128 = e.u128 = e.U128_MAX_BIGINT = void 0;
  const t = Po, r = Up, n = h5, o = d5, a = f5;
  e.U128_MAX_BIGINT = 0xffffffffffffffffffffffffffffffffn;
  function i(u) {
    return (typeof u == "bigint" ? u : BigInt(u)) & e.U128_MAX_BIGINT;
  }
  e.u128 = i, function(u) {
    u.MAX = u(e.U128_MAX_BIGINT);
    function l(I, O) {
      const z = I + O;
      return z > u.MAX ? t.None : (0, t.Some)(u(z));
    }
    u.checkedAdd = l;
    function c(I, O) {
      const z = u.checkedAdd(I, O);
      if (z.isNone())
        throw new Error("checked add overflow");
      return z.unwrap();
    }
    u.checkedAddThrow = c;
    function f(I, O) {
      const z = I - O;
      return z < 0n ? t.None : (0, t.Some)(u(z));
    }
    u.checkedSub = f;
    function h(I, O) {
      const z = u.checkedSub(I, O);
      if (z.isNone())
        throw new Error("checked sub overflow");
      return z.unwrap();
    }
    u.checkedSubThrow = h;
    function p(I, O) {
      const z = I * O;
      return z > u.MAX ? t.None : (0, t.Some)(u(z));
    }
    u.checkedMultiply = p;
    function y(I, O) {
      const z = I + O;
      return z > u.MAX ? u.MAX : u(z);
    }
    u.saturatingAdd = y;
    function m(I, O) {
      const z = I * O;
      return z > u.MAX ? u.MAX : u(z);
    }
    u.saturatingMultiply = m;
    function b(I, O) {
      return u(I < O ? 0 : I - O);
    }
    u.saturatingSub = b;
    function v(I) {
      try {
        return (0, t.Some)(k(I));
      } catch {
        return t.None;
      }
    }
    u.decodeVarInt = v;
    function k(I) {
      let O = u(0);
      for (let z = 0; z <= 18; z++) {
        const D = I.readUInt8();
        if (D === void 0)
          throw new Error("Unterminated");
        const G = u(D) & 127n;
        if (z === 18 && (G & 124n) !== 0n)
          throw new Error("Overflow");
        if (O = u(O | G << u(7 * z)), !(D & 128))
          return O;
      }
      throw new Error("Overlong");
    }
    u.tryDecodeVarInt = k;
    function E(I) {
      const O = [];
      for (; I >> 7n > 0n; )
        O.push(Number(I & 0xffn) | 128), I = u(I >> 7n);
      return O.push(Number(I & 0xffn)), Buffer.from(O);
    }
    u.encodeVarInt = E;
    function A(I) {
      return I > n.u64.MAX ? t.None : (0, t.Some)((0, n.u64)(I));
    }
    u.tryIntoU64 = A;
    function S(I) {
      return I > o.u32.MAX ? t.None : (0, t.Some)((0, o.u32)(I));
    }
    u.tryIntoU32 = S;
    function _(I) {
      return I > a.u8.MAX ? t.None : (0, t.Some)((0, a.u8)(I));
    }
    u.tryIntoU8 = _;
  }(i || (e.u128 = i = {}));
  function* s(u) {
    const l = new r.SeekBuffer(u);
    for (; !l.isFinished(); ) {
      const c = i.tryDecodeVarInt(l);
      if (c === void 0)
        return;
      yield c;
    }
  }
  e.getAllU128 = s;
})(pT);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.u128 = e.u64 = e.u32 = e.u8 = void 0;
  var t = f5;
  Object.defineProperty(e, "u8", { enumerable: !0, get: function() {
    return t.u8;
  } });
  var r = d5;
  Object.defineProperty(e, "u32", { enumerable: !0, get: function() {
    return r.u32;
  } });
  var n = h5;
  Object.defineProperty(e, "u64", { enumerable: !0, get: function() {
    return n.u64;
  } });
  var o = pT;
  Object.defineProperty(e, "u128", { enumerable: !0, get: function() {
    return o.u128;
  } });
})(To);
var zu = {};
Object.defineProperty(zu, "__esModule", { value: !0 });
zu.script = zu.opcodes = void 0;
var ah;
(function(e) {
  function t(o) {
    return o < qo.OP_PUSHDATA1 ? 1 : o <= 255 ? 2 : o <= 65535 ? 3 : 5;
  }
  e.encodingLength = t;
  function r(o, a, i) {
    const s = t(a);
    return s === 1 ? o.writeUInt8(a, i) : s === 2 ? (o.writeUInt8(qo.OP_PUSHDATA1, i), o.writeUInt8(a, i + 1)) : s === 3 ? (o.writeUInt8(qo.OP_PUSHDATA2, i), o.writeUInt16LE(a, i + 1)) : (o.writeUInt8(qo.OP_PUSHDATA4, i), o.writeUInt32LE(a, i + 1)), s;
  }
  e.encode = r;
  function n(o, a) {
    const i = o.readUInt8(a);
    let s, u;
    if (i < qo.OP_PUSHDATA1)
      s = i, u = 1;
    else if (i === qo.OP_PUSHDATA1) {
      if (a + 2 > o.length)
        return null;
      s = o.readUInt8(a + 1), u = 2;
    } else if (i === qo.OP_PUSHDATA2) {
      if (a + 3 > o.length)
        return null;
      s = o.readUInt16LE(a + 1), u = 3;
    } else {
      if (a + 5 > o.length)
        return null;
      if (i !== qo.OP_PUSHDATA4)
        throw new Error("Unexpected opcode");
      s = o.readUInt32LE(a + 1), u = 5;
    }
    return {
      opcode: i,
      number: s,
      size: u
    };
  }
  e.decode = n;
})(ah || (ah = {}));
const qo = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
zu.opcodes = qo;
qo.OP_RESERVED;
function QE(e) {
  return Buffer.isBuffer(e);
}
var e7;
(function(e) {
  function t(n) {
    const o = n.reduce((s, u) => QE(u) ? s + ah.encodingLength(u.length) + u.length : s + 1, 0), a = Buffer.allocUnsafe(o);
    let i = 0;
    if (n.forEach((s) => {
      QE(s) ? (i += ah.encode(a, s.length, i), s.copy(a, i), i += s.length) : (a.writeUInt8(s, i), i += 1);
    }), i !== a.length)
      throw new Error("Could not decode chunks");
    return a;
  }
  e.compile = t;
  function* r(n) {
    let o = 0;
    for (; o < n.length; ) {
      const a = n[o];
      if (a >= qo.OP_0 && a <= qo.OP_PUSHDATA4) {
        const i = ah.decode(n, o);
        if (i === null || (o += i.size, o + i.number > n.length))
          return !1;
        const s = n.slice(o, o + i.number);
        o += i.number, yield s;
      } else
        yield a, o += 1;
    }
    return !0;
  }
  e.decompile = r;
})(e7 || (zu.script = e7 = {}));
Object.defineProperty(er, "__esModule", { value: !0 });
er.TAPROOT_SCRIPT_PUBKEY_TYPE = er.COMMIT_CONFIRMATIONS = er.TAPROOT_ANNEX_PREFIX = er.MAGIC_NUMBER = er.OP_RETURN = er.MAX_SCRIPT_ELEMENT_SIZE = er.SUBSIDY_HALVING_INTERVAL = er.RESERVED = er.MAX_DIVISIBILITY = void 0;
const gT = To, mT = zu;
er.MAX_DIVISIBILITY = (0, gT.u8)(38);
er.RESERVED = (0, gT.u128)(6402364363415443603228541259936211926n);
er.SUBSIDY_HALVING_INTERVAL = 21e4;
er.MAX_SCRIPT_ELEMENT_SIZE = 520;
er.OP_RETURN = mT.opcodes.OP_RETURN;
er.MAGIC_NUMBER = mT.opcodes.OP_13;
er.TAPROOT_ANNEX_PREFIX = 80;
er.COMMIT_CONFIRMATIONS = 6;
er.TAPROOT_SCRIPT_PUBKEY_TYPE = "witness_v1_taproot";
var Rp = {};
Object.defineProperty(Rp, "__esModule", { value: !0 });
Rp.Etching = void 0;
const t7 = Po, jd = To;
class ZQ {
  constructor(t, r, n, o, a, i, s) {
    this.divisibility = t, this.rune = r, this.spacers = n, this.terms = a, this.premine = i, this.turbo = s, this.symbol = o.andThen((u) => {
      const l = u.codePointAt(0);
      return l !== void 0 ? (0, t7.Some)(String.fromCodePoint(l)) : t7.None;
    });
  }
  get supply() {
    const t = this.premine.unwrapOr((0, jd.u128)(0)), r = this.terms.andThen((o) => o.cap).unwrapOr((0, jd.u128)(0)), n = this.terms.andThen((o) => o.amount).unwrapOr((0, jd.u128)(0));
    return jd.u128.checkedMultiply(r, n).andThen((o) => jd.u128.checkedAdd(t, o));
  }
}
Rp.Etching = ZQ;
var id = {};
Object.defineProperty(id, "__esModule", { value: !0 });
id.Flaw = void 0;
var r7;
(function(e) {
  e[e.EDICT_OUTPUT = 0] = "EDICT_OUTPUT", e[e.EDICT_RUNE_ID = 1] = "EDICT_RUNE_ID", e[e.INVALID_SCRIPT = 2] = "INVALID_SCRIPT", e[e.OPCODE = 3] = "OPCODE", e[e.SUPPLY_OVERFLOW = 4] = "SUPPLY_OVERFLOW", e[e.TRAILING_INTEGERS = 5] = "TRAILING_INTEGERS", e[e.TRUNCATED_FIELD = 6] = "TRUNCATED_FIELD", e[e.UNRECOGNIZED_EVEN_TAG = 7] = "UNRECOGNIZED_EVEN_TAG", e[e.UNRECOGNIZED_FLAG = 8] = "UNRECOGNIZED_FLAG", e[e.VARINT = 9] = "VARINT";
})(r7 || (id.Flaw = r7 = {}));
var ad = {};
Object.defineProperty(ad, "__esModule", { value: !0 });
ad.RuneId = void 0;
const Ks = Po, qi = To;
let WQ = class _1 {
  constructor(t, r) {
    this.block = t, this.tx = r;
  }
  static new(t, r) {
    const n = new _1(t, r);
    return n.block === 0n && n.tx > 0 ? Ks.None : (0, Ks.Some)(n);
  }
  static sort(t) {
    return [...t].sort((r, n) => Number(r.block - n.block || r.tx - n.tx));
  }
  delta(t) {
    const r = qi.u64.checkedSub(t.block, this.block);
    if (r.isNone())
      return Ks.None;
    const n = r.unwrap();
    let o;
    if (n === 0n) {
      const a = qi.u32.checkedSub(t.tx, this.tx);
      if (a.isNone())
        return Ks.None;
      o = a.unwrap();
    } else
      o = t.tx;
    return (0, Ks.Some)([(0, qi.u128)(n), (0, qi.u128)(o)]);
  }
  next(t, r) {
    const n = qi.u128.tryIntoU64(t), o = qi.u128.tryIntoU32(r);
    if (n.isNone() || o.isNone())
      return Ks.None;
    const a = n.unwrap(), i = o.unwrap(), s = qi.u64.checkedAdd(this.block, a);
    if (s.isNone())
      return Ks.None;
    let u;
    if (a === 0n) {
      const l = qi.u32.checkedAdd(this.tx, i);
      if (l.isNone())
        return Ks.None;
      u = l.unwrap();
    } else
      u = i;
    return _1.new(s.unwrap(), u);
  }
  toString() {
    return `${this.block}:${this.tx}`;
  }
  static fromString(t) {
    const r = t.split(":");
    if (r.length !== 2)
      throw new Error(`invalid rune ID: ${t}`);
    const [n, o] = r;
    if (!/^\d+$/.test(n) || !/^\d+$/.test(o))
      throw new Error(`invalid rune ID: ${t}`);
    return new _1((0, qi.u64)(BigInt(n)), (0, qi.u32)(BigInt(o)));
  }
};
ad.RuneId = WQ;
var p5 = {}, sd = {};
Object.defineProperty(sd, "__esModule", { value: !0 });
sd.Tag = void 0;
const C0 = Po, Cl = To;
var Tg;
(function(e) {
  e[e.BODY = 0] = "BODY", e[e.FLAGS = 2] = "FLAGS", e[e.RUNE = 4] = "RUNE", e[e.PREMINE = 6] = "PREMINE", e[e.CAP = 8] = "CAP", e[e.AMOUNT = 10] = "AMOUNT", e[e.HEIGHT_START = 12] = "HEIGHT_START", e[e.HEIGHT_END = 14] = "HEIGHT_END", e[e.OFFSET_START = 16] = "OFFSET_START", e[e.OFFSET_END = 18] = "OFFSET_END", e[e.MINT = 20] = "MINT", e[e.POINTER = 22] = "POINTER", e[e.CENOTAPH = 126] = "CENOTAPH", e[e.DIVISIBILITY = 1] = "DIVISIBILITY", e[e.SPACERS = 3] = "SPACERS", e[e.SYMBOL = 5] = "SYMBOL", e[e.NOP = 127] = "NOP";
})(Tg || (sd.Tag = Tg = {}));
(function(e) {
  function t(o, a, i, s) {
    const u = a.get((0, Cl.u128)(o));
    if (u === void 0)
      return C0.None;
    const l = [];
    for (const f of [...Array(i).keys()]) {
      if (u[f] === void 0)
        return C0.None;
      l[f] = u[f];
    }
    const c = s(l);
    return c.isNone() ? C0.None : (u.splice(0, i), u.length === 0 && a.delete((0, Cl.u128)(o)), (0, C0.Some)(c.unwrap()));
  }
  e.take = t;
  function r(o, a) {
    return Buffer.concat(a.map((i) => [Cl.u128.encodeVarInt((0, Cl.u128)(o)), Cl.u128.encodeVarInt(i)]).flat());
  }
  e.encode = r;
  function n(o, a) {
    return a.map((i) => e.encode(o, [(0, Cl.u128)(i)])).unwrapOr(Buffer.alloc(0));
  }
  e.encodeOptionInt = n;
})(Tg || (sd.Tag = Tg = {}));
var ud = {}, dl = {};
Object.defineProperty(dl, "__esModule", { value: !0 });
dl.Network = void 0;
const B0 = er;
var Pg;
(function(e) {
  e[e.MAINNET = 0] = "MAINNET", e[e.SIGNET = 1] = "SIGNET", e[e.TESTNET = 2] = "TESTNET", e[e.REGTEST = 3] = "REGTEST";
})(Pg || (dl.Network = Pg = {}));
(function(e) {
  function t(r) {
    switch (r) {
      case e.MAINNET:
        return B0.SUBSIDY_HALVING_INTERVAL * 4;
      case e.REGTEST:
        return B0.SUBSIDY_HALVING_INTERVAL * 0;
      case e.SIGNET:
        return B0.SUBSIDY_HALVING_INTERVAL * 0;
      case e.TESTNET:
        return B0.SUBSIDY_HALVING_INTERVAL * 12;
    }
  }
  e.getFirstRuneHeight = t;
})(Pg || (dl.Network = Pg = {}));
Object.defineProperty(ud, "__esModule", { value: !0 });
ud.Rune = void 0;
const XQ = dl, N0 = er, Pe = To;
let yT = class La {
  constructor(t) {
    this.value = t;
  }
  static getMinimumAtHeight(t, r) {
    let n = Pe.u128.saturatingAdd(r, (0, Pe.u128)(1));
    const o = (0, Pe.u128)(N0.SUBSIDY_HALVING_INTERVAL / 12);
    let a = (0, Pe.u128)(XQ.Network.getFirstRuneHeight(t)), i = Pe.u128.saturatingAdd(a, (0, Pe.u128)(N0.SUBSIDY_HALVING_INTERVAL));
    if (n < a)
      return new La(La.STEPS[12]);
    if (n >= i)
      return new La((0, Pe.u128)(0));
    let s = Pe.u128.saturatingSub(n, a), u = Pe.u128.saturatingSub((0, Pe.u128)(12n), (0, Pe.u128)(s / o)), l = Number(u & (0, Pe.u128)(Pe.u32.MAX)), c = La.STEPS[l], f = La.STEPS[l - 1], h = (0, Pe.u128)(s % o);
    return new La((0, Pe.u128)(c - (c - f) * h / o));
  }
  get reserved() {
    return this.value >= N0.RESERVED;
  }
  get commitment() {
    const t = Buffer.alloc(16);
    t.writeBigUInt64LE(0xffffffffffffffffn & this.value, 0), t.writeBigUInt64LE(this.value >> 64n, 8);
    let r = t.length;
    for (; r > 0 && t.at(r - 1) === 0; )
      r--;
    return t.subarray(0, r);
  }
  static getReserved(t, r) {
    return new La(Pe.u128.checkedAdd(N0.RESERVED, (0, Pe.u128)(t << 32n | r)).unwrap());
  }
  toString() {
    let t = this.value;
    if (t === Pe.u128.MAX)
      return "BCGDENLQRQWDSLRUGSNLBTMFIJAV";
    t = (0, Pe.u128)(t + 1n);
    let r = "";
    for (; t > 0; )
      r = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Number((t - 1n) % 26n)] + r, t = (0, Pe.u128)((t - 1n) / 26n);
    return r;
  }
  static fromString(t) {
    let r = (0, Pe.u128)(0);
    for (const n of [...Array(t.length).keys()]) {
      const o = t[n];
      if (n > 0 && (r = (0, Pe.u128)(r + 1n)), r = Pe.u128.checkedMultiply(r, (0, Pe.u128)(26)).unwrap(), "A" <= o && o <= "Z")
        r = Pe.u128.checkedAdd(r, (0, Pe.u128)(o.charCodeAt(0) - 65)).unwrap();
      else
        throw new Error(`invalid character in rune name: ${o}`);
    }
    return new La(r);
  }
};
ud.Rune = yT;
yT.STEPS = [
  (0, Pe.u128)(0n),
  (0, Pe.u128)(26n),
  (0, Pe.u128)(702n),
  (0, Pe.u128)(18278n),
  (0, Pe.u128)(475254n),
  (0, Pe.u128)(12356630n),
  (0, Pe.u128)(321272406n),
  (0, Pe.u128)(8353082582n),
  (0, Pe.u128)(217180147158n),
  (0, Pe.u128)(5646683826134n),
  (0, Pe.u128)(146813779479510n),
  (0, Pe.u128)(3817158266467286n),
  (0, Pe.u128)(99246114928149462n),
  (0, Pe.u128)(2580398988131886038n),
  (0, Pe.u128)(67090373691429037014n),
  (0, Pe.u128)(1744349715977154962390n),
  (0, Pe.u128)(45353092615406029022166n),
  (0, Pe.u128)(1179180408000556754576342n),
  (0, Pe.u128)(30658690608014475618984918n),
  (0, Pe.u128)(797125955808376366093607894n),
  (0, Pe.u128)(20725274851017785518433805270n),
  (0, Pe.u128)(538857146126462423479278937046n),
  (0, Pe.u128)(14010285799288023010461252363222n),
  (0, Pe.u128)(364267430781488598271992561443798n),
  (0, Pe.u128)(9470953200318703555071806597538774n),
  (0, Pe.u128)(246244783208286292431866971536008150n),
  (0, Pe.u128)(6402364363415443603228541259936211926n),
  (0, Pe.u128)(166461473448801533683942072758341510102n)
];
var zp = {};
Object.defineProperty(zp, "__esModule", { value: !0 });
zp.Flag = void 0;
const _2 = To;
var Og;
(function(e) {
  e[e.ETCHING = 0] = "ETCHING", e[e.TERMS = 1] = "TERMS", e[e.TURBO = 2] = "TURBO", e[e.CENOTAPH = 127] = "CENOTAPH";
})(Og || (zp.Flag = Og = {}));
(function(e) {
  function t(o) {
    return (0, _2.u128)(1n << BigInt(o));
  }
  e.mask = t;
  function r(o, a) {
    const i = e.mask(a), s = (o & i) !== 0n;
    return { set: s, flags: s ? (0, _2.u128)(o - i) : o };
  }
  e.take = r;
  function n(o, a) {
    return (0, _2.u128)(o | e.mask(a));
  }
  e.set = n;
})(Og || (zp.Flag = Og = {}));
var py = {};
Object.defineProperty(py, "__esModule", { value: !0 });
py.Instruction = void 0;
var n7;
(function(e) {
  function t(n) {
    return typeof n == "number";
  }
  e.isNumber = t;
  function r(n) {
    return typeof n != "number";
  }
  e.isBuffer = r;
})(n7 || (py.Instruction = n7 = {}));
var gy = {}, my = {};
Object.defineProperty(my, "__esModule", { value: !0 });
my.Edict = void 0;
const U0 = Po, YQ = To;
var o7;
(function(e) {
  function t(r, n, o, a) {
    if (n.block === 0n && n.tx > 0n)
      return U0.None;
    const i = YQ.u128.tryIntoU32(a);
    if (i.isNone())
      return U0.None;
    const s = i.unwrap();
    return s > r ? U0.None : (0, U0.Some)({ id: n, amount: o, output: s });
  }
  e.fromIntegers = t;
})(o7 || (my.Edict = o7 = {}));
Object.defineProperty(gy, "__esModule", { value: !0 });
gy.Message = void 0;
const JQ = my, R0 = id, I2 = To, QQ = ad, eee = sd;
let tee = class bT {
  constructor(t, r, n) {
    this.flaws = t, this.edicts = r, this.fields = n;
  }
  static fromIntegers(t, r) {
    const n = [], o = /* @__PURE__ */ new Map(), a = [];
    for (const i of [...Array(Math.ceil(r.length / 2)).keys()].map((s) => s * 2)) {
      const s = r[i];
      if ((0, I2.u128)(eee.Tag.BODY) === s) {
        let c = new QQ.RuneId((0, I2.u64)(0), (0, I2.u32)(0));
        const f = 4, h = r.slice(i + 1);
        for (let p = 0; p < h.length; p += f) {
          const y = h.slice(p, p + f);
          if (y.length !== f) {
            a.push(R0.Flaw.TRAILING_INTEGERS);
            break;
          }
          const m = c.next(y[0], y[1]);
          if (m.isNone()) {
            a.push(R0.Flaw.EDICT_RUNE_ID);
            break;
          }
          const b = m.unwrap(), v = JQ.Edict.fromIntegers(t, b, y[2], y[3]);
          if (v.isNone()) {
            a.push(R0.Flaw.EDICT_OUTPUT);
            break;
          }
          const k = v.unwrap();
          c = b, n.push(k);
        }
        break;
      }
      const u = r[i + 1];
      if (u === void 0) {
        a.push(R0.Flaw.TRUNCATED_FIELD);
        break;
      }
      const l = o.get(s) ?? [];
      l.push(u), o.set(s, l);
    }
    return new bT(a, n, o);
  }
};
gy.Message = tee;
var yy = {};
Object.defineProperty(yy, "__esModule", { value: !0 });
yy.Cenotaph = void 0;
const i7 = Po;
class ree {
  constructor(t, r = i7.None, n = i7.None) {
    this.flaws = t, this.etching = r, this.mint = n;
  }
}
yy.Cenotaph = ree;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Runestone = e.isValidPayload = e.MAX_SPACERS = void 0;
  const t = er, r = Rp, n = Up, o = sd, a = To, i = Po, s = ud, u = zp, l = py, c = ad, f = zu, h = gy, p = id, y = yy;
  e.MAX_SPACERS = 134217727;
  function m(v) {
    return Buffer.isBuffer(v);
  }
  e.isValidPayload = m;
  class b {
    constructor(k, E, A, S) {
      this.mint = k, this.pointer = E, this.edicts = A, this.etching = S;
    }
    static decipher(k) {
      const E = b.payload(k);
      if (E.isNone())
        return i.None;
      const A = E.unwrap();
      if (!m(A))
        return (0, i.Some)(new y.Cenotaph([A]));
      const S = b.integers(A);
      if (S.isNone())
        return (0, i.Some)(new y.Cenotaph([p.Flaw.VARINT]));
      const { flaws: _, edicts: I, fields: O } = h.Message.fromIntegers(k.vout.length, S.unwrap());
      let z = o.Tag.take(o.Tag.FLAGS, O, 1, ([C]) => (0, i.Some)(C)).unwrapOr((0, a.u128)(0));
      const D = u.Flag.take(z, u.Flag.ETCHING), G = D.set;
      z = D.flags;
      const U = G ? (() => {
        const C = o.Tag.take(o.Tag.DIVISIBILITY, O, 1, ([Ae]) => a.u128.tryIntoU8(Ae).andThen((ye) => ye <= t.MAX_DIVISIBILITY ? (0, i.Some)(ye) : i.None)), R = o.Tag.take(o.Tag.RUNE, O, 1, ([Ae]) => (0, i.Some)(new s.Rune(Ae))), M = o.Tag.take(o.Tag.SPACERS, O, 1, ([Ae]) => a.u128.tryIntoU32(Ae).andThen((ye) => ye <= e.MAX_SPACERS ? (0, i.Some)(ye) : i.None)), re = o.Tag.take(o.Tag.SYMBOL, O, 1, ([Ae]) => a.u128.tryIntoU32(Ae).andThen((ye) => {
          try {
            return (0, i.Some)(String.fromCodePoint(Number(ye)));
          } catch {
            return i.None;
          }
        })), W = u.Flag.take(z, u.Flag.TERMS), ne = W.set;
        z = W.flags;
        const oe = ne ? (() => {
          const Ae = o.Tag.take(o.Tag.AMOUNT, O, 1, ([be]) => (0, i.Some)(be)), ye = o.Tag.take(o.Tag.CAP, O, 1, ([be]) => (0, i.Some)(be)), Et = [
            o.Tag.take(o.Tag.OFFSET_START, O, 1, ([be]) => a.u128.tryIntoU64(be)),
            o.Tag.take(o.Tag.OFFSET_END, O, 1, ([be]) => a.u128.tryIntoU64(be))
          ], Ge = [
            o.Tag.take(o.Tag.HEIGHT_START, O, 1, ([be]) => a.u128.tryIntoU64(be)),
            o.Tag.take(o.Tag.HEIGHT_END, O, 1, ([be]) => a.u128.tryIntoU64(be))
          ];
          return (0, i.Some)({ amount: Ae, cap: ye, offset: Et, height: Ge });
        })() : i.None, se = o.Tag.take(o.Tag.PREMINE, O, 1, ([Ae]) => (0, i.Some)(Ae)), K = u.Flag.take(z, u.Flag.TURBO), he = D.set;
        return z = K.flags, (0, i.Some)(new r.Etching(C, R, M, re, oe, se, he));
      })() : i.None, V = o.Tag.take(o.Tag.MINT, O, 2, ([C, R]) => {
        const M = a.u128.tryIntoU64(C), re = a.u128.tryIntoU32(R);
        return M.isNone() || re.isNone() ? i.None : c.RuneId.new(M.unwrap(), re.unwrap());
      }), F = o.Tag.take(o.Tag.POINTER, O, 1, ([C]) => a.u128.tryIntoU32(C).andThen((R) => R < k.vout.length ? (0, i.Some)(R) : i.None));
      return U.map((C) => C.supply.isNone()).unwrapOr(!1) && _.push(p.Flaw.SUPPLY_OVERFLOW), z !== 0n && _.push(p.Flaw.UNRECOGNIZED_FLAG), [...O.keys()].find((C) => C % 2n === 0n) !== void 0 && _.push(p.Flaw.UNRECOGNIZED_EVEN_TAG), _.length !== 0 ? (0, i.Some)(new y.Cenotaph(_, U.andThen((C) => C.rune), V)) : (0, i.Some)(new b(V, F, I, U));
    }
    encipher() {
      const k = [];
      if (this.etching.isSome()) {
        const S = this.etching.unwrap();
        let _ = (0, a.u128)(0);
        if (_ = u.Flag.set(_, u.Flag.ETCHING), S.terms.isSome() && (_ = u.Flag.set(_, u.Flag.TERMS)), S.turbo && (_ = u.Flag.set(_, u.Flag.TURBO)), k.push(o.Tag.encode(o.Tag.FLAGS, [_])), k.push(o.Tag.encodeOptionInt(o.Tag.RUNE, S.rune.map((I) => I.value))), k.push(o.Tag.encodeOptionInt(o.Tag.DIVISIBILITY, S.divisibility.map(a.u128))), k.push(o.Tag.encodeOptionInt(o.Tag.SPACERS, S.spacers.map(a.u128))), k.push(o.Tag.encodeOptionInt(o.Tag.SYMBOL, S.symbol.map((I) => (0, a.u128)(I.codePointAt(0))))), k.push(o.Tag.encodeOptionInt(o.Tag.PREMINE, S.premine)), S.terms.isSome()) {
          const I = S.terms.unwrap();
          k.push(o.Tag.encodeOptionInt(o.Tag.AMOUNT, I.amount)), k.push(o.Tag.encodeOptionInt(o.Tag.CAP, I.cap)), k.push(o.Tag.encodeOptionInt(o.Tag.HEIGHT_START, I.height[0])), k.push(o.Tag.encodeOptionInt(o.Tag.HEIGHT_END, I.height[1])), k.push(o.Tag.encodeOptionInt(o.Tag.OFFSET_START, I.offset[0])), k.push(o.Tag.encodeOptionInt(o.Tag.OFFSET_END, I.offset[1]));
        }
      }
      if (this.mint.isSome()) {
        const S = this.mint.unwrap();
        k.push(o.Tag.encode(o.Tag.MINT, [S.block, S.tx].map(a.u128)));
      }
      if (k.push(o.Tag.encodeOptionInt(o.Tag.POINTER, this.pointer.map(a.u128))), this.edicts.length) {
        k.push(a.u128.encodeVarInt((0, a.u128)(o.Tag.BODY)));
        const S = [...this.edicts].sort((I, O) => Number(I.id.block - O.id.block || I.id.tx - O.id.tx));
        let _ = new c.RuneId((0, a.u64)(0), (0, a.u32)(0));
        for (const I of S) {
          const [O, z] = _.delta(I.id).unwrap();
          k.push(a.u128.encodeVarInt(O)), k.push(a.u128.encodeVarInt(z)), k.push(a.u128.encodeVarInt(I.amount)), k.push(a.u128.encodeVarInt((0, a.u128)(I.output))), _ = I.id;
        }
      }
      const E = [];
      E.push(t.OP_RETURN), E.push(t.MAGIC_NUMBER);
      const A = Buffer.concat(k);
      for (let S = 0; S < A.length; S += t.MAX_SCRIPT_ELEMENT_SIZE)
        E.push(A.subarray(S, S + t.MAX_SCRIPT_ELEMENT_SIZE));
      return f.script.compile(E);
    }
    static payload(k) {
      for (const E of k.vout) {
        const A = f.script.decompile(Buffer.from(E.scriptPubKey.hex, "hex"));
        if (A === null)
          throw new Error("unable to decompile");
        let S = A.next();
        if (S.done || S.value !== t.OP_RETURN || (S = A.next(), S.done || l.Instruction.isBuffer(S.value) || S.value !== t.MAGIC_NUMBER))
          continue;
        let _ = [];
        do {
          if (S = A.next(), S.done) {
            if (!S.value)
              return (0, i.Some)(p.Flaw.INVALID_SCRIPT);
            break;
          }
          const I = S.value;
          if (l.Instruction.isBuffer(I))
            _.push(I);
          else
            return (0, i.Some)(p.Flaw.OPCODE);
        } while (!0);
        return (0, i.Some)(Buffer.concat(_));
      }
      return i.None;
    }
    static integers(k) {
      const E = [], A = new n.SeekBuffer(k);
      for (; !A.isFinished(); ) {
        const S = a.u128.decodeVarInt(A);
        if (S.isNone())
          return i.None;
        E.push(S.unwrap());
      }
      return (0, i.Some)(E);
    }
  }
  e.Runestone = b;
})(p5);
var jp = {};
Object.defineProperty(jp, "__esModule", { value: !0 });
jp.SpacedRune = void 0;
const nee = ud;
let oee = class wT {
  constructor(t, r) {
    this.rune = t, this.spacers = r;
  }
  static fromString(t) {
    let r = "", n = 0;
    for (const o of t)
      if ("A" <= o && o <= "Z")
        r += o;
      else if (o === "." || o === "") {
        if (r.length === 0)
          throw new Error("leading spacer");
        const a = 1 << r.length - 1;
        if (n & a)
          throw new Error("double spacer");
        n |= a;
      } else
        throw new Error("invalid character");
    if (n >= 1 << r.length - 1)
      throw new Error("trailing spacer");
    return new wT(nee.Rune.fromString(r), n);
  }
  toString() {
    const t = this.rune.toString();
    let r = 0, n = "";
    for (const o of t)
      n += o, r < t.length - 1 && this.spacers & 1 << r && (n += ""), r++;
    return n;
  }
};
jp.SpacedRune = oee;
var vT = {}, Fh = {}, Lp = {};
Object.defineProperty(Lp, "__esModule", { value: !0 });
Lp.RuneLocation = void 0;
var a7;
(function(e) {
  function t(r) {
    return `${r.block}:${r.tx}`;
  }
  e.toString = t;
})(a7 || (Lp.RuneLocation = a7 = {}));
Object.defineProperty(Fh, "__esModule", { value: !0 });
Fh.RuneUpdater = void 0;
const Ld = Np, I1 = er, lt = To, go = Po, s7 = ud, iee = p5, aee = zu, u7 = jp, Ca = Lp;
function T2(e) {
  return e && Buffer.from(e, "hex")[0] === I1.OP_RETURN;
}
class see {
  constructor(t, r, n, o, a) {
    this.reorg = n, this._storage = o, this._rpc = a, this.etchings = [], this.utxoBalances = [], this.spentBalances = [], this._mintCountsByRuneLocation = /* @__PURE__ */ new Map(), this._burnedBalancesByRuneLocation = /* @__PURE__ */ new Map(), this.block = {
      height: r.height,
      hash: r.hash,
      previousblockhash: r.previousblockhash,
      time: r.time
    }, this._minimum = s7.Rune.getMinimumAtHeight(t, (0, lt.u128)(r.height));
  }
  get mintCounts() {
    return [...this._mintCountsByRuneLocation.values()];
  }
  get burnedBalances() {
    return [...this._burnedBalancesByRuneLocation.values()];
  }
  async indexRunes(t, r) {
    const n = iee.Runestone.decipher(t), o = await this.unallocated(t), a = [...new Array(t.vout.length)].map(() => /* @__PURE__ */ new Map());
    function i(c) {
      const f = Ca.RuneLocation.toString(c), h = o.get(f) ?? { runeId: c, amount: 0n };
      return o.set(f, h), h;
    }
    function s(c, f) {
      const h = Ca.RuneLocation.toString(f), p = a[c].get(h) ?? { runeId: f, amount: 0n };
      return a[c].set(h, p), p;
    }
    if (n.isSome()) {
      const c = n.unwrap(), f = c.mint;
      if (f.isSome()) {
        const p = f.unwrap(), y = {
          block: Number(p.block),
          tx: Number(p.tx)
        }, m = await this.mint(y, t.txid);
        if (m.isSome()) {
          const b = m.unwrap(), v = i(y);
          v.amount = lt.u128.checkedAddThrow((0, lt.u128)(v.amount), (0, lt.u128)(b));
        }
      }
      const h = await this.etched(r, t, c);
      if ((0, Ld.isRunestone)(c)) {
        const p = c;
        if (h.isSome()) {
          const y = h.unwrap(), m = i(y.runeId);
          m.amount = lt.u128.checkedAddThrow((0, lt.u128)(m.amount), p.etching.unwrap().premine.unwrapOr((0, lt.u128)(0)));
        }
        for (const { id: y, amount: m, output: b } of [...p.edicts]) {
          if (b > t.vout.length)
            throw new Error("Runestone edict output should never exceed transaction output size");
          if (y.block === 0n && y.tx === 0n && h.isNone())
            continue;
          const v = y.block === 0n && y.tx === 0n ? h.unwrap().runeId : { block: Number(y.block), tx: Number(y.tx) }, k = Ca.RuneLocation.toString(v), E = o.get(k);
          if (E === void 0)
            continue;
          let A = (S, _) => {
            if (S > 0n) {
              const I = s(_, v);
              E.amount = lt.u128.checkedSubThrow((0, lt.u128)(E.amount), S), I.amount = lt.u128.checkedAddThrow((0, lt.u128)(I.amount), S);
            }
          };
          if (Number(b) === t.vout.length) {
            const S = [...t.vout.entries()].filter(([_, I]) => !T2(I.scriptPubKey.hex)).map(([_]) => _);
            if (S.length !== 0)
              if (m === 0n) {
                const _ = (0, lt.u128)((0, lt.u128)(E.amount) / (0, lt.u128)(S.length)), I = (0, lt.u128)(E.amount) % (0, lt.u128)(S.length);
                for (const [O, z] of S.entries())
                  A(O < I ? lt.u128.checkedAddThrow(_, (0, lt.u128)(1)) : _, z);
              } else
                for (const _ of S)
                  A(m < E.amount ? m : (0, lt.u128)(E.amount), _);
          } else
            A(m !== 0n && m < (0, lt.u128)(E.amount) ? m : (0, lt.u128)(E.amount), Number(b));
        }
      }
      if (h.isSome()) {
        const { runeId: p, rune: y } = h.unwrap();
        this.createEtching(t.txid, c, p, y);
      }
    }
    const u = /* @__PURE__ */ new Map();
    function l(c) {
      const f = Ca.RuneLocation.toString(c), h = u.get(f) ?? { runeId: c, amount: 0n };
      return u.set(f, h), h;
    }
    if (n.isSome() && !(0, Ld.isRunestone)(n.unwrap()))
      for (const c of o.values()) {
        const f = l(c.runeId);
        f.amount = lt.u128.checkedAddThrow((0, lt.u128)(f.amount), (0, lt.u128)(c.amount));
      }
    else {
      const c = n.map((f) => {
        if (!(0, Ld.isRunestone)(f))
          throw new Error("unreachable");
        return f.pointer;
      }).unwrapOr(go.None).map((f) => Number(f)).inspect((f) => {
        if (f < 0 || f >= a.length)
          throw new Error("Pointer is invalid");
      }).orElse(() => {
        const f = [...t.vout.entries()].find(([h, p]) => !T2(p.scriptPubKey.hex));
        return f !== void 0 ? (0, go.Some)(f[0]) : go.None;
      });
      if (c.isSome()) {
        const f = c.unwrap();
        for (const h of o.values())
          if (h.amount > 0) {
            const p = s(f, h.runeId);
            p.amount = lt.u128.checkedAddThrow((0, lt.u128)(p.amount), (0, lt.u128)(h.amount));
          }
      } else
        for (const [f, h] of o)
          if (h.amount > 0) {
            const p = l(h.runeId);
            u.set(f, {
              runeId: h.runeId,
              amount: lt.u128.checkedAddThrow((0, lt.u128)(p.amount), (0, lt.u128)(h.amount))
            });
          }
    }
    for (const [c, f] of a.entries()) {
      if (f.size === 0)
        continue;
      const h = t.vout[c];
      if (T2(h.scriptPubKey.hex)) {
        for (const [y, m] of f) {
          const b = l(m.runeId);
          b.amount = lt.u128.checkedAddThrow((0, lt.u128)(b.amount), (0, lt.u128)(m.amount));
        }
        continue;
      }
      const p = new Map(this.etchings.map((y) => [Ca.RuneLocation.toString(y.runeId), y]));
      for (const y of f.values()) {
        const m = Ca.RuneLocation.toString(y.runeId), b = p.get(m) ?? await this._storage.getEtching(m);
        if (b === null)
          throw new Error("Rune should exist at this point");
        this.utxoBalances.push({
          runeId: y.runeId,
          runeTicker: b.runeTicker,
          amount: y.amount,
          scriptPubKey: Buffer.from(h.scriptPubKey.hex),
          txid: t.txid,
          vout: c,
          address: h.scriptPubKey.address
        });
      }
    }
    for (const [c, f] of u)
      this._burnedBalancesByRuneLocation.set(c, f);
  }
  async etched(t, r, n) {
    let o;
    if ((0, Ld.isRunestone)(n)) {
      const i = n;
      if (i.etching.isNone())
        return go.None;
      o = i.etching.unwrap().rune;
    } else {
      const i = n;
      if (i.etching.isNone())
        return go.None;
      o = i.etching;
    }
    let a;
    if (o.isSome()) {
      if (a = o.unwrap(), a.value < this._minimum.value || a.reserved || this.etchings.find((s) => u7.SpacedRune.fromString(s.runeName).rune.toString() === a.toString()))
        return go.None;
      const i = await this._storage.getRuneLocation(a.toString());
      if (i && i.block < this.block.height || !await this.txCommitsToRune(r, a))
        return go.None;
    } else
      a = s7.Rune.getReserved((0, lt.u64)(this.block.height), (0, lt.u32)(t));
    return (0, go.Some)({
      runeId: {
        block: this.block.height,
        tx: t
      },
      rune: a
    });
  }
  async mint(t, r) {
    var n, o, a, i;
    const s = Ca.RuneLocation.toString(t), u = new Map(this.etchings.map((E) => [Ca.RuneLocation.toString(E.runeId), E])).get(s) ?? await this._storage.getEtching(s);
    if (u === null || !u.valid || !u.terms)
      return go.None;
    const l = u.terms, c = ((n = l.offset) == null ? void 0 : n.start) !== void 0 ? u.runeId.block + Number(l.offset.start) : null, f = ((o = l.height) == null ? void 0 : o.start) !== void 0 ? Number(l.height.start) : null, h = c !== null || f !== null ? Math.max(c ?? -1 / 0, f ?? -1 / 0) : null;
    if (h !== null && this.block.height < h)
      return go.None;
    const p = ((a = l.offset) == null ? void 0 : a.end) !== void 0 ? u.runeId.block + Number(l.offset.end) : null, y = ((i = l.height) == null ? void 0 : i.end) !== void 0 ? Number(l.height.end) : null, m = p !== null || y !== null ? Math.max(p ?? -1 / 0, y ?? -1 / 0) : null;
    if (m !== null && this.block.height >= m)
      return go.None;
    const b = l.cap ?? 0n, v = this._mintCountsByRuneLocation.get(s) ?? {
      mint: t,
      count: 0
    };
    if (this._mintCountsByRuneLocation.set(s, v), v.count + await this._storage.getValidMintCount(s, this.block.height - 1) >= b)
      return go.None;
    const k = l.amount ?? 0n;
    return v.count++, (0, go.Some)(k);
  }
  async unallocated(t) {
    const r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    for (const o of this.utxoBalances) {
      const a = `${o.txid}:${o.vout}`, i = n.get(a) ?? [];
      i.push(o), n.set(a, i);
    }
    for (const o of t.vin) {
      if ("coinbase" in o)
        continue;
      const a = n.get(`${o.txid}:${o.vout}`) ?? await this._storage.getUtxoBalance(o.txid, o.vout);
      for (const i of a) {
        const s = i.runeId, u = Ca.RuneLocation.toString(s), l = r.get(u) ?? { runeId: s, amount: 0n };
        r.set(u, l), l.amount = lt.u128.checkedAddThrow((0, lt.u128)(l.amount), (0, lt.u128)(i.amount)), this.spentBalances.push({
          txid: o.txid,
          vout: o.vout,
          address: i.address,
          scriptPubKey: i.scriptPubKey,
          runeId: i.runeId,
          runeTicker: i.runeTicker,
          amount: i.amount,
          spentTxid: t.txid
        });
      }
    }
    return r;
  }
  async txCommitsToRune(t, r) {
    const n = r.commitment;
    for (const o of t.vin) {
      if ("coinbase" in o)
        continue;
      const a = o.txinwitness.map((c) => Buffer.from(c, "hex")), i = a[a.length - 1], s = a.length >= 2 && i[0] === I1.TAPROOT_ANNEX_PREFIX ? 3 : 2;
      if (s > a.length)
        continue;
      const u = a[a.length - s];
      if (u === void 0)
        continue;
      const l = aee.script.decompile(u);
      for (const c of l) {
        if (!Buffer.isBuffer(c) || Buffer.compare(c, n) !== 0)
          continue;
        const f = await this._rpc.getrawtransaction({
          txid: o.txid,
          verbose: !0
        });
        if (f.error !== null)
          throw f.error;
        const h = f.result;
        if (h.vout[o.vout].scriptPubKey.type !== I1.TAPROOT_SCRIPT_PUBKEY_TYPE)
          continue;
        const p = await this._rpc.getblock({ blockhash: h.blockhash });
        if (p.error !== null)
          throw p.error;
        const y = p.result.height;
        if (lt.u128.checkedSubThrow((0, lt.u128)(this.block.height), (0, lt.u128)(y)) + 1n >= I1.COMMIT_CONFIRMATIONS)
          return !0;
      }
    }
    return !1;
  }
  createEtching(t, r, n, o) {
    if ((0, Ld.isRunestone)(r)) {
      const { divisibility: a, terms: i, premine: s, spacers: u, symbol: l } = r.etching.unwrap();
      this.etchings.push({
        valid: !0,
        runeTicker: o.toString(),
        runeName: new u7.SpacedRune(o, Number(u.map(Number).unwrapOr(0))).toString(),
        runeId: n,
        txid: t,
        ...a.isSome() ? { divisibility: a.map(Number).unwrap() } : {},
        ...s.isSome() ? { premine: s.unwrap() } : {},
        ...l.isSome() ? { symbol: l.unwrap() } : {},
        ...i.isSome() ? {
          terms: (() => {
            const c = i.unwrap();
            return {
              ...c.amount.isSome() ? { amount: c.amount.unwrap() } : {},
              ...c.cap.isSome() ? { cap: c.cap.unwrap() } : {},
              ...c.height.filter((f) => f.isSome()).length ? {
                height: {
                  ...c.height[0].isSome() ? { start: c.height[0].unwrap() } : {},
                  ...c.height[1].isSome() ? { end: c.height[1].unwrap() } : {}
                }
              } : {},
              ...c.offset.filter((f) => f.isSome()).length ? {
                offset: {
                  ...c.offset[0].isSome() ? { start: c.offset[0].unwrap() } : {},
                  ...c.offset[1].isSome() ? { end: c.offset[1].unwrap() } : {}
                }
              } : {}
            };
          })()
        } : {}
      });
    } else
      this.etchings.push({
        valid: !1,
        runeId: n,
        txid: t,
        runeTicker: o.toString(),
        runeName: o.toString()
      });
  }
}
Fh.RuneUpdater = see;
(function(e) {
  var t = Me && Me.__createBinding || (Object.create ? function(u, l, c, f) {
    f === void 0 && (f = c);
    var h = Object.getOwnPropertyDescriptor(l, c);
    (!h || ("get" in h ? !l.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return l[c];
    } }), Object.defineProperty(u, f, h);
  } : function(u, l, c, f) {
    f === void 0 && (f = c), u[f] = l[c];
  }), r = Me && Me.__exportStar || function(u, l) {
    for (var c in u) c !== "default" && !Object.prototype.hasOwnProperty.call(l, c) && t(l, u, c);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.RunestoneIndexer = e.RuneUpdater = void 0;
  const n = dl, o = Fh, a = To;
  r(Lp, e);
  var i = Fh;
  Object.defineProperty(e, "RuneUpdater", { enumerable: !0, get: function() {
    return i.RuneUpdater;
  } });
  class s {
    constructor(l) {
      this._started = !1, this._updateInProgress = !1, this._rpc = l.bitcoinRpcClient, this._storage = l.storage, this._network = l.network;
    }
    async start() {
      this._started || (await this._storage.connect(), this._started = !0, this._network === n.Network.MAINNET && this._storage.seedEtchings([
        {
          runeTicker: "UNCOMMONGOODS",
          runeName: "UNCOMMONGOODS",
          runeId: { block: 1, tx: 0 },
          txid: "0000000000000000000000000000000000000000000000000000000000000000",
          valid: !0,
          symbol: "",
          terms: { amount: 1n, cap: a.u128.MAX, height: { start: 840000n, end: 1050000n } }
        }
      ]));
    }
    async stop() {
      this._started && (await this._storage.disconnect(), this._started = !1);
    }
    async updateRuneUtxoBalances() {
      if (!this._started)
        throw new Error("Runestone indexer is not started");
      if (!this._updateInProgress) {
        this._updateInProgress = !0;
        try {
          await this.updateRuneUtxoBalancesImpl();
        } finally {
          this._updateInProgress = !1;
        }
      }
    }
    async updateRuneUtxoBalancesImpl() {
      const l = await this._storage.getCurrentBlock();
      if (l) {
        const h = [];
        let p = l.height, y = (await this._rpc.getblockhash({ height: p })).result, m = l.hash;
        for (; m !== y; )
          y && h.push(y), p--, y = (await this._rpc.getblockhash({ height: p })).result, m = await this._storage.getBlockhash(p);
        h.reverse();
        for (const b of h) {
          const v = await this._rpc.getblock({ blockhash: b, verbosity: 2 });
          if (v.error !== null)
            throw v.error;
          const k = v.result, E = new o.RuneUpdater(this._network, k, !0, this._storage, this._rpc);
          for (const [A, S] of k.tx.entries())
            await E.indexRunes(S, A);
          await this._storage.saveBlockIndex(E);
        }
      }
      let c = Math.max(n.Network.getFirstRuneHeight(this._network), l ? l.height + 1 : 0), f = (await this._rpc.getblockhash({ height: c })).result;
      for (; f !== null; ) {
        const h = await this._rpc.getblock({ blockhash: f, verbosity: 2 });
        if (h.error !== null)
          throw h.error;
        const p = h.result, y = new o.RuneUpdater(this._network, p, !1, this._storage, this._rpc);
        for (const [m, b] of p.tx.entries())
          await y.indexRunes(b, m);
        await this._storage.saveBlockIndex(y), c++, f = (await this._rpc.getblockhash({ height: c })).result;
      }
    }
  }
  e.RunestoneIndexer = s;
})(vT);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.tryDecodeRunestone = e.isRunestone = e.encodeRunestone = e.Network = e.RunestoneIndexer = e.RuneUpdater = e.RuneLocation = void 0;
  const t = Np, r = er, n = Rp, o = id, a = To, i = Po, s = ad, u = p5, l = jp;
  var c = vT;
  Object.defineProperty(e, "RuneLocation", { enumerable: !0, get: function() {
    return c.RuneLocation;
  } }), Object.defineProperty(e, "RuneUpdater", { enumerable: !0, get: function() {
    return c.RuneUpdater;
  } }), Object.defineProperty(e, "RunestoneIndexer", { enumerable: !0, get: function() {
    return c.RunestoneIndexer;
  } });
  var f = dl;
  Object.defineProperty(e, "Network", { enumerable: !0, get: function() {
    return f.Network;
  } });
  function h(A) {
    switch (A) {
      case o.Flaw.EDICT_OUTPUT:
        return "edict_output";
      case o.Flaw.EDICT_RUNE_ID:
        return "edict_rune_id";
      case o.Flaw.INVALID_SCRIPT:
        return "invalid_script";
      case o.Flaw.OPCODE:
        return "opcode";
      case o.Flaw.SUPPLY_OVERFLOW:
        return "supply_overflow";
      case o.Flaw.TRAILING_INTEGERS:
        return "trailing_integers";
      case o.Flaw.TRUNCATED_FIELD:
        return "truncated_field";
      case o.Flaw.UNRECOGNIZED_EVEN_TAG:
        return "unrecognized_even_tag";
      case o.Flaw.UNRECOGNIZED_FLAG:
        return "unrecognized_flag";
      case o.Flaw.VARINT:
        return "varint";
    }
  }
  const p = (A) => {
    const S = BigInt(A);
    if (S < 0n || S > a.u8.MAX)
      throw Error("u8 overflow");
    return (0, a.u8)(S);
  }, y = (A) => {
    const S = BigInt(A);
    if (S < 0n || S > a.u32.MAX)
      throw Error("u32 overflow");
    return (0, a.u32)(S);
  }, m = (A) => {
    const S = BigInt(A);
    if (S < 0n || S > a.u64.MAX)
      throw Error("u64 overflow");
    return (0, a.u64)(S);
  }, b = (A) => {
    const S = BigInt(A);
    if (S < 0n || S > a.u128.MAX)
      throw Error("u128 overflow");
    return (0, a.u128)(S);
  };
  function v(A) {
    const S = A.mint ? (0, i.Some)(new s.RuneId(m(A.mint.block), y(A.mint.tx))) : i.None, _ = A.pointer !== void 0 ? (0, i.Some)(A.pointer).map(y) : i.None, I = (A.edicts ?? []).map((D) => ({
      id: new s.RuneId(m(D.id.block), y(D.id.tx)),
      amount: b(D.amount),
      output: y(D.output)
    }));
    let O = i.None, z;
    if (A.etching) {
      const D = A.etching, G = D.runeName ? l.SpacedRune.fromString(D.runeName) : void 0, U = (G == null ? void 0 : G.rune) !== void 0 ? (0, i.Some)(G.rune) : i.None;
      if (D.symbol && !(D.symbol.length === 1 || D.symbol.length === 2 && D.symbol.codePointAt(0) >= 65536))
        throw Error("Symbol must be one code point");
      const V = D.divisibility !== void 0 ? (0, i.Some)(D.divisibility).map(p) : i.None, F = D.premine !== void 0 ? (0, i.Some)(D.premine).map(b) : i.None, C = (G == null ? void 0 : G.spacers) !== void 0 && G.spacers !== 0 ? (0, i.Some)(y(G.spacers)) : i.None, R = D.symbol ? (0, i.Some)(D.symbol) : i.None;
      if (V.isSome() && V.unwrap() > r.MAX_DIVISIBILITY)
        throw Error(`Divisibility is greater than protocol max ${r.MAX_DIVISIBILITY}`);
      let M = i.None;
      if (D.terms) {
        const W = D.terms, ne = W.amount !== void 0 ? (0, i.Some)(W.amount).map(b) : i.None, oe = W.cap !== void 0 ? (0, i.Some)(W.cap).map(b) : i.None, se = W.height ? [
          W.height.start !== void 0 ? (0, i.Some)(W.height.start).map(m) : i.None,
          W.height.end !== void 0 ? (0, i.Some)(W.height.end).map(m) : i.None
        ] : [i.None, i.None], K = W.offset ? [
          W.offset.start !== void 0 ? (0, i.Some)(W.offset.start).map(m) : i.None,
          W.offset.end !== void 0 ? (0, i.Some)(W.offset.end).map(m) : i.None
        ] : [i.None, i.None];
        if (ne.isSome() && oe.isSome() && ne.unwrap() * oe.unwrap() > a.u128.MAX)
          throw Error("Terms overflow with amount times cap");
        M = (0, i.Some)({ amount: ne, cap: oe, height: se, offset: K });
      }
      const re = D.turbo ?? !1;
      O = (0, i.Some)(new n.Etching(V, U, C, R, M, F, re)), z = U.isSome() ? U.unwrap().commitment : void 0;
    }
    return {
      encodedRunestone: new u.Runestone(S, _, I, O).encipher(),
      etchingCommitment: z
    };
  }
  e.encodeRunestone = v;
  function k(A) {
    return !("flaws" in A);
  }
  e.isRunestone = k;
  function E(A) {
    const S = u.Runestone.decipher(A);
    if (S.isNone())
      return null;
    const _ = S.unwrap();
    if ((0, t.isRunestone)(_)) {
      const I = _, O = () => I.etching.unwrap(), z = () => O().terms.unwrap();
      return {
        ...I.etching.isSome() ? {
          etching: {
            ...O().divisibility.isSome() ? { divisibility: O().divisibility.map(Number).unwrap() } : {},
            ...O().premine.isSome() ? { premine: O().premine.unwrap() } : {},
            ...O().rune.isSome() ? {
              runeName: new l.SpacedRune(O().rune.unwrap(), O().spacers.map(Number).unwrapOr(0)).toString()
            } : {},
            ...O().symbol.isSome() ? { symbol: O().symbol.unwrap() } : {},
            ...O().terms.isSome() ? {
              terms: {
                ...z().amount.isSome() ? { amount: z().amount.unwrap() } : {},
                ...z().cap.isSome() ? { cap: z().cap.unwrap() } : {},
                ...z().height.find((D) => D.isSome()) ? {
                  height: {
                    ...z().height[0].isSome() ? { start: z().height[0].unwrap() } : {},
                    ...z().height[1].isSome() ? { end: z().height[1].unwrap() } : {}
                  }
                } : {},
                ...z().offset.find((D) => D.isSome()) ? {
                  offset: {
                    ...z().offset[0].isSome() ? { start: z().offset[0].unwrap() } : {},
                    ...z().offset[1].isSome() ? { end: z().offset[1].unwrap() } : {}
                  }
                } : {}
              }
            } : {},
            turbo: O().turbo
          }
        } : {},
        ...I.mint.isSome() ? {
          mint: {
            block: I.mint.unwrap().block,
            tx: Number(I.mint.unwrap().tx)
          }
        } : {},
        ...I.pointer.isSome() ? { pointer: Number(I.pointer.unwrap()) } : {},
        ...I.edicts.length ? {
          edicts: I.edicts.map((D) => ({
            id: {
              block: D.id.block,
              tx: Number(D.id.tx)
            },
            amount: D.amount,
            output: Number(D.output)
          }))
        } : {}
      };
    } else {
      const I = _;
      return {
        flaws: I.flaws.map(h),
        ...I.etching.isSome() ? { etching: I.etching.unwrap().toString() } : {},
        ...I.mint.isSome() ? { mint: { block: I.mint.unwrap().block, tx: Number(I.mint.unwrap().tx) } } : {}
      };
    }
  }
  e.tryDecodeRunestone = E;
})(qQ);
const uee = (e) => /^(?:[A-Za-z0-9+\/]{4})*?(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(e), cee = (e) => /^[a-fA-F0-9]+$/.test(e), ic = (e) => {
  const t = [];
  let r = e;
  do {
    let n = r & BigInt(127);
    r >>= BigInt(7), r !== BigInt(0) && (n |= BigInt(128)), t.push(Number(n));
  } while (r !== BigInt(0));
  return { varint: Buffer.from(t) };
}, lee = ({
  runeId: e,
  amount: t,
  divisibility: r = 0,
  sendOutputIndex: n = 1,
  pointer: o = 0
}) => {
  r === 0 && (t = Math.floor(t));
  const a = ic(BigInt(22)).varint, i = ic(BigInt(o)).varint, s = ic(BigInt(0)).varint, u = ic(BigInt(t * 10 ** r)).varint, l = ic(BigInt(n)).varint, c = e.split(":"), f = Number(c[0]), h = Number(c[1]), p = ic(BigInt(f)).varint, y = ic(BigInt(h)).varint, m = Buffer.concat([
    a,
    i,
    s,
    p,
    y,
    u,
    l
  ]);
  let b = m.byteLength.toString(16);
  return b.length % 2 !== 0 && (b = "0" + m.byteLength.toString(16)), Buffer.concat([
    Buffer.from("6a", "hex"),
    Buffer.from("5d", "hex"),
    Buffer.from(b, "hex"),
    m
  ]);
}, fee = "https://mainnet.sandshrew.io/v1/lasereyes", by = async (e, t) => {
  const r = JSON.stringify({
    jsonrpc: "2.0",
    id: e,
    method: e,
    params: t
  });
  return await rr.post(fee, r, {
    headers: {
      "content-type": "application/json"
    }
  }).then((n) => n.data).catch((n) => {
    throw n;
  });
}, ET = async (e) => {
  try {
    return (await by("ord_address", [
      e
    ])).result;
  } catch (t) {
    throw t;
  }
}, kT = async (e) => {
  try {
    return (await by("ord_rune", [e])).result;
  } catch (t) {
    throw t;
  }
}, dee = async (e) => {
  try {
    return await by("ord_rune", [e]);
  } catch (t) {
    throw t;
  }
}, hee = async ({
  outpoints: e,
  rune_name: t
}) => {
  const r = [];
  for (let n = 0; n < e.length; n += 1e3) {
    const o = e.slice(n, n + 1e3), a = o.map((u) => ["ord_output", [u]]), { result: i } = await by("sandshrew_multicall", a);
    for (let u = 0; u < i.length; u++)
      i[u].result.output = o[u];
    const s = i.filter(
      (u) => Object.keys(u.result.runes).includes(t)
    );
    r.push(...s);
  }
  return r;
}, pee = async (e) => {
  try {
    const t = (await ET(e)).runes_balances;
    if (!t)
      throw new Error("No runes data found");
    return t.map((r) => ({
      name: r[0],
      balance: r[1],
      symbol: r[2]
    }));
  } catch (t) {
    console.error("Error fetching ord address:", t);
  }
}, gee = async ({
  ordOutputs: e
}) => {
  var t;
  try {
    const r = [];
    for (let n = 0; n < e.length; n++) {
      const o = e[n], { result: a } = o;
      if (!((t = a.output) != null && t.split(":")))
        throw new Error("No output found");
      const { output: i, address: s, runes: u } = a, l = {
        output: i,
        wallet_addr: s,
        script: "",
        balances: [],
        decimals: [],
        rune_ids: [],
        value: a.value
      }, [c, f] = i.split(":");
      if (console.log(c, f, i), l.script = Buffer.from(
        jQ(s, Ot)
      ).toString("hex"), typeof u == "object" && !Array.isArray(u))
        for (const h in u)
          l.balances.push(u[h].amount), l.decimals.push(u[h].divisibility), l.rune_ids.push((await dee(h)).id);
      r.push(l);
    }
    return r;
  } catch (r) {
    throw r;
  }
}, mee = async ({
  address: e,
  runeId: t
}) => {
  const r = await ET(e), { entry: n } = await kT(t), o = n.spaced_rune, a = await hee({
    outpoints: r.outputs,
    rune_name: o
  });
  return await gee({
    ordOutputs: a
  });
}, yee = async ({
  runeId: e,
  amount: t,
  ordinalAddress: r,
  ordinalPublicKey: n,
  paymentAddress: o,
  paymentPublicKey: a,
  toAddress: i,
  signPsbt: s,
  network: u = Ot
}) => {
  try {
    const l = await bee({
      fromAddress: r,
      fromAddressPublicKey: n,
      fromPaymentAddress: o,
      fromPaymentPublicKey: a,
      toAddress: i,
      runeId: e,
      amount: t,
      network: u
    });
    if (!l || !(l != null && l.psbtHex))
      throw new Error("couldn't get commit tx");
    const c = String(l == null ? void 0 : l.psbtHex), f = String(l == null ? void 0 : l.psbtBase64), h = await s(
      "",
      c,
      f,
      !0,
      !1,
      u
    );
    if (!h) throw new Error("sign psbt failed");
    const p = Gt.fromHex((h == null ? void 0 : h.signedPsbtHex) || "").extractTransaction();
    return await hy(p.toHex(), u);
  } catch (l) {
    throw l;
  }
}, bee = async ({
  fromAddress: e,
  fromAddressPublicKey: t,
  fromPaymentAddress: r,
  fromPaymentPublicKey: n,
  toAddress: o,
  runeId: a,
  amount: i,
  network: s
}) => {
  try {
    const { fastestFee: u } = await cT(s);
    let l = (await dy(r, s)).sort((_, I) => I.value - _.value).filter((_) => _.value > 3e3);
    if (l.length === 0)
      throw new Error("No utxos found");
    let c = new Gt({ network: Er(s) }), f = 0;
    const h = await kT(a), p = await mee({ runeId: a, address: e }), y = dT(l), m = fT(p.length, 2, 4);
    let b = m * u < 250 ? 250 : m * u, v = 0;
    for await (const _ of p) {
      const { output: I, value: O, script: z } = _, D = I.split(":"), G = D[0], U = D[1];
      c.addInput({
        hash: G,
        index: parseInt(U),
        witnessUtxo: {
          value: BigInt(O),
          script: Buffer.from(z, "hex")
        },
        tapInternalKey: Pc(Buffer.from(t, "hex"))
      }), v++, f += O;
    }
    const k = lT(r, s);
    for (let _ = 0; _ < l.length; _++) {
      const I = wp(
        r,
        Er(Ot)
      ), O = l[_];
      if (k === tf && c.addInput({
        hash: O.txid,
        index: O.vout,
        witnessUtxo: {
          value: BigInt(O.value),
          script: I
        },
        tapInternalKey: Pc(Buffer.from(n, "hex"))
      }), k === B8) {
        let z = a5(n, s);
        c.addInput({
          hash: O.txid,
          index: O.vout,
          witnessUtxo: {
            value: BigInt(O.value),
            script: I
          },
          redeemScript: z
        });
      }
      k === "p2wpkh" && c.addInput({
        hash: O.txid,
        index: O.vout,
        witnessUtxo: {
          value: BigInt(O.value),
          script: I
        }
      });
    }
    const E = { script: lee({
      runeId: h.id,
      amount: i,
      divisibility: h.entry.divisibility,
      sendOutputIndex: 2,
      pointer: 1
    }), value: BigInt(0) };
    c.addOutput(E);
    const A = 546, S = y - (b + A * 2);
    return c.addOutput({
      value: BigInt(A),
      address: e
    }), c.addOutput({
      value: BigInt(A),
      address: o
    }), c.addOutput({
      address: e,
      value: BigInt(S)
    }), { psbtBase64: c.toBase64(), psbtHex: c.toHex() };
  } catch (u) {
    throw u;
  }
}, Tv = new Error(
  "The connected wallet doesn't support this method..."
), wee = new Error("Wallet is not installed");
let Bi = class {
  constructor(t, r, n) {
    ke(this, "$store"), ke(this, "$network"), this.parent = r, this.config = n, this.$store = t.$store, this.$network = t.$network, this.initialize();
  }
  disconnect() {
  }
  async requestAccounts() {
    return [this.$store.get().address, this.$store.get().paymentAddress];
  }
  async switchNetwork(t) {
    throw this.parent.disconnect(), Tv;
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [Yt, on, pn, Nn].includes(this.$network.get()) ? this.$network.get() : Ot;
  }
  async getPublicKey() {
    return this.$store.get().publicKey;
  }
  async getBalance() {
    const { paymentAddress: t } = this.$store.get();
    return await as(t, this.$network.get());
  }
  async getMetaBalances(t) {
    switch (t) {
      case YE:
        return await this.getBalance();
      case JE:
        if (this.$network.get() !== Ot)
          throw new Error("Unsupported network");
        return await pee(this.$store.get().address);
      default:
        throw new Error("Unsupported protocol");
    }
  }
  async getInscriptions(t, r) {
    throw console.log("getInscriptions not implemented", t, r), Tv;
  }
  async pushPsbt(t) {
    let r = t;
    return r.startsWith("02") || (r = Gt.fromHex(r).extractTransaction().toHex()), await hy(r, this.$network.get());
  }
  async inscribe(t, r) {
    return await FQ({
      contentBase64: t,
      mimeType: r,
      ordinalAddress: this.$store.get().address,
      paymentAddress: this.$store.get().paymentAddress,
      paymentPublicKey: this.$store.get().paymentPublicKey,
      signPsbt: this.signPsbt.bind(this),
      network: this.$network.get()
    });
  }
  async send(t, r) {
    switch (t) {
      case YE:
        return await this.sendBTC(r.toAddress, r.amount);
      case JE:
        const n = this.$network.get();
        if (n !== Ot)
          throw new Error("Unsupported network");
        const o = r;
        if (!o.runeId || !o.amount || !o.toAddress)
          throw new Error("Missing required parameters");
        return await yee({
          runeId: o.runeId,
          amount: o.amount,
          ordinalAddress: this.$store.get().address,
          ordinalPublicKey: this.$store.get().publicKey,
          paymentAddress: this.$store.get().paymentAddress,
          paymentPublicKey: this.$store.get().paymentPublicKey,
          toAddress: o.toAddress,
          signPsbt: this.signPsbt.bind(this),
          network: n
        });
      default:
        throw new Error("Unsupported protocol");
    }
  }
};
class vee extends Bi {
  constructor() {
    super(...arguments), ke(this, "observer");
  }
  get library() {
    return window.unisat;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Vl]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Yo(this.$store, ["provider"], (t) => {
      if (t.provider !== Vl) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener(
      "accountsChanged",
      this.handleAccountsChanged.bind(this)
    ), (r = this.library) == null || r.removeListener(
      "networkChanged",
      this.handleNetworkChanged.bind(this)
    ));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(Vl) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = Ag(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(Vl);
  }
  async connect(t) {
    if (!this.library) throw new Error("Unisat isn't installed");
    const r = await this.library.requestAccounts();
    if (!r) throw new Error("No accounts found");
    await this.getNetwork().then((o) => {
      this.network !== o && this.switchNetwork(this.network);
    });
    const n = await this.library.getPublicKey();
    if (!n) throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n);
  }
  async getNetwork() {
    var t;
    const r = await ((t = this.library) == null ? void 0 : t.getChain());
    return r ? Ag(r.enum) : this.network;
  }
  async sendBTC(t, r) {
    var n;
    const o = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
    if (!o) throw new Error("Transaction failed");
    return o;
  }
  async signMessage(t, r) {
    var n;
    const o = (r == null ? void 0 : r.protocol) === i5 ? fy : r == null ? void 0 : r.protocol;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t, o));
  }
  async signPsbt(t, r, n, o, a) {
    var i;
    const s = await ((i = this.library) == null ? void 0 : i.signPsbt(r, {
      autoFinalized: o
    })), u = Gt.fromHex(s);
    if (o && a) {
      const l = await this.pushPsbt(s);
      return {
        signedPsbtHex: u.toHex(),
        signedPsbtBase64: u.toBase64(),
        txId: l
      };
    }
    return {
      signedPsbtHex: u.toHex(),
      signedPsbtBase64: u.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var r;
    const n = Y_(t);
    await ((r = this.library) == null ? void 0 : r.switchChain(n)), this.$network.set(t);
  }
}
function Eee(e) {
  typeof window < "u" && typeof localStorage < "u" && setTimeout(() => {
    const t = document.createTextNode(" ");
    document.body.appendChild(t), t.remove(), Promise.resolve().then(e);
  }, 1500);
}
function x5e() {
  return {
    $store: Nk({
      provider: void 0,
      address: "",
      paymentAddress: "",
      publicKey: "",
      paymentPublicKey: "",
      connected: !1,
      isConnecting: !1,
      isInitializing: !0,
      accounts: [],
      balance: void 0,
      hasProvider: {
        [rh]: !1,
        [Vl]: !1,
        [vu]: !1,
        [nh]: !1,
        [hc]: !1,
        [dc]: !1,
        [th]: !1,
        [Zl]: !0,
        [fc]: !1,
        [Gl]: !1,
        [lc]: !1
      }
    }),
    $network: xw(Ot),
    $library: xw(void 0)
  };
}
function A5e({ network: e }) {
  return {
    network: e
  };
}
const Xu = [
  "address",
  "paymentAddress",
  "publicKey",
  "paymentPublicKey",
  "balance"
];
function hl(e, t, r, n) {
  var o, a, i;
  t.provider === e && (r ? r === "balance" ? n.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : Xu.includes(r) && n.setKey(
    r,
    ((a = t[r]) == null ? void 0 : a.toString()) ?? ""
  ) : n.set({
    address: t.address,
    paymentAddress: t.paymentAddress,
    paymentPublicKey: t.paymentPublicKey,
    publicKey: t.publicKey,
    balance: ((i = t.balance) == null ? void 0 : i.toString()) ?? ""
  }));
}
const kee = (e) => {
  const t = e.match(/.{1,2}/g);
  if (!t)
    throw new Error("Invalid hex string");
  return Uint8Array.from(t.map((r) => parseInt(r, 16)));
};
function xee(e, t) {
  var r;
  return (r = void 0) == null ? void 0 : r.get(t);
}
function wy(e) {
  var t, r;
  let n = typeof e;
  return n === "object" && (n = (e && ((r = (t = Object.getPrototypeOf(e)) == null ? void 0 : t.constructor) == null ? void 0 : r.name)) ?? "null"), n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n;
}
function ao(e, t, r, n, o) {
  const a = o && "input" in o ? o.input : r.value, i = (o == null ? void 0 : o.expected) ?? e.expects ?? null, s = (o == null ? void 0 : o.received) ?? wy(a), u = {
    kind: e.kind,
    type: e.type,
    input: a,
    expected: i,
    received: s,
    message: `Invalid ${t}: ${i ? `Expected ${i} but r` : "R"}eceived ${s}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, l = e.kind === "schema", c = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? xee(e.reference, u.lang) ?? (l ? (u.lang, void 0) : null) ?? n.message ?? (u.lang, void 0);
  c && (u.message = typeof c == "function" ? c(u) : c), l && (r.typed = !1), r.issues ? r.issues.push(u) : r.issues = [u];
}
function Aee(e, t) {
  return Object.hasOwn(e, t) && t !== "__proto__" && t !== "prototype" && t !== "constructor";
}
function xT(e, t, r) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, r)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function c7(e, t) {
  return !e._run({ typed: !1, value: t }, { abortEarly: !0 }).issues;
}
function Si(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: Si,
    expects: "Array",
    async: !1,
    item: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (Array.isArray(a)) {
        r.typed = !0, r.value = [];
        for (let i = 0; i < a.length; i++) {
          const s = a[i], u = this.item._run({ typed: !1, value: s }, n);
          if (u.issues) {
            const l = {
              type: "array",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), r.value.push(u.value);
        }
      } else
        ao(this, "type", r, n);
      return r;
    }
  };
}
function AT(e) {
  return {
    kind: "schema",
    type: "boolean",
    reference: AT,
    expects: "boolean",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "boolean" ? t.typed = !0 : ao(this, "type", t, r), t;
    }
  };
}
function Vc(e, t) {
  const r = Object.entries(e).filter(([n]) => isNaN(+n)).map(([, n]) => n);
  return {
    kind: "schema",
    type: "enum",
    reference: Vc,
    expects: r.map(wy).join(" | ") || "never",
    async: !1,
    enum: e,
    options: r,
    message: t,
    _run(n, o) {
      return this.options.includes(n.value) ? n.typed = !0 : ao(this, "type", n, o), n;
    }
  };
}
function wr(e, t) {
  return {
    kind: "schema",
    type: "literal",
    reference: wr,
    expects: wy(e),
    async: !1,
    literal: e,
    message: t,
    _run(r, n) {
      return r.value === this.literal ? r.typed = !0 : ao(this, "type", r, n), r;
    }
  };
}
function ST(e, t) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: ST,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (a && typeof a == "object") {
        r.typed = !0, r.value = {};
        for (const i in this.entries) {
          const s = a[i], u = this.entries[i]._run(
            { typed: !1, value: s },
            n
          );
          if (u.issues) {
            const l = {
              type: "object",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), (u.value !== void 0 || i in a) && (r.value[i] = u.value);
        }
        if (!r.issues || !n.abortEarly)
          for (const i in a)
            Aee(a, i) && !(i in this.entries) && (r.value[i] = a[i]);
      } else
        ao(this, "type", r, n);
      return r;
    }
  };
}
function g5(e, t) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: g5,
    expects: "!undefined",
    async: !1,
    wrapped: e,
    message: t,
    _run(r, n) {
      return r.value === void 0 ? (ao(this, "type", r, n), r) : this.wrapped._run(r, n);
    }
  };
}
function pl(e) {
  return {
    kind: "schema",
    type: "null",
    reference: pl,
    expects: "null",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value === null ? t.typed = !0 : ao(this, "type", t, r), t;
    }
  };
}
function gl(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullish",
    reference: gl,
    expects: `${e.expects} | null | undefined`,
    async: !1,
    wrapped: e,
    _run(n, o) {
      return (n.value === null || n.value === void 0) && ("default" in this && (n.value = xT(
        this,
        n,
        o
      )), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function oa(e) {
  return {
    kind: "schema",
    type: "number",
    reference: oa,
    expects: "number",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : ao(this, "type", t, r), t;
    }
  };
}
function $e(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: $e,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (a && typeof a == "object") {
        r.typed = !0, r.value = {};
        for (const i in this.entries) {
          const s = a[i], u = this.entries[i]._run(
            { typed: !1, value: s },
            n
          );
          if (u.issues) {
            const l = {
              type: "object",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), (u.value !== void 0 || i in a) && (r.value[i] = u.value);
        }
      } else
        ao(this, "type", r, n);
      return r;
    }
  };
}
function _i(e, ...t) {
  const r = {
    kind: "schema",
    type: "optional",
    reference: _i,
    expects: `${e.expects} | undefined`,
    async: !1,
    wrapped: e,
    _run(n, o) {
      return n.value === void 0 && ("default" in this && (n.value = xT(
        this,
        n,
        o
      )), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function _T(e, t) {
  return {
    kind: "schema",
    type: "picklist",
    reference: _T,
    expects: e.map(wy).join(" | ") || "never",
    async: !1,
    options: e,
    message: t,
    _run(r, n) {
      return this.options.includes(r.value) ? r.typed = !0 : ao(this, "type", r, n), r;
    }
  };
}
function je(e) {
  return {
    kind: "schema",
    type: "string",
    reference: je,
    expects: "string",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = !0 : ao(this, "type", t, r), t;
    }
  };
}
function m5(e) {
  return {
    kind: "schema",
    type: "undefined",
    reference: m5,
    expects: "undefined",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value === void 0 ? t.typed = !0 : ao(this, "type", t, r), t;
    }
  };
}
function l7(e) {
  let t;
  if (e)
    for (const r of e)
      t ? t.push(...r.issues) : t = r.issues;
  return t;
}
function vy(e, t) {
  return {
    kind: "schema",
    type: "union",
    reference: vy,
    expects: [...new Set(e.map((r) => r.expects))].join(" | ") || "never",
    async: !1,
    options: e,
    message: t,
    _run(r, n) {
      let o, a, i;
      for (const s of this.options) {
        const u = s._run(
          { typed: !1, value: r.value },
          n
        );
        if (u.typed)
          if (u.issues)
            a ? a.push(u) : a = [u];
          else {
            o = u;
            break;
          }
        else
          i ? i.push(u) : i = [u];
      }
      if (o)
        return o;
      if (a) {
        if (a.length === 1)
          return a[0];
        ao(this, "type", r, n, {
          issues: l7(a)
        }), r.typed = !0;
      } else {
        if ((i == null ? void 0 : i.length) === 1)
          return i[0];
        ao(this, "type", r, n, {
          issues: l7(i)
        });
      }
      return r;
    }
  };
}
function Ey() {
  return {
    kind: "schema",
    type: "unknown",
    reference: Ey,
    expects: "unknown",
    async: !1,
    _run(e) {
      return e.typed = !0, e;
    }
  };
}
var Oo = {}, Of = {}, $n = {}, cd = {};
cd.byteLength = Iee;
cd.toByteArray = Pee;
cd.fromByteArray = Cee;
var ia = [], Mo = [], See = typeof Uint8Array < "u" ? Uint8Array : Array, P2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Bl = 0, _ee = P2.length; Bl < _ee; ++Bl)
  ia[Bl] = P2[Bl], Mo[P2.charCodeAt(Bl)] = Bl;
Mo[45] = 62;
Mo[95] = 63;
function IT(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function Iee(e) {
  var t = IT(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function Tee(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function Pee(e) {
  var t, r = IT(e), n = r[0], o = r[1], a = new See(Tee(e, n, o)), i = 0, s = o > 0 ? n - 4 : n, u;
  for (u = 0; u < s; u += 4)
    t = Mo[e.charCodeAt(u)] << 18 | Mo[e.charCodeAt(u + 1)] << 12 | Mo[e.charCodeAt(u + 2)] << 6 | Mo[e.charCodeAt(u + 3)], a[i++] = t >> 16 & 255, a[i++] = t >> 8 & 255, a[i++] = t & 255;
  return o === 2 && (t = Mo[e.charCodeAt(u)] << 2 | Mo[e.charCodeAt(u + 1)] >> 4, a[i++] = t & 255), o === 1 && (t = Mo[e.charCodeAt(u)] << 10 | Mo[e.charCodeAt(u + 1)] << 4 | Mo[e.charCodeAt(u + 2)] >> 2, a[i++] = t >> 8 & 255, a[i++] = t & 255), a;
}
function Oee(e) {
  return ia[e >> 18 & 63] + ia[e >> 12 & 63] + ia[e >> 6 & 63] + ia[e & 63];
}
function $ee(e, t, r) {
  for (var n, o = [], a = t; a < r; a += 3)
    n = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (e[a + 2] & 255), o.push(Oee(n));
  return o.join("");
}
function Cee(e) {
  for (var t, r = e.length, n = r % 3, o = [], a = 16383, i = 0, s = r - n; i < s; i += a)
    o.push($ee(e, i, i + a > s ? s : i + a));
  return n === 1 ? (t = e[r - 1], o.push(
    ia[t >> 2] + ia[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], o.push(
    ia[t >> 10] + ia[t >> 4 & 63] + ia[t << 2 & 63] + "="
  )), o.join("");
}
Object.defineProperty($n, "__esModule", { value: !0 });
$n.decode = $n.encode = $n.unescape = $n.escape = $n.pad = void 0;
const TT = cd;
function y5(e) {
  return `${e}${"=".repeat(4 - (e.length % 4 || 4))}`;
}
$n.pad = y5;
function PT(e) {
  return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
$n.escape = PT;
function OT(e) {
  return y5(e).replace(/-/g, "+").replace(/_/g, "/");
}
$n.unescape = OT;
function Bee(e) {
  return PT((0, TT.fromByteArray)(new TextEncoder().encode(e)));
}
$n.encode = Bee;
function Nee(e) {
  return new TextDecoder().decode((0, TT.toByteArray)(y5(OT(e))));
}
$n.decode = Nee;
var ky = {}, xy = {}, $f = {};
Object.defineProperty($f, "__esModule", { value: !0 });
$f.joseToDer = $f.derToJose = void 0;
const $T = cd, CT = $n;
function O2(e) {
  return (e / 8 | 0) + (e % 8 === 0 ? 0 : 1);
}
const Uee = {
  ES256: O2(256),
  ES384: O2(384),
  ES512: O2(521)
};
function BT(e) {
  const t = Uee[e];
  if (t)
    return t;
  throw new Error(`Unknown algorithm "${e}"`);
}
const $g = 128, NT = 0, Ree = 32, zee = 16, jee = 2, UT = zee | Ree | NT << 6, Cg = jee | NT << 6;
function RT(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return (0, $T.toByteArray)((0, CT.pad)(e));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function Lee(e, t) {
  const r = RT(e), n = BT(t), o = n + 1, a = r.length;
  let i = 0;
  if (r[i++] !== UT)
    throw new Error('Could not find expected "seq"');
  let s = r[i++];
  if (s === ($g | 1) && (s = r[i++]), a - i < s)
    throw new Error(`"seq" specified length of "${s}", only "${a - i}" remaining`);
  if (r[i++] !== Cg)
    throw new Error('Could not find expected "int" for "r"');
  const u = r[i++];
  if (a - i - 2 < u)
    throw new Error(`"r" specified length of "${u}", only "${a - i - 2}" available`);
  if (o < u)
    throw new Error(`"r" specified length of "${u}", max of "${o}" is acceptable`);
  const l = i;
  if (i += u, r[i++] !== Cg)
    throw new Error('Could not find expected "int" for "s"');
  const c = r[i++];
  if (a - i !== c)
    throw new Error(`"s" specified length of "${c}", expected "${a - i}"`);
  if (o < c)
    throw new Error(`"s" specified length of "${c}", max of "${o}" is acceptable`);
  const f = i;
  if (i += c, i !== a)
    throw new Error(`Expected to consume entire array, but "${a - i}" bytes remain`);
  const h = n - u, p = n - c, y = new Uint8Array(h + u + p + c);
  for (i = 0; i < h; ++i)
    y[i] = 0;
  y.set(r.subarray(l + Math.max(-h, 0), l + u), i), i = n;
  for (const m = i; i < m + p; ++i)
    y[i] = 0;
  return y.set(r.subarray(f + Math.max(-p, 0), f + c), i), (0, CT.escape)((0, $T.fromByteArray)(y));
}
$f.derToJose = Lee;
function f7(e, t, r) {
  let n = 0;
  for (; t + n < r && e[t + n] === 0; )
    ++n;
  return e[t + n] >= $g && --n, n;
}
function Hee(e, t) {
  e = RT(e);
  const r = BT(t), n = e.length;
  if (n !== r * 2)
    throw new TypeError(`"${t}" signatures must be "${r * 2}" bytes, saw "${n}"`);
  const o = f7(e, 0, r), a = f7(e, r, e.length), i = r - o, s = r - a, u = 2 + i + 1 + 1 + s, l = u < $g, c = new Uint8Array((l ? 2 : 3) + u);
  let f = 0;
  return c[f++] = UT, l ? c[f++] = u : (c[f++] = $g | 1, c[f++] = u & 255), c[f++] = Cg, c[f++] = i, o < 0 ? (c[f++] = 0, c.set(e.subarray(0, r), f), f += r) : (c.set(e.subarray(o, r), f), f += r - o), c[f++] = Cg, c[f++] = s, a < 0 ? (c[f++] = 0, c.set(e.subarray(r), f)) : c.set(e.subarray(r + a), f), c;
}
$f.joseToDer = Hee;
var ss = {};
Object.defineProperty(ss, "__esModule", { value: !0 });
ss.InvalidTokenError = ss.MissingParametersError = void 0;
let Fee = class extends Error {
  constructor(t) {
    super(), this.name = "MissingParametersError", this.message = t || "";
  }
};
ss.MissingParametersError = Fee;
let Dee = class extends Error {
  constructor(t) {
    super(), this.name = "InvalidTokenError", this.message = t || "";
  }
};
ss.InvalidTokenError = Dee;
Object.defineProperty(xy, "__esModule", { value: !0 });
xy.SECP256K1Client = void 0;
const Mee = Zm, Kee = yi, T1 = K3, d7 = $f, h7 = ss, p7 = Gu;
T1.utils.hmacSha256Sync = (e, ...t) => {
  const r = Mee.hmac.create(Kee.sha256, e);
  return t.forEach((n) => r.update(n)), r.digest();
};
let zT = class {
  static derivePublicKey(t, r = !0) {
    return t.length === 66 && (t = t.slice(0, 64)), t.length < 64 && (t = t.padStart(64, "0")), (0, p7.bytesToHex)(T1.getPublicKey(t, r));
  }
  static signHash(t, r, n = "jose") {
    if (!t || !r)
      throw new h7.MissingParametersError("a signing input hash and private key are all required");
    const o = T1.signSync(t, r.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (n === "der")
      return (0, p7.bytesToHex)(o);
    if (n === "jose")
      return (0, d7.derToJose)(o, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(t) {
    return (0, d7.joseToDer)(t, "ES256");
  }
  static verifyHash(t, r, n) {
    if (!t || !r || !n)
      throw new h7.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return T1.verify(r, t, n, { strict: !1 });
  }
};
xy.SECP256K1Client = zT;
zT.algorithmName = "ES256K";
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.cryptoClients = e.SECP256K1Client = void 0;
  const t = xy;
  Object.defineProperty(e, "SECP256K1Client", { enumerable: !0, get: function() {
    return t.SECP256K1Client;
  } });
  const r = {
    ES256K: t.SECP256K1Client
  };
  e.cryptoClients = r;
})(ky);
var Gc = {}, qee = Me && Me.__awaiter || function(e, t, r, n) {
  function o(a) {
    return a instanceof r ? a : new r(function(i) {
      i(a);
    });
  }
  return new (r || (r = Promise))(function(a, i) {
    function s(c) {
      try {
        l(n.next(c));
      } catch (f) {
        i(f);
      }
    }
    function u(c) {
      try {
        l(n.throw(c));
      } catch (f) {
        i(f);
      }
    }
    function l(c) {
      c.done ? a(c.value) : o(c.value).then(s, u);
    }
    l((n = n.apply(e, t || [])).next());
  });
};
Object.defineProperty(Gc, "__esModule", { value: !0 });
Gc.hashSha256Async = Gc.hashSha256 = void 0;
const Vee = yi;
function jT(e) {
  return (0, Vee.sha256)(e);
}
Gc.hashSha256 = jT;
function Gee(e) {
  return qee(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const t = typeof e == "string" ? new TextEncoder().encode(e) : e, r = yield crypto.subtle.digest("SHA-256", t);
        return new Uint8Array(r);
      } else {
        const t = O_;
        if (!t.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(t.createHash("sha256").update(e).digest());
      }
    } catch (t) {
      return console.log(t), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(jT(e));
    }
  });
}
Gc.hashSha256Async = Gee;
var Zee = Me && Me.__awaiter || function(e, t, r, n) {
  function o(a) {
    return a instanceof r ? a : new r(function(i) {
      i(a);
    });
  }
  return new (r || (r = Promise))(function(a, i) {
    function s(c) {
      try {
        l(n.next(c));
      } catch (f) {
        i(f);
      }
    }
    function u(c) {
      try {
        l(n.throw(c));
      } catch (f) {
        i(f);
      }
    }
    function l(c) {
      c.done ? a(c.value) : o(c.value).then(s, u);
    }
    l((n = n.apply(e, t || [])).next());
  });
};
Object.defineProperty(Of, "__esModule", { value: !0 });
Of.TokenSigner = Of.createUnsecuredToken = void 0;
const Pv = $n, g7 = ky, Wee = ss, m7 = Gc;
function Ov(e, t) {
  const r = [], n = Pv.encode(JSON.stringify(t));
  r.push(n);
  const o = Pv.encode(JSON.stringify(e));
  return r.push(o), r.join(".");
}
function Xee(e) {
  return Ov(e, { typ: "JWT", alg: "none" }) + ".";
}
Of.createUnsecuredToken = Xee;
let Yee = class {
  constructor(t, r) {
    if (!(t && r))
      throw new Wee.MissingParametersError("a signing algorithm and private key are required");
    if (typeof t != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (t = t.toUpperCase(), !g7.cryptoClients.hasOwnProperty(t))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = g7.cryptoClients[t], this.rawPrivateKey = r;
  }
  header(t = {}) {
    const r = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, r, t);
  }
  sign(t, r = !1, n = {}) {
    const o = this.header(n), a = Ov(t, o), i = (0, m7.hashSha256)(a);
    return this.createWithSignedHash(t, r, o, a, i);
  }
  signAsync(t, r = !1, n = {}) {
    return Zee(this, void 0, void 0, function* () {
      const o = this.header(n), a = Ov(t, o), i = yield (0, m7.hashSha256Async)(a);
      return this.createWithSignedHash(t, r, o, a, i);
    });
  }
  createWithSignedHash(t, r, n, o, a) {
    const i = this.cryptoClient.signHash(a, this.rawPrivateKey);
    return r ? {
      header: [Pv.encode(JSON.stringify(n))],
      payload: JSON.stringify(t),
      signature: [i]
    } : [o, i].join(".");
  }
};
Of.TokenSigner = Yee;
var Ay = {};
Object.defineProperty(Ay, "__esModule", { value: !0 });
Ay.TokenVerifier = void 0;
const Jee = $n, y7 = ky, Qee = ss, z0 = Gc;
let ete = class {
  constructor(t, r) {
    if (!(t && r))
      throw new Qee.MissingParametersError("a signing algorithm and public key are required");
    if (typeof t != "string")
      throw "signing algorithm parameter must be a string";
    if (t = t.toUpperCase(), !y7.cryptoClients.hasOwnProperty(t))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = y7.cryptoClients[t], this.rawPublicKey = r;
  }
  verify(t) {
    return typeof t == "string" ? this.verifyCompact(t, !1) : typeof t == "object" ? this.verifyExpanded(t, !1) : !1;
  }
  verifyAsync(t) {
    return typeof t == "string" ? this.verifyCompact(t, !0) : typeof t == "object" ? this.verifyExpanded(t, !0) : Promise.resolve(!1);
  }
  verifyCompact(t, r) {
    const n = t.split("."), o = n[0] + "." + n[1], a = (i) => {
      const s = this.cryptoClient.loadSignature(n[2]);
      return this.cryptoClient.verifyHash(i, s, this.rawPublicKey);
    };
    if (r)
      return (0, z0.hashSha256Async)(o).then((i) => a(i));
    {
      const i = (0, z0.hashSha256)(o);
      return a(i);
    }
  }
  verifyExpanded(t, r) {
    const n = [t.header.join("."), Jee.encode(t.payload)].join(".");
    let o = !0;
    const a = (i) => (t.signature.map((s) => {
      const u = this.cryptoClient.loadSignature(s);
      this.cryptoClient.verifyHash(i, u, this.rawPublicKey) || (o = !1);
    }), o);
    if (r)
      return (0, z0.hashSha256Async)(n).then((i) => a(i));
    {
      const i = (0, z0.hashSha256)(n);
      return a(i);
    }
  }
};
Ay.TokenVerifier = ete;
var Sy = {};
Object.defineProperty(Sy, "__esModule", { value: !0 });
Sy.decodeToken = void 0;
const j0 = $n;
function tte(e) {
  if (typeof e == "string") {
    const t = e.split("."), r = JSON.parse(j0.decode(t[0])), n = JSON.parse(j0.decode(t[1])), o = t[2];
    return {
      header: r,
      payload: n,
      signature: o
    };
  } else if (typeof e == "object") {
    if (typeof e.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let t = e.payload;
    e.payload[0] !== "{" && (t = j0.decode(t));
    const r = [];
    return e.header.map((n) => {
      const o = JSON.parse(j0.decode(n));
      r.push(o);
    }), {
      header: r,
      payload: JSON.parse(t),
      signature: e.signature
    };
  }
}
Sy.decodeToken = tte;
(function(e) {
  var t = Me && Me.__createBinding || (Object.create ? function(n, o, a, i) {
    i === void 0 && (i = a);
    var s = Object.getOwnPropertyDescriptor(o, a);
    (!s || ("get" in s ? !o.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return o[a];
    } }), Object.defineProperty(n, i, s);
  } : function(n, o, a, i) {
    i === void 0 && (i = a), n[i] = o[a];
  }), r = Me && Me.__exportStar || function(n, o) {
    for (var a in n) a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && t(o, n, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Of, e), r(Ay, e), r(Sy, e), r(ss, e), r(ky, e);
})(Oo);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var b7 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const e = Array(256).fill(-1);
  for (let t = 0; t < b7.length; ++t) e[b7.charCodeAt(t)] = t;
})();
var w7, $2, L0, b5 = (w7 = function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.bech32m = t.bech32 = void 0;
  const r = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", n = {};
  for (let f = 0; f < 32; f++) {
    const h = r.charAt(f);
    n[h] = f;
  }
  function o(f) {
    const h = f >> 25;
    return (33554431 & f) << 5 ^ 996825010 & -(h >> 0 & 1) ^ 642813549 & -(h >> 1 & 1) ^ 513874426 & -(h >> 2 & 1) ^ 1027748829 & -(h >> 3 & 1) ^ 705979059 & -(h >> 4 & 1);
  }
  function a(f) {
    let h = 1;
    for (let p = 0; p < f.length; ++p) {
      const y = f.charCodeAt(p);
      if (y < 33 || y > 126) return "Invalid prefix (" + f + ")";
      h = o(h) ^ y >> 5;
    }
    h = o(h);
    for (let p = 0; p < f.length; ++p) {
      const y = f.charCodeAt(p);
      h = o(h) ^ 31 & y;
    }
    return h;
  }
  function i(f, h, p, y) {
    let m = 0, b = 0;
    const v = (1 << p) - 1, k = [];
    for (let E = 0; E < f.length; ++E) for (m = m << h | f[E], b += h; b >= p; ) b -= p, k.push(m >> b & v);
    if (y) b > 0 && k.push(m << p - b & v);
    else {
      if (b >= h) return "Excess padding";
      if (m << p - b & v) return "Non-zero padding";
    }
    return k;
  }
  function s(f) {
    return i(f, 8, 5, !0);
  }
  function u(f) {
    const h = i(f, 5, 8, !1);
    if (Array.isArray(h)) return h;
  }
  function l(f) {
    const h = i(f, 5, 8, !1);
    if (Array.isArray(h)) return h;
    throw new Error(h);
  }
  function c(f) {
    let h;
    function p(y, m) {
      if (m = m || 90, y.length < 8) return y + " too short";
      if (y.length > m) return "Exceeds length limit";
      const b = y.toLowerCase(), v = y.toUpperCase();
      if (y !== b && y !== v) return "Mixed-case string " + y;
      const k = (y = b).lastIndexOf("1");
      if (k === -1) return "No separator character for " + y;
      if (k === 0) return "Missing prefix for " + y;
      const E = y.slice(0, k), A = y.slice(k + 1);
      if (A.length < 6) return "Data too short";
      let S = a(E);
      if (typeof S == "string") return S;
      const _ = [];
      for (let I = 0; I < A.length; ++I) {
        const O = A.charAt(I), z = n[O];
        if (z === void 0) return "Unknown character " + O;
        S = o(S) ^ z, I + 6 >= A.length || _.push(z);
      }
      return S !== h ? "Invalid checksum for " + y : { prefix: E, words: _ };
    }
    return h = f === "bech32" ? 1 : 734539939, { decodeUnsafe: function(y, m) {
      const b = p(y, m);
      if (typeof b == "object") return b;
    }, decode: function(y, m) {
      const b = p(y, m);
      if (typeof b == "object") return b;
      throw new Error(b);
    }, encode: function(y, m, b) {
      if (b = b || 90, y.length + 7 + m.length > b) throw new TypeError("Exceeds length limit");
      let v = a(y = y.toLowerCase());
      if (typeof v == "string") throw new Error(v);
      let k = y + "1";
      for (let E = 0; E < m.length; ++E) {
        const A = m[E];
        if (A >> 5) throw new Error("Non 5-bit word");
        v = o(v) ^ A, k += r.charAt(A);
      }
      for (let E = 0; E < 6; ++E) v = o(v);
      v ^= h;
      for (let E = 0; E < 6; ++E) k += r.charAt(v >> 5 * (5 - E) & 31);
      return k;
    }, toWords: s, fromWordsUnsafe: u, fromWords: l };
  }
  t.bech32 = c("bech32"), t.bech32m = c("bech32m");
}, w7($2 = { exports: {} }, $2.exports), $2.exports);
(L0 = b5) && L0.__esModule && Object.prototype.hasOwnProperty.call(L0, "default") && L0.default;
b5.bech32m;
b5.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var Xl, Yl;
(function(e) {
  e.mainnet = "mainnet", e.testnet = "testnet", e.regtest = "regtest";
})(Xl || (Xl = {})), function(e) {
  e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr";
}(Yl || (Yl = {}));
Yl.p2pkh, Xl.mainnet, Yl.p2pkh, Xl.testnet, Yl.p2sh, Xl.mainnet, Yl.p2sh, Xl.testnet;
var rte = {}, w5 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
w5.read = function(e, t, r, n, o) {
  var a, i, s = o * 8 - n - 1, u = (1 << s) - 1, l = u >> 1, c = -7, f = r ? o - 1 : 0, h = r ? -1 : 1, p = e[t + f];
  for (f += h, a = p & (1 << -c) - 1, p >>= -c, c += s; c > 0; a = a * 256 + e[t + f], f += h, c -= 8)
    ;
  for (i = a & (1 << -c) - 1, a >>= -c, c += n; c > 0; i = i * 256 + e[t + f], f += h, c -= 8)
    ;
  if (a === 0)
    a = 1 - l;
  else {
    if (a === u)
      return i ? NaN : (p ? -1 : 1) * (1 / 0);
    i = i + Math.pow(2, n), a = a - l;
  }
  return (p ? -1 : 1) * i * Math.pow(2, a - n);
};
w5.write = function(e, t, r, n, o, a) {
  var i, s, u, l = a * 8 - o - 1, c = (1 << l) - 1, f = c >> 1, h = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : a - 1, y = n ? 1 : -1, m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, i = c) : (i = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -i)) < 1 && (i--, u *= 2), i + f >= 1 ? t += h / u : t += h * Math.pow(2, 1 - f), t * u >= 2 && (i++, u /= 2), i + f >= c ? (s = 0, i = c) : i + f >= 1 ? (s = (t * u - 1) * Math.pow(2, o), i = i + f) : (s = t * Math.pow(2, f - 1) * Math.pow(2, o), i = 0)); o >= 8; e[r + p] = s & 255, p += y, s /= 256, o -= 8)
    ;
  for (i = i << o | s, l += o; l > 0; e[r + p] = i & 255, p += y, i /= 256, l -= 8)
    ;
  e[r + p - y] |= m * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = cd, r = w5, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = s, e.SlowBuffer = k, e.INSPECT_MAX_BYTES = 50;
  const o = 2147483647;
  e.kMaxLength = o, s.TYPED_ARRAY_SUPPORT = a(), !s.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a() {
    try {
      const d = new Uint8Array(1), g = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(g, Uint8Array.prototype), Object.setPrototypeOf(d, g), d.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(s.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(s.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.byteOffset;
    }
  });
  function i(d) {
    if (d > o)
      throw new RangeError('The value "' + d + '" is invalid for option "size"');
    const g = new Uint8Array(d);
    return Object.setPrototypeOf(g, s.prototype), g;
  }
  function s(d, g, w) {
    if (typeof d == "number") {
      if (typeof g == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return f(d);
    }
    return u(d, g, w);
  }
  s.poolSize = 8192;
  function u(d, g, w) {
    if (typeof d == "string")
      return h(d, g);
    if (ArrayBuffer.isView(d))
      return y(d);
    if (d == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof d
      );
    if (Xt(d, ArrayBuffer) || d && Xt(d.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Xt(d, SharedArrayBuffer) || d && Xt(d.buffer, SharedArrayBuffer)))
      return m(d, g, w);
    if (typeof d == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const $ = d.valueOf && d.valueOf();
    if ($ != null && $ !== d)
      return s.from($, g, w);
    const N = b(d);
    if (N) return N;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof d[Symbol.toPrimitive] == "function")
      return s.from(d[Symbol.toPrimitive]("string"), g, w);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof d
    );
  }
  s.from = function(d, g, w) {
    return u(d, g, w);
  }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array);
  function l(d) {
    if (typeof d != "number")
      throw new TypeError('"size" argument must be of type number');
    if (d < 0)
      throw new RangeError('The value "' + d + '" is invalid for option "size"');
  }
  function c(d, g, w) {
    return l(d), d <= 0 ? i(d) : g !== void 0 ? typeof w == "string" ? i(d).fill(g, w) : i(d).fill(g) : i(d);
  }
  s.alloc = function(d, g, w) {
    return c(d, g, w);
  };
  function f(d) {
    return l(d), i(d < 0 ? 0 : v(d) | 0);
  }
  s.allocUnsafe = function(d) {
    return f(d);
  }, s.allocUnsafeSlow = function(d) {
    return f(d);
  };
  function h(d, g) {
    if ((typeof g != "string" || g === "") && (g = "utf8"), !s.isEncoding(g))
      throw new TypeError("Unknown encoding: " + g);
    const w = E(d, g) | 0;
    let $ = i(w);
    const N = $.write(d, g);
    return N !== w && ($ = $.slice(0, N)), $;
  }
  function p(d) {
    const g = d.length < 0 ? 0 : v(d.length) | 0, w = i(g);
    for (let $ = 0; $ < g; $ += 1)
      w[$] = d[$] & 255;
    return w;
  }
  function y(d) {
    if (Xt(d, Uint8Array)) {
      const g = new Uint8Array(d);
      return m(g.buffer, g.byteOffset, g.byteLength);
    }
    return p(d);
  }
  function m(d, g, w) {
    if (g < 0 || d.byteLength < g)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (d.byteLength < g + (w || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let $;
    return g === void 0 && w === void 0 ? $ = new Uint8Array(d) : w === void 0 ? $ = new Uint8Array(d, g) : $ = new Uint8Array(d, g, w), Object.setPrototypeOf($, s.prototype), $;
  }
  function b(d) {
    if (s.isBuffer(d)) {
      const g = v(d.length) | 0, w = i(g);
      return w.length === 0 || d.copy(w, 0, 0, g), w;
    }
    if (d.length !== void 0)
      return typeof d.length != "number" || lo(d.length) ? i(0) : p(d);
    if (d.type === "Buffer" && Array.isArray(d.data))
      return p(d.data);
  }
  function v(d) {
    if (d >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return d | 0;
  }
  function k(d) {
    return +d != d && (d = 0), s.alloc(+d);
  }
  s.isBuffer = function(d) {
    return d != null && d._isBuffer === !0 && d !== s.prototype;
  }, s.compare = function(d, g) {
    if (Xt(d, Uint8Array) && (d = s.from(d, d.offset, d.byteLength)), Xt(g, Uint8Array) && (g = s.from(g, g.offset, g.byteLength)), !s.isBuffer(d) || !s.isBuffer(g))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (d === g) return 0;
    let w = d.length, $ = g.length;
    for (let N = 0, H = Math.min(w, $); N < H; ++N)
      if (d[N] !== g[N]) {
        w = d[N], $ = g[N];
        break;
      }
    return w < $ ? -1 : $ < w ? 1 : 0;
  }, s.isEncoding = function(d) {
    switch (String(d).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, s.concat = function(d, g) {
    if (!Array.isArray(d))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (d.length === 0)
      return s.alloc(0);
    let w;
    if (g === void 0)
      for (g = 0, w = 0; w < d.length; ++w)
        g += d[w].length;
    const $ = s.allocUnsafe(g);
    let N = 0;
    for (w = 0; w < d.length; ++w) {
      let H = d[w];
      if (Xt(H, Uint8Array))
        N + H.length > $.length ? (s.isBuffer(H) || (H = s.from(H)), H.copy($, N)) : Uint8Array.prototype.set.call(
          $,
          H,
          N
        );
      else if (s.isBuffer(H))
        H.copy($, N);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      N += H.length;
    }
    return $;
  };
  function E(d, g) {
    if (s.isBuffer(d))
      return d.length;
    if (ArrayBuffer.isView(d) || Xt(d, ArrayBuffer))
      return d.byteLength;
    if (typeof d != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof d
      );
    const w = d.length, $ = arguments.length > 2 && arguments[2] === !0;
    if (!$ && w === 0) return 0;
    let N = !1;
    for (; ; )
      switch (g) {
        case "ascii":
        case "latin1":
        case "binary":
          return w;
        case "utf8":
        case "utf-8":
          return Sn(d).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return w * 2;
        case "hex":
          return w >>> 1;
        case "base64":
          return xa(d).length;
        default:
          if (N)
            return $ ? -1 : Sn(d).length;
          g = ("" + g).toLowerCase(), N = !0;
      }
  }
  s.byteLength = E;
  function A(d, g, w) {
    let $ = !1;
    if ((g === void 0 || g < 0) && (g = 0), g > this.length || ((w === void 0 || w > this.length) && (w = this.length), w <= 0) || (w >>>= 0, g >>>= 0, w <= g))
      return "";
    for (d || (d = "utf8"); ; )
      switch (d) {
        case "hex":
          return W(this, g, w);
        case "utf8":
        case "utf-8":
          return F(this, g, w);
        case "ascii":
          return M(this, g, w);
        case "latin1":
        case "binary":
          return re(this, g, w);
        case "base64":
          return V(this, g, w);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ne(this, g, w);
        default:
          if ($) throw new TypeError("Unknown encoding: " + d);
          d = (d + "").toLowerCase(), $ = !0;
      }
  }
  s.prototype._isBuffer = !0;
  function S(d, g, w) {
    const $ = d[g];
    d[g] = d[w], d[w] = $;
  }
  s.prototype.swap16 = function() {
    const d = this.length;
    if (d % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let g = 0; g < d; g += 2)
      S(this, g, g + 1);
    return this;
  }, s.prototype.swap32 = function() {
    const d = this.length;
    if (d % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let g = 0; g < d; g += 4)
      S(this, g, g + 3), S(this, g + 1, g + 2);
    return this;
  }, s.prototype.swap64 = function() {
    const d = this.length;
    if (d % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let g = 0; g < d; g += 8)
      S(this, g, g + 7), S(this, g + 1, g + 6), S(this, g + 2, g + 5), S(this, g + 3, g + 4);
    return this;
  }, s.prototype.toString = function() {
    const d = this.length;
    return d === 0 ? "" : arguments.length === 0 ? F(this, 0, d) : A.apply(this, arguments);
  }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(d) {
    if (!s.isBuffer(d)) throw new TypeError("Argument must be a Buffer");
    return this === d ? !0 : s.compare(this, d) === 0;
  }, s.prototype.inspect = function() {
    let d = "";
    const g = e.INSPECT_MAX_BYTES;
    return d = this.toString("hex", 0, g).replace(/(.{2})/g, "$1 ").trim(), this.length > g && (d += " ... "), "<Buffer " + d + ">";
  }, n && (s.prototype[n] = s.prototype.inspect), s.prototype.compare = function(d, g, w, $, N) {
    if (Xt(d, Uint8Array) && (d = s.from(d, d.offset, d.byteLength)), !s.isBuffer(d))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof d
      );
    if (g === void 0 && (g = 0), w === void 0 && (w = d ? d.length : 0), $ === void 0 && ($ = 0), N === void 0 && (N = this.length), g < 0 || w > d.length || $ < 0 || N > this.length)
      throw new RangeError("out of range index");
    if ($ >= N && g >= w)
      return 0;
    if ($ >= N)
      return -1;
    if (g >= w)
      return 1;
    if (g >>>= 0, w >>>= 0, $ >>>= 0, N >>>= 0, this === d) return 0;
    let H = N - $, Z = w - g;
    const Te = Math.min(H, Z), ut = this.slice($, N), Be = d.slice(g, w);
    for (let Ie = 0; Ie < Te; ++Ie)
      if (ut[Ie] !== Be[Ie]) {
        H = ut[Ie], Z = Be[Ie];
        break;
      }
    return H < Z ? -1 : Z < H ? 1 : 0;
  };
  function _(d, g, w, $, N) {
    if (d.length === 0) return -1;
    if (typeof w == "string" ? ($ = w, w = 0) : w > 2147483647 ? w = 2147483647 : w < -2147483648 && (w = -2147483648), w = +w, lo(w) && (w = N ? 0 : d.length - 1), w < 0 && (w = d.length + w), w >= d.length) {
      if (N) return -1;
      w = d.length - 1;
    } else if (w < 0)
      if (N) w = 0;
      else return -1;
    if (typeof g == "string" && (g = s.from(g, $)), s.isBuffer(g))
      return g.length === 0 ? -1 : I(d, g, w, $, N);
    if (typeof g == "number")
      return g = g & 255, typeof Uint8Array.prototype.indexOf == "function" ? N ? Uint8Array.prototype.indexOf.call(d, g, w) : Uint8Array.prototype.lastIndexOf.call(d, g, w) : I(d, [g], w, $, N);
    throw new TypeError("val must be string, number or Buffer");
  }
  function I(d, g, w, $, N) {
    let H = 1, Z = d.length, Te = g.length;
    if ($ !== void 0 && ($ = String($).toLowerCase(), $ === "ucs2" || $ === "ucs-2" || $ === "utf16le" || $ === "utf-16le")) {
      if (d.length < 2 || g.length < 2)
        return -1;
      H = 2, Z /= 2, Te /= 2, w /= 2;
    }
    function ut(Ie, Xe) {
      return H === 1 ? Ie[Xe] : Ie.readUInt16BE(Xe * H);
    }
    let Be;
    if (N) {
      let Ie = -1;
      for (Be = w; Be < Z; Be++)
        if (ut(d, Be) === ut(g, Ie === -1 ? 0 : Be - Ie)) {
          if (Ie === -1 && (Ie = Be), Be - Ie + 1 === Te) return Ie * H;
        } else
          Ie !== -1 && (Be -= Be - Ie), Ie = -1;
    } else
      for (w + Te > Z && (w = Z - Te), Be = w; Be >= 0; Be--) {
        let Ie = !0;
        for (let Xe = 0; Xe < Te; Xe++)
          if (ut(d, Be + Xe) !== ut(g, Xe)) {
            Ie = !1;
            break;
          }
        if (Ie) return Be;
      }
    return -1;
  }
  s.prototype.includes = function(d, g, w) {
    return this.indexOf(d, g, w) !== -1;
  }, s.prototype.indexOf = function(d, g, w) {
    return _(this, d, g, w, !0);
  }, s.prototype.lastIndexOf = function(d, g, w) {
    return _(this, d, g, w, !1);
  };
  function O(d, g, w, $) {
    w = Number(w) || 0;
    const N = d.length - w;
    $ ? ($ = Number($), $ > N && ($ = N)) : $ = N;
    const H = g.length;
    $ > H / 2 && ($ = H / 2);
    let Z;
    for (Z = 0; Z < $; ++Z) {
      const Te = parseInt(g.substr(Z * 2, 2), 16);
      if (lo(Te)) return Z;
      d[w + Z] = Te;
    }
    return Z;
  }
  function z(d, g, w, $) {
    return _n(Sn(g, d.length - w), d, w, $);
  }
  function D(d, g, w, $) {
    return _n(ka(g), d, w, $);
  }
  function G(d, g, w, $) {
    return _n(xa(g), d, w, $);
  }
  function U(d, g, w, $) {
    return _n(tc(g, d.length - w), d, w, $);
  }
  s.prototype.write = function(d, g, w, $) {
    if (g === void 0)
      $ = "utf8", w = this.length, g = 0;
    else if (w === void 0 && typeof g == "string")
      $ = g, w = this.length, g = 0;
    else if (isFinite(g))
      g = g >>> 0, isFinite(w) ? (w = w >>> 0, $ === void 0 && ($ = "utf8")) : ($ = w, w = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const N = this.length - g;
    if ((w === void 0 || w > N) && (w = N), d.length > 0 && (w < 0 || g < 0) || g > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    $ || ($ = "utf8");
    let H = !1;
    for (; ; )
      switch ($) {
        case "hex":
          return O(this, d, g, w);
        case "utf8":
        case "utf-8":
          return z(this, d, g, w);
        case "ascii":
        case "latin1":
        case "binary":
          return D(this, d, g, w);
        case "base64":
          return G(this, d, g, w);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return U(this, d, g, w);
        default:
          if (H) throw new TypeError("Unknown encoding: " + $);
          $ = ("" + $).toLowerCase(), H = !0;
      }
  }, s.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function V(d, g, w) {
    return g === 0 && w === d.length ? t.fromByteArray(d) : t.fromByteArray(d.slice(g, w));
  }
  function F(d, g, w) {
    w = Math.min(d.length, w);
    const $ = [];
    let N = g;
    for (; N < w; ) {
      const H = d[N];
      let Z = null, Te = H > 239 ? 4 : H > 223 ? 3 : H > 191 ? 2 : 1;
      if (N + Te <= w) {
        let ut, Be, Ie, Xe;
        switch (Te) {
          case 1:
            H < 128 && (Z = H);
            break;
          case 2:
            ut = d[N + 1], (ut & 192) === 128 && (Xe = (H & 31) << 6 | ut & 63, Xe > 127 && (Z = Xe));
            break;
          case 3:
            ut = d[N + 1], Be = d[N + 2], (ut & 192) === 128 && (Be & 192) === 128 && (Xe = (H & 15) << 12 | (ut & 63) << 6 | Be & 63, Xe > 2047 && (Xe < 55296 || Xe > 57343) && (Z = Xe));
            break;
          case 4:
            ut = d[N + 1], Be = d[N + 2], Ie = d[N + 3], (ut & 192) === 128 && (Be & 192) === 128 && (Ie & 192) === 128 && (Xe = (H & 15) << 18 | (ut & 63) << 12 | (Be & 63) << 6 | Ie & 63, Xe > 65535 && Xe < 1114112 && (Z = Xe));
        }
      }
      Z === null ? (Z = 65533, Te = 1) : Z > 65535 && (Z -= 65536, $.push(Z >>> 10 & 1023 | 55296), Z = 56320 | Z & 1023), $.push(Z), N += Te;
    }
    return R($);
  }
  const C = 4096;
  function R(d) {
    const g = d.length;
    if (g <= C)
      return String.fromCharCode.apply(String, d);
    let w = "", $ = 0;
    for (; $ < g; )
      w += String.fromCharCode.apply(
        String,
        d.slice($, $ += C)
      );
    return w;
  }
  function M(d, g, w) {
    let $ = "";
    w = Math.min(d.length, w);
    for (let N = g; N < w; ++N)
      $ += String.fromCharCode(d[N] & 127);
    return $;
  }
  function re(d, g, w) {
    let $ = "";
    w = Math.min(d.length, w);
    for (let N = g; N < w; ++N)
      $ += String.fromCharCode(d[N]);
    return $;
  }
  function W(d, g, w) {
    const $ = d.length;
    (!g || g < 0) && (g = 0), (!w || w < 0 || w > $) && (w = $);
    let N = "";
    for (let H = g; H < w; ++H)
      N += rc[d[H]];
    return N;
  }
  function ne(d, g, w) {
    const $ = d.slice(g, w);
    let N = "";
    for (let H = 0; H < $.length - 1; H += 2)
      N += String.fromCharCode($[H] + $[H + 1] * 256);
    return N;
  }
  s.prototype.slice = function(d, g) {
    const w = this.length;
    d = ~~d, g = g === void 0 ? w : ~~g, d < 0 ? (d += w, d < 0 && (d = 0)) : d > w && (d = w), g < 0 ? (g += w, g < 0 && (g = 0)) : g > w && (g = w), g < d && (g = d);
    const $ = this.subarray(d, g);
    return Object.setPrototypeOf($, s.prototype), $;
  };
  function oe(d, g, w) {
    if (d % 1 !== 0 || d < 0) throw new RangeError("offset is not uint");
    if (d + g > w) throw new RangeError("Trying to access beyond buffer length");
  }
  s.prototype.readUintLE = s.prototype.readUIntLE = function(d, g, w) {
    d = d >>> 0, g = g >>> 0, w || oe(d, g, this.length);
    let $ = this[d], N = 1, H = 0;
    for (; ++H < g && (N *= 256); )
      $ += this[d + H] * N;
    return $;
  }, s.prototype.readUintBE = s.prototype.readUIntBE = function(d, g, w) {
    d = d >>> 0, g = g >>> 0, w || oe(d, g, this.length);
    let $ = this[d + --g], N = 1;
    for (; g > 0 && (N *= 256); )
      $ += this[d + --g] * N;
    return $;
  }, s.prototype.readUint8 = s.prototype.readUInt8 = function(d, g) {
    return d = d >>> 0, g || oe(d, 1, this.length), this[d];
  }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(d, g) {
    return d = d >>> 0, g || oe(d, 2, this.length), this[d] | this[d + 1] << 8;
  }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(d, g) {
    return d = d >>> 0, g || oe(d, 2, this.length), this[d] << 8 | this[d + 1];
  }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(d, g) {
    return d = d >>> 0, g || oe(d, 4, this.length), (this[d] | this[d + 1] << 8 | this[d + 2] << 16) + this[d + 3] * 16777216;
  }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(d, g) {
    return d = d >>> 0, g || oe(d, 4, this.length), this[d] * 16777216 + (this[d + 1] << 16 | this[d + 2] << 8 | this[d + 3]);
  }, s.prototype.readBigUInt64LE = or(function(d) {
    d = d >>> 0, Re(d, "offset");
    const g = this[d], w = this[d + 7];
    (g === void 0 || w === void 0) && Tt(d, this.length - 8);
    const $ = g + this[++d] * 2 ** 8 + this[++d] * 2 ** 16 + this[++d] * 2 ** 24, N = this[++d] + this[++d] * 2 ** 8 + this[++d] * 2 ** 16 + w * 2 ** 24;
    return BigInt($) + (BigInt(N) << BigInt(32));
  }), s.prototype.readBigUInt64BE = or(function(d) {
    d = d >>> 0, Re(d, "offset");
    const g = this[d], w = this[d + 7];
    (g === void 0 || w === void 0) && Tt(d, this.length - 8);
    const $ = g * 2 ** 24 + this[++d] * 2 ** 16 + this[++d] * 2 ** 8 + this[++d], N = this[++d] * 2 ** 24 + this[++d] * 2 ** 16 + this[++d] * 2 ** 8 + w;
    return (BigInt($) << BigInt(32)) + BigInt(N);
  }), s.prototype.readIntLE = function(d, g, w) {
    d = d >>> 0, g = g >>> 0, w || oe(d, g, this.length);
    let $ = this[d], N = 1, H = 0;
    for (; ++H < g && (N *= 256); )
      $ += this[d + H] * N;
    return N *= 128, $ >= N && ($ -= Math.pow(2, 8 * g)), $;
  }, s.prototype.readIntBE = function(d, g, w) {
    d = d >>> 0, g = g >>> 0, w || oe(d, g, this.length);
    let $ = g, N = 1, H = this[d + --$];
    for (; $ > 0 && (N *= 256); )
      H += this[d + --$] * N;
    return N *= 128, H >= N && (H -= Math.pow(2, 8 * g)), H;
  }, s.prototype.readInt8 = function(d, g) {
    return d = d >>> 0, g || oe(d, 1, this.length), this[d] & 128 ? (255 - this[d] + 1) * -1 : this[d];
  }, s.prototype.readInt16LE = function(d, g) {
    d = d >>> 0, g || oe(d, 2, this.length);
    const w = this[d] | this[d + 1] << 8;
    return w & 32768 ? w | 4294901760 : w;
  }, s.prototype.readInt16BE = function(d, g) {
    d = d >>> 0, g || oe(d, 2, this.length);
    const w = this[d + 1] | this[d] << 8;
    return w & 32768 ? w | 4294901760 : w;
  }, s.prototype.readInt32LE = function(d, g) {
    return d = d >>> 0, g || oe(d, 4, this.length), this[d] | this[d + 1] << 8 | this[d + 2] << 16 | this[d + 3] << 24;
  }, s.prototype.readInt32BE = function(d, g) {
    return d = d >>> 0, g || oe(d, 4, this.length), this[d] << 24 | this[d + 1] << 16 | this[d + 2] << 8 | this[d + 3];
  }, s.prototype.readBigInt64LE = or(function(d) {
    d = d >>> 0, Re(d, "offset");
    const g = this[d], w = this[d + 7];
    (g === void 0 || w === void 0) && Tt(d, this.length - 8);
    const $ = this[d + 4] + this[d + 5] * 2 ** 8 + this[d + 6] * 2 ** 16 + (w << 24);
    return (BigInt($) << BigInt(32)) + BigInt(g + this[++d] * 2 ** 8 + this[++d] * 2 ** 16 + this[++d] * 2 ** 24);
  }), s.prototype.readBigInt64BE = or(function(d) {
    d = d >>> 0, Re(d, "offset");
    const g = this[d], w = this[d + 7];
    (g === void 0 || w === void 0) && Tt(d, this.length - 8);
    const $ = (g << 24) + // Overflow
    this[++d] * 2 ** 16 + this[++d] * 2 ** 8 + this[++d];
    return (BigInt($) << BigInt(32)) + BigInt(this[++d] * 2 ** 24 + this[++d] * 2 ** 16 + this[++d] * 2 ** 8 + w);
  }), s.prototype.readFloatLE = function(d, g) {
    return d = d >>> 0, g || oe(d, 4, this.length), r.read(this, d, !0, 23, 4);
  }, s.prototype.readFloatBE = function(d, g) {
    return d = d >>> 0, g || oe(d, 4, this.length), r.read(this, d, !1, 23, 4);
  }, s.prototype.readDoubleLE = function(d, g) {
    return d = d >>> 0, g || oe(d, 8, this.length), r.read(this, d, !0, 52, 8);
  }, s.prototype.readDoubleBE = function(d, g) {
    return d = d >>> 0, g || oe(d, 8, this.length), r.read(this, d, !1, 52, 8);
  };
  function se(d, g, w, $, N, H) {
    if (!s.isBuffer(d)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (g > N || g < H) throw new RangeError('"value" argument is out of bounds');
    if (w + $ > d.length) throw new RangeError("Index out of range");
  }
  s.prototype.writeUintLE = s.prototype.writeUIntLE = function(d, g, w, $) {
    if (d = +d, g = g >>> 0, w = w >>> 0, !$) {
      const Z = Math.pow(2, 8 * w) - 1;
      se(this, d, g, w, Z, 0);
    }
    let N = 1, H = 0;
    for (this[g] = d & 255; ++H < w && (N *= 256); )
      this[g + H] = d / N & 255;
    return g + w;
  }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(d, g, w, $) {
    if (d = +d, g = g >>> 0, w = w >>> 0, !$) {
      const Z = Math.pow(2, 8 * w) - 1;
      se(this, d, g, w, Z, 0);
    }
    let N = w - 1, H = 1;
    for (this[g + N] = d & 255; --N >= 0 && (H *= 256); )
      this[g + N] = d / H & 255;
    return g + w;
  }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 1, 255, 0), this[g] = d & 255, g + 1;
  }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 2, 65535, 0), this[g] = d & 255, this[g + 1] = d >>> 8, g + 2;
  }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 2, 65535, 0), this[g] = d >>> 8, this[g + 1] = d & 255, g + 2;
  }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 4, 4294967295, 0), this[g + 3] = d >>> 24, this[g + 2] = d >>> 16, this[g + 1] = d >>> 8, this[g] = d & 255, g + 4;
  }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 4, 4294967295, 0), this[g] = d >>> 24, this[g + 1] = d >>> 16, this[g + 2] = d >>> 8, this[g + 3] = d & 255, g + 4;
  };
  function K(d, g, w, $, N) {
    We(g, $, N, d, w, 7);
    let H = Number(g & BigInt(4294967295));
    d[w++] = H, H = H >> 8, d[w++] = H, H = H >> 8, d[w++] = H, H = H >> 8, d[w++] = H;
    let Z = Number(g >> BigInt(32) & BigInt(4294967295));
    return d[w++] = Z, Z = Z >> 8, d[w++] = Z, Z = Z >> 8, d[w++] = Z, Z = Z >> 8, d[w++] = Z, w;
  }
  function he(d, g, w, $, N) {
    We(g, $, N, d, w, 7);
    let H = Number(g & BigInt(4294967295));
    d[w + 7] = H, H = H >> 8, d[w + 6] = H, H = H >> 8, d[w + 5] = H, H = H >> 8, d[w + 4] = H;
    let Z = Number(g >> BigInt(32) & BigInt(4294967295));
    return d[w + 3] = Z, Z = Z >> 8, d[w + 2] = Z, Z = Z >> 8, d[w + 1] = Z, Z = Z >> 8, d[w] = Z, w + 8;
  }
  s.prototype.writeBigUInt64LE = or(function(d, g = 0) {
    return K(this, d, g, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeBigUInt64BE = or(function(d, g = 0) {
    return he(this, d, g, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeIntLE = function(d, g, w, $) {
    if (d = +d, g = g >>> 0, !$) {
      const Te = Math.pow(2, 8 * w - 1);
      se(this, d, g, w, Te - 1, -Te);
    }
    let N = 0, H = 1, Z = 0;
    for (this[g] = d & 255; ++N < w && (H *= 256); )
      d < 0 && Z === 0 && this[g + N - 1] !== 0 && (Z = 1), this[g + N] = (d / H >> 0) - Z & 255;
    return g + w;
  }, s.prototype.writeIntBE = function(d, g, w, $) {
    if (d = +d, g = g >>> 0, !$) {
      const Te = Math.pow(2, 8 * w - 1);
      se(this, d, g, w, Te - 1, -Te);
    }
    let N = w - 1, H = 1, Z = 0;
    for (this[g + N] = d & 255; --N >= 0 && (H *= 256); )
      d < 0 && Z === 0 && this[g + N + 1] !== 0 && (Z = 1), this[g + N] = (d / H >> 0) - Z & 255;
    return g + w;
  }, s.prototype.writeInt8 = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 1, 127, -128), d < 0 && (d = 255 + d + 1), this[g] = d & 255, g + 1;
  }, s.prototype.writeInt16LE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 2, 32767, -32768), this[g] = d & 255, this[g + 1] = d >>> 8, g + 2;
  }, s.prototype.writeInt16BE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 2, 32767, -32768), this[g] = d >>> 8, this[g + 1] = d & 255, g + 2;
  }, s.prototype.writeInt32LE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 4, 2147483647, -2147483648), this[g] = d & 255, this[g + 1] = d >>> 8, this[g + 2] = d >>> 16, this[g + 3] = d >>> 24, g + 4;
  }, s.prototype.writeInt32BE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 4, 2147483647, -2147483648), d < 0 && (d = 4294967295 + d + 1), this[g] = d >>> 24, this[g + 1] = d >>> 16, this[g + 2] = d >>> 8, this[g + 3] = d & 255, g + 4;
  }, s.prototype.writeBigInt64LE = or(function(d, g = 0) {
    return K(this, d, g, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), s.prototype.writeBigInt64BE = or(function(d, g = 0) {
    return he(this, d, g, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Ae(d, g, w, $, N, H) {
    if (w + $ > d.length) throw new RangeError("Index out of range");
    if (w < 0) throw new RangeError("Index out of range");
  }
  function ye(d, g, w, $, N) {
    return g = +g, w = w >>> 0, N || Ae(d, g, w, 4), r.write(d, g, w, $, 23, 4), w + 4;
  }
  s.prototype.writeFloatLE = function(d, g, w) {
    return ye(this, d, g, !0, w);
  }, s.prototype.writeFloatBE = function(d, g, w) {
    return ye(this, d, g, !1, w);
  };
  function Et(d, g, w, $, N) {
    return g = +g, w = w >>> 0, N || Ae(d, g, w, 8), r.write(d, g, w, $, 52, 8), w + 8;
  }
  s.prototype.writeDoubleLE = function(d, g, w) {
    return Et(this, d, g, !0, w);
  }, s.prototype.writeDoubleBE = function(d, g, w) {
    return Et(this, d, g, !1, w);
  }, s.prototype.copy = function(d, g, w, $) {
    if (!s.isBuffer(d)) throw new TypeError("argument should be a Buffer");
    if (w || (w = 0), !$ && $ !== 0 && ($ = this.length), g >= d.length && (g = d.length), g || (g = 0), $ > 0 && $ < w && ($ = w), $ === w || d.length === 0 || this.length === 0) return 0;
    if (g < 0)
      throw new RangeError("targetStart out of bounds");
    if (w < 0 || w >= this.length) throw new RangeError("Index out of range");
    if ($ < 0) throw new RangeError("sourceEnd out of bounds");
    $ > this.length && ($ = this.length), d.length - g < $ - w && ($ = d.length - g + w);
    const N = $ - w;
    return this === d && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(g, w, $) : Uint8Array.prototype.set.call(
      d,
      this.subarray(w, $),
      g
    ), N;
  }, s.prototype.fill = function(d, g, w, $) {
    if (typeof d == "string") {
      if (typeof g == "string" ? ($ = g, g = 0, w = this.length) : typeof w == "string" && ($ = w, w = this.length), $ !== void 0 && typeof $ != "string")
        throw new TypeError("encoding must be a string");
      if (typeof $ == "string" && !s.isEncoding($))
        throw new TypeError("Unknown encoding: " + $);
      if (d.length === 1) {
        const H = d.charCodeAt(0);
        ($ === "utf8" && H < 128 || $ === "latin1") && (d = H);
      }
    } else typeof d == "number" ? d = d & 255 : typeof d == "boolean" && (d = Number(d));
    if (g < 0 || this.length < g || this.length < w)
      throw new RangeError("Out of range index");
    if (w <= g)
      return this;
    g = g >>> 0, w = w === void 0 ? this.length : w >>> 0, d || (d = 0);
    let N;
    if (typeof d == "number")
      for (N = g; N < w; ++N)
        this[N] = d;
    else {
      const H = s.isBuffer(d) ? d : s.from(d, $), Z = H.length;
      if (Z === 0)
        throw new TypeError('The value "' + d + '" is invalid for argument "value"');
      for (N = 0; N < w - g; ++N)
        this[N + g] = H[N % Z];
    }
    return this;
  };
  const Ge = {};
  function be(d, g, w) {
    Ge[d] = class extends w {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: g.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${d}]`, this.stack, delete this.name;
      }
      get code() {
        return d;
      }
      set code($) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: $,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${d}]: ${this.message}`;
      }
    };
  }
  be(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(d) {
      return d ? `${d} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), be(
    "ERR_INVALID_ARG_TYPE",
    function(d, g) {
      return `The "${d}" argument must be of type number. Received type ${typeof g}`;
    },
    TypeError
  ), be(
    "ERR_OUT_OF_RANGE",
    function(d, g, w) {
      let $ = `The value of "${d}" is out of range.`, N = w;
      return Number.isInteger(w) && Math.abs(w) > 2 ** 32 ? N = st(String(w)) : typeof w == "bigint" && (N = String(w), (w > BigInt(2) ** BigInt(32) || w < -(BigInt(2) ** BigInt(32))) && (N = st(N)), N += "n"), $ += ` It must be ${g}. Received ${N}`, $;
    },
    RangeError
  );
  function st(d) {
    let g = "", w = d.length;
    const $ = d[0] === "-" ? 1 : 0;
    for (; w >= $ + 4; w -= 3)
      g = `_${d.slice(w - 3, w)}${g}`;
    return `${d.slice(0, w)}${g}`;
  }
  function Ze(d, g, w) {
    Re(g, "offset"), (d[g] === void 0 || d[g + w] === void 0) && Tt(g, d.length - (w + 1));
  }
  function We(d, g, w, $, N, H) {
    if (d > w || d < g) {
      const Z = typeof g == "bigint" ? "n" : "";
      let Te;
      throw g === 0 || g === BigInt(0) ? Te = `>= 0${Z} and < 2${Z} ** ${(H + 1) * 8}${Z}` : Te = `>= -(2${Z} ** ${(H + 1) * 8 - 1}${Z}) and < 2 ** ${(H + 1) * 8 - 1}${Z}`, new Ge.ERR_OUT_OF_RANGE("value", Te, d);
    }
    Ze($, N, H);
  }
  function Re(d, g) {
    if (typeof d != "number")
      throw new Ge.ERR_INVALID_ARG_TYPE(g, "number", d);
  }
  function Tt(d, g, w) {
    throw Math.floor(d) !== d ? (Re(d, w), new Ge.ERR_OUT_OF_RANGE("offset", "an integer", d)) : g < 0 ? new Ge.ERR_BUFFER_OUT_OF_BOUNDS() : new Ge.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${g}`,
      d
    );
  }
  const xr = /[^+/0-9A-Za-z-_]/g;
  function Wt(d) {
    if (d = d.split("=")[0], d = d.trim().replace(xr, ""), d.length < 2) return "";
    for (; d.length % 4 !== 0; )
      d = d + "=";
    return d;
  }
  function Sn(d, g) {
    g = g || 1 / 0;
    let w;
    const $ = d.length;
    let N = null;
    const H = [];
    for (let Z = 0; Z < $; ++Z) {
      if (w = d.charCodeAt(Z), w > 55295 && w < 57344) {
        if (!N) {
          if (w > 56319) {
            (g -= 3) > -1 && H.push(239, 191, 189);
            continue;
          } else if (Z + 1 === $) {
            (g -= 3) > -1 && H.push(239, 191, 189);
            continue;
          }
          N = w;
          continue;
        }
        if (w < 56320) {
          (g -= 3) > -1 && H.push(239, 191, 189), N = w;
          continue;
        }
        w = (N - 55296 << 10 | w - 56320) + 65536;
      } else N && (g -= 3) > -1 && H.push(239, 191, 189);
      if (N = null, w < 128) {
        if ((g -= 1) < 0) break;
        H.push(w);
      } else if (w < 2048) {
        if ((g -= 2) < 0) break;
        H.push(
          w >> 6 | 192,
          w & 63 | 128
        );
      } else if (w < 65536) {
        if ((g -= 3) < 0) break;
        H.push(
          w >> 12 | 224,
          w >> 6 & 63 | 128,
          w & 63 | 128
        );
      } else if (w < 1114112) {
        if ((g -= 4) < 0) break;
        H.push(
          w >> 18 | 240,
          w >> 12 & 63 | 128,
          w >> 6 & 63 | 128,
          w & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return H;
  }
  function ka(d) {
    const g = [];
    for (let w = 0; w < d.length; ++w)
      g.push(d.charCodeAt(w) & 255);
    return g;
  }
  function tc(d, g) {
    let w, $, N;
    const H = [];
    for (let Z = 0; Z < d.length && !((g -= 2) < 0); ++Z)
      w = d.charCodeAt(Z), $ = w >> 8, N = w % 256, H.push(N), H.push($);
    return H;
  }
  function xa(d) {
    return t.toByteArray(Wt(d));
  }
  function _n(d, g, w, $) {
    let N;
    for (N = 0; N < $ && !(N + w >= g.length || N >= d.length); ++N)
      g[N + w] = d[N];
    return N;
  }
  function Xt(d, g) {
    return d instanceof g || d != null && d.constructor != null && d.constructor.name != null && d.constructor.name === g.name;
  }
  function lo(d) {
    return d !== d;
  }
  const rc = function() {
    const d = "0123456789abcdef", g = new Array(256);
    for (let w = 0; w < 16; ++w) {
      const $ = w * 16;
      for (let N = 0; N < 16; ++N)
        g[$ + N] = d[w] + d[N];
    }
    return g;
  }();
  function or(d) {
    return typeof BigInt > "u" ? Aa : d;
  }
  function Aa() {
    throw new Error("BigInt not supported");
  }
})(rte);
var nte = "accountChange";
$e({
  type: wr(nte)
});
var ote = "networkChange";
$e({
  type: wr(ote)
});
var ite = "disconnect";
$e({
  type: wr(ite)
});
async function _y(e) {
  var t;
  const r = await (e == null ? void 0 : e()) || ((t = window.XverseProviders) == null ? void 0 : t.BitcoinProvider) || window.BitcoinProvider;
  if (!r)
    throw new Error("No Bitcoin wallet installed");
  return r;
}
var LT = /* @__PURE__ */ ((e) => (e.Mainnet = "Mainnet", e.Testnet = "Testnet", e.Signet = "Signet", e))(LT || {}), v5 = _i(vy([je(), oa(), pl()])), uo = $e({
  jsonrpc: wr("2.0"),
  method: je(),
  params: _i(
    vy([
      Si(Ey()),
      ST({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      pl()
    ])
  ),
  id: v5
}), sh = /* @__PURE__ */ ((e) => (e[e.PARSE_ERROR = -32700] = "PARSE_ERROR", e[e.INVALID_REQUEST = -32600] = "INVALID_REQUEST", e[e.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", e[e.INVALID_PARAMS = -32602] = "INVALID_PARAMS", e[e.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", e[e.USER_REJECTION = -32e3] = "USER_REJECTION", e[e.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED", e[e.ACCESS_DENIED = -32002] = "ACCESS_DENIED", e))(sh || {}), HT = $e({
  jsonrpc: wr("2.0"),
  result: g5(Ey()),
  id: v5
}), FT = $e({
  jsonrpc: wr("2.0"),
  error: g5(Ey()),
  id: v5
});
vy([
  HT,
  FT
]);
var Iy = /* @__PURE__ */ ((e) => (e.Ordinals = "ordinals", e.Payment = "payment", e.Stacks = "stacks", e))(Iy || {}), DT = /* @__PURE__ */ ((e) => (e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr", e.stacks = "stacks", e))(DT || {}), ate = $e({
  address: je(),
  publicKey: je(),
  purpose: Vc(Iy),
  addressType: Vc(DT)
}), MT = async (e) => {
  var t, r;
  const n = await _y(e.getProvider), { purposes: o } = e.payload;
  if (!o)
    throw new Error("Address purposes are required");
  try {
    const a = Oo.createUnsecuredToken(e.payload), i = await n.connect(a);
    (t = e.onFinish) == null || t.call(e, i);
  } catch (a) {
    console.error("[Connect] Error during address request", a), (r = e.onCancel) == null || r.call(e);
  }
}, ste = "stx_getAddresses", ute = gl(
  $e({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: _i(je())
  })
);
$e({
  ...uo.entries,
  ...$e({
    method: wr(ste),
    params: ute,
    id: je()
  }).entries
});
var cte = "stx_signTransaction", lte = $e({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: je(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: _i(je()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: _i(AT())
});
$e({
  ...uo.entries,
  ...$e({
    method: wr(cte),
    params: lte,
    id: je()
  }).entries
});
var fte = ["software", "ledger"], dte = _T(fte), hte = "getInfo", pte = gl(pl());
$e({
  /**
   * Version of the wallet.
   */
  version: je(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: _i(Si(je())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: Si(je())
});
$e({
  ...uo.entries,
  ...$e({
    method: wr(hte),
    params: pte,
    id: je()
  }).entries
});
var gte = "getAddresses", mte = $e({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: Si(Vc(Iy)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: _i(je())
});
$e({
  ...uo.entries,
  ...$e({
    method: wr(gte),
    params: mte,
    id: je()
  }).entries
});
var yte = "signMessage", Zc = /* @__PURE__ */ ((e) => (e.ECDSA = "ECDSA", e.BIP322 = "BIP322", e))(Zc || {}), bte = $e({
  /**
   * The address used for signing.
   **/
  address: je(),
  /**
   * The message to sign.
   **/
  message: je(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: _i(Vc(Zc))
});
$e({
  /**
   * The signature of the message.
   */
  signature: je(),
  /**
   * hash of the message.
   */
  messageHash: je(),
  /**
   * The address used for signing.
   */
  address: je(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: Vc(Zc)
});
$e({
  ...uo.entries,
  ...$e({
    method: wr(yte),
    params: bte,
    id: je()
  }).entries
});
var wte = "getAccounts", vte = $e({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: Si(Vc(Iy)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: _i(je())
});
Si(
  $e({
    ...ate.entries,
    ...$e({
      walletType: dte
    }).entries
  })
);
$e({
  ...uo.entries,
  ...$e({
    method: wr(wte),
    params: vte,
    id: je()
  }).entries
});
var Ete = "getBalance";
gl(pl());
$e({
  ...uo.entries,
  ...$e({
    method: wr(Ete),
    id: je()
  }).entries
});
var kte = "wallet_requestPermissions", xte = m5();
wr(!0);
$e({
  ...uo.entries,
  ...$e({
    method: wr(kte),
    params: xte,
    id: je()
  }).entries
});
var Ate = "wallet_renouncePermissions", Ste = m5();
wr(!0);
$e({
  ...uo.entries,
  ...$e({
    method: wr(Ate),
    params: Ste,
    id: je()
  }).entries
});
var _te = "wallet_getWalletType";
gl(pl());
$e({
  ...uo.entries,
  ...$e({
    method: wr(_te),
    id: je()
  }).entries
});
var Ite = "runes_getBalance", Tte = gl(pl());
$e({
  balances: Si(
    $e({
      runeName: je(),
      amount: je(),
      divisibility: oa(),
      symbol: je(),
      inscriptionId: gl(je())
    })
  )
});
$e({
  ...uo.entries,
  ...$e({
    method: wr(Ite),
    params: Tte,
    id: je()
  }).entries
});
var Pte = "runes_transfer", Ote = $e({
  recipients: Si(
    $e({
      runeName: je(),
      amount: je(),
      address: je()
    })
  )
});
$e({
  ...uo.entries,
  ...$e({
    method: wr(Pte),
    params: Ote,
    id: je()
  }).entries
});
var $te = "ord_getInscriptions", Cte = $e({
  offset: oa(),
  limit: oa()
});
$e({
  total: oa(),
  limit: oa(),
  offset: oa(),
  inscriptions: Si(
    $e({
      inscriptionId: je(),
      inscriptionNumber: je(),
      address: je(),
      collectionName: _i(je()),
      postage: je(),
      contentLength: je(),
      contentType: je(),
      timestamp: oa(),
      offset: oa(),
      genesisTransaction: je(),
      output: je()
    })
  )
});
$e({
  ...uo.entries,
  ...$e({
    method: wr($te),
    params: Cte,
    id: je()
  }).entries
});
var Bte = "ord_sendInscriptions", Nte = $e({
  transfers: Si(
    $e({
      address: je(),
      inscriptionId: je()
    })
  )
});
$e({
  ...uo.entries,
  ...$e({
    method: wr(Bte),
    params: Nte,
    id: je()
  }).entries
});
var H0 = async (e, t, r) => {
  var n;
  let o = ((n = window.XverseProviders) == null ? void 0 : n.BitcoinProvider) || window.BitcoinProvider;
  if (!o)
    throw new Error("no wallet provider was found");
  if (!e)
    throw new Error("A wallet method is required");
  const a = await o.request(e, t);
  return c7(FT, a) ? {
    status: "error",
    error: a.error
  } : c7(HT, a) ? {
    status: "success",
    result: a.result
  } : {
    status: "error",
    error: {
      code: -32603,
      message: "Received unknown response from provider.",
      data: a
    }
  };
}, Ute = async (e) => {
  var t, r;
  const n = await _y(e.getProvider), { address: o, message: a } = e.payload;
  if (!o)
    throw new Error("An address is required to sign a message");
  if (!a)
    throw new Error("A message to be signed is required");
  try {
    const i = Oo.createUnsecuredToken(e.payload), s = await n.signMessage(i);
    (t = e.onFinish) == null || t.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during sign message request", i), (r = e.onCancel) == null || r.call(e);
  }
}, Rte = (e) => e.map((t) => {
  const { address: r, amountSats: n } = t;
  return {
    address: r,
    amountSats: n.toString()
  };
}), zte = async (e) => {
  var t, r;
  const n = await _y(e.getProvider), { recipients: o, senderAddress: a, network: i, message: s } = e.payload;
  if (!o || o.length === 0)
    throw new Error("At least one recipient is required");
  if (o.some(
    (u) => typeof u.address != "string" || typeof u.amountSats != "bigint"
  ))
    throw new Error("Incorrect recipient format");
  if (!a)
    throw new Error("The sender address is required");
  try {
    const u = Rte(o), l = {
      network: i,
      senderAddress: a,
      message: s,
      recipients: u
    }, c = Oo.createUnsecuredToken(l), f = await n.sendBtcTransaction(c);
    (t = e.onFinish) == null || t.call(e, f);
  } catch (u) {
    console.error("[Connect] Error during send BTC transaction request", u), (r = e.onCancel) == null || r.call(e);
  }
}, jte = async (e) => {
  var t, r;
  const n = await _y(e.getProvider), { psbtBase64: o, inputsToSign: a } = e.payload;
  if (!o)
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!a)
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const i = Oo.createUnsecuredToken(e.payload), s = await n.signTransaction(i);
    (t = e.onFinish) == null || t.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during sign transaction request", i), (r = e.onCancel) == null || r.call(e);
  }
};
let v7 = (e) => e, Qd = {}, yu = { addEventListener() {
}, removeEventListener() {
} };
function Lte() {
  try {
    return typeof localStorage < "u";
  } catch {
    return !1;
  }
}
Lte() && (Qd = localStorage);
let Hte = {
  addEventListener(e, t, r) {
    window.addEventListener("storage", t), window.addEventListener("pageshow", r);
  },
  removeEventListener(e, t, r) {
    window.removeEventListener("storage", t), window.removeEventListener("pageshow", r);
  }
};
typeof window < "u" && (yu = Hte);
function ml(e, t = {}, r = {}) {
  let n = r.encode || v7, o = r.decode || v7, a = Nk(), i = a.setKey, s = (f, h) => {
    typeof h > "u" ? (r.listen !== !1 && yu.perKey && yu.removeEventListener(e + f, l, c), delete Qd[e + f]) : (r.listen !== !1 && yu.perKey && !(f in a.value) && yu.addEventListener(e + f, l, c), Qd[e + f] = n(h));
  };
  a.setKey = (f, h) => {
    s(f, h), i(f, h);
  };
  let u = a.set;
  a.set = function(f) {
    for (let h in f)
      s(h, f[h]);
    for (let h in a.value)
      h in f || s(h, void 0);
    u(f);
  };
  function l(f) {
    f.key ? f.key.startsWith(e) && (f.newValue === null ? i(f.key.slice(e.length), void 0) : i(f.key.slice(e.length), o(f.newValue))) : u({});
  }
  function c() {
    let f = { ...t };
    for (let h in Qd)
      h.startsWith(e) && (f[h.slice(e.length)] = o(Qd[h]));
    for (let h in f)
      a.setKey(h, f[h]);
  }
  return $U(a, () => {
    if (c(), r.listen !== !1)
      return yu.addEventListener(e, l, c), () => {
        yu.removeEventListener(e, l, c);
        for (let f in a.value)
          yu.removeEventListener(e + f, l, c);
      };
  }), a;
}
const Fte = "XVERSE_CONNECTED_WALLET_STATE";
class Dte extends Bi {
  constructor() {
    super(...arguments), ke(this, "observer"), ke(this, "$valueStore", ml(
      Fte,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), ke(this, "removeSubscriber");
  }
  get library() {
    return window == null ? void 0 : window.BitcoinProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Xu)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    hl(lc, t, n, this.$valueStore);
  }
  initialize() {
    Yo(this.$store, ["provider"], (t) => {
      t.provider !== lc ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    }), typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t, r;
      (t = window == null ? void 0 : window.XverseProviders) != null && t.BitcoinProvider && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [lc]: !0
      }), (r = this.observer) == null || r.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 }));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r)
        if (r.startsWith("tb1") && od(this.network))
          this.disconnect();
        else {
          this.restorePersistedValues(), as(n, this.network).then((a) => {
            this.$store.setKey("balance", a);
          });
          return;
        }
      let o = x1(this.network || Ot);
      await MT({
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Connecting with lasereyes",
          network: {
            type: o
          }
        },
        onFinish: (a) => {
          const i = s5(a.addresses), s = u5(a.addresses);
          if (!i || !s)
            throw new Error("Could not find the addresses");
          i && s && (this.$store.setKey("address", i.address), this.$store.setKey("paymentAddress", s.address), this.$store.setKey("accounts", [
            i.address,
            s.address
          ])), this.$store.setKey(
            "publicKey",
            String(a.addresses[0].publicKey)
          ), this.$store.setKey(
            "paymentPublicKey",
            String(a.addresses[1].publicKey)
          );
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${lc} wallet`);
        },
        onError: (a) => {
          throw new Error(`Can't lasereyes to ${lc} wallet`);
        }
      });
    } catch (o) {
      throw o;
    }
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [Yt, on, pn, Nn].includes(this.network) ? this.network : Ot;
  }
  async sendBTC(t, r) {
    const n = await H0("sendTransfer", {
      recipients: [
        {
          address: t,
          amount: r
        }
      ]
    });
    if (n.status === "success")
      return n.result.txid;
    throw n.error.code === sh.USER_REJECTION ? new Error("User rejected the request") : new Error("Error sending BTC: " + n.error.message);
  }
  async signMessage(t, { toSignAddress: r, protocol: n }) {
    const o = r || this.$store.get().paymentAddress, a = await H0("signMessage", {
      address: o,
      message: t,
      protocol: n === Bp ? Zc.ECDSA : Zc.BIP322
    });
    if (a.status === "success")
      return a.result.signature;
    throw a.error.code === sh.USER_REJECTION ? new Error("User rejected the request") : new Error("Error signing message: " + a.error.message);
  }
  async signPsbt(t, r, n, o, a) {
    try {
      const i = Gt.fromBase64(String(n), {
        network: Er(this.network)
      }), s = this.$store.get().address, u = this.$store.get().paymentAddress, l = i.data.inputs;
      let c = {};
      const f = {
        [s]: []
      }, h = {
        [u]: []
      };
      let p = 0;
      for await (let E of l) {
        if (E.witnessUtxo === void 0)
          h[u].push(Number(p));
        else {
          const { script: A } = E.witnessUtxo, S = bp(
            A,
            Er(this.network)
          );
          S === u ? h[u].push(Number(p)) : S === s && f[s].push(Number(p));
        }
        p++;
      }
      f[s].length > 0 && (c = { ...c, ...f }), h[u].length > 0 && (c = { ...c, ...h });
      let y, m, b, v;
      const k = await H0("signPsbt", {
        psbt: n,
        broadcast: !!a,
        signInputs: c
      });
      if (k.status === "success")
        v = Gt.fromBase64(k.result.psbt, {
          network: Er(this.network)
        }), y = k.result.txid;
      else
        throw k.error.code === sh.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
      if (!v)
        throw new Error("Error signing psbt");
      return o && !y ? (v.finalizeAllInputs(), m = v.toHex(), b = v.toBase64()) : (m = v.toHex(), b = v.toBase64()), {
        signedPsbtHex: m,
        signedPsbtBase64: b,
        txId: y
      };
    } catch (i) {
      throw console.error(i), i;
    }
  }
  async getInscriptions(t, r) {
    const n = await H0("ord_getInscriptions", {
      offset: t || 0,
      limit: r || 10
    });
    if (n.status === "success")
      return console.log(n.result), n.result.inscriptions;
    throw console.error(n.error), new Error("Error getting inscriptions");
  }
}
class Mte extends Bi {
  constructor() {
    super(...arguments), ke(this, "observer");
  }
  get library() {
    return window.wizz;
  }
  get network() {
    return this.$network.get();
  }
  handleNetworkChanged(t) {
    this.parent.connect(Gl);
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && this.$store.setKey("accounts", t);
  }
  initialize() {
    Yo(this.$store, ["provider"], (t) => {
      t.provider === Gl ? this.addLibraryListeners() : this.removeLibraryListeners();
    }), typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Gl]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 }));
  }
  removeLibraryListeners() {
    var t, r;
    (t = this.library) == null || t.removeListener(
      "networkChanged",
      this.handleNetworkChanged.bind(this)
    ), (r = this.library) == null || r.removeListener(
      "accountsChanged",
      this.handleAccountsChanged.bind(this)
    );
  }
  addLibraryListeners() {
    var t, r;
    (t = this.library) == null || t.on("networkChanged", this.handleNetworkChanged.bind(this)), (r = this.library) == null || r.on("accountsChanged", this.handleAccountsChanged.bind(this));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeLibraryListeners();
  }
  async connect() {
    if (!this.library) throw wee;
    const t = await this.library.requestAccounts();
    if (!t) throw new Error("No accounts found");
    const r = await this.library.getPublicKey();
    if (!r) throw new Error("No public key found");
    this.$store.setKey("accounts", t), this.$store.setKey("address", t[0]), this.$store.setKey("paymentAddress", t[0]), this.$store.setKey("publicKey", r), this.$store.setKey("paymentPublicKey", r), this.$store.setKey("provider", Gl), await this.getNetwork().then((n) => {
      var o;
      n && ((o = this.config) == null ? void 0 : o.network) !== n && this.parent.switchNetwork(n);
    }), this.$store.setKey("connected", !0);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async getNetwork() {
    var t;
    const r = await ((t = this.library) == null ? void 0 : t.getNetwork());
    return r ? $E(r) : void 0;
  }
  async switchNetwork(t) {
    var r;
    if (t === Nn || t === fl)
      return await this.library.switchNetwork(xg);
    const n = $E(t);
    await ((r = this.library) == null ? void 0 : r.switchNetwork(n)), this.$network.set(t), await this.parent.getBalance();
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async sendBTC(t, r) {
    var n;
    const o = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
    if (o)
      return o;
    throw new Error("Error sending BTC");
  }
  async signMessage(t, r) {
    var n;
    const o = (r == null ? void 0 : r.protocol) === i5 ? fy : r == null ? void 0 : r.protocol;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t, o));
  }
  async signPsbt(t, r, n, o, a) {
    var i;
    const s = await ((i = this.library) == null ? void 0 : i.signPsbt(r, {
      autoFinalized: o,
      broadcast: !1
    })), u = Gt.fromHex(s);
    let l;
    return o && a && (l = await this.pushPsbt(s)), {
      signedPsbtHex: u.toHex(),
      signedPsbtBase64: u.toBase64(),
      txId: l
    };
  }
}
const Kte = "OYL_CONNECTED_WALLET_STATE";
class qte extends Bi {
  constructor() {
    super(...arguments), ke(this, "observer"), ke(this, "$valueStore", ml(
      Kte,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), ke(this, "removeSubscriber");
  }
  get library() {
    return window.oyl;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Xu)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    hl(th, t, n, this.$valueStore);
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      window != null && window.oyl && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [th]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Yo(this.$store, ["provider"], (t) => {
      t.provider !== th ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    if (r)
      if (r.startsWith("tb1") && od(this.network))
        this.disconnect();
      else {
        this.restorePersistedValues(), as(n, this.network).then((i) => {
          this.$store.setKey("balance", i);
        });
        return;
      }
    if (!this.library) throw new Error("Oyl isn't installed");
    if (l5(this.network))
      throw new Error(`${this.network} is not supported by Oyl`);
    const { nativeSegwit: o, taproot: a } = await this.library.getAddresses();
    if (!o || !a) throw new Error("No accounts found");
    this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", a.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey);
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    const { psbtHex: n } = await c5(
      this.$store.get().address,
      this.$store.get().paymentAddress,
      t,
      r,
      this.$store.get().paymentPublicKey,
      this.network,
      7
    ), o = await this.signPsbt("", n, "", !0, !0);
    if (!o) throw new Error("Error sending BTC");
    return o.txId;
  }
  async signMessage(t, r) {
    const n = (r == null ? void 0 : r.toSignAddress) || this.$store.get().paymentAddress;
    return (await this.library.signMessage({
      address: n,
      message: t,
      protocol: r == null ? void 0 : r.protocol
    })).signature;
  }
  async signPsbt(t, r, n, o, a) {
    const { psbt: i, txid: s } = await this.library.signPsbt({
      psbt: r,
      finalize: o,
      broadcast: a
    }), u = Gt.fromHex(i);
    return {
      signedPsbtHex: u.toHex(),
      signedPsbtBase64: u.toBase64(),
      txId: s
    };
  }
  async pushPsbt(t) {
    return (await this.library.pushPsbt({ psbt: t })).txid;
  }
  async getPublicKey() {
    const { nativeSegwit: t, taproot: r } = await this.library.getAddresses();
    if (!t || !r) throw new Error("No accounts found");
    return this.$store.setKey("publicKey", r.publicKey), this.$store.setKey("paymentPublicKey", t.publicKey), r.publicKey;
  }
  async getBalance() {
    const { total: t } = await this.library.getBalance();
    return this.$store.setKey("balance", t), t;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async requestAccounts() {
    return [this.$store.get().address, this.$store.get().paymentAddress];
  }
  async switchNetwork() {
    throw Tv;
  }
}
const Vte = "LEATHER_CONNECTED_WALLET_STATE";
class Gte extends Bi {
  constructor() {
    super(...arguments), ke(this, "observer"), ke(this, "$valueStore", ml(
      Vte,
      {
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }
    )), ke(this, "removeSubscriber");
  }
  get library() {
    return window.LeatherProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Xu)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    hl(
      rh,
      t,
      n,
      this.$valueStore
    );
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      window != null && window.LeatherProvider && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [rh]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Yo(this.$store, ["provider"], (t) => {
      t.provider !== rh ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    var r;
    const { address: n, paymentAddress: o } = this.$valueStore.get();
    if (n)
      if (n.startsWith("tb1") && od(this.network))
        this.disconnect();
      else {
        this.restorePersistedValues(), as(o, this.network).then((c) => {
          this.$store.setKey("balance", c);
        });
        return;
      }
    if (!this.library) throw new Error("Leather isn't installed");
    const a = await this.library.request("getAddresses");
    if (!a) throw new Error("No accounts found");
    const i = a.result.addresses, s = i.map(
      (c) => c.address
    ), u = i.find(
      (c) => c.type === tf
    ), l = i.find(
      (c) => c.type === Aw
    );
    if (!(u != null && u.publicKey) || !(l != null && l.publicKey))
      throw new Error("No accounts found");
    if ((r = String(u == null ? void 0 : u.address)) != null && r.startsWith("tb") && this.network !== Yt && this.network !== on && this.network !== pn)
      throw new Error(
        `Please switch networks to ${this.network} in the wallet settings.`
      );
    this.$store.setKey("accounts", s), this.$store.setKey("address", u.address), this.$store.setKey("paymentAddress", l.address), this.$store.setKey("publicKey", u.publicKey), this.$store.setKey("paymentPublicKey", l.publicKey);
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    var n, o;
    const a = await ((n = this.library) == null ? void 0 : n.request("sendTransfer", {
      recipients: [
        {
          address: t,
          amount: r
        }
      ]
    }));
    if ((o = a == null ? void 0 : a.result) != null && o.txid)
      return a.result.txid;
    throw a.error.code === sh.USER_REJECTION ? new Error("User rejected the request") : new Error("Error sending BTC: " + a.error.message);
  }
  async signMessage(t, r) {
    var n;
    const o = r == null ? void 0 : r.toSignAddress;
    if ((r == null ? void 0 : r.protocol) === Bp)
      throw new Error("Leather doesn't support ECDSA message signing");
    const a = o === this.$store.get().address ? tf : Aw;
    if (o !== this.$store.get().address && o !== this.$store.get().paymentAddress)
      throw new Error("Invalid address to sign message");
    const i = await this.library.request("signMessage", {
      message: t,
      paymentType: a
    });
    return (n = i == null ? void 0 : i.result) == null ? void 0 : n.signature;
  }
  async signPsbt(t, r, n, o, a) {
    const i = {
      hex: r,
      broadcast: !1,
      network: this.network
    }, s = (await this.library.request(
      "signPsbt",
      i
    )).result.hex, u = Gt.fromHex(String(s));
    if (o && a) {
      const l = u.finalizeAllInputs(), c = await this.pushPsbt(l.toHex());
      return {
        signedPsbtHex: u.toHex(),
        signedPsbtBase64: u.toBase64(),
        txId: c
      };
    } else if (o) {
      const l = u.finalizeAllInputs();
      return {
        signedPsbtHex: l.toHex(),
        signedPsbtBase64: l.toBase64(),
        txId: void 0
      };
    } else
      return {
        signedPsbtHex: u.toHex(),
        signedPsbtBase64: u.toBase64(),
        txId: void 0
      };
  }
  async getPublicKey() {
    const { result: t } = await this.library.request(
      "getAddresses"
    ), r = t.addresses.find(
      (n) => n.type === tf
    );
    if (!(r != null && r.publicKey))
      throw new Error("No accounts found");
    return r.publicKey;
  }
  async getBalance() {
    const t = await as(
      this.$store.get().paymentAddress,
      this.network
    );
    return this.$store.setKey("balance", t), t.toString();
  }
  async requestAccounts() {
    const { result: t } = await this.library.request(
      "getAddresses"
    ), r = t.addresses.map((n) => n.address);
    return this.$store.setKey("accounts", r), r;
  }
}
var uh = {}, KT = {}, Ni = {}, qT = {};
Object.defineProperty(qT, "__esModule", { value: !0 });
(function(e) {
  var t = Me && Me.__createBinding || (Object.create ? function(i, s, u, l) {
    l === void 0 && (l = u);
    var c = Object.getOwnPropertyDescriptor(s, u);
    (!c || ("get" in c ? !s.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return s[u];
    } }), Object.defineProperty(i, l, c);
  } : function(i, s, u, l) {
    l === void 0 && (l = u), i[l] = s[u];
  }), r = Me && Me.__exportStar || function(i, s) {
    for (var u in i) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && t(s, i, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getProviderById = e.getProviders = e.getProviderOrThrow = void 0;
  async function n(i) {
    var s, u;
    if (i) {
      const c = await i();
      if (c)
        return c;
    }
    const l = window.OrangeBitcoinProvider || ((s = window.OrangecryptoProviders) == null ? void 0 : s.BitcoinProvider) || ((u = window.OrangeWalletProviders) == null ? void 0 : u.OrangeBitcoinProvider);
    if (!l)
      throw new Error("No Orange Bitcoin wallet installed");
    return l;
  }
  e.getProviderOrThrow = n;
  function o() {
    return window.btc_providers || (window.btc_providers = []), window.btc_providers;
  }
  e.getProviders = o;
  function a(i) {
    var s;
    if (Array.isArray(window.btc_providers)) {
      const u = window.btc_providers.find((l) => l.id === i);
      return (s = u == null ? void 0 : u.id) == null ? void 0 : s.split(".").reduce((l, c) => l == null ? void 0 : l[c], window);
    } else {
      console.log("window.btc_providers is not defined or not an array");
      return;
    }
  }
  e.getProviderById = a, r(qT, e);
})(Ni);
var VT = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.AddressType = e.AddressPurpose = void 0, function(t) {
    t.Ordinals = "ordinals", t.Payment = "payment", t.Stacks = "stacks";
  }(e.AddressPurpose || (e.AddressPurpose = {})), function(t) {
    t.p2pkh = "p2pkh", t.p2sh = "p2sh", t.p2wpkh = "p2wpkh", t.p2wsh = "p2wsh", t.p2tr = "p2tr", t.stacks = "stacks";
  }(e.AddressType || (e.AddressType = {}));
})(VT);
(function(e) {
  var t = Me && Me.__createBinding || (Object.create ? function(i, s, u, l) {
    l === void 0 && (l = u);
    var c = Object.getOwnPropertyDescriptor(s, u);
    (!c || ("get" in c ? !s.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return s[u];
    } }), Object.defineProperty(i, l, c);
  } : function(i, s, u, l) {
    l === void 0 && (l = u), i[l] = s[u];
  }), r = Me && Me.__exportStar || function(i, s) {
    for (var u in i) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && t(s, i, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getAddress = void 0;
  const n = Oo, o = Ni, a = async (i) => {
    var s, u;
    const l = await (0, o.getProviderOrThrow)(i.getProvider), { purposes: c } = i.payload;
    if (!c)
      throw new Error("Address purposes are required");
    try {
      const f = (0, n.createUnsecuredToken)(i.payload), h = await l.connect(f);
      (s = i.onFinish) == null || s.call(i, h);
    } catch (f) {
      console.error("[Connect] Error during address request", f), (u = i.onCancel) == null || u.call(i);
    }
  };
  e.getAddress = a, r(VT, e);
})(KT);
var GT = {}, ZT = {}, WT = {};
Object.defineProperty(WT, "__esModule", { value: !0 });
var XT = {};
Object.defineProperty(XT, "__esModule", { value: !0 });
(function(e) {
  var t = Me && Me.__createBinding || (Object.create ? function(n, o, a, i) {
    i === void 0 && (i = a);
    var s = Object.getOwnPropertyDescriptor(o, a);
    (!s || ("get" in s ? !o.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return o[a];
    } }), Object.defineProperty(n, i, s);
  } : function(n, o, a, i) {
    i === void 0 && (i = a), n[i] = o[a];
  }), r = Me && Me.__exportStar || function(n, o) {
    for (var a in n) a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && t(o, n, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(WT, e), r(XT, e);
})(ZT);
(function(e) {
  var t = Me && Me.__createBinding || (Object.create ? function(i, s, u, l) {
    l === void 0 && (l = u);
    var c = Object.getOwnPropertyDescriptor(s, u);
    (!c || ("get" in c ? !s.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return s[u];
    } }), Object.defineProperty(i, l, c);
  } : function(i, s, u, l) {
    l === void 0 && (l = u), i[l] = s[u];
  }), r = Me && Me.__exportStar || function(i, s) {
    for (var u in i) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && t(s, i, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.request = void 0;
  const n = Ni, o = async (i, s, u) => {
    var l;
    let c = ((l = window.OrangecryptoProviders) == null ? void 0 : l.BitcoinProvider) || window.OrangeBitcoinProvider;
    if (u && (c = await (0, n.getProviderById)(u)), !c)
      throw new Error("no wallet provider was found");
    if (!i)
      throw new Error("A wallet method is required");
    const f = await c.request(i, s);
    return a(f) ? {
      status: "success",
      result: f.result
    } : {
      status: "error",
      error: f.error
    };
  };
  e.request = o;
  const a = (i) => Object.hasOwn(i, "result") && !!i.result;
  r(ZT, e);
})(GT);
var YT = {}, JT = {};
Object.defineProperty(JT, "__esModule", { value: !0 });
(function(e) {
  var t = Me && Me.__createBinding || (Object.create ? function(s, u, l, c) {
    c === void 0 && (c = l);
    var f = Object.getOwnPropertyDescriptor(u, l);
    (!f || ("get" in f ? !u.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return u[l];
    } }), Object.defineProperty(s, c, f);
  } : function(s, u, l, c) {
    c === void 0 && (c = l), s[c] = u[l];
  }), r = Me && Me.__exportStar || function(s, u) {
    for (var l in s) l !== "default" && !Object.prototype.hasOwnProperty.call(u, l) && t(u, s, l);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getCapabilities = void 0;
  const n = Oo, o = Ni, a = (s, u) => {
    const l = (f) => !(!s[f] || u && !u.has(f)), c = {
      request: l("request"),
      connect: l("connect"),
      signMessage: l("signMessage"),
      signTransaction: l("signTransaction"),
      sendBtcTransaction: l("sendBtcTransaction"),
      createInscription: l("createInscription"),
      createRepeatInscriptions: l("createRepeatInscriptions"),
      signMultipleTransactions: l("signMultipleTransactions")
    };
    return Object.entries(c).reduce((f, [h, p]) => p ? [...f, h] : f, []);
  }, i = async (s) => {
    var u, l, c;
    const f = await (0, o.getProviderOrThrow)(s.getProvider), h = (0, n.createUnsecuredToken)(s.payload);
    if (f.getCapabilities)
      try {
        const p = await f.getCapabilities(h);
        (u = s.onFinish) == null || u.call(s, a(f, new Set(p)));
      } catch (p) {
        console.error("[Connect] Error during capabilities request", p);
      }
    try {
      const p = a(f);
      (l = s.onFinish) == null || l.call(s, p);
    } catch (p) {
      console.error("[Connect] Error during capabilities request", p), (c = s.onCancel) == null || c.call(s);
    }
  };
  e.getCapabilities = i, r(JT, e);
})(YT);
var QT = {}, Ty = {}, Hp = {};
Object.defineProperty(Hp, "__esModule", { value: !0 });
Hp.validateInscriptionPayload = void 0;
const Zte = 4e5, Wte = 6e4, Xte = (e) => {
  const { contentType: t, content: r, payloadType: n, network: o, appFeeAddress: a, appFee: i } = e;
  if (!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(t))
    throw new Error("Invalid content type detected");
  if (!r || r.length === 0)
    throw new Error("Empty content not allowed");
  if (!n || n !== "BASE_64" && n !== "PLAIN_TEXT")
    throw new Error("Empty invalid payloadType specified");
  if (r.length > (o.type === "Mainnet" ? Zte : Wte))
    throw new Error("Content too large");
  if (((a == null ? void 0 : a.length) ?? 0) > 0 && (i ?? 0) <= 0)
    throw new Error("Invalid combination of app fee address and fee provided");
};
Hp.validateInscriptionPayload = Xte;
Object.defineProperty(Ty, "__esModule", { value: !0 });
Ty.createInscription = void 0;
const Yte = Oo, Jte = Ni, Qte = Hp, ere = async (e) => {
  var t, r;
  const { getProvider: n } = e, o = await (0, Jte.getProviderOrThrow)(n);
  (0, Qte.validateInscriptionPayload)(e.payload);
  try {
    const a = (0, Yte.createUnsecuredToken)(e.payload), i = await o.createInscription(a);
    (t = e.onFinish) == null || t.call(e, i);
  } catch (a) {
    console.error("[Connect] Error during create inscription", a), (r = e.onCancel) == null || r.call(e);
  }
};
Ty.createInscription = ere;
var Py = {};
Object.defineProperty(Py, "__esModule", { value: !0 });
Py.createRepeatInscriptions = void 0;
const tre = Ni, rre = Oo, nre = Hp, ore = async (e) => {
  var t, r;
  const { getProvider: n } = e, o = await (0, tre.getProviderOrThrow)(n);
  (0, nre.validateInscriptionPayload)(e.payload);
  try {
    const a = (0, rre.createUnsecuredToken)(e.payload), i = await o.createRepeatInscriptions(a);
    (t = e.onFinish) == null || t.call(e, i);
  } catch (a) {
    console.error("[Connect] Error during create repeat inscriptions", a), (r = e.onCancel) == null || r.call(e);
  }
};
Py.createRepeatInscriptions = ore;
var eP = {};
Object.defineProperty(eP, "__esModule", { value: !0 });
(function(e) {
  var t = Me && Me.__createBinding || (Object.create ? function(n, o, a, i) {
    i === void 0 && (i = a);
    var s = Object.getOwnPropertyDescriptor(o, a);
    (!s || ("get" in s ? !o.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return o[a];
    } }), Object.defineProperty(n, i, s);
  } : function(n, o, a, i) {
    i === void 0 && (i = a), n[i] = o[a];
  }), r = Me && Me.__exportStar || function(n, o) {
    for (var a in n) a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && t(o, n, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Ty, e), r(Py, e), r(eP, e);
})(QT);
var tP = {}, rP = {};
Object.defineProperty(rP, "__esModule", { value: !0 });
(function(e) {
  var t = Me && Me.__createBinding || (Object.create ? function(i, s, u, l) {
    l === void 0 && (l = u);
    var c = Object.getOwnPropertyDescriptor(s, u);
    (!c || ("get" in c ? !s.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return s[u];
    } }), Object.defineProperty(i, l, c);
  } : function(i, s, u, l) {
    l === void 0 && (l = u), i[l] = s[u];
  }), r = Me && Me.__exportStar || function(i, s) {
    for (var u in i) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && t(s, i, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.signMessage = void 0;
  const n = Oo, o = Ni, a = async (i) => {
    var s, u;
    const l = await (0, o.getProviderOrThrow)(i.getProvider), { address: c, message: f } = i.payload;
    if (!c)
      throw new Error("An address is required to sign a message");
    if (!f)
      throw new Error("A message to be signed is required");
    try {
      const h = (0, n.createUnsecuredToken)(i.payload), p = await l.signMessage(h);
      (s = i.onFinish) == null || s.call(i, p);
    } catch (h) {
      console.error("[Connect] Error during sign message request", h), (u = i.onCancel) == null || u.call(i);
    }
  };
  e.signMessage = a, r(rP, e);
})(tP);
var nP = {}, Oy = {};
Object.defineProperty(Oy, "__esModule", { value: !0 });
Oy.sendBtcTransaction = void 0;
const ire = Oo, are = Ni, sre = (e) => e.map((t) => {
  const { address: r, amountSats: n } = t;
  return {
    address: r,
    amountSats: n.toString()
  };
}), ure = async (e) => {
  var t, r;
  const n = await (0, are.getProviderOrThrow)(e.getProvider), { recipients: o, senderAddress: a, network: i, message: s } = e.payload;
  if (!o || o.length === 0)
    throw new Error("At least one recipient is required");
  if (o.some((u) => typeof u.address != "string" || typeof u.amountSats != "bigint"))
    throw new Error("Incorrect recipient format");
  if (!a)
    throw new Error("The sender address is required");
  try {
    const u = sre(o), l = {
      network: i,
      senderAddress: a,
      message: s,
      recipients: u
    }, c = (0, ire.createUnsecuredToken)(l), f = await n.sendBtcTransaction(c);
    (t = e.onFinish) == null || t.call(e, f);
  } catch (u) {
    console.error("[Connect] Error during send BTC transaction request", u), (r = e.onCancel) == null || r.call(e);
  }
};
Oy.sendBtcTransaction = ure;
var $y = {};
Object.defineProperty($y, "__esModule", { value: !0 });
$y.signTransaction = void 0;
const cre = Oo, lre = Ni, fre = async (e) => {
  var t, r;
  const n = await (0, lre.getProviderOrThrow)(e.getProvider), { psbtBase64: o, inputsToSign: a } = e.payload;
  if (!o)
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!a)
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const i = (0, cre.createUnsecuredToken)(e.payload), s = await n.signTransaction(i);
    (t = e.onFinish) == null || t.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during sign transaction request", i), (r = e.onCancel) == null || r.call(e);
  }
};
$y.signTransaction = fre;
var Cy = {};
Object.defineProperty(Cy, "__esModule", { value: !0 });
Cy.signMultipleTransactions = void 0;
const dre = Oo, hre = Ni, pre = async (e) => {
  var t, r;
  const n = await (0, hre.getProviderOrThrow)(e.getProvider), { psbts: o } = e.payload;
  if (!o || !o.length)
    throw new Error("psbts array is required");
  if (o.length > 100)
    throw new Error("psbts array must contain less than 100 psbts");
  try {
    const a = (0, dre.createUnsecuredToken)(e.payload), i = await n.signMultipleTransactions(a);
    (t = e.onFinish) == null || t.call(e, i);
  } catch (a) {
    console.error("[Connect] Error during sign Multiple transactions request", a), (r = e.onCancel) == null || r.call(e);
  }
};
Cy.signMultipleTransactions = pre;
var oP = {};
Object.defineProperty(oP, "__esModule", { value: !0 });
(function(e) {
  var t = Me && Me.__createBinding || (Object.create ? function(n, o, a, i) {
    i === void 0 && (i = a);
    var s = Object.getOwnPropertyDescriptor(o, a);
    (!s || ("get" in s ? !o.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return o[a];
    } }), Object.defineProperty(n, i, s);
  } : function(n, o, a, i) {
    i === void 0 && (i = a), n[i] = o[a];
  }), r = Me && Me.__exportStar || function(n, o) {
    for (var a in n) a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && t(o, n, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Oy, e), r($y, e), r(Cy, e), r(oP, e);
})(nP);
var iP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.RpcErrorCode = e.BitcoinNetworkType = void 0, function(t) {
    t.Mainnet = "Mainnet", t.Testnet = "Testnet";
  }(e.BitcoinNetworkType || (e.BitcoinNetworkType = {})), function(t) {
    t[t.PARSE_ERROR = -32700] = "PARSE_ERROR", t[t.INVALID_REQUEST = -32600] = "INVALID_REQUEST", t[t.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", t[t.INVALID_PARAMS = -32602] = "INVALID_PARAMS", t[t.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", t[t.USER_REJECTION = -32e3] = "USER_REJECTION", t[t.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED";
  }(e.RpcErrorCode || (e.RpcErrorCode = {}));
})(iP);
(function(e) {
  var t = Me && Me.__createBinding || (Object.create ? function(n, o, a, i) {
    i === void 0 && (i = a);
    var s = Object.getOwnPropertyDescriptor(o, a);
    (!s || ("get" in s ? !o.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return o[a];
    } }), Object.defineProperty(n, i, s);
  } : function(n, o, a, i) {
    i === void 0 && (i = a), n[i] = o[a];
  }), r = Me && Me.__exportStar || function(n, o) {
    for (var a in n) a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && t(o, n, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(KT, e), r(GT, e), r(YT, e), r(QT, e), r(tP, e), r(Ni, e), r(nP, e), r(iP, e);
})(uh);
const gre = /* @__PURE__ */ zR(uh), { signMessage: mre, sendBtcTransaction: yre } = gre, bre = "ORANGE_CONNECTED_WALLET_STATE";
class wre extends Bi {
  constructor() {
    super(...arguments), ke(this, "observer"), ke(this, "$valueStore", ml(
      bre,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), ke(this, "removeSubscriber");
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.OrangeWalletProviders) == null ? void 0 : t.OrangeBitcoinProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Xu)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    hl(dc, t, n, this.$valueStore);
  }
  initialize() {
    var t;
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r;
      window != null && window.OrangeBitcoinProvider && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [dc]: !0
      }), (r = this.observer) == null || r.disconnect());
    }), (t = this.observer) == null || t.observe(document, { childList: !0, subtree: !0 })), Yo(this.$store, ["provider"], (r) => {
      r.provider !== dc ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r) {
        this.restorePersistedValues(), as(n, this.network).then((i) => {
          this.$store.setKey("balance", i);
        });
        return;
      }
      let o = v2(this.network || Ot);
      const a = {
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Address for receiving Ordinals and payments",
          network: {
            type: o
          }
        },
        onFinish: (i) => {
          const s = s5(i.addresses), u = u5(i.addresses);
          if (!s || !(u != null && u.address))
            throw new Error("Could not find addresses");
          s && u && (this.$store.setKey("provider", dc), this.$store.setKey("address", s.address), this.$store.setKey("paymentAddress", u.address)), this.$store.setKey("publicKey", String(s.publicKey)), this.$store.setKey(
            "paymentPublicKey",
            String(u.publicKey)
          );
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${dc} wallet`);
        }
      };
      await uh.getAddress(a), this.$store.setKey("connected", !0);
    } catch (o) {
      throw o;
    }
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [Yt, on, pn, Nn].includes(this.network) ? this.network : Ot;
  }
  async sendBTC(t, r) {
    let n = "";
    const o = {
      payload: {
        network: {
          type: v2(this.network)
        },
        recipients: [
          {
            address: t,
            amountSats: BigInt(r)
          }
        ],
        senderAddress: this.$store.get().paymentAddress
      },
      onFinish: (a) => {
        n = a;
      },
      onCancel: () => {
        throw new Error("User canceled the request");
      }
    };
    return await yre(o), n;
  }
  async signMessage(t, r) {
    let n = "";
    const o = (r == null ? void 0 : r.toSignAddress) || this.$store.get().paymentAddress, a = {
      payload: {
        network: {
          type: v2(this.network)
        },
        address: o,
        message: t
      },
      onFinish: (i) => {
        n = i;
      },
      onCancel: () => {
        throw new Error("User canceled the request");
      }
    };
    return await mre(a), n;
  }
  async signPsbt(t, r, n, o, a) {
    try {
      const i = Gt.fromBase64(String(n), {
        network: Er(this.network)
      }), s = this.$store.get().address, u = this.$store.get().paymentAddress, l = i.data.inputs;
      let c = {};
      const f = {
        [s]: []
      }, h = {
        [u]: []
      };
      let p = 0;
      for await (let E of l) {
        if (E.witnessUtxo === void 0)
          h[u].push(Number(p));
        else {
          const { script: A } = E.witnessUtxo, S = bp(
            A,
            Er(this.network)
          );
          S === u ? h[u].push(Number(p)) : S === s && f[s].push(Number(p));
        }
        p++;
      }
      f[s].length > 0 && (c = { ...c, ...f }), h[u].length > 0 && (c = { ...c, ...h });
      let y, m, b, v;
      const k = await uh.request("signPsbt", {
        psbt: n,
        broadcast: !!a,
        signInputs: c
      });
      if (k.status === "success")
        v = Gt.fromBase64(k.result.psbt, {
          network: Er(this.network)
        }), y = k.result.txid;
      else
        throw k.error.code === uh.RpcErrorCode.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
      if (!v)
        throw new Error("Error signing psbt");
      return o && !y ? (v.finalizeAllInputs(), m = v.toHex(), b = v.toBase64()) : (m = v.toHex(), b = v.toBase64()), {
        signedPsbtHex: m,
        signedPsbtBase64: b,
        txId: y
      };
    } catch (i) {
      throw console.error(i), i;
    }
  }
}
const vre = "OKX_CONNECTED_WALLET_STATE";
let Ere = class extends Bi {
  constructor() {
    super(...arguments), ke(this, "observer"), ke(this, "$valueStore", ml(
      vre,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), ke(this, "removeSubscriber");
  }
  get library() {
    var t, r;
    let n;
    return this.network === Yt || this.network === on || this.network === pn || this.network === Nn ? n = (t = window == null ? void 0 : window.okxwallet) == null ? void 0 : t.bitcoinTestnet : (this.network === Ot || this.network === fl) && (n = (r = window == null ? void 0 : window.okxwallet) == null ? void 0 : r.bitcoin), n;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Xu)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    hl(nh, t, n, this.$valueStore);
  }
  initialize() {
    var t;
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [nh]: !0
      }), (r = this.observer) == null || r.disconnect());
    }), (t = this.observer) == null || t.observe(document, { childList: !0, subtree: !0 })), Yo(this.$store, ["provider"], (r) => {
      r.provider !== nh ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    if (r)
      if (r.startsWith("tb1") && od(this.network))
        this.disconnect();
      else {
        this.restorePersistedValues(), as(n, this.network).then((o) => {
          this.$store.setKey("balance", o);
        });
        return;
      }
    try {
      const o = await this.library.connect();
      if (!o) throw new Error("No accounts found");
      this.$store.setKey("address", o.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", o.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey), this.$store.setKey("accounts", [o]);
    } catch (o) {
      throw o;
    }
  }
  async requestAccounts() {
    const t = this.library, r = this.network;
    return r === Yt || r === on || r === Nn ? await t.connect() : await t.requestAccounts();
  }
  async getNetwork() {
    const { address: t } = this.$store.get(), r = this.network;
    if (t.slice(0, 1) === "t")
      return r === Yt ? Yt : r === on ? on : r === pn ? pn : r === Nn ? Nn : Yt;
    const n = await this.library.getNetwork();
    return rY(n);
  }
  async getPublicKey() {
    const t = this.library;
    return await (t == null ? void 0 : t.getPublicKey());
  }
  async getInscriptions(t, r) {
    return await this.library.getInscriptions(t, r);
  }
  async sendBTC(t, r) {
    const n = await this.library.sendBitcoin(t, r);
    if (!n) throw new Error("Transaction failed");
    return n;
  }
  async signMessage(t, r) {
    const n = this.library, o = (r == null ? void 0 : r.protocol) === Bp ? fy : r == null ? void 0 : r.protocol;
    return await (n == null ? void 0 : n.signMessage(t, o));
  }
  async signPsbt(t, r, n, o, a) {
    const i = await this.library.signPsbt(r, {
      autoFinalized: o
    }), s = Gt.fromHex(i);
    if (o && a) {
      const u = await this.pushPsbt(i);
      return {
        signedPsbtHex: s.toHex(),
        signedPsbtBase64: s.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: s.toHex(),
      signedPsbtBase64: s.toBase64(),
      txId: void 0
    };
  }
};
const kre = "MAGIC_EDEN_CONNECTED_WALLET_STATE";
let xre = class extends Bi {
  constructor() {
    super(...arguments), ke(this, "observer"), ke(this, "$valueStore", ml(
      kre,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), ke(this, "removeSubscriber");
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.magicEden) == null ? void 0 : t.bitcoin;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Xu) {
      if (r === "balance") {
        this.$store.setKey(r, BigInt(t[r]));
        continue;
      }
      this.$store.setKey(r, t[r]);
    }
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    hl(
      vu,
      t,
      n,
      this.$valueStore
    );
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t, r;
      (t = window == null ? void 0 : window.magicEden) != null && t.bitcoin && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [vu]: !0
      }), (r = this.observer) == null || r.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Yo(this.$store, ["provider"], (t) => {
      t.provider !== vu ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r)
        if (r.startsWith("tb1") && od(this.network))
          this.disconnect();
        else {
          as(n, this.network).then((a) => {
            this.$store.setKey("balance", a);
          }), this.restorePersistedValues();
          return;
        }
      if (l5(this.network))
        throw new Error(`${this.network} is not supported by ${vu}`);
      let o = x1(this.network || Ot);
      await MT({
        getProvider: async () => this.library,
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Connecting with lasereyes",
          network: {
            type: o
          }
        },
        onFinish: (a) => {
          const i = s5(a.addresses), s = u5(a.addresses);
          if (!i || !s)
            throw new Error("No address found");
          i && s && (this.$store.setKey("address", i.address), this.$store.setKey("paymentAddress", s.address), this.$store.setKey("accounts", [
            i.address,
            s.address
          ])), this.$store.setKey(
            "publicKey",
            String(a.addresses[0].publicKey)
          ), this.$store.setKey(
            "paymentPublicKey",
            String(a.addresses[1].publicKey)
          );
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${vu} wallet`);
        },
        onError: (a) => {
          throw new Error(`Can't lasereyes to ${vu} wallet`);
        }
      });
    } catch (o) {
      throw o;
    }
  }
  async sendBTC(t, r) {
    let n;
    if (await zte({
      getProvider: async () => this.library,
      payload: {
        network: {
          type: x1(this.network)
        },
        recipients: [
          {
            address: t,
            amountSats: BigInt(r)
          }
        ],
        senderAddress: this.$store.get().paymentAddress
      },
      onFinish: (o) => {
        n = o;
      },
      onCancel: () => {
        throw console.error("Request canceled"), new Error("User canceled the request");
      }
    }), !n) throw new Error("Error sending BTC");
    return n.txid;
  }
  async signMessage(t, r) {
    try {
      const n = (r == null ? void 0 : r.toSignAddress) || this.$store.get().paymentAddress;
      let o = "";
      return await Ute({
        getProvider: async () => this.library,
        payload: {
          network: {
            type: LT.Mainnet
          },
          address: n,
          message: t,
          protocol: (r == null ? void 0 : r.protocol) === Bp ? Zc.ECDSA : Zc.BIP322
        },
        onFinish: (a) => {
          o = a;
        },
        onCancel: () => {
          throw console.error("Request canceled"), new Error("User canceled the request");
        }
      }), o;
    } catch (n) {
      throw n;
    }
  }
  async signPsbt(t, r, n, o, a) {
    console.log("signPsbt", n, o, a);
    const { address: i, paymentAddress: s } = this.$store.get(), u = Gt.fromBase64(String(n), {
      network: Er(this.network)
    }), l = u.data.inputs, c = [], f = {
      address: i,
      signingIndexes: []
    }, h = {
      address: s,
      signingIndexes: []
    };
    let p = 0;
    for await (let A of l) {
      const { script: S } = A.witnessUtxo, _ = bp(
        S,
        Er(this.network)
      );
      _ === s ? (h.signingIndexes.push(Number(p)), A.sighashType && (console.log("Updating sigHash for paymentsAddressData"), h.sigHash = A.sighashType)) : _ === i && (f.signingIndexes.push(Number(p)), A.sighashType && (console.log("Updating sigHash for ordinalAddressData"), f.sigHash = A.sighashType)), p++;
    }
    f.signingIndexes.length > 0 && c.push(f), h.signingIndexes.length > 0 && c.push(h);
    let y, m, b, v;
    const k = x1(this.network), E = {
      getProvider: async () => this.library,
      payload: {
        network: {
          type: k
        },
        message: "Sign Transaction",
        psbtBase64: u.toBase64(),
        broadcast: a,
        inputsToSign: c
      },
      onFinish: async (A) => {
        A.psbtBase64 && (v = Gt.fromBase64(String(A.psbtBase64), {
          network: Er(this.network)
        }), m = v.toHex(), b = v.toBase64());
      },
      onCancel: () => {
        throw console.log("Canceled"), new Error("User canceled the request");
      },
      onError: (A) => {
        throw console.log("error", A), A;
      }
    };
    if (await jte(E), !v)
      throw new Error("signature failed");
    return o || a ? (v.finalizeAllInputs(), {
      signedPsbtHex: v.toHex(),
      signedPsbtBase64: b,
      txId: y
    }) : {
      signedPsbtHex: m,
      signedPsbtBase64: b,
      txId: y
    };
  }
}, Are = class extends Bi {
  constructor() {
    super(...arguments), ke(this, "observer");
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.phantom) == null ? void 0 : t.bitcoin;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [fc]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Yo(this.$store, ["provider"], (t) => {
      t.provider === fc && this.library.requestAccounts().then((r) => {
        this.handleAccountsChanged(r);
      });
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(fc) : this.parent.disconnect());
  }
  async connect(t) {
    if (!this.library) throw new Error("Phantom isn't installed");
    if (l5(this.network))
      throw new Error(`${this.network} is not supported by ${fc}`);
    const r = await this.library.requestAccounts();
    if (!r) throw new Error("No accounts found");
    this.$store.setKey("accounts", r);
    const n = r.find(
      (a) => a.purpose === "ordinals"
    ), o = r.find(
      (a) => a.purpose === "payment"
    );
    this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey), this.$store.setKey("provider", fc), this.$store.setKey("connected", !0);
  }
  async getNetwork() {
    return this.$store.get().address.slice(0, 1) === "t" ? Yt : Ot;
  }
  async sendBTC(t, r) {
    const { psbtHex: n } = await c5(
      this.$store.get().address,
      this.$store.get().paymentAddress,
      t,
      r,
      this.$store.get().paymentPublicKey,
      this.network,
      7
    ), o = await this.signPsbt("", n, "", !0, !0);
    if (!o) throw new Error("Error sending BTC");
    return o.txId;
  }
  async signMessage(t, r) {
    var n;
    if ((r == null ? void 0 : r.protocol) === Bp)
      throw new Error("ECDSA signing is not supported by Phantom");
    const o = new TextEncoder().encode(t), a = new Uint8Array(o), i = (r == null ? void 0 : r.toSignAddress) || this.$store.get().paymentAddress, s = await ((n = this.library) == null ? void 0 : n.signMessage(i, a)), u = String.fromCharCode(...s.signature);
    return btoa(u);
  }
  async signPsbt(t, r, n, o, a) {
    const { address: i, paymentAddress: s } = this.$store.get(), u = Gt.fromHex(String(r), {
      network: Er(this.network)
    }).data.inputs, l = [], c = {
      address: i,
      signingIndexes: []
    }, f = {
      address: s,
      signingIndexes: []
    };
    let h = 0;
    for await (let m of u) {
      const { script: b } = m.witnessUtxo, v = bp(
        b,
        Er(this.network)
      );
      v === s ? f.signingIndexes.push(Number(h)) : v === i && c.signingIndexes.push(Number(h)), h++;
    }
    c.signingIndexes.length > 0 && l.push(c), f.signingIndexes.length > 0 && l.push(f);
    const p = await this.library.signPSBT(
      kee(r),
      {
        inputsToSign: l
      }
    ), y = Gt.fromBuffer(p);
    if (o && l.forEach((m) => {
      m.signingIndexes.forEach((b) => {
        y.finalizeInput(b);
      });
    }), a) {
      const m = await this.pushPsbt(y.toHex());
      return {
        signedPsbtHex: y.toHex(),
        signedPsbtBase64: y.toBase64(),
        txId: m
      };
    }
    return {
      signedPsbtHex: y.toHex(),
      signedPsbtBase64: y.toBase64(),
      txId: void 0
    };
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
}, Sre = class extends Bi {
  constructor() {
    super(...arguments), ke(this, "observer");
  }
  get library() {
    return window == null ? void 0 : window.opnet;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [hc]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Yo(this.$store, ["provider"], (t) => {
      if (t.provider !== hc) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener(
      "accountsChanged",
      this.handleAccountsChanged.bind(this)
    ), (r = this.library) == null || r.removeListener(
      "networkChanged",
      this.handleNetworkChanged.bind(this)
    ));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(hc) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = Ag(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(hc);
  }
  async connect(t) {
    if (!this.library) throw new Error("OP_NET isn't installed");
    const r = await this.library.requestAccounts();
    if (!r) throw new Error("No accounts found");
    const n = await this.library.getPublicKey();
    if (!n) throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), this.$store.setKey("provider", hc), await this.getNetwork().then((o) => {
      var a;
      ((a = this.config) == null ? void 0 : a.network) !== o && this.switchNetwork(o);
    }), this.$store.setKey("connected", !0);
  }
  async getNetwork() {
    var t;
    const r = await ((t = this.library) == null ? void 0 : t.getChain());
    return r ? Ag(r.enum) : this.network;
  }
  async sendBTC(t, r) {
    var n;
    const o = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
    if (!o) throw new Error("Transaction failed");
    return o;
  }
  async signMessage(t, r) {
    var n;
    const o = (r == null ? void 0 : r.protocol) === i5 ? fy : r == null ? void 0 : r.protocol;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t, o));
  }
  async signPsbt(t, r, n, o, a) {
    var i;
    const s = await ((i = this.library) == null ? void 0 : i.signPsbt(r, {
      autoFinalized: o
    })), u = Gt.fromHex(s);
    if (o && a) {
      const l = await this.pushPsbt(s);
      return {
        signedPsbtHex: u.toHex(),
        signedPsbtBase64: u.toBase64(),
        txId: l
      };
    }
    return {
      signedPsbtHex: u.toHex(),
      signedPsbtBase64: u.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    return await this.library.getInscriptions(t, r);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var r;
    const n = Y_(t);
    await ((r = this.library) == null ? void 0 : r.switchChain(n)), this.$network.set(t);
  }
};
const F0 = {};
function Hd(e) {
  if (F0[e])
    return console.warn(`Multiple requests for "${e}" detected`), F0[e];
  const t = new Promise((r) => {
    const n = console.log;
    console.log = (...o) => {
      o.length > 0 && typeof o[0] == "string" && (console.log = n, F0[e] = void 0, r(o[0]));
    }, n(
      `Please log a value for "${e}" using 
 console.log('<your-value>') 
 to continue.`
    );
  });
  return F0[e] = t, t;
}
let _re = class {
  async requestAccounts() {
    const t = await Hd("address");
    if (!t) throw new Error("No address provided");
    const r = await Hd("paymentAddress");
    if (!r) throw new Error("No payment address provided");
    return [t, r];
  }
  async signMessage(t) {
    return console.log("sign this message in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await Hd("message to sign");
  }
  async signPsbt(t) {
    return console.log("sign this in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await Hd("signed psbt hex");
  }
  async getPublicKey() {
    const t = await Hd("publicKey");
    if (!t) throw new Error("No public key provided");
    return t;
  }
  // TODO: Implement network switching between mainnet and testnet
  async getNetwork() {
    return "mainnet";
  }
  async switchNetwork(t) {
  }
};
const Ire = "SPARROW_CONNECTED_WALLET_STATE";
let Tre = class extends Bi {
  constructor() {
    super(...arguments), ke(this, "observer"), ke(this, "$valueStore", ml(
      Ire,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), ke(this, "removeSubscriber");
  }
  get library() {
    return window == null ? void 0 : window.SparrowWalletProvider;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library || (window.SparrowWalletProvider = new _re()), this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Zl]: !0
      }), (t = this.observer) == null || t.disconnect();
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Yo(this.$store, ["provider"], (t) => {
      t.provider !== Zl ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  watchStateChange(t, r, n) {
    hl(
      Zl,
      t,
      n,
      this.$valueStore
    );
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Xu)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    try {
      const { address: r, paymentAddress: n } = this.$valueStore.get();
      if (r && n)
        if (r.startsWith("tb1") && od(this.network))
          this.disconnect();
        else {
          this.restorePersistedValues();
          return;
        }
      if (!this.library) throw new Error("Sparrow wallet isn't supported");
      const o = await this.library.requestAccounts();
      if (!o) throw new Error("No accounts found");
      await this.getNetwork().then((i) => {
        this.network !== i && this.switchNetwork(this.network);
      });
      const a = await this.library.getPublicKey();
      if (!a) throw new Error("No public key found");
      this.$store.setKey("accounts", o), this.$store.setKey("address", o[0]), this.$store.setKey("paymentAddress", o[1]), this.$store.setKey("publicKey", a), this.$store.setKey("paymentPublicKey", a);
    } catch (r) {
      throw console.error("Error during sparrow connect:", r), r;
    }
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    const { psbtBase64: n } = await c5(
      this.$store.get().address,
      this.$store.get().paymentAddress,
      t,
      r,
      this.$store.get().paymentPublicKey,
      this.network,
      7
    ), o = await this.library.signPsbt(n);
    if (!o) throw new Error("No signed PSBT provided");
    const a = await this.pushPsbt(o);
    if (!a) throw new Error("send failed, no txid returned");
    return a;
  }
  async signMessage(t) {
    return await this.library.signMessage(t);
  }
  async signPsbt(t, r, n, o, a) {
    const i = Gt.fromBase64(n), s = await this.library.signPsbt(n);
    if (o && a) {
      const u = await this.pushPsbt(s);
      return {
        signedPsbtHex: s,
        signedPsbtBase64: i.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: s,
      signedPsbtBase64: i.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    const t = await this.library.getPublicKey();
    return this.$store.setKey("publicKey", t), t;
  }
  async getBalance() {
    const t = await as(
      this.$store.get().paymentAddress,
      this.network
    );
    return this.$store.setKey("balance", t), t.toString();
  }
  async requestAccounts() {
    return await this.connect(Zl), this.$store.get().accounts;
  }
}, R5e = class {
  constructor(t, r) {
    ke(this, "$store"), ke(this, "$network"), ke(this, "$providerMap"), ke(this, "disposed", !1), this.config = r, this.$store = t.$store, this.$network = t.$network, CU(this.$store), this.$providerMap = {
      [rh]: new Gte(t, this, r),
      [vu]: new xre(t, this, r),
      [nh]: new Ere(t, this, r),
      [hc]: new Sre(t, this, r),
      [dc]: new wre(t, this, r),
      [th]: new qte(t, this, r),
      [fc]: new Are(t, this, r),
      [Zl]: new Tre(t, this, r),
      [Vl]: new vee(t, this, r),
      [lc]: new Dte(t, this, r),
      [Gl]: new Mte(t, this, r)
    };
  }
  dispose() {
    this.disposed = !0, Object.values(this.$providerMap).forEach((t) => t == null ? void 0 : t.dispose());
  }
  initialize() {
    this.$network.listen(this.watchNetworkChange.bind(this)), Yo(this.$store, ["isInitializing"], (t, r) => {
      if (!this.disposed && t.isInitializing !== r.isInitializing)
        return this.handleIsInitializingChanged(t.isInitializing);
    }), this.config && this.config.network && (this.$network.set(this.config.network), this.getNetwork().then((t) => {
      try {
        this.config.network !== t && this.switchNetwork(this.config.network);
      } catch {
        this.disconnect();
      }
    })), Eee(() => this.$store.setKey("isInitializing", !1));
  }
  handleIsInitializingChanged(t) {
    if (typeof window < "u" && typeof localStorage < "u" && !t) {
      const r = localStorage == null ? void 0 : localStorage.getItem(
        Db
      );
      r && this.connect(r);
    }
  }
  async connect(t) {
    if (this.disposed) {
      console.warn("Client disposed, cannot connect");
      return;
    }
    this.$store.setKey("isConnecting", !0);
    try {
      if (localStorage == null || localStorage.setItem(Db, t), !this.$providerMap[t])
        throw new Error("Unsupported wallet provider");
      const r = this.$providerMap[t];
      await (r == null ? void 0 : r.connect(t)), this.$store.setKey("connected", !0), this.$store.setKey("provider", t);
    } catch (r) {
      throw console.error("Error during connect:", r), this.$store.setKey("isConnecting", !1), this.disconnect(), r;
    } finally {
      this.$store.setKey("isConnecting", !1);
    }
  }
  async requestAccounts() {
    var t;
    if (!this.$store.get().provider)
      throw new Error("No wallet provider connected");
    try {
      return await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.requestAccounts());
    } catch (r) {
      throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : r;
    }
  }
  disconnect() {
    this.$store.set({
      provider: void 0,
      address: "",
      paymentAddress: "",
      publicKey: "",
      paymentPublicKey: "",
      balance: void 0,
      accounts: [],
      connected: !1,
      isConnecting: !1,
      isInitializing: !1,
      hasProvider: this.$store.get().hasProvider
    }), localStorage == null || localStorage.removeItem(Db);
  }
  async switchNetwork(t) {
    var r;
    try {
      this.$store.get().provider && await ((r = this.$providerMap[this.$store.get().provider]) == null ? void 0 : r.switchNetwork(
        t
      ));
    } catch (n) {
      throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? (this.disconnect(), new Error(
        "The connected wallet doesn't support programmatic network changes.."
      )) : n;
    }
  }
  watchNetworkChange() {
    this.$store.setKey("balance", void 0);
  }
  async getNetwork() {
    var t;
    return this.$store.get().provider && this.$providerMap[this.$store.get().provider] ? await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.getNetwork()) : this.$network.get();
  }
  async sendBTC(t, r) {
    var n;
    if (r <= 0) throw new Error("Amount must be greater than 0");
    if (!Number.isInteger(r)) throw new Error("Amount must be an integer");
    if (!this.$store.get().provider) throw new Error("No wallet connected");
    if (this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.sendBTC(
          t,
          r
        ));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support sending BTC..."
        ) : o;
      }
  }
  async signMessage(t, r) {
    var n;
    let o = {};
    if (typeof r == "string" ? o = { toSignAddress: r } : r && (o = r), !!this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.signMessage(t, o));
      } catch (a) {
        throw a instanceof Error && a.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support message signing..."
        ) : a;
      }
  }
  async signPsbt(t, r = !1, n = !1) {
    var o;
    let a, i;
    if (!t) throw new Error("No PSBT provided");
    if (cee(t))
      i = Gt.fromHex(t).toBase64(), a = t;
    else if (uee(t))
      i = t, a = Gt.fromBase64(t).toHex();
    else
      throw new Error("Invalid PSBT format");
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((o = this.$providerMap[this.$store.get().provider]) == null ? void 0 : o.signPsbt(t, a, i, r, n));
      } catch (s) {
        throw s instanceof Error && s.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support PSBT signing..."
        ) : s;
      }
    else
      throw new Error("No wallet provider connected");
  }
  async pushPsbt(t) {
    var r;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((r = this.$providerMap[this.$store.get().provider]) == null ? void 0 : r.pushPsbt(
          t
        ));
      } catch (n) {
        throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support PSBT signing..."
        ) : n;
      }
  }
  async inscribe(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.inscribe(
          t,
          r
        ));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support inscribing..."
        ) : o;
      }
  }
  async send(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.send(
          t,
          r
        ));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support sending stuff..."
        ) : o;
      }
  }
  async getPublicKey() {
    var t;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.getPublicKey());
      } catch (r) {
        throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getPublicKey") : r;
      }
  }
  async getBalance() {
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        const t = await this.$providerMap[this.$store.get().provider].getBalance();
        return this.$store.setKey("balance", BigInt(t)), t;
      } catch (t) {
        throw t instanceof Error && t.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : t;
      }
  }
  async getMetaBalances(t) {
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        if (!t)
          throw new Error("No protocol provided");
        return await this.$providerMap[this.$store.get().provider].getMetaBalances(
          t
        );
      } catch (r) {
        throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : r;
      }
  }
  async getInscriptions(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.getInscriptions(t, r));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : o;
      }
  }
};
var Pre = Object.defineProperty, Ore = (e, t, r) => t in e ? Pre(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, xe = (e, t, r) => Ore(e, typeof t != "symbol" ? t + "" : t, r);
function $re(e, t) {
  for (var r = 0; r < t.length; r++) {
    const n = t[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const o in n)
        if (o !== "default" && !(o in e)) {
          const a = Object.getOwnPropertyDescriptor(n, o);
          a && Object.defineProperty(e, o, a.get ? a : {
            enumerable: !0,
            get: () => n[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
let $v = Symbol("clean"), ti = [], qs = 0;
const D0 = 4;
let Cv = (e) => {
  let t = [], r = {
    get() {
      return r.lc || r.listen(() => {
      })(), r.value;
    },
    lc: 0,
    listen(n) {
      return r.lc = t.push(n), () => {
        for (let a = qs + D0; a < ti.length; )
          ti[a] === n ? ti.splice(a, D0) : a += D0;
        let o = t.indexOf(n);
        ~o && (t.splice(o, 1), --r.lc || r.off());
      };
    },
    notify(n, o) {
      let a = !ti.length;
      for (let i of t)
        ti.push(
          i,
          r.value,
          n,
          o
        );
      if (a) {
        for (qs = 0; qs < ti.length; qs += D0)
          ti[qs](
            ti[qs + 1],
            ti[qs + 2],
            ti[qs + 3]
          );
        ti.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(n) {
      let o = r.value;
      o !== n && (r.value = n, r.notify(o));
    },
    subscribe(n) {
      let o = r.listen(n);
      return n(r.value), o;
    },
    value: e
  };
  return process.env.NODE_ENV !== "production" && (r[$v] = () => {
    t = [], r.lc = 0, r.off();
  }), r;
};
const Cre = 5, Nl = 6, M0 = 10;
let Bre = (e, t, r, n) => (e.events = e.events || {}, e.events[r + M0] || (e.events[r + M0] = n((o) => {
  e.events[r].reduceRight((a, i) => (i(a), a), {
    shared: {},
    ...o
  });
})), e.events[r] = e.events[r] || [], e.events[r].push(t), () => {
  let o = e.events[r], a = o.indexOf(t);
  o.splice(a, 1), o.length || (delete e.events[r], e.events[r + M0](), delete e.events[r + M0]);
}), Nre = 1e3, Ure = (e, t) => Bre(e, (r) => {
  let n = t(r);
  n && e.events[Nl].push(n);
}, Cre, (r) => {
  let n = e.listen;
  e.listen = (...a) => (!e.lc && !e.active && (e.active = !0, r()), n(...a));
  let o = e.off;
  if (e.events[Nl] = [], e.off = () => {
    o(), setTimeout(() => {
      if (e.active && !e.lc) {
        e.active = !1;
        for (let a of e.events[Nl]) a();
        e.events[Nl] = [];
      }
    }, Nre);
  }, process.env.NODE_ENV !== "production") {
    let a = e[$v];
    e[$v] = () => {
      for (let i of e.events[Nl]) i();
      e.events[Nl] = [], e.active = !1, a();
    };
  }
  return () => {
    e.listen = n, e.off = o;
  };
}), Rre = (e) => {
  e.listen(() => {
  });
};
function Jo(e, t, r) {
  let n = /* @__PURE__ */ new Set([...t, void 0]);
  return e.listen((o, a, i) => {
    n.has(i) && r(o, a, i);
  });
}
let aP = (e = {}) => {
  let t = Cv(e);
  return t.setKey = function(r, n) {
    let o = t.value;
    typeof n > "u" && r in t.value ? (t.value = { ...t.value }, delete t.value[r], t.notify(o, r)) : t.value[r] !== n && (t.value = {
      ...t.value,
      [r]: n
    }, t.notify(o, r));
  }, t;
};
const sf = "oyl", kc = "unisat", Au = "xverse", Su = "phantom", uf = "leather", qa = "magic-eden", cf = "okx", xc = "wizz", _u = "orange", Iu = "op_net", Ac = "sparrow", lf = "p2tr", zre = "p2pkh", jre = "p2sh-p2wpkh", Bv = "p2wpkh", Lre = "p2wsh", E5 = "p2sh", C2 = "defaultWallet", Ui = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
}, Hre = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
function Fre(e) {
  if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return !1;
  const t = e[3];
  if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return !1;
  const r = e[5 + t];
  return !(r === 0 || 6 + t + r !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128));
}
function Dre(e) {
  if (e.length < 8) throw new Error("DER sequence length is too short");
  if (e.length > 72) throw new Error("DER sequence length is too long");
  if (e[0] !== 48) throw new Error("Expected DER sequence");
  if (e[1] !== e.length - 2)
    throw new Error("DER sequence length is invalid");
  if (e[2] !== 2) throw new Error("Expected DER integer");
  const t = e[3];
  if (t === 0) throw new Error("R length is zero");
  if (5 + t >= e.length) throw new Error("R length is too long");
  if (e[4 + t] !== 2) throw new Error("Expected DER integer (2)");
  const r = e[5 + t];
  if (r === 0) throw new Error("S length is zero");
  if (6 + t + r !== e.length) throw new Error("S length is invalid");
  if (e[4] & 128) throw new Error("R value is negative");
  if (t > 1 && e[4] === 0 && !(e[5] & 128))
    throw new Error("R value excessively padded");
  if (e[t + 6] & 128) throw new Error("S value is negative");
  if (r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: e.slice(4, 4 + t),
    s: e.slice(6 + t)
  };
}
function Mre(e, t) {
  const r = e.length, n = t.length;
  if (r === 0) throw new Error("R length is zero");
  if (n === 0) throw new Error("S length is zero");
  if (r > 33) throw new Error("R length is too long");
  if (n > 33) throw new Error("S length is too long");
  if (e[0] & 128) throw new Error("R value is negative");
  if (t[0] & 128) throw new Error("S value is negative");
  if (r > 1 && e[0] === 0 && !(e[1] & 128))
    throw new Error("R value excessively padded");
  if (n > 1 && t[0] === 0 && !(t[1] & 128))
    throw new Error("S value excessively padded");
  const o = new Uint8Array(6 + r + n);
  return o[0] = 48, o[1] = o.length - 2, o[2] = 2, o[3] = e.length, o.set(e, 4), o[4 + r] = 2, o[5 + r] = t.length, o.set(t, 6 + r), o;
}
const Lt = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
}, sP = {};
for (const e of Object.keys(Lt)) {
  const t = Lt[e];
  sP[t] = e;
}
const Bg = "0123456789abcdefABCDEF", Ng = Bg.split("").map((e) => e.codePointAt(0)), Ug = Array(256).fill(!0).map((e, t) => {
  const r = String.fromCodePoint(t), n = Bg.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), uP = new TextEncoder(), cP = new TextDecoder();
function Kre(e) {
  return cP.decode(e);
}
function qre(e) {
  return uP.encode(e);
}
function yr(e) {
  const t = e.reduce((o, a) => o + a.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const o of e)
    r.set(o, n), n += o.length;
  return r;
}
function Ve(e) {
  const t = e || new Uint8Array();
  return t.length > 512 ? Gre(t) : Vre(t);
}
function Vre(e) {
  let t = "";
  for (let r = 0; r < e.length; ++r)
    t += Bg[Ug[Ng[e[r] >> 4]]], t += Bg[Ug[Ng[e[r] & 15]]];
  return t;
}
function Gre(e) {
  const t = new Uint8Array(e.length * 2);
  for (let r = 0; r < e.length; ++r)
    t[r * 2] = Ng[e[r] >> 4], t[r * 2 + 1] = Ng[e[r] & 15];
  return cP.decode(t);
}
function ys(e) {
  const t = uP.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let n;
  for (n = 0; n < r.length; n++) {
    const o = Ug[t[n * 2]], a = Ug[t[n * 2 + 1]];
    if (o === void 0 || a === void 0)
      break;
    r[n] = o << 4 | a;
  }
  return n === r.length ? r : r.slice(0, n);
}
function Zre(e) {
  return btoa(String.fromCharCode(...e));
}
function lP(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t.charCodeAt(n);
  return r;
}
function de(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; ++n)
    if (e[n] !== t[n])
      return e[n] < t[n] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function vo(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  return e[t] = r, t + 1;
}
function Wre(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function Fp(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function Xre(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  return n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function us(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  return e[t];
}
function Yre(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function ld(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function fP(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 2147483647 || r < -2147483648)
    throw new Error(`The value of "value" is out of range. It must be >= -2147483648 and <= 2147483647. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function dP(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n)
    throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function Jre(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    const n = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24 >>> 0);
    return e[t + 3] <= 127 ? n : n - 4294967296;
  } else {
    const n = (e[t] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];
    return e[t] <= 127 ? n : n - 4294967296;
  }
}
function hP(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  r = r.toUpperCase();
  let n = 0n;
  if (r === "LE")
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? n : n - 0x10000000000000000n;
  {
    let o = 0n;
    return o = (o << 8n) + BigInt(e[t]), o = (o << 8n) + BigInt(e[t + 1]), o = (o << 8n) + BigInt(e[t + 2]), o = (o << 8n) + BigInt(e[t + 3]), o = (o << 8n) + BigInt(e[t + 4]), o = (o << 8n) + BigInt(e[t + 5]), o = (o << 8n) + BigInt(e[t + 6]), o = (o << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? o : o - 0x10000000000000000n;
  }
}
function pP(e) {
  return e < Lt.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5;
}
function Qre(e, t, r) {
  const n = pP(t);
  return n === 1 ? vo(e, r, t) : n === 2 ? (vo(e, r, Lt.OP_PUSHDATA1), vo(e, r + 1, t)) : n === 3 ? (vo(e, r, Lt.OP_PUSHDATA2), Wre(e, r + 1, t, "LE")) : (vo(e, r, Lt.OP_PUSHDATA4), Fp(e, r + 1, t, "LE")), n;
}
function ene(e, t) {
  const r = us(e, t);
  let n, o;
  if (r < Lt.OP_PUSHDATA1)
    n = r, o = 1;
  else if (r === Lt.OP_PUSHDATA1) {
    if (t + 2 > e.length) return null;
    n = us(e, t + 1), o = 2;
  } else if (r === Lt.OP_PUSHDATA2) {
    if (t + 3 > e.length) return null;
    n = Yre(e, t + 1, "LE"), o = 3;
  } else {
    if (t + 5 > e.length) return null;
    if (r !== Lt.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    n = ld(e, t + 1, "LE"), o = 5;
  }
  return {
    opcode: r,
    number: n,
    size: o
  };
}
function tne(e) {
  return e > 2147483647 ? 5 : e > 8388607 ? 4 : e > 32767 ? 3 : e > 127 ? 2 : e > 0 ? 1 : 0;
}
function rne(e) {
  let t = Math.abs(e);
  const r = tne(t), n = new Uint8Array(r), o = e < 0;
  for (let a = 0; a < r; ++a)
    vo(n, a, t & 255), t >>= 8;
  return n[r - 1] & 128 ? vo(n, r - 1, o ? 128 : 0) : o && (n[r - 1] |= 128), n;
}
function nne(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? void 0,
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? void 0,
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? void 0
  };
}
function one(e, t) {
  var r;
  return (r = void 0) == null ? void 0 : r.get(t);
}
function Dh(e) {
  var t, r;
  const n = typeof e;
  return n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n === "object" || n === "function" ? (e && ((r = (t = Object.getPrototypeOf(e)) == null ? void 0 : t.constructor) == null ? void 0 : r.name)) ?? "null" : n;
}
function xn(e, t, r, n, o) {
  const a = o && "input" in o ? o.input : r.value, i = (o == null ? void 0 : o.expected) ?? e.expects ?? null, s = (o == null ? void 0 : o.received) ?? Dh(a), u = {
    kind: e.kind,
    type: e.type,
    input: a,
    expected: i,
    received: s,
    message: `Invalid ${t}: ${i ? `Expected ${i} but r` : "R"}eceived ${s}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, l = e.kind === "schema", c = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? one(e.reference, u.lang) ?? (l ? (u.lang, void 0) : null) ?? n.message ?? (u.lang, void 0);
  c && (u.message = typeof c == "function" ? c(u) : c), l && (r.typed = !1), r.issues ? r.issues.push(u) : r.issues = [u];
}
function ine(e, t) {
  const r = [...new Set(e)];
  return r.length > 1 ? `(${r.join(` ${t} `)})` : r[0] ?? "never";
}
var ane = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e) {
    super(e[0].message), xe(this, "issues"), this.name = "ValiError", this.issues = e;
  }
};
function gP(e, t) {
  return {
    kind: "validation",
    type: "every_item",
    reference: gP,
    async: !1,
    expects: null,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !r.value.every(this.requirement) && xn(this, "item", r, n), r;
    }
  };
}
function k5(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: k5,
    async: !1,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && xn(this, "integer", t, r), t;
    }
  };
}
function mP(e, t) {
  return {
    kind: "validation",
    type: "length",
    reference: mP,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length !== this.requirement && xn(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function By(e, t) {
  return {
    kind: "validation",
    type: "max_value",
    reference: By,
    async: !1,
    expects: `<=${e instanceof Date ? e.toJSON() : Dh(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value > this.requirement && xn(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : Dh(r.value)
      }), r;
    }
  };
}
function Ny(e, t) {
  return {
    kind: "validation",
    type: "min_value",
    reference: Ny,
    async: !1,
    expects: `>=${e instanceof Date ? e.toJSON() : Dh(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value < this.requirement && xn(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : Dh(r.value)
      }), r;
    }
  };
}
function yP(e, t) {
  return {
    kind: "validation",
    type: "regex",
    reference: yP,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.test(r.value) && xn(this, "format", r, n), r;
    }
  };
}
function x5(e, t, r) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, r)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function Uy(e, t) {
  return !e._run({ typed: !1, value: t }, { abortEarly: !0 }).issues;
}
function bP() {
  return {
    kind: "schema",
    type: "any",
    reference: bP,
    expects: "any",
    async: !1,
    _run(e) {
      return e.typed = !0, e;
    }
  };
}
function to(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: to,
    expects: "Array",
    async: !1,
    item: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (Array.isArray(a)) {
        r.typed = !0, r.value = [];
        for (let i = 0; i < a.length; i++) {
          const s = a[i], u = this.item._run({ typed: !1, value: s }, n);
          if (u.issues) {
            const l = {
              type: "array",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), r.value.push(u.value);
        }
      } else
        xn(this, "type", r, n);
      return r;
    }
  };
}
function wP(e) {
  return {
    kind: "schema",
    type: "bigint",
    reference: wP,
    expects: "bigint",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "bigint" ? t.typed = !0 : xn(this, "type", t, r), t;
    }
  };
}
function Ii(e, t) {
  return {
    kind: "schema",
    type: "custom",
    reference: Ii,
    expects: "unknown",
    async: !1,
    check: e,
    message: t,
    _run(r, n) {
      return this.check(r.value) ? r.typed = !0 : xn(this, "type", r, n), r;
    }
  };
}
function Ry(e, t) {
  return {
    kind: "schema",
    type: "instance",
    reference: Ry,
    expects: e.name,
    async: !1,
    class: e,
    message: t,
    _run(r, n) {
      return r.value instanceof this.class ? r.typed = !0 : xn(this, "type", r, n), r;
    }
  };
}
function Nv(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullable",
    reference: Nv,
    expects: `(${e.expects} | null)`,
    async: !1,
    wrapped: e,
    _run(n, o) {
      return n.value === null && ("default" in this && (n.value = x5(
        this,
        n,
        o
      )), n.value === null) ? (n.typed = !0, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function vP(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullish",
    reference: vP,
    expects: `(${e.expects} | null | undefined)`,
    async: !1,
    wrapped: e,
    _run(n, o) {
      return (n.value === null || n.value === void 0) && ("default" in this && (n.value = x5(
        this,
        n,
        o
      )), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function Wn(e) {
  return {
    kind: "schema",
    type: "number",
    reference: Wn,
    expects: "number",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : xn(this, "type", t, r), t;
    }
  };
}
function Rr(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: Rr,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (a && typeof a == "object") {
        r.typed = !0, r.value = {};
        for (const i in this.entries) {
          const s = a[i], u = this.entries[i]._run(
            { typed: !1, value: s },
            n
          );
          if (u.issues) {
            const l = {
              type: "object",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), (u.value !== void 0 || i in a) && (r.value[i] = u.value);
        }
      } else
        xn(this, "type", r, n);
      return r;
    }
  };
}
function Rg(e, ...t) {
  const r = {
    kind: "schema",
    type: "optional",
    reference: Rg,
    expects: `(${e.expects} | undefined)`,
    async: !1,
    wrapped: e,
    _run(n, o) {
      return n.value === void 0 && ("default" in this && (n.value = x5(
        this,
        n,
        o
      )), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function yl(e) {
  return {
    kind: "schema",
    type: "string",
    reference: yl,
    expects: "string",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = !0 : xn(this, "type", t, r), t;
    }
  };
}
function ra(e, t) {
  return {
    kind: "schema",
    type: "tuple",
    reference: ra,
    expects: "Array",
    async: !1,
    items: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (Array.isArray(a)) {
        r.typed = !0, r.value = [];
        for (let i = 0; i < this.items.length; i++) {
          const s = a[i], u = this.items[i]._run(
            { typed: !1, value: s },
            n
          );
          if (u.issues) {
            const l = {
              type: "array",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), r.value.push(u.value);
        }
      } else
        xn(this, "type", r, n);
      return r;
    }
  };
}
function E7(e) {
  let t;
  if (e)
    for (const r of e)
      t ? t.push(...r.issues) : t = r.issues;
  return t;
}
function A5(e, t) {
  return {
    kind: "schema",
    type: "union",
    reference: A5,
    expects: ine(
      e.map((r) => r.expects),
      "|"
    ),
    async: !1,
    options: e,
    message: t,
    _run(r, n) {
      let o, a, i;
      for (const s of this.options) {
        const u = s._run(
          { typed: !1, value: r.value },
          n
        );
        if (u.typed)
          if (u.issues)
            a ? a.push(u) : a = [u];
          else {
            o = u;
            break;
          }
        else
          i ? i.push(u) : i = [u];
      }
      if (o)
        return o;
      if (a) {
        if (a.length === 1)
          return a[0];
        xn(this, "type", r, n, {
          issues: E7(a)
        }), r.typed = !0;
      } else {
        if ((i == null ? void 0 : i.length) === 1)
          return i[0];
        xn(this, "type", r, n, {
          issues: E7(i)
        });
      }
      return r;
    }
  };
}
function lr(e, t, r) {
  const n = e._run(
    { typed: !1, value: t },
    nne(r)
  );
  if (n.issues)
    throw new ane(n.issues);
  return n.value;
}
function ju(e, t) {
  const r = {};
  for (const n in e.entries)
    r[n] = Rg(e.entries[n]);
  return { ...e, entries: r };
}
function fd(...e) {
  return {
    ...e[0],
    pipe: e,
    _run(t, r) {
      for (const n of e)
        if (n.kind !== "metadata") {
          if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
            t.typed = !1;
            break;
          }
          (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
        }
      return t;
    }
  };
}
const k7 = new Uint8Array(32), x7 = ys(
  "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
), Zr = (e) => fd(Ry(Uint8Array), mP(e));
function Mh(e, t) {
  return e.length !== t.length ? !1 : e.every((r, n) => de(r, t[n]) === 0);
}
function bi(e) {
  if (!(e instanceof Uint8Array) || e.length < 33) return !1;
  const t = e[0], r = e.slice(1, 33);
  if (de(k7, r) === 0 || de(r, x7) >= 0) return !1;
  if ((t === 2 || t === 3) && e.length === 33)
    return !0;
  const n = e.slice(33);
  return de(k7, n) === 0 || de(n, x7) >= 0 ? !1 : t === 4 && e.length === 65;
}
const P1 = 254;
function S5(e) {
  return !e || !("output" in e) || !(e.output instanceof Uint8Array) ? !1 : e.version !== void 0 ? (e.version & P1) === e.version : !0;
}
function EP(e) {
  return Array.isArray(e) ? e.length !== 2 ? !1 : e.every((t) => EP(t)) : S5(e);
}
const sne = Zr(32), une = Zr(20), A7 = Zr(32), zt = Ry(Uint8Array);
fd(yl(), yP(/^([0-9a-f]{2})+$/i));
const cne = fd(
  Wn(),
  k5(),
  Ny(0),
  By(255)
), Da = fd(
  Wn(),
  k5(),
  Ny(0),
  By(4294967295)
), B2 = fd(
  wP(),
  Ny(0n),
  By(0x7fffffffffffffffn)
), S7 = (e) => Rr(
  Object.entries(e).reduce(
    (t, r) => ({ ...t, [r[0]]: vP(r[1]) }),
    {}
  )
), _7 = new Uint8Array(1);
function I7(e) {
  let t = 0;
  for (; e[t] === 0; ) ++t;
  return t === e.length ? _7 : (e = e.slice(t), e[0] & 128 ? yr([_7, e]) : e);
}
function T7(e) {
  e[0] === 0 && (e = e.slice(1));
  const t = new Uint8Array(32), r = Math.max(0, 32 - e.length);
  return t.set(e, r), t;
}
function lne(e) {
  const t = us(e, e.length - 1);
  if (!I5(t))
    throw new Error("Invalid hashType " + t);
  const r = Dre(e.subarray(0, -1)), n = T7(r.r), o = T7(r.s);
  return { signature: yr([n, o]), hashType: t };
}
function fne(e, t) {
  if (lr(
    Rr({
      signature: Zr(64),
      hashType: cne
    }),
    { signature: e, hashType: t }
  ), !I5(t))
    throw new Error("Invalid hashType " + t);
  const r = new Uint8Array(1);
  vo(r, 0, t);
  const n = I7(e.slice(0, 32)), o = I7(e.slice(32, 64));
  return yr([Mre(n, o), r]);
}
const dne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: lne,
  encode: fne
}, Symbol.toStringTag, { value: "Module" })), kP = Lt.OP_RESERVED, xP = to(A5([Ry(Uint8Array), Wn()]));
function hne(e) {
  return Uy(Wn(), e) && (e === Lt.OP_0 || e >= Lt.OP_1 && e <= Lt.OP_16 || e === Lt.OP_1NEGATE);
}
function AP(e) {
  return Uy(zt, e) || hne(e);
}
function _5(e) {
  return Uy(fd(bP(), gP(AP)), e);
}
function SP(e) {
  return e.length - e.filter(AP).length;
}
function zg(e) {
  if (e.length === 0) return Lt.OP_0;
  if (e.length === 1) {
    if (e[0] >= 1 && e[0] <= 16) return kP + e[0];
    if (e[0] === 129) return Lt.OP_1NEGATE;
  }
}
function _P(e) {
  return e instanceof Uint8Array;
}
function pne(e) {
  return Uy(xP, e);
}
function jg(e) {
  return e instanceof Uint8Array;
}
function ro(e) {
  if (_P(e)) return e;
  lr(xP, e);
  const t = e.reduce((o, a) => jg(a) ? a.length === 1 && zg(a) !== void 0 ? o + 1 : o + pP(a.length) + a.length : o + 1, 0), r = new Uint8Array(t);
  let n = 0;
  if (e.forEach((o) => {
    if (jg(o)) {
      const a = zg(o);
      if (a !== void 0) {
        vo(r, n, a), n += 1;
        return;
      }
      n += Qre(r, o.length, n), r.set(o, n), n += o.length;
    } else
      vo(r, n, o), n += 1;
  }), n !== r.length) throw new Error("Could not decode chunks");
  return r;
}
function dr(e) {
  if (pne(e)) return e;
  lr(zt, e);
  const t = [];
  let r = 0;
  for (; r < e.length; ) {
    const n = e[r];
    if (n > Lt.OP_0 && n <= Lt.OP_PUSHDATA4) {
      const o = ene(e, r);
      if (o === null || (r += o.size, r + o.number > e.length)) return null;
      const a = e.slice(r, r + o.number);
      r += o.number;
      const i = zg(a);
      i !== void 0 ? t.push(i) : t.push(a);
    } else
      t.push(n), r += 1;
  }
  return t;
}
function gne(e) {
  if (_P(e) && (e = dr(e)), !e)
    throw new Error("Could not convert invalid chunks to ASM");
  return e.map((t) => {
    if (jg(t)) {
      const r = zg(t);
      if (r === void 0) return Ve(t);
      t = r;
    }
    return sP[t];
  }).join(" ");
}
function mne(e) {
  return e = dr(e), lr(Ii(_5), e), e.map((t) => jg(t) ? t : t === Lt.OP_0 ? new Uint8Array(0) : rne(t - kP));
}
function yne(e) {
  return bi(e);
}
function I5(e) {
  const t = e & -129;
  return t > 0 && t < 4;
}
function cs(e) {
  return !(e instanceof Uint8Array) || !I5(e[e.length - 1]) ? !1 : Fre(e.slice(0, -1));
}
const ch = dne;
function Le(e, t, r) {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !0,
    get() {
      const n = r.call(this);
      return this[t] = n, n;
    },
    set(n) {
      Object.defineProperty(this, t, {
        configurable: !0,
        enumerable: !0,
        value: n,
        writable: !0
      });
    }
  });
}
function Zo(e) {
  let t;
  return () => (t !== void 0 || (t = e()), t);
}
const Ml = Lt, K0 = Ml.OP_RESERVED;
function zy(e, t) {
  if (!e.input && !e.output && !(e.pubkeys && e.m !== void 0) && !e.signatures)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {});
  function r(s) {
    return cs(s) || (t.allowIncomplete && s === Ml.OP_0) !== void 0;
  }
  lr(
    ju(
      Rr({
        network: Rr({}),
        m: Wn(),
        n: Wn(),
        output: zt,
        pubkeys: to(Ii(bi), "Received invalid pubkey"),
        signatures: to(
          Ii(r),
          "Expected signature to be of type isAcceptableSignature"
        ),
        input: zt
      })
    ),
    e
  );
  const n = { network: e.network || Ui };
  let o = [], a = !1;
  function i(s) {
    a || (a = !0, o = dr(s), n.m = o[0] - K0, n.n = o[o.length - 2] - K0, n.pubkeys = o.slice(1, -2));
  }
  if (Le(n, "output", () => {
    if (e.m && n.n && e.pubkeys)
      return ro(
        [].concat(
          K0 + e.m,
          e.pubkeys,
          K0 + n.n,
          Ml.OP_CHECKMULTISIG
        )
      );
  }), Le(n, "m", () => {
    if (n.output)
      return i(n.output), n.m;
  }), Le(n, "n", () => {
    if (n.pubkeys)
      return n.pubkeys.length;
  }), Le(n, "pubkeys", () => {
    if (e.output)
      return i(e.output), n.pubkeys;
  }), Le(n, "signatures", () => {
    if (e.input)
      return dr(e.input).slice(1);
  }), Le(n, "input", () => {
    if (e.signatures)
      return ro([Ml.OP_0].concat(e.signatures));
  }), Le(n, "witness", () => {
    if (n.input)
      return [];
  }), Le(n, "name", () => {
    if (!(!n.m || !n.n))
      return `p2ms(${n.m} of ${n.n})`;
  }), t.validate) {
    if (e.output) {
      if (i(e.output), lr(Wn(), o[0], { message: "Output is invalid" }), lr(Wn(), o[o.length - 2], {
        message: "Output is invalid"
      }), o[o.length - 1] !== Ml.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (n.m <= 0 || n.n > 16 || n.m > n.n || n.n !== o.length - 3)
        throw new TypeError("Output is invalid");
      if (!n.pubkeys.every((s) => bi(s)))
        throw new TypeError("Output is invalid");
      if (e.m !== void 0 && e.m !== n.m) throw new TypeError("m mismatch");
      if (e.n !== void 0 && e.n !== n.n) throw new TypeError("n mismatch");
      if (e.pubkeys && !Mh(e.pubkeys, n.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (e.pubkeys) {
      if (e.n !== void 0 && e.n !== e.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (n.n = e.pubkeys.length, n.n < n.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (e.signatures) {
      if (e.signatures.length < n.m)
        throw new TypeError("Not enough signatures provided");
      if (e.signatures.length > n.m)
        throw new TypeError("Too many signatures provided");
    }
    if (e.input) {
      if (e.input[0] !== Ml.OP_0) throw new TypeError("Input is invalid");
      if (n.signatures.length === 0 || !n.signatures.every(r))
        throw new TypeError("Input has invalid signature(s)");
      if (e.signatures && !Mh(e.signatures, n.signatures))
        throw new TypeError("Signature mismatch");
      if (e.m !== void 0 && e.m !== e.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(n, e);
}
const P7 = Lt;
function IP(e, t) {
  if (!e.input && !e.output && !e.pubkey && !e.input && !e.signature)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), lr(
    ju(
      Rr({
        network: Rr({}),
        output: zt,
        pubkey: Ii(bi, "invalid pubkey"),
        signature: Ii(
          cs,
          "Expected signature to be of type isCanonicalScriptSignature"
        ),
        input: zt
      })
    ),
    e
  );
  const r = Zo(() => dr(e.input)), n = { name: "p2pk", network: e.network || Ui };
  if (Le(n, "output", () => {
    if (e.pubkey)
      return ro([e.pubkey, P7.OP_CHECKSIG]);
  }), Le(n, "pubkey", () => {
    if (e.output)
      return e.output.slice(1, -1);
  }), Le(n, "signature", () => {
    if (e.input)
      return r()[0];
  }), Le(n, "input", () => {
    if (e.signature)
      return ro([e.signature]);
  }), Le(n, "witness", () => {
    if (n.input)
      return [];
  }), t.validate) {
    if (e.output) {
      if (e.output[e.output.length - 1] !== P7.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!bi(n.pubkey)) throw new TypeError("Output pubkey is invalid");
      if (e.pubkey && de(e.pubkey, n.pubkey) !== 0)
        throw new TypeError("Pubkey mismatch");
    }
    if (e.signature && e.input && de(e.input, n.input) !== 0)
      throw new TypeError("Signature mismatch");
    if (e.input) {
      if (r().length !== 1) throw new TypeError("Input is invalid");
      if (!cs(n.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(n, e);
}
function O7(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function bne(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function jy(e, ...t) {
  if (!bne(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function wne(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  O7(e.outputLen), O7(e.blockLen);
}
function Lg(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function vne(e, t) {
  jy(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const Ul = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const N2 = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Vi = (e, t) => e << 32 - t | e >>> t, q0 = (e, t) => e << t | e >>> 32 - t >>> 0;
new Uint8Array(new Uint32Array([287454020]).buffer)[0];
function Ene(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function T5(e) {
  return typeof e == "string" && (e = Ene(e)), jy(e), e;
}
function kne(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const o = e[n];
    jy(o), t += o.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, o = 0; n < e.length; n++) {
    const a = e[n];
    r.set(a, o), o += a.length;
  }
  return r;
}
let TP = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function P5(e) {
  const t = (n) => e().update(T5(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function xne(e = 32) {
  if (Ul && typeof Ul.getRandomValues == "function")
    return Ul.getRandomValues(new Uint8Array(e));
  if (Ul && typeof Ul.randomBytes == "function")
    return Ul.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
function Ane(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
const Sne = (e, t, r) => e & t ^ ~e & r, _ne = (e, t, r) => e & t ^ e & r ^ t & r;
let O5 = class extends TP {
  constructor(e, t, r, n) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = N2(this.buffer);
  }
  update(e) {
    Lg(this);
    const { view: t, buffer: r, blockLen: n } = this;
    e = T5(e);
    const o = e.length;
    for (let a = 0; a < o; ) {
      const i = Math.min(n - this.pos, o - a);
      if (i === n) {
        const s = N2(e);
        for (; n <= o - a; a += n)
          this.process(s, a);
        continue;
      }
      r.set(e.subarray(a, a + i), this.pos), this.pos += i, a += i, this.pos === n && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Lg(this), vne(e, this), this.finished = !0;
    const { buffer: t, view: r, blockLen: n, isLE: o } = this;
    let { pos: a } = this;
    t[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > n - a && (this.process(r, 0), a = 0);
    for (let c = a; c < n; c++)
      t[c] = 0;
    Ane(r, n - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const i = N2(e), s = this.outputLen;
    if (s % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = s / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let c = 0; c < u; c++)
      i.setUint32(4 * c, l[c], o);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: n, finished: o, destroyed: a, pos: i } = this;
    return e.length = n, e.pos = i, e.finished = o, e.destroyed = a, n % t && e.buffer.set(r), e;
  }
};
const Ine = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), PP = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((e, t) => t)), Tne = /* @__PURE__ */ PP.map((e) => (9 * e + 5) % 16);
let $5 = [PP], C5 = [Tne];
for (let e = 0; e < 4; e++)
  for (let t of [$5, C5])
    t.push(t[e].map((r) => Ine[r]));
const OP = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => new Uint8Array(e)), Pne = /* @__PURE__ */ $5.map((e, t) => e.map((r) => OP[t][r])), One = /* @__PURE__ */ C5.map((e, t) => e.map((r) => OP[t][r])), $ne = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Cne = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function $7(e, t, r, n) {
  return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const V0 = /* @__PURE__ */ new Uint32Array(16);
let Bne = class extends O5 {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: e, h1: t, h2: r, h3: n, h4: o } = this;
    return [e, t, r, n, o];
  }
  set(e, t, r, n, o) {
    this.h0 = e | 0, this.h1 = t | 0, this.h2 = r | 0, this.h3 = n | 0, this.h4 = o | 0;
  }
  process(e, t) {
    for (let h = 0; h < 16; h++, t += 4)
      V0[h] = e.getUint32(t, !0);
    let r = this.h0 | 0, n = r, o = this.h1 | 0, a = o, i = this.h2 | 0, s = i, u = this.h3 | 0, l = u, c = this.h4 | 0, f = c;
    for (let h = 0; h < 5; h++) {
      const p = 4 - h, y = $ne[h], m = Cne[h], b = $5[h], v = C5[h], k = Pne[h], E = One[h];
      for (let A = 0; A < 16; A++) {
        const S = q0(r + $7(h, o, i, u) + V0[b[A]] + y, k[A]) + c | 0;
        r = c, c = u, u = q0(i, 10) | 0, i = o, o = S;
      }
      for (let A = 0; A < 16; A++) {
        const S = q0(n + $7(p, a, s, l) + V0[v[A]] + m, E[A]) + f | 0;
        n = f, f = l, l = q0(s, 10) | 0, s = a, a = S;
      }
    }
    this.set(this.h1 + i + l | 0, this.h2 + u + f | 0, this.h3 + c + n | 0, this.h4 + r + a | 0, this.h0 + o + s | 0);
  }
  roundClean() {
    V0.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
};
const $P = /* @__PURE__ */ P5(() => new Bne()), Nne = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Vs = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Gs = /* @__PURE__ */ new Uint32Array(64);
let Une = class extends O5 {
  constructor() {
    super(64, 32, 8, !1), this.A = Vs[0] | 0, this.B = Vs[1] | 0, this.C = Vs[2] | 0, this.D = Vs[3] | 0, this.E = Vs[4] | 0, this.F = Vs[5] | 0, this.G = Vs[6] | 0, this.H = Vs[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: n, E: o, F: a, G: i, H: s } = this;
    return [e, t, r, n, o, a, i, s];
  }
  // prettier-ignore
  set(e, t, r, n, o, a, i, s) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = o | 0, this.F = a | 0, this.G = i | 0, this.H = s | 0;
  }
  process(e, t) {
    for (let c = 0; c < 16; c++, t += 4)
      Gs[c] = e.getUint32(t, !1);
    for (let c = 16; c < 64; c++) {
      const f = Gs[c - 15], h = Gs[c - 2], p = Vi(f, 7) ^ Vi(f, 18) ^ f >>> 3, y = Vi(h, 17) ^ Vi(h, 19) ^ h >>> 10;
      Gs[c] = y + Gs[c - 7] + p + Gs[c - 16] | 0;
    }
    let { A: r, B: n, C: o, D: a, E: i, F: s, G: u, H: l } = this;
    for (let c = 0; c < 64; c++) {
      const f = Vi(i, 6) ^ Vi(i, 11) ^ Vi(i, 25), h = l + f + Sne(i, s, u) + Nne[c] + Gs[c] | 0, p = (Vi(r, 2) ^ Vi(r, 13) ^ Vi(r, 22)) + _ne(r, n, o) | 0;
      l = u, u = s, s = i, i = a + h | 0, a = o, o = n, n = r, r = h + p | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, i = i + this.E | 0, s = s + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, n, o, a, i, s, u, l);
  }
  roundClean() {
    Gs.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const tn = /* @__PURE__ */ P5(() => new Une());
function es(e) {
  return $P(tn(e));
}
function ac(e) {
  return tn(tn(e));
}
const Rne = {
  "BIP0340/challenge": Uint8Array.from([
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124,
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124
  ]),
  "BIP0340/aux": Uint8Array.from([
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144,
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144
  ]),
  "BIP0340/nonce": Uint8Array.from([
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47,
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47
  ]),
  TapLeaf: Uint8Array.from([
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238,
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238
  ]),
  TapBranch: Uint8Array.from([
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21,
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21
  ]),
  TapSighash: Uint8Array.from([
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49,
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49
  ]),
  TapTweak: Uint8Array.from([
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233,
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233
  ]),
  "KeyAgg list": Uint8Array.from([
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240,
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240
  ]),
  "KeyAgg coefficient": Uint8Array.from([
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129,
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129
  ])
};
function Ly(e, t) {
  return tn(yr([Rne[e], t]));
}
function zne(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let l = 0; l < t.length; l++)
    t[l] = 255;
  for (let l = 0; l < e.length; l++) {
    const c = e.charAt(l), f = c.charCodeAt(0);
    if (t[f] !== 255)
      throw new TypeError(c + " is ambiguous");
    t[f] = l;
  }
  const r = e.length, n = e.charAt(0), o = Math.log(r) / Math.log(256), a = Math.log(256) / Math.log(r);
  function i(l) {
    if (l instanceof Uint8Array || (ArrayBuffer.isView(l) ? l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : Array.isArray(l) && (l = Uint8Array.from(l))), !(l instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (l.length === 0)
      return "";
    let c = 0, f = 0, h = 0;
    const p = l.length;
    for (; h !== p && l[h] === 0; )
      h++, c++;
    const y = (p - h) * a + 1 >>> 0, m = new Uint8Array(y);
    for (; h !== p; ) {
      let k = l[h], E = 0;
      for (let A = y - 1; (k !== 0 || E < f) && A !== -1; A--, E++)
        k += 256 * m[A] >>> 0, m[A] = k % r >>> 0, k = k / r >>> 0;
      if (k !== 0)
        throw new Error("Non-zero carry");
      f = E, h++;
    }
    let b = y - f;
    for (; b !== y && m[b] === 0; )
      b++;
    let v = n.repeat(c);
    for (; b < y; ++b)
      v += e.charAt(m[b]);
    return v;
  }
  function s(l) {
    if (typeof l != "string")
      throw new TypeError("Expected String");
    if (l.length === 0)
      return new Uint8Array();
    let c = 0, f = 0, h = 0;
    for (; l[c] === n; )
      f++, c++;
    const p = (l.length - c) * o + 1 >>> 0, y = new Uint8Array(p);
    for (; l[c]; ) {
      let k = t[l.charCodeAt(c)];
      if (k === 255)
        return;
      let E = 0;
      for (let A = p - 1; (k !== 0 || E < h) && A !== -1; A--, E++)
        k += r * y[A] >>> 0, y[A] = k % 256 >>> 0, k = k / 256 >>> 0;
      if (k !== 0)
        throw new Error("Non-zero carry");
      h = E, c++;
    }
    let m = p - h;
    for (; m !== p && y[m] === 0; )
      m++;
    const b = new Uint8Array(f + (p - m));
    let v = f;
    for (; m !== p; )
      b[v++] = y[m++];
    return b;
  }
  function u(l) {
    const c = s(l);
    if (c)
      return c;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: i,
    decodeUnsafe: s,
    decode: u
  };
}
var jne = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const U2 = zne(jne);
function Lne(e) {
  function t(a) {
    var i = Uint8Array.from(a), s = e(i), u = i.length + 4, l = new Uint8Array(u);
    return l.set(i, 0), l.set(s.subarray(0, 4), i.length), U2.encode(l);
  }
  function r(a) {
    var i = a.slice(0, -4), s = a.slice(-4), u = e(i);
    if (!(s[0] ^ u[0] | s[1] ^ u[1] | s[2] ^ u[2] | s[3] ^ u[3]))
      return i;
  }
  function n(a) {
    var i = U2.decodeUnsafe(a);
    if (i != null)
      return r(i);
  }
  function o(a) {
    var i = U2.decode(a), s = r(i);
    if (s == null)
      throw new Error("Invalid checksum");
    return s;
  }
  return {
    encode: t,
    decode: o,
    decodeUnsafe: n
  };
}
function Hne(e) {
  return tn(tn(e));
}
const Cf = Lne(Hne), Zs = Lt;
function Dp(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.input)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), lr(
    ju(
      Rr({
        network: Rr({}),
        address: yl(),
        hash: une,
        output: Zr(25),
        pubkey: Ii(bi),
        signature: Ii(cs),
        input: zt
      })
    ),
    e
  );
  const r = Zo(() => {
    const i = Cf.decode(e.address), s = us(i, 0), u = i.slice(1);
    return { version: s, hash: u };
  }), n = Zo(() => dr(e.input)), o = e.network || Ui, a = { name: "p2pkh", network: o };
  if (Le(a, "address", () => {
    if (!a.hash) return;
    const i = new Uint8Array(21);
    return vo(i, 0, o.pubKeyHash), i.set(a.hash, 1), Cf.encode(i);
  }), Le(a, "hash", () => {
    if (e.output) return e.output.slice(3, 23);
    if (e.address) return r().hash;
    if (e.pubkey || a.pubkey) return es(e.pubkey || a.pubkey);
  }), Le(a, "output", () => {
    if (a.hash)
      return ro([
        Zs.OP_DUP,
        Zs.OP_HASH160,
        a.hash,
        Zs.OP_EQUALVERIFY,
        Zs.OP_CHECKSIG
      ]);
  }), Le(a, "pubkey", () => {
    if (e.input)
      return n()[1];
  }), Le(a, "signature", () => {
    if (e.input)
      return n()[0];
  }), Le(a, "input", () => {
    if (e.pubkey && e.signature)
      return ro([e.signature, e.pubkey]);
  }), Le(a, "witness", () => {
    if (a.input)
      return [];
  }), t.validate) {
    let i = Uint8Array.from([]);
    if (e.address) {
      if (r().version !== o.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (r().hash.length !== 20) throw new TypeError("Invalid address");
      i = r().hash;
    }
    if (e.hash) {
      if (i.length > 0 && de(i, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      i = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 25 || e.output[0] !== Zs.OP_DUP || e.output[1] !== Zs.OP_HASH160 || e.output[2] !== 20 || e.output[23] !== Zs.OP_EQUALVERIFY || e.output[24] !== Zs.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const s = e.output.slice(3, 23);
      if (i.length > 0 && de(i, s) !== 0)
        throw new TypeError("Hash mismatch");
      i = s;
    }
    if (e.pubkey) {
      const s = es(e.pubkey);
      if (i.length > 0 && de(i, s) !== 0)
        throw new TypeError("Hash mismatch");
      i = s;
    }
    if (e.input) {
      const s = n();
      if (s.length !== 2) throw new TypeError("Input is invalid");
      if (!cs(s[0]))
        throw new TypeError("Input has invalid signature");
      if (!bi(s[1])) throw new TypeError("Input has invalid pubkey");
      if (e.signature && de(e.signature, s[0]) !== 0)
        throw new TypeError("Signature mismatch");
      if (e.pubkey && de(e.pubkey, s[1]) !== 0)
        throw new TypeError("Pubkey mismatch");
      const u = es(s[1]);
      if (i.length > 0 && de(i, u) !== 0)
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(a, e);
}
const Fd = Lt;
function dd(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.input)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), lr(
    ju(
      Rr({
        network: Rr({}),
        address: yl(),
        hash: Zr(20),
        output: Zr(23),
        redeem: ju(
          Rr({
            network: Rr({}),
            output: zt,
            input: zt,
            witness: to(zt)
          })
        ),
        input: zt,
        witness: to(zt)
      })
    ),
    e
  );
  let r = e.network;
  r || (r = e.redeem && e.redeem.network || Ui);
  const n = { network: r }, o = Zo(() => {
    const s = Cf.decode(e.address), u = us(s, 0), l = s.slice(1);
    return { version: u, hash: l };
  }), a = Zo(() => dr(e.input)), i = Zo(() => {
    const s = a(), u = s[s.length - 1];
    return {
      network: r,
      output: u === Fd.OP_FALSE ? Uint8Array.from([]) : u,
      input: ro(s.slice(0, -1)),
      witness: e.witness || []
    };
  });
  if (Le(n, "address", () => {
    if (!n.hash) return;
    const s = new Uint8Array(21);
    return vo(s, 0, n.network.scriptHash), s.set(n.hash, 1), Cf.encode(s);
  }), Le(n, "hash", () => {
    if (e.output) return e.output.slice(2, 22);
    if (e.address) return o().hash;
    if (n.redeem && n.redeem.output) return es(n.redeem.output);
  }), Le(n, "output", () => {
    if (n.hash)
      return ro([Fd.OP_HASH160, n.hash, Fd.OP_EQUAL]);
  }), Le(n, "redeem", () => {
    if (e.input)
      return i();
  }), Le(n, "input", () => {
    if (!(!e.redeem || !e.redeem.input || !e.redeem.output))
      return ro(
        [].concat(dr(e.redeem.input), e.redeem.output)
      );
  }), Le(n, "witness", () => {
    if (n.redeem && n.redeem.witness) return n.redeem.witness;
    if (n.input) return [];
  }), Le(n, "name", () => {
    const s = ["p2sh"];
    return n.redeem !== void 0 && n.redeem.name !== void 0 && s.push(n.redeem.name), s.join("-");
  }), t.validate) {
    let s = Uint8Array.from([]);
    if (e.address) {
      if (o().version !== r.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (o().hash.length !== 20) throw new TypeError("Invalid address");
      s = o().hash;
    }
    if (e.hash) {
      if (s.length > 0 && de(s, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      s = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 23 || e.output[0] !== Fd.OP_HASH160 || e.output[1] !== 20 || e.output[22] !== Fd.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const l = e.output.slice(2, 22);
      if (s.length > 0 && de(s, l) !== 0)
        throw new TypeError("Hash mismatch");
      s = l;
    }
    const u = (l) => {
      if (l.output) {
        const c = dr(l.output);
        if (!c || c.length < 1)
          throw new TypeError("Redeem.output too short");
        if (l.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (SP(c) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const f = es(l.output);
        if (s.length > 0 && de(s, f) !== 0)
          throw new TypeError("Hash mismatch");
        s = f;
      }
      if (l.input) {
        const c = l.input.length > 0, f = l.witness && l.witness.length > 0;
        if (!c && !f) throw new TypeError("Empty input");
        if (c && f)
          throw new TypeError("Input and witness provided");
        if (c) {
          const h = dr(l.input);
          if (!_5(h))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (e.input) {
      const l = a();
      if (!l || l.length < 1) throw new TypeError("Input too short");
      if (!(i().output instanceof Uint8Array))
        throw new TypeError("Input is invalid");
      u(i());
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== r)
        throw new TypeError("Network mismatch");
      if (e.input) {
        const l = i();
        if (e.redeem.output && de(e.redeem.output, l.output) !== 0)
          throw new TypeError("Redeem.output mismatch");
        if (e.redeem.input && de(e.redeem.input, l.input) !== 0)
          throw new TypeError("Redeem.input mismatch");
      }
      u(e.redeem);
    }
    if (e.witness && e.redeem && e.redeem.witness && !Mh(e.redeem.witness, e.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(n, e);
}
var Ke = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Fne(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Dne(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var o = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, o.get ? o : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var Kh = {};
Object.defineProperty(Kh, "__esModule", { value: !0 });
var qh = Kh.bech32m = ko = Kh.bech32 = void 0;
const Hg = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", CP = {};
for (let e = 0; e < Hg.length; e++) {
  const t = Hg.charAt(e);
  CP[t] = e;
}
function ff(e) {
  const t = e >> 25;
  return (e & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059;
}
function C7(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = e.charCodeAt(r);
    if (n < 33 || n > 126)
      return "Invalid prefix (" + e + ")";
    t = ff(t) ^ n >> 5;
  }
  t = ff(t);
  for (let r = 0; r < e.length; ++r) {
    const n = e.charCodeAt(r);
    t = ff(t) ^ n & 31;
  }
  return t;
}
function B5(e, t, r, n) {
  let o = 0, a = 0;
  const i = (1 << r) - 1, s = [];
  for (let u = 0; u < e.length; ++u)
    for (o = o << t | e[u], a += t; a >= r; )
      a -= r, s.push(o >> a & i);
  if (n)
    a > 0 && s.push(o << r - a & i);
  else {
    if (a >= t)
      return "Excess padding";
    if (o << r - a & i)
      return "Non-zero padding";
  }
  return s;
}
function Mne(e) {
  return B5(e, 8, 5, !0);
}
function Kne(e) {
  const t = B5(e, 5, 8, !1);
  if (Array.isArray(t))
    return t;
}
function qne(e) {
  const t = B5(e, 5, 8, !1);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
function BP(e) {
  let t;
  e === "bech32" ? t = 1 : t = 734539939;
  function r(i, s, u) {
    if (u = u || 90, i.length + 7 + s.length > u)
      throw new TypeError("Exceeds length limit");
    i = i.toLowerCase();
    let l = C7(i);
    if (typeof l == "string")
      throw new Error(l);
    let c = i + "1";
    for (let f = 0; f < s.length; ++f) {
      const h = s[f];
      if (h >> 5)
        throw new Error("Non 5-bit word");
      l = ff(l) ^ h, c += Hg.charAt(h);
    }
    for (let f = 0; f < 6; ++f)
      l = ff(l);
    l ^= t;
    for (let f = 0; f < 6; ++f) {
      const h = l >> (5 - f) * 5 & 31;
      c += Hg.charAt(h);
    }
    return c;
  }
  function n(i, s) {
    if (s = s || 90, i.length < 8)
      return i + " too short";
    if (i.length > s)
      return "Exceeds length limit";
    const u = i.toLowerCase(), l = i.toUpperCase();
    if (i !== u && i !== l)
      return "Mixed-case string " + i;
    i = u;
    const c = i.lastIndexOf("1");
    if (c === -1)
      return "No separator character for " + i;
    if (c === 0)
      return "Missing prefix for " + i;
    const f = i.slice(0, c), h = i.slice(c + 1);
    if (h.length < 6)
      return "Data too short";
    let p = C7(f);
    if (typeof p == "string")
      return p;
    const y = [];
    for (let m = 0; m < h.length; ++m) {
      const b = h.charAt(m), v = CP[b];
      if (v === void 0)
        return "Unknown character " + b;
      p = ff(p) ^ v, !(m + 6 >= h.length) && y.push(v);
    }
    return p !== t ? "Invalid checksum for " + i : { prefix: f, words: y };
  }
  function o(i, s) {
    const u = n(i, s);
    if (typeof u == "object")
      return u;
  }
  function a(i, s) {
    const u = n(i, s);
    if (typeof u == "object")
      return u;
    throw new Error(u);
  }
  return {
    decodeUnsafe: o,
    decode: a,
    encode: r,
    toWords: Mne,
    fromWordsUnsafe: Kne,
    fromWords: qne
  };
}
var ko = Kh.bech32 = BP("bech32");
qh = Kh.bech32m = BP("bech32m");
const B7 = Lt, Vne = new Uint8Array(0);
function Mp(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.witness)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), lr(
    ju(
      Rr({
        address: yl(),
        hash: Zr(20),
        input: Zr(0),
        network: Rr({}),
        output: Zr(22),
        pubkey: Ii(bi, "Not a valid pubkey"),
        signature: Ii(cs),
        witness: to(zt)
      })
    ),
    e
  );
  const r = Zo(() => {
    const a = ko.decode(e.address), i = a.words.shift(), s = ko.fromWords(a.words);
    return {
      version: i,
      prefix: a.prefix,
      data: Uint8Array.from(s)
    };
  }), n = e.network || Ui, o = { name: "p2wpkh", network: n };
  if (Le(o, "address", () => {
    if (!o.hash) return;
    const a = ko.toWords(o.hash);
    return a.unshift(0), ko.encode(n.bech32, a);
  }), Le(o, "hash", () => {
    if (e.output) return e.output.slice(2, 22);
    if (e.address) return r().data;
    if (e.pubkey || o.pubkey) return es(e.pubkey || o.pubkey);
  }), Le(o, "output", () => {
    if (o.hash)
      return ro([B7.OP_0, o.hash]);
  }), Le(o, "pubkey", () => {
    if (e.pubkey) return e.pubkey;
    if (e.witness)
      return e.witness[1];
  }), Le(o, "signature", () => {
    if (e.witness)
      return e.witness[0];
  }), Le(o, "input", () => {
    if (o.witness)
      return Vne;
  }), Le(o, "witness", () => {
    if (e.pubkey && e.signature)
      return [e.signature, e.pubkey];
  }), t.validate) {
    let a = Uint8Array.from([]);
    if (e.address) {
      if (n && n.bech32 !== r().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== 0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 20)
        throw new TypeError("Invalid address data");
      a = r().data;
    }
    if (e.hash) {
      if (a.length > 0 && de(a, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      a = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 22 || e.output[0] !== B7.OP_0 || e.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (a.length > 0 && de(a, e.output.slice(2)) !== 0)
        throw new TypeError("Hash mismatch");
      a = e.output.slice(2);
    }
    if (e.pubkey) {
      const i = es(e.pubkey);
      if (a.length > 0 && de(a, i) !== 0)
        throw new TypeError("Hash mismatch");
      if (a = i, !bi(e.pubkey) || e.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (e.witness) {
      if (e.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!cs(e.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!bi(e.witness[1]) || e.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (e.signature && de(e.signature, e.witness[0]) !== 0)
        throw new TypeError("Signature mismatch");
      if (e.pubkey && de(e.pubkey, e.witness[1]) !== 0)
        throw new TypeError("Pubkey mismatch");
      const i = es(e.witness[1]);
      if (a.length > 0 && de(a, i) !== 0)
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(o, e);
}
const N7 = Lt, R2 = new Uint8Array(0);
function G0(e) {
  return !!(e instanceof Uint8Array && e.length === 65 && e[0] === 4 && bi(e));
}
function Kp(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.witness)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), lr(
    S7({
      network: Rr({}),
      address: yl(),
      hash: sne,
      output: Zr(34),
      redeem: S7({
        input: zt,
        network: Rr({}),
        output: zt,
        witness: to(zt)
      }),
      input: Zr(0),
      witness: to(zt)
    }),
    e
  );
  const r = Zo(() => {
    const i = ko.decode(e.address), s = i.words.shift(), u = ko.fromWords(i.words);
    return {
      version: s,
      prefix: i.prefix,
      data: Uint8Array.from(u)
    };
  }), n = Zo(() => dr(e.redeem.input));
  let o = e.network;
  o || (o = e.redeem && e.redeem.network || Ui);
  const a = { network: o };
  if (Le(a, "address", () => {
    if (!a.hash) return;
    const i = ko.toWords(a.hash);
    return i.unshift(0), ko.encode(o.bech32, i);
  }), Le(a, "hash", () => {
    if (e.output) return e.output.slice(2);
    if (e.address) return r().data;
    if (a.redeem && a.redeem.output) return tn(a.redeem.output);
  }), Le(a, "output", () => {
    if (a.hash)
      return ro([N7.OP_0, a.hash]);
  }), Le(a, "redeem", () => {
    if (e.witness)
      return {
        output: e.witness[e.witness.length - 1],
        input: R2,
        witness: e.witness.slice(0, -1)
      };
  }), Le(a, "input", () => {
    if (a.witness)
      return R2;
  }), Le(a, "witness", () => {
    if (e.redeem && e.redeem.input && e.redeem.input.length > 0 && e.redeem.output && e.redeem.output.length > 0) {
      const i = mne(n());
      return a.redeem = Object.assign({ witness: i }, e.redeem), a.redeem.input = R2, [].concat(i, e.redeem.output);
    }
    if (e.redeem && e.redeem.output && e.redeem.witness)
      return [].concat(e.redeem.witness, e.redeem.output);
  }), Le(a, "name", () => {
    const i = ["p2wsh"];
    return a.redeem !== void 0 && a.redeem.name !== void 0 && i.push(a.redeem.name), i.join("-");
  }), t.validate) {
    let i = Uint8Array.from([]);
    if (e.address) {
      if (r().prefix !== o.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== 0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 32)
        throw new TypeError("Invalid address data");
      i = r().data;
    }
    if (e.hash) {
      if (i.length > 0 && de(i, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      i = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== N7.OP_0 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const s = e.output.slice(2);
      if (i.length > 0 && de(i, s) !== 0)
        throw new TypeError("Hash mismatch");
      i = s;
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== o)
        throw new TypeError("Network mismatch");
      if (e.redeem.input && e.redeem.input.length > 0 && e.redeem.witness && e.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (e.redeem.output) {
        const s = dr(e.redeem.output);
        if (!s || s.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (e.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (SP(s) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const u = tn(e.redeem.output);
        if (i.length > 0 && de(i, u) !== 0)
          throw new TypeError("Hash mismatch");
        i = u;
      }
      if (e.redeem.input && !_5(n()))
        throw new TypeError("Non push-only scriptSig");
      if (e.witness && e.redeem.witness && !Mh(e.witness, e.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (e.redeem.input && n().some(G0) || e.redeem.output && (dr(e.redeem.output) || []).some(
        G0
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (e.witness && e.witness.length > 0) {
      const s = e.witness[e.witness.length - 1];
      if (e.redeem && e.redeem.output && de(e.redeem.output, s) !== 0)
        throw new TypeError("Witness and redeem.output mismatch");
      if (e.witness.some(G0) || (dr(s) || []).some(G0))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(a, e);
}
const lh = {};
function N5(e) {
  e ? e !== lh.eccLib && (Gne(e), lh.eccLib = e) : lh.eccLib = e;
}
function Uv() {
  if (!lh.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return lh.eccLib;
}
const Ba = (e) => ys(e);
function Gne(e) {
  jo(typeof e.isXOnlyPoint == "function"), jo(
    e.isXOnlyPoint(
      Ba("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), jo(
    e.isXOnlyPoint(
      Ba("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), jo(
    e.isXOnlyPoint(
      Ba("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), jo(
    e.isXOnlyPoint(
      Ba("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), jo(
    !e.isXOnlyPoint(
      Ba("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), jo(
    !e.isXOnlyPoint(
      Ba("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), jo(typeof e.xOnlyPointAddTweak == "function"), Zne.forEach((t) => {
    const r = e.xOnlyPointAddTweak(Ba(t.pubkey), Ba(t.tweak));
    t.result === null ? jo(r === null) : (jo(r !== null), jo(r.parity === t.parity), jo(de(r.xOnlyPubkey, Ba(t.result)) === 0));
  });
}
function jo(e) {
  if (!e) throw new Error("ecc library invalid");
}
const Zne = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
], NP = "0123456789abcdefABCDEF";
NP.split("").map((e) => e.codePointAt(0));
const U7 = Array(256).fill(!0).map((e, t) => {
  const r = String.fromCodePoint(t), n = NP.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), UP = new TextEncoder();
new TextDecoder();
function Wne(e) {
  return UP.encode(e);
}
function Xne(e) {
  const t = e.reduce((o, a) => o + a.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const o of e)
    r.set(o, n), n += o.length;
  return r;
}
function Yne(e) {
  const t = UP.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let n;
  for (n = 0; n < r.length; n++) {
    const o = U7[t[n * 2]], a = U7[t[n * 2 + 1]];
    if (o === void 0 || a === void 0)
      break;
    r[n] = o << 4 | a;
  }
  return n === r.length ? r : r.slice(0, n);
}
function Na(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; ++n)
    if (e[n] !== t[n])
      return e[n] < t[n] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function R7(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  e[t] = r;
}
function Jne(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255);
}
function cc(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255);
}
function Qne(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn));
}
function eoe(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function Kl(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function toe(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), n;
  } else {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 7]), n;
  }
}
const roe = (e) => {
  if (e < 0 || e > 0xffffffffffffffffn)
    throw new RangeError("value out of range");
};
function noe(e) {
  if (e < 0 || e > Number.MAX_SAFE_INTEGER || e % 1 !== 0)
    throw new RangeError("value out of range");
}
function RP(e) {
  typeof e == "number" ? noe(e) : roe(e);
}
function Lu(e, t, r) {
  RP(e), r === void 0 && (r = 0), t === void 0 && (t = new Uint8Array(Xo(e)));
  let n = 0;
  return e < 253 ? (t.set([Number(e)], r), n = 1) : e <= 65535 ? (t.set([253], r), Jne(t, r + 1, Number(e), "LE"), n = 3) : e <= 4294967295 ? (t.set([254], r), cc(t, r + 1, Number(e), "LE"), n = 5) : (t.set([255], r), Qne(t, r + 1, BigInt(e), "LE"), n = 9), { buffer: t, bytes: n };
}
function hd(e, t) {
  t === void 0 && (t = 0);
  const r = e.at(t);
  if (r === void 0)
    throw new Error("buffer too small");
  if (r < 253)
    return { numberValue: r, bigintValue: BigInt(r), bytes: 1 };
  if (r === 253) {
    const n = eoe(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 3
    };
  } else if (r === 254) {
    const n = Kl(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 5
    };
  } else {
    const n = toe(e, t + 1, "LE");
    return { numberValue: n <= Number.MAX_SAFE_INTEGER ? Number(n) : null, bigintValue: n, bytes: 9 };
  }
}
function Xo(e) {
  return RP(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
const ooe = 9007199254740991;
function ioe(e, t) {
  if (typeof e != "number" && typeof e != "bigint")
    throw new Error("cannot write a non-number as a number");
  if (e < 0 && e < BigInt(0))
    throw new Error("specified a negative value for writing an unsigned value");
  if (e > t && e > BigInt(t))
    throw new Error("RangeError: value out of range");
  if (Math.floor(Number(e)) !== Number(e))
    throw new Error("value has a fractional component");
}
function U5(e) {
  if (e.length < 1) return e;
  let t = e.length - 1, r = 0;
  for (let n = 0; n < e.length / 2; n++)
    r = e[n], e[n] = e[t], e[t] = r, t--;
  return e;
}
function z7(e) {
  const t = new Uint8Array(e.length);
  return t.set(e), t;
}
class bn {
  constructor(t, r = 0) {
    xe(this, "buffer"), xe(this, "offset"), this.buffer = t, this.offset = r, lr(ra([zt, Da]), [
      t,
      r
    ]);
  }
  static withCapacity(t) {
    return new bn(new Uint8Array(t));
  }
  writeUInt8(t) {
    this.offset = vo(this.buffer, this.offset, t);
  }
  writeInt32(t) {
    this.offset = fP(this.buffer, this.offset, t, "LE");
  }
  writeInt64(t) {
    this.offset = dP(this.buffer, this.offset, BigInt(t), "LE");
  }
  writeUInt32(t) {
    this.offset = Fp(this.buffer, this.offset, t, "LE");
  }
  writeUInt64(t) {
    this.offset = Xre(this.buffer, this.offset, BigInt(t), "LE");
  }
  writeVarInt(t) {
    const { bytes: r } = Lu(t, this.buffer, this.offset);
    this.offset += r;
  }
  writeSlice(t) {
    if (this.buffer.length < this.offset + t.length)
      throw new Error("Cannot write slice out of bounds");
    this.buffer.set(t, this.offset), this.offset += t.length;
  }
  writeVarSlice(t) {
    this.writeVarInt(t.length), this.writeSlice(t);
  }
  writeVector(t) {
    this.writeVarInt(t.length), t.forEach((r) => this.writeVarSlice(r));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
class aoe {
  constructor(t, r = 0) {
    xe(this, "buffer"), xe(this, "offset"), this.buffer = t, this.offset = r, lr(ra([zt, Da]), [
      t,
      r
    ]);
  }
  readUInt8() {
    const t = us(this.buffer, this.offset);
    return this.offset++, t;
  }
  readInt32() {
    const t = Jre(this.buffer, this.offset, "LE");
    return this.offset += 4, t;
  }
  readUInt32() {
    const t = ld(this.buffer, this.offset, "LE");
    return this.offset += 4, t;
  }
  readInt64() {
    const t = hP(this.buffer, this.offset, "LE");
    return this.offset += 8, t;
  }
  readVarInt() {
    const { bigintValue: t, bytes: r } = hd(this.buffer, this.offset);
    return this.offset += r, t;
  }
  readSlice(t) {
    ioe(t, ooe);
    const r = Number(t);
    if (this.buffer.length < this.offset + r)
      throw new Error("Cannot read slice out of bounds");
    const n = this.buffer.slice(this.offset, this.offset + r);
    return this.offset += r, n;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const t = this.readVarInt(), r = [];
    for (let n = 0; n < t; n++) r.push(this.readVarSlice());
    return r;
  }
}
const zP = 192, soe = 128, uoe = (e) => "left" in e && "right" in e;
function Rv(e, t) {
  if (e.length < 33)
    throw new TypeError(
      `The control-block length is too small. Got ${e.length}, expected min 33.`
    );
  const r = (e.length - 33) / 32;
  let n = t;
  for (let o = 0; o < r; o++) {
    const a = e.slice(33 + 32 * o, 65 + 32 * o);
    de(n, a) < 0 ? n = jv(n, a) : n = jv(a, n);
  }
  return n;
}
function zv(e) {
  if (S5(e)) return { hash: Xa(e) };
  const t = [zv(e[0]), zv(e[1])];
  t.sort((o, a) => de(o.hash, a.hash));
  const [r, n] = t;
  return {
    hash: jv(r.hash, n.hash),
    left: r,
    right: n
  };
}
function Fg(e, t) {
  if (uoe(e)) {
    const r = Fg(e.left, t);
    if (r !== void 0) return [...r, e.right.hash];
    const n = Fg(e.right, t);
    if (n !== void 0) return [...n, e.left.hash];
  } else if (de(e.hash, t) === 0)
    return [];
}
function Xa(e) {
  const t = e.version || zP;
  return Ly(
    "TapLeaf",
    yr([Uint8Array.from([t]), loe(e.output)])
  );
}
function coe(e, t) {
  return Ly(
    "TapTweak",
    yr(t ? [e, t] : [e])
  );
}
function Z0(e, t) {
  if (!(e instanceof Uint8Array) || e.length !== 32 || t && t.length !== 32) return null;
  const r = coe(e, t), n = Uv().xOnlyPointAddTweak(e, r);
  return !n || n.xOnlyPubkey === null ? null : {
    parity: n.parity,
    x: Uint8Array.from(n.xOnlyPubkey)
  };
}
function jv(e, t) {
  return Ly("TapBranch", yr([e, t]));
}
function loe(e) {
  const t = Xo(e.length), r = new Uint8Array(t);
  return Lu(e.length, r), yr([r, e]);
}
const j7 = Lt, L7 = 1, foe = 80;
function qp(e, t) {
  if (!e.address && !e.output && !e.pubkey && !e.internalPubkey && !(e.witness && e.witness.length > 1))
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), lr(
    ju(
      Rr({
        address: yl(),
        input: Zr(0),
        network: Rr({}),
        output: Zr(34),
        internalPubkey: Zr(32),
        hash: Zr(32),
        // merkle root hash, the tweak
        pubkey: Zr(32),
        // tweaked with `hash` from `internalPubkey`
        signature: A5([
          Zr(64),
          Zr(65)
        ]),
        witness: to(zt),
        scriptTree: Ii(EP, "Taptree is not of type isTaptree"),
        redeem: ju(
          Rr({
            output: zt,
            // tapleaf script
            redeemVersion: Wn(),
            // tapleaf version
            witness: to(zt)
          })
        ),
        redeemVersion: Wn()
      })
    ),
    e
  );
  const r = Zo(() => R5(e.address)), n = Zo(() => {
    if (!(!e.witness || !e.witness.length))
      return e.witness.length >= 2 && e.witness[e.witness.length - 1][0] === foe ? e.witness.slice(0, -1) : e.witness.slice();
  }), o = Zo(() => {
    if (e.scriptTree) return zv(e.scriptTree);
    if (e.hash) return { hash: e.hash };
  }), a = e.network || Ui, i = { name: "p2tr", network: a };
  if (Le(i, "address", () => {
    if (!i.pubkey) return;
    const s = qh.toWords(i.pubkey);
    return s.unshift(L7), qh.encode(a.bech32, s);
  }), Le(i, "hash", () => {
    const s = o();
    if (s) return s.hash;
    const u = n();
    if (u && u.length > 1) {
      const l = u[u.length - 1], c = l[0] & P1, f = u[u.length - 2], h = Xa({ output: f, version: c });
      return Rv(l, h);
    }
    return null;
  }), Le(i, "output", () => {
    if (i.pubkey)
      return ro([j7.OP_1, i.pubkey]);
  }), Le(i, "redeemVersion", () => e.redeemVersion ? e.redeemVersion : e.redeem && e.redeem.redeemVersion !== void 0 && e.redeem.redeemVersion !== null ? e.redeem.redeemVersion : zP), Le(i, "redeem", () => {
    const s = n();
    if (!(!s || s.length < 2))
      return {
        output: s[s.length - 2],
        witness: s.slice(0, -2),
        redeemVersion: s[s.length - 1][0] & P1
      };
  }), Le(i, "pubkey", () => {
    if (e.pubkey) return e.pubkey;
    if (e.output) return e.output.slice(2);
    if (e.address) return r().data;
    if (i.internalPubkey) {
      const s = Z0(i.internalPubkey, i.hash);
      if (s) return s.x;
    }
  }), Le(i, "internalPubkey", () => {
    if (e.internalPubkey) return e.internalPubkey;
    const s = n();
    if (s && s.length > 1)
      return s[s.length - 1].slice(1, 33);
  }), Le(i, "signature", () => {
    if (e.signature) return e.signature;
    const s = n();
    if (!(!s || s.length !== 1))
      return s[0];
  }), Le(i, "witness", () => {
    if (e.witness) return e.witness;
    const s = o();
    if (s && e.redeem && e.redeem.output && e.internalPubkey) {
      const u = Xa({
        output: e.redeem.output,
        version: i.redeemVersion
      }), l = Fg(s, u);
      if (!l) return;
      const c = Z0(e.internalPubkey, s.hash);
      if (!c) return;
      const f = yr(
        [
          Uint8Array.from([i.redeemVersion | c.parity]),
          e.internalPubkey
        ].concat(l)
      );
      return [e.redeem.output, f];
    }
    if (e.signature) return [e.signature];
  }), t.validate) {
    let s = Uint8Array.from([]);
    if (e.address) {
      if (a && a.bech32 !== r().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== L7)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 32)
        throw new TypeError("Invalid address data");
      s = r().data;
    }
    if (e.pubkey) {
      if (s.length > 0 && de(s, e.pubkey) !== 0)
        throw new TypeError("Pubkey mismatch");
      s = e.pubkey;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== j7.OP_1 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      if (s.length > 0 && de(s, e.output.slice(2)) !== 0)
        throw new TypeError("Pubkey mismatch");
      s = e.output.slice(2);
    }
    if (e.internalPubkey) {
      const c = Z0(e.internalPubkey, i.hash);
      if (s.length > 0 && de(s, c.x) !== 0)
        throw new TypeError("Pubkey mismatch");
      s = c.x;
    }
    if (s && s.length && !Uv().isXOnlyPoint(s))
      throw new TypeError("Invalid pubkey for p2tr");
    const u = o();
    if (e.hash && u && de(e.hash, u.hash) !== 0)
      throw new TypeError("Hash mismatch");
    if (e.redeem && e.redeem.output && u) {
      const c = Xa({
        output: e.redeem.output,
        version: i.redeemVersion
      });
      if (!Fg(u, c))
        throw new TypeError("Redeem script not in tree");
    }
    const l = n();
    if (e.redeem && i.redeem) {
      if (e.redeem.redeemVersion && e.redeem.redeemVersion !== i.redeem.redeemVersion)
        throw new TypeError("Redeem.redeemVersion and witness mismatch");
      if (e.redeem.output) {
        if (dr(e.redeem.output).length === 0)
          throw new TypeError("Redeem.output is invalid");
        if (i.redeem.output && de(e.redeem.output, i.redeem.output) !== 0)
          throw new TypeError("Redeem.output and witness mismatch");
      }
      if (e.redeem.witness && i.redeem.witness && !Mh(e.redeem.witness, i.redeem.witness))
        throw new TypeError("Redeem.witness and witness mismatch");
    }
    if (l && l.length)
      if (l.length === 1) {
        if (e.signature && de(e.signature, l[0]) !== 0)
          throw new TypeError("Signature mismatch");
      } else {
        const c = l[l.length - 1];
        if (c.length < 33)
          throw new TypeError(
            `The control-block length is too small. Got ${c.length}, expected min 33.`
          );
        if ((c.length - 33) % 32 !== 0)
          throw new TypeError(
            `The control-block length of ${c.length} is incorrect!`
          );
        const f = (c.length - 33) / 32;
        if (f > 128)
          throw new TypeError(
            `The script path is too long. Got ${f}, expected max 128.`
          );
        const h = c.slice(1, 33);
        if (e.internalPubkey && de(e.internalPubkey, h) !== 0)
          throw new TypeError("Internal pubkey mismatch");
        if (!Uv().isXOnlyPoint(h))
          throw new TypeError("Invalid internalPubkey for p2tr witness");
        const p = c[0] & P1, y = l[l.length - 2], m = Xa({ output: y, version: p }), b = Rv(c, m), v = Z0(h, b);
        if (!v)
          throw new TypeError("Invalid outputKey for p2tr witness");
        if (s.length && de(s, v.x) !== 0)
          throw new TypeError("Pubkey mismatch for p2tr witness");
        if (v.parity !== (c[0] & 1))
          throw new Error("Incorrect parity");
      }
  }
  return Object.assign(i, e);
}
const jP = 40, LP = 2, HP = 16, FP = 2, DP = 80, MP = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
function doe(e, t) {
  const r = e.slice(2);
  if (r.length < LP || r.length > jP)
    throw new TypeError("Invalid program length for segwit address");
  const n = e[0] - DP;
  if (n < FP || n > HP)
    throw new TypeError("Invalid version for segwit address");
  if (e[1] !== r.length)
    throw new TypeError("Invalid script for segwit address");
  return console.warn(MP), hoe(r, n, t.bech32);
}
function KP(e) {
  const t = Cf.decode(e);
  if (t.length < 21) throw new TypeError(e + " is too short");
  if (t.length > 21) throw new TypeError(e + " is too long");
  const r = us(t, 0), n = t.slice(1);
  return { version: r, hash: n };
}
function R5(e) {
  let t, r;
  try {
    t = ko.decode(e);
  } catch {
  }
  if (t) {
    if (r = t.words[0], r !== 0) throw new TypeError(e + " uses wrong encoding");
  } else if (t = qh.decode(e), r = t.words[0], r === 0) throw new TypeError(e + " uses wrong encoding");
  const n = ko.fromWords(t.words.slice(1));
  return {
    version: r,
    prefix: t.prefix,
    data: Uint8Array.from(n)
  };
}
function hoe(e, t, r) {
  const n = ko.toWords(e);
  return n.unshift(t), t === 0 ? ko.encode(r, n) : qh.encode(r, n);
}
function Vp(e, t) {
  t = t || Ui;
  try {
    return Dp({ output: e, network: t }).address;
  } catch {
  }
  try {
    return dd({ output: e, network: t }).address;
  } catch {
  }
  try {
    return Mp({ output: e, network: t }).address;
  } catch {
  }
  try {
    return Kp({ output: e, network: t }).address;
  } catch {
  }
  try {
    return qp({ output: e, network: t }).address;
  } catch {
  }
  try {
    return doe(e, t);
  } catch {
  }
  throw new Error(gne(e) + " has no matching Address");
}
function Gp(e, t) {
  t = t || Ui;
  let r, n;
  try {
    r = KP(e);
  } catch {
  }
  if (r) {
    if (r.version === t.pubKeyHash)
      return Dp({ hash: r.hash }).output;
    if (r.version === t.scriptHash)
      return dd({ hash: r.hash }).output;
  } else {
    try {
      n = R5(e);
    } catch {
    }
    if (n) {
      if (n.prefix !== t.bech32)
        throw new Error(e + " has an invalid prefix");
      if (n.version === 0) {
        if (n.data.length === 20)
          return Mp({ hash: n.data }).output;
        if (n.data.length === 32)
          return Kp({ hash: n.data }).output;
      } else if (n.version === 1) {
        if (n.data.length === 32)
          return qp({ pubkey: n.data }).output;
      } else if (n.version >= FP && n.version <= HP && n.data.length >= LP && n.data.length <= jP)
        return console.warn(MP), ro([
          n.version + DP,
          n.data
        ]);
    }
  }
  throw new Error(e + " has no matching Script");
}
function ea(e) {
  const t = e.length;
  return Xo(t) + t;
}
function poe(e) {
  const t = e.length;
  return Xo(t) + e.reduce((r, n) => r + ea(n), 0);
}
const bu = new Uint8Array(0), H7 = [], z2 = ys(
  "0000000000000000000000000000000000000000000000000000000000000000"
), F7 = ys(
  "0000000000000000000000000000000000000000000000000000000000000001"
), goe = ys("ffffffffffffffff"), moe = {
  script: bu,
  valueBuffer: goe
};
function yoe(e) {
  return e.value !== void 0;
}
const oi = class Vt {
  constructor() {
    xe(this, "version", 1), xe(this, "locktime", 0), xe(this, "ins", []), xe(this, "outs", []);
  }
  static fromBuffer(t, r) {
    const n = new aoe(t), o = new Vt();
    o.version = n.readInt32();
    const a = n.readUInt8(), i = n.readUInt8();
    let s = !1;
    a === Vt.ADVANCED_TRANSACTION_MARKER && i === Vt.ADVANCED_TRANSACTION_FLAG ? s = !0 : n.offset -= 2;
    const u = n.readVarInt();
    for (let c = 0; c < u; ++c)
      o.ins.push({
        hash: n.readSlice(32),
        index: n.readUInt32(),
        script: n.readVarSlice(),
        sequence: n.readUInt32(),
        witness: H7
      });
    const l = n.readVarInt();
    for (let c = 0; c < l; ++c)
      o.outs.push({
        value: n.readInt64(),
        script: n.readVarSlice()
      });
    if (s) {
      for (let c = 0; c < u; ++c)
        o.ins[c].witness = n.readVector();
      if (!o.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (o.locktime = n.readUInt32(), r) return o;
    if (n.offset !== t.length)
      throw new Error("Transaction has unexpected data");
    return o;
  }
  static fromHex(t) {
    return Vt.fromBuffer(ys(t), !1);
  }
  static isCoinbaseHash(t) {
    lr(A7, t);
    for (let r = 0; r < 32; ++r)
      if (t[r] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Vt.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(t, r, n, o) {
    return lr(
      ra([
        A7,
        Da,
        Nv(Rg(Da)),
        Nv(Rg(zt))
      ]),
      [t, r, n, o]
    ), n == null && (n = Vt.DEFAULT_SEQUENCE), this.ins.push({
      hash: t,
      index: r,
      script: o || bu,
      sequence: n,
      witness: H7
    }) - 1;
  }
  addOutput(t, r) {
    return lr(ra([zt, B2]), [
      t,
      r
    ]), this.outs.push({
      script: t,
      value: r
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((t) => t.witness.length !== 0);
  }
  weight() {
    const t = this.byteLength(!1), r = this.byteLength(!0);
    return t * 3 + r;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(t = !0) {
    const r = t && this.hasWitnesses();
    return (r ? 10 : 8) + Xo(this.ins.length) + Xo(this.outs.length) + this.ins.reduce((n, o) => n + 40 + ea(o.script), 0) + this.outs.reduce((n, o) => n + 8 + ea(o.script), 0) + (r ? this.ins.reduce((n, o) => n + poe(o.witness), 0) : 0);
  }
  clone() {
    const t = new Vt();
    return t.version = this.version, t.locktime = this.locktime, t.ins = this.ins.map((r) => ({
      hash: r.hash,
      index: r.index,
      script: r.script,
      sequence: r.sequence,
      witness: r.witness
    })), t.outs = this.outs.map((r) => ({
      script: r.script,
      value: r.value
    })), t;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(t, r, n) {
    if (lr(ra([Da, zt, Wn()]), [
      t,
      r,
      n
    ]), t >= this.ins.length) return F7;
    const o = ro(
      dr(r).filter((s) => s !== Lt.OP_CODESEPARATOR)
    ), a = this.clone();
    if ((n & 31) === Vt.SIGHASH_NONE)
      a.outs = [], a.ins.forEach((s, u) => {
        u !== t && (s.sequence = 0);
      });
    else if ((n & 31) === Vt.SIGHASH_SINGLE) {
      if (t >= this.outs.length) return F7;
      a.outs.length = t + 1;
      for (let s = 0; s < t; s++)
        a.outs[s] = moe;
      a.ins.forEach((s, u) => {
        u !== t && (s.sequence = 0);
      });
    }
    n & Vt.SIGHASH_ANYONECANPAY ? (a.ins = [a.ins[t]], a.ins[0].script = o) : (a.ins.forEach((s) => {
      s.script = bu;
    }), a.ins[t].script = o);
    const i = new Uint8Array(a.byteLength(!1) + 4);
    return fP(i, i.length - 4, n, "LE"), a.__toBuffer(i, 0, !1), ac(i);
  }
  hashForWitnessV1(t, r, n, o, a, i) {
    if (lr(
      ra([
        Da,
        to(zt),
        to(B2),
        Da
      ]),
      [t, r, n, o]
    ), n.length !== this.ins.length || r.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const s = o === Vt.SIGHASH_DEFAULT ? Vt.SIGHASH_ALL : o & Vt.SIGHASH_OUTPUT_MASK, u = (o & Vt.SIGHASH_INPUT_MASK) === Vt.SIGHASH_ANYONECANPAY, l = s === Vt.SIGHASH_NONE, c = s === Vt.SIGHASH_SINGLE;
    let f = bu, h = bu, p = bu, y = bu, m = bu;
    if (!u) {
      let E = bn.withCapacity(36 * this.ins.length);
      this.ins.forEach((A) => {
        E.writeSlice(A.hash), E.writeUInt32(A.index);
      }), f = tn(E.end()), E = bn.withCapacity(8 * this.ins.length), n.forEach((A) => E.writeInt64(A)), h = tn(E.end()), E = bn.withCapacity(
        r.map(ea).reduce((A, S) => A + S)
      ), r.forEach(
        (A) => E.writeVarSlice(A)
      ), p = tn(E.end()), E = bn.withCapacity(4 * this.ins.length), this.ins.forEach((A) => E.writeUInt32(A.sequence)), y = tn(E.end());
    }
    if (l || c) {
      if (c && t < this.outs.length) {
        const E = this.outs[t], A = bn.withCapacity(
          8 + ea(E.script)
        );
        A.writeInt64(E.value), A.writeVarSlice(E.script), m = tn(A.end());
      }
    } else {
      if (!this.outs.length)
        throw new Error("Add outputs to the transaction before signing.");
      const E = this.outs.map((S) => 8 + ea(S.script)).reduce((S, _) => S + _), A = bn.withCapacity(E);
      this.outs.forEach((S) => {
        A.writeInt64(S.value), A.writeVarSlice(S.script);
      }), m = tn(A.end());
    }
    const b = (a ? 2 : 0) + (i ? 1 : 0), v = 174 - (u ? 49 : 0) - (l ? 32 : 0) + (i ? 32 : 0) + (a ? 37 : 0), k = bn.withCapacity(v);
    if (k.writeUInt8(o), k.writeInt32(this.version), k.writeUInt32(this.locktime), k.writeSlice(f), k.writeSlice(h), k.writeSlice(p), k.writeSlice(y), l || c || k.writeSlice(m), k.writeUInt8(b), u) {
      const E = this.ins[t];
      k.writeSlice(E.hash), k.writeUInt32(E.index), k.writeInt64(n[t]), k.writeVarSlice(r[t]), k.writeUInt32(E.sequence);
    } else
      k.writeUInt32(t);
    if (i) {
      const E = bn.withCapacity(ea(i));
      E.writeVarSlice(i), k.writeSlice(tn(E.end()));
    }
    return c && k.writeSlice(m), a && (k.writeSlice(a), k.writeUInt8(0), k.writeUInt32(4294967295)), Ly(
      "TapSighash",
      yr([Uint8Array.from([0]), k.end()])
    );
  }
  hashForWitnessV0(t, r, n, o) {
    lr(
      ra([
        Da,
        zt,
        B2,
        Da
      ]),
      [t, r, n, o]
    );
    let a = Uint8Array.from([]), i, s = z2, u = z2, l = z2;
    if (o & Vt.SIGHASH_ANYONECANPAY || (a = new Uint8Array(36 * this.ins.length), i = new bn(a, 0), this.ins.forEach((f) => {
      i.writeSlice(f.hash), i.writeUInt32(f.index);
    }), u = ac(a)), !(o & Vt.SIGHASH_ANYONECANPAY) && (o & 31) !== Vt.SIGHASH_SINGLE && (o & 31) !== Vt.SIGHASH_NONE && (a = new Uint8Array(4 * this.ins.length), i = new bn(a, 0), this.ins.forEach((f) => {
      i.writeUInt32(f.sequence);
    }), l = ac(a)), (o & 31) !== Vt.SIGHASH_SINGLE && (o & 31) !== Vt.SIGHASH_NONE) {
      const f = this.outs.reduce((h, p) => h + 8 + ea(p.script), 0);
      a = new Uint8Array(f), i = new bn(a, 0), this.outs.forEach((h) => {
        i.writeInt64(h.value), i.writeVarSlice(h.script);
      }), s = ac(a);
    } else if ((o & 31) === Vt.SIGHASH_SINGLE && t < this.outs.length) {
      const f = this.outs[t];
      a = new Uint8Array(8 + ea(f.script)), i = new bn(a, 0), i.writeInt64(f.value), i.writeVarSlice(f.script), s = ac(a);
    }
    a = new Uint8Array(156 + ea(r)), i = new bn(a, 0);
    const c = this.ins[t];
    return i.writeInt32(this.version), i.writeSlice(u), i.writeSlice(l), i.writeSlice(c.hash), i.writeUInt32(c.index), i.writeVarSlice(r), i.writeInt64(n), i.writeUInt32(c.sequence), i.writeSlice(s), i.writeUInt32(this.locktime), i.writeUInt32(o), ac(a);
  }
  getHash(t) {
    return t && this.isCoinbase() ? new Uint8Array(32) : ac(this.__toBuffer(void 0, void 0, t));
  }
  getId() {
    return Ve(U5(this.getHash(!1)));
  }
  toBuffer(t, r) {
    return this.__toBuffer(t, r, !0);
  }
  toHex() {
    return Ve(this.toBuffer(void 0, void 0));
  }
  setInputScript(t, r) {
    lr(ra([Wn(), zt]), [t, r]), this.ins[t].script = r;
  }
  setWitness(t, r) {
    lr(ra([Wn(), to(zt)]), [
      t,
      r
    ]), this.ins[t].witness = r;
  }
  __toBuffer(t, r, n = !1) {
    t || (t = new Uint8Array(this.byteLength(n)));
    const o = new bn(t, r || 0);
    o.writeInt32(this.version);
    const a = n && this.hasWitnesses();
    return a && (o.writeUInt8(Vt.ADVANCED_TRANSACTION_MARKER), o.writeUInt8(Vt.ADVANCED_TRANSACTION_FLAG)), o.writeVarInt(this.ins.length), this.ins.forEach((i) => {
      o.writeSlice(i.hash), o.writeUInt32(i.index), o.writeVarSlice(i.script), o.writeUInt32(i.sequence);
    }), o.writeVarInt(this.outs.length), this.outs.forEach((i) => {
      yoe(i) ? o.writeInt64(i.value) : o.writeSlice(i.valueBuffer), o.writeVarSlice(i.script);
    }), a && this.ins.forEach((i) => {
      o.writeVector(i.witness);
    }), o.writeUInt32(this.locktime), r !== void 0 ? t.slice(r, o.offset) : t;
  }
};
xe(oi, "DEFAULT_SEQUENCE", 4294967295), xe(oi, "SIGHASH_DEFAULT", 0), xe(oi, "SIGHASH_ALL", 1), xe(oi, "SIGHASH_NONE", 2), xe(oi, "SIGHASH_SINGLE", 3), xe(oi, "SIGHASH_ANYONECANPAY", 128), xe(oi, "SIGHASH_OUTPUT_MASK", 3), xe(oi, "SIGHASH_INPUT_MASK", 128), xe(oi, "ADVANCED_TRANSACTION_MARKER", 0), xe(oi, "ADVANCED_TRANSACTION_FLAG", 1);
let Ir = oi;
var la;
(function(e) {
  e[e.UNSIGNED_TX = 0] = "UNSIGNED_TX", e[e.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
})(la || (la = {}));
var _e;
(function(e) {
  e[e.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", e[e.WITNESS_UTXO = 1] = "WITNESS_UTXO", e[e.PARTIAL_SIG = 2] = "PARTIAL_SIG", e[e.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", e[e.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", e[e.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", e[e.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", e[e.POR_COMMITMENT = 9] = "POR_COMMITMENT", e[e.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", e[e.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", e[e.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", e[e.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", e[e.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
})(_e || (_e = {}));
var Sr;
(function(e) {
  e[e.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", e[e.TAP_TREE = 6] = "TAP_TREE", e[e.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
})(Sr || (Sr = {}));
const boe = (e) => [...Array(e).keys()];
function woe(e) {
  if (e.key[0] !== la.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + Ve(e.key)
    );
  if (e.key.length !== 79 || ![2, 3].includes(e.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + Ve(e.key)
    );
  if (e.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const t = e.key.slice(1), r = {
    masterFingerprint: e.value.slice(0, 4),
    extendedPubkey: t,
    path: "m"
  };
  for (const n of boe(e.value.length / 4 - 1)) {
    const o = ld(e.value, n * 4 + 4, "LE"), a = !!(o & 2147483648), i = o & 2147483647;
    r.path += "/" + i.toString(10) + (a ? "'" : "");
  }
  return r;
}
function voe(e) {
  const t = new Uint8Array([la.GLOBAL_XPUB]), r = yr([t, e.extendedPubkey]), n = e.path.split("/"), o = new Uint8Array(n.length * 4);
  o.set(e.masterFingerprint, 0);
  let a = 4;
  return n.slice(1).forEach((i) => {
    const s = i.slice(-1) === "'";
    let u = 2147483647 & parseInt(s ? i.slice(0, -1) : i, 10);
    s && (u += 2147483648), Fp(o, a, u, "LE"), a += 4;
  }), {
    key: r,
    value: o
  };
}
const Eoe = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function koe(e) {
  const t = e.extendedPubkey, r = e.masterFingerprint, n = e.path;
  return t instanceof Uint8Array && t.length === 78 && [2, 3].indexOf(t[45]) > -1 && r instanceof Uint8Array && r.length === 4 && typeof n == "string" && !!n.match(/^m(\/\d+'?)*$/);
}
function xoe(e, t, r) {
  const n = Ve(t.extendedPubkey);
  return r.has(n) ? !1 : (r.add(n), e.filter((o) => de(o.extendedPubkey, t.extendedPubkey)).length === 0);
}
const Aoe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: xoe,
  check: koe,
  decode: woe,
  encode: voe,
  expected: Eoe
}, Symbol.toStringTag, { value: "Module" }));
function Soe(e) {
  return {
    key: new Uint8Array([la.UNSIGNED_TX]),
    value: e.toBuffer()
  };
}
const _oe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  encode: Soe
}, Symbol.toStringTag, { value: "Module" }));
function Ioe(e) {
  if (e.key[0] !== _e.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + Ve(e.key)
    );
  return e.value;
}
function Toe(e) {
  return {
    key: new Uint8Array([_e.FINAL_SCRIPTSIG]),
    value: e
  };
}
const Poe = "Uint8Array";
function Ooe(e) {
  return e instanceof Uint8Array;
}
function $oe(e, t) {
  return !!e && !!t && e.finalScriptSig === void 0;
}
const Coe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: $oe,
  check: Ooe,
  decode: Ioe,
  encode: Toe,
  expected: Poe
}, Symbol.toStringTag, { value: "Module" }));
function Boe(e) {
  if (e.key[0] !== _e.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + Ve(e.key)
    );
  return e.value;
}
function Noe(e) {
  return {
    key: new Uint8Array([_e.FINAL_SCRIPTWITNESS]),
    value: e
  };
}
const Uoe = "Uint8Array";
function Roe(e) {
  return e instanceof Uint8Array;
}
function zoe(e, t) {
  return !!e && !!t && e.finalScriptWitness === void 0;
}
const joe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: zoe,
  check: Roe,
  decode: Boe,
  encode: Noe,
  expected: Uoe
}, Symbol.toStringTag, { value: "Module" }));
function Loe(e) {
  if (e.key[0] !== _e.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + Ve(e.key)
    );
  return e.value;
}
function Hoe(e) {
  return {
    key: new Uint8Array([_e.NON_WITNESS_UTXO]),
    value: e
  };
}
const Foe = "Uint8Array";
function Doe(e) {
  return e instanceof Uint8Array;
}
function Moe(e, t) {
  return !!e && !!t && e.nonWitnessUtxo === void 0;
}
const Koe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Moe,
  check: Doe,
  decode: Loe,
  encode: Hoe,
  expected: Foe
}, Symbol.toStringTag, { value: "Module" }));
function qoe(e) {
  if (e.key[0] !== _e.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + Ve(e.key)
    );
  if (!(e.key.length === 34 || e.key.length === 66) || ![2, 3, 4].includes(e.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + Ve(e.key)
    );
  return {
    pubkey: e.key.slice(1),
    signature: e.value
  };
}
function Voe(e) {
  const t = new Uint8Array([_e.PARTIAL_SIG]);
  return {
    key: yr([t, e.pubkey]),
    value: e.signature
  };
}
const Goe = "{ pubkey: Uint8Array; signature: Uint8Array; }";
function Zoe(e) {
  return e.pubkey instanceof Uint8Array && e.signature instanceof Uint8Array && [33, 65].includes(e.pubkey.length) && [2, 3, 4].includes(e.pubkey[0]) && Woe(e.signature);
}
function Woe(e) {
  if (!(e instanceof Uint8Array) || e.length < 9 || e[0] !== 48 || e.length !== e[1] + 3 || e[2] !== 2) return !1;
  const t = e[3];
  if (t > 33 || t < 1 || e[3 + t + 1] !== 2) return !1;
  const r = e[3 + t + 2];
  return !(r > 33 || r < 1 || e.length !== 3 + t + 2 + r + 2);
}
function Xoe(e, t, r) {
  const n = Ve(t.pubkey);
  return r.has(n) ? !1 : (r.add(n), e.filter((o) => de(o.pubkey, t.pubkey) === 0).length === 0);
}
const Yoe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: Xoe,
  check: Zoe,
  decode: qoe,
  encode: Voe,
  expected: Goe
}, Symbol.toStringTag, { value: "Module" }));
function Joe(e) {
  if (e.key[0] !== _e.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + Ve(e.key)
    );
  return Kre(e.value);
}
function Qoe(e) {
  return {
    key: new Uint8Array([_e.POR_COMMITMENT]),
    value: qre(e)
  };
}
const eie = "string";
function tie(e) {
  return typeof e == "string";
}
function rie(e, t) {
  return !!e && !!t && e.porCommitment === void 0;
}
const nie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: rie,
  check: tie,
  decode: Joe,
  encode: Qoe,
  expected: eie
}, Symbol.toStringTag, { value: "Module" }));
function oie(e) {
  if (e.key[0] !== _e.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + Ve(e.key)
    );
  return Number(ld(e.value, 0, "LE"));
}
function iie(e) {
  const t = Uint8Array.from([_e.SIGHASH_TYPE]), r = new Uint8Array(4);
  return Fp(r, 0, e, "LE"), {
    key: t,
    value: r
  };
}
const aie = "number";
function sie(e) {
  return typeof e == "number";
}
function uie(e, t) {
  return !!e && !!t && e.sighashType === void 0;
}
const cie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: uie,
  check: sie,
  decode: oie,
  encode: iie,
  expected: aie
}, Symbol.toStringTag, { value: "Module" }));
function lie(e) {
  if (e.key[0] !== _e.TAP_KEY_SIG || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + Ve(e.key)
    );
  if (!qP(e.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return e.value;
}
function fie(e) {
  return { key: Uint8Array.from([_e.TAP_KEY_SIG]), value: e };
}
const die = "Uint8Array";
function qP(e) {
  return e instanceof Uint8Array && (e.length === 64 || e.length === 65);
}
function hie(e, t) {
  return !!e && !!t && e.tapKeySig === void 0;
}
const pie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: hie,
  check: qP,
  decode: lie,
  encode: fie,
  expected: die
}, Symbol.toStringTag, { value: "Module" }));
function gie(e) {
  if (e.key[0] !== _e.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + Ve(e.key)
    );
  if ((e.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + Ve(e.key)
    );
  const t = e.value[e.value.length - 1];
  if ((e.key[1] & 254) !== t)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + Ve(e.key)
    );
  const r = e.value.slice(0, -1);
  return { controlBlock: e.key.slice(1), script: r, leafVersion: t };
}
function mie(e) {
  const t = Uint8Array.from([_e.TAP_LEAF_SCRIPT]), r = Uint8Array.from([e.leafVersion]);
  return {
    key: yr([t, e.controlBlock]),
    value: yr([e.script, r])
  };
}
const yie = "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }";
function bie(e) {
  return e.controlBlock instanceof Uint8Array && (e.controlBlock.length - 1) % 32 === 0 && (e.controlBlock[0] & 254) === e.leafVersion && e.script instanceof Uint8Array;
}
function wie(e, t, r) {
  const n = Ve(t.controlBlock);
  return r.has(n) ? !1 : (r.add(n), e.filter((o) => de(o.controlBlock, t.controlBlock) === 0).length === 0);
}
const vie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: wie,
  check: bie,
  decode: gie,
  encode: mie,
  expected: yie
}, Symbol.toStringTag, { value: "Module" }));
function Eie(e) {
  if (e.key[0] !== _e.TAP_MERKLE_ROOT || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + Ve(e.key)
    );
  if (!VP(e.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return e.value;
}
function kie(e) {
  return { key: Uint8Array.from([_e.TAP_MERKLE_ROOT]), value: e };
}
const xie = "Uint8Array";
function VP(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function Aie(e, t) {
  return !!e && !!t && e.tapMerkleRoot === void 0;
}
const Sie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Aie,
  check: VP,
  decode: Eie,
  encode: kie,
  expected: xie
}, Symbol.toStringTag, { value: "Module" }));
function _ie(e) {
  if (e.key[0] !== _e.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + Ve(e.key)
    );
  if (e.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + Ve(e.key)
    );
  if (e.value.length !== 64 && e.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + Ve(e.key)
    );
  const t = e.key.slice(1, 33), r = e.key.slice(33);
  return {
    pubkey: t,
    leafHash: r,
    signature: e.value
  };
}
function Iie(e) {
  const t = Uint8Array.from([_e.TAP_SCRIPT_SIG]);
  return {
    key: yr([t, e.pubkey, e.leafHash]),
    value: e.signature
  };
}
const Tie = "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }";
function Pie(e) {
  return e.pubkey instanceof Uint8Array && e.leafHash instanceof Uint8Array && e.signature instanceof Uint8Array && e.pubkey.length === 32 && e.leafHash.length === 32 && (e.signature.length === 64 || e.signature.length === 65);
}
function Oie(e, t, r) {
  const n = Ve(t.pubkey) + Ve(t.leafHash);
  return r.has(n) ? !1 : (r.add(n), e.filter(
    (o) => de(o.pubkey, t.pubkey) === 0 && de(o.leafHash, t.leafHash) === 0
  ).length === 0);
}
const $ie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: Oie,
  check: Pie,
  decode: _ie,
  encode: Iie,
  expected: Tie
}, Symbol.toStringTag, { value: "Module" }));
function Cie(e) {
  if (e.key[0] !== _e.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + Ve(e.key)
    );
  const t = hP(e.value, 0, "LE");
  let r = 8;
  const { numberValue: n, bytes: o } = hd(
    e.value,
    r
  );
  r += o;
  const a = e.value.slice(r);
  if (a.length !== n)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: a,
    value: t
  };
}
function Bie(e) {
  const { script: t, value: r } = e, n = Xo(t.length), o = new Uint8Array(8 + n + t.length);
  return dP(o, 0, BigInt(r), "LE"), Lu(t.length, o, 8), o.set(t, 8 + n), {
    key: Uint8Array.from([_e.WITNESS_UTXO]),
    value: o
  };
}
const Nie = "{ script: Uint8Array; value: bigint; }";
function Uie(e) {
  return e.script instanceof Uint8Array && typeof e.value == "bigint";
}
function Rie(e, t) {
  return !!e && !!t && e.witnessUtxo === void 0;
}
const zie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Rie,
  check: Uie,
  decode: Cie,
  encode: Bie,
  expected: Nie
}, Symbol.toStringTag, { value: "Module" }));
function jie(e) {
  if (e.key[0] !== Sr.TAP_TREE || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + Ve(e.key)
    );
  let t = 0;
  const r = [];
  for (; t < e.value.length; ) {
    const n = e.value[t++], o = e.value[t++], { numberValue: a, bytes: i } = hd(
      e.value,
      t
    );
    t += i, r.push({
      depth: n,
      leafVersion: o,
      script: e.value.slice(t, t + a)
    }), t += a;
  }
  return { leaves: r };
}
function Lie(e) {
  const t = Uint8Array.from([Sr.TAP_TREE]), r = [].concat(
    ...e.leaves.map((n) => [
      Uint8Array.of(n.depth, n.leafVersion),
      Lu(BigInt(n.script.length)).buffer,
      n.script
    ])
  );
  return {
    key: t,
    value: yr(r)
  };
}
const Hie = "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }";
function Fie(e) {
  return Array.isArray(e.leaves) && e.leaves.every(
    (t) => t.depth >= 0 && t.depth <= 128 && (t.leafVersion & 254) === t.leafVersion && t.script instanceof Uint8Array
  );
}
function Die(e, t) {
  return !!e && !!t && e.tapTree === void 0;
}
const Mie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Die,
  check: Fie,
  decode: jie,
  encode: Lie,
  expected: Hie
}, Symbol.toStringTag, { value: "Module" })), Kie = (e) => [...Array(e).keys()], qie = (e) => e.length === 33 && [2, 3].includes(e[0]) || e.length === 65 && e[0] === 4;
function z5(e, t = qie) {
  function r(s) {
    if (s.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + Ve(s.key)
      );
    const u = s.key.slice(1);
    if (!t(u))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + Ve(s.key)
      );
    if (s.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const l = {
      masterFingerprint: s.value.slice(0, 4),
      pubkey: u,
      path: "m"
    };
    for (const c of Kie(s.value.length / 4 - 1)) {
      const f = ld(s.value, c * 4 + 4, "LE"), h = !!(f & 2147483648), p = f & 2147483647;
      l.path += "/" + p.toString(10) + (h ? "'" : "");
    }
    return l;
  }
  function n(s) {
    const u = Uint8Array.from([e]), l = yr([u, s.pubkey]), c = s.path.split("/"), f = new Uint8Array(c.length * 4);
    f.set(s.masterFingerprint, 0);
    let h = 4;
    return c.slice(1).forEach((p) => {
      const y = p.slice(-1) === "'";
      let m = 2147483647 & parseInt(y ? p.slice(0, -1) : p, 10);
      y && (m += 2147483648), Fp(f, h, m, "LE"), h += 4;
    }), {
      key: l,
      value: f
    };
  }
  const o = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }";
  function a(s) {
    return s.pubkey instanceof Uint8Array && s.masterFingerprint instanceof Uint8Array && typeof s.path == "string" && t(s.pubkey) && s.masterFingerprint.length === 4;
  }
  function i(s, u, l) {
    const c = Ve(u.pubkey);
    return l.has(c) ? !1 : (l.add(c), s.filter((f) => de(f.pubkey, u.pubkey) === 0).length === 0);
  }
  return {
    decode: r,
    encode: n,
    check: a,
    expected: o,
    canAddToArray: i
  };
}
function j5(e) {
  return t;
  function t(r) {
    let n;
    if (e.includes(r.key[0]) && (n = r.key.slice(1), !(n.length === 33 || n.length === 65) || ![2, 3, 4].includes(n[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + Ve(r.key)
      );
    return n;
  }
}
function GP(e) {
  function t(i) {
    if (i.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + Ve(i.key)
      );
    return i.value;
  }
  function r(i) {
    return {
      key: Uint8Array.from([e]),
      value: i
    };
  }
  const n = "Uint8Array";
  function o(i) {
    return i instanceof Uint8Array;
  }
  function a(i, s) {
    return !!i && !!s && i.redeemScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: o,
    expected: n,
    canAdd: a
  };
}
const Vie = (e) => e.length === 32;
function ZP(e) {
  const t = z5(e, Vie);
  function r(i) {
    const { numberValue: s, bytes: u } = hd(
      i.value
    ), l = t.decode({
      key: i.key,
      value: i.value.slice(u + Number(s) * 32)
    }), c = new Array(Number(s));
    for (let f = 0, h = u; f < s; f++, h += 32)
      c[f] = i.value.slice(h, h + 32);
    return { ...l, leafHashes: c };
  }
  function n(i) {
    const s = t.encode(i), u = Xo(i.leafHashes.length), l = new Uint8Array(u);
    Lu(i.leafHashes.length, l);
    const c = yr([l, ...i.leafHashes, s.value]);
    return { ...s, value: c };
  }
  const o = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }";
  function a(i) {
    return Array.isArray(i.leafHashes) && i.leafHashes.every(
      (s) => s instanceof Uint8Array && s.length === 32
    ) && t.check(i);
  }
  return {
    decode: r,
    encode: n,
    check: a,
    expected: o,
    canAddToArray: t.canAddToArray
  };
}
function WP(e) {
  function t(i) {
    if (i.key[0] !== e || i.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + Ve(i.key)
      );
    if (i.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return i.value;
  }
  function r(i) {
    return { key: Uint8Array.from([e]), value: i };
  }
  const n = "Uint8Array";
  function o(i) {
    return i instanceof Uint8Array && i.length === 32;
  }
  function a(i, s) {
    return !!i && !!s && i.tapInternalKey === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: o,
    expected: n,
    canAdd: a
  };
}
function XP(e) {
  function t(i) {
    if (i.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + Ve(i.key)
      );
    return i.value;
  }
  function r(i) {
    return {
      key: Uint8Array.from([e]),
      value: i
    };
  }
  const n = "Uint8Array";
  function o(i) {
    return i instanceof Uint8Array;
  }
  function a(i, s) {
    return !!i && !!s && i.witnessScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: o,
    expected: n,
    canAdd: a
  };
}
const L5 = {
  unsignedTx: _oe,
  globalXpub: Aoe,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: j5([])
}, Mr = {
  nonWitnessUtxo: Koe,
  partialSig: Yoe,
  sighashType: cie,
  finalScriptSig: Coe,
  finalScriptWitness: joe,
  porCommitment: nie,
  witnessUtxo: zie,
  bip32Derivation: z5(_e.BIP32_DERIVATION),
  redeemScript: GP(_e.REDEEM_SCRIPT),
  witnessScript: XP(_e.WITNESS_SCRIPT),
  checkPubkey: j5([
    _e.PARTIAL_SIG,
    _e.BIP32_DERIVATION
  ]),
  tapKeySig: pie,
  tapScriptSig: $ie,
  tapLeafScript: vie,
  tapBip32Derivation: ZP(
    _e.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: WP(_e.TAP_INTERNAL_KEY),
  tapMerkleRoot: Sie
}, Ma = {
  bip32Derivation: z5(Sr.BIP32_DERIVATION),
  redeemScript: GP(Sr.REDEEM_SCRIPT),
  witnessScript: XP(Sr.WITNESS_SCRIPT),
  checkPubkey: j5([Sr.BIP32_DERIVATION]),
  tapBip32Derivation: ZP(
    Sr.TAP_BIP32_DERIVATION
  ),
  tapTree: Mie,
  tapInternalKey: WP(Sr.TAP_INTERNAL_KEY)
}, Gie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  globals: L5,
  inputs: Mr,
  outputs: Ma
}, Symbol.toStringTag, { value: "Module" })), Dg = (e) => [...Array(e).keys()];
function D7(e) {
  const t = e.map(Zie);
  return t.push(Uint8Array.from([0])), yr(t);
}
function Zie(e) {
  const t = e.key.length, r = e.value.length, n = Xo(t), o = Xo(r), a = new Uint8Array(n + t + o + r);
  return Lu(t, a, 0), a.set(e.key, n), Lu(r, a, n + t), a.set(e.value, n + t + o), a;
}
function Wie(e, t) {
  let r = 0;
  function n() {
    const { numberValue: b, bytes: v } = hd(e, r);
    r += v;
    const k = e.slice(r, r + Number(b));
    return r += Number(b), k;
  }
  function o() {
    const b = ld(e, r, "BE");
    return r += 4, b;
  }
  function a() {
    const b = us(e, r);
    return r += 1, b;
  }
  function i() {
    const b = n(), v = n();
    return {
      key: b,
      value: v
    };
  }
  function s() {
    if (r >= e.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const b = us(e, r) === 0;
    return b && r++, b;
  }
  if (o() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (a() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const u = [], l = {};
  for (; !s(); ) {
    const b = i(), v = Ve(b.key);
    if (l[v])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + v
      );
    l[v] = 1, u.push(b);
  }
  const c = u.filter(
    (b) => b.key[0] === la.UNSIGNED_TX
  );
  if (c.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const f = t(c[0].value), { inputCount: h, outputCount: p } = f.getInputOutputCounts(), y = [], m = [];
  for (const b of Dg(h)) {
    const v = {}, k = [];
    for (; !s(); ) {
      const E = i(), A = Ve(E.key);
      if (v[A])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + b + " key " + A
        );
      v[A] = 1, k.push(E);
    }
    y.push(k);
  }
  for (const b of Dg(p)) {
    const v = {}, k = [];
    for (; !s(); ) {
      const E = i(), A = Ve(E.key);
      if (v[A])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + b + " key " + A
        );
      v[A] = 1, k.push(E);
    }
    m.push(k);
  }
  return YP(f, {
    globalMapKeyVals: u,
    inputKeyVals: y,
    outputKeyVals: m
  });
}
function mn(e, t, r) {
  if (de(t, Uint8Array.from([r])))
    throw new Error(
      // `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
      `Format Error: Invalid ${e} key: ${Ve(t)}`
    );
}
function YP(e, { globalMapKeyVals: t, inputKeyVals: r, outputKeyVals: n }) {
  const o = {
    unsignedTx: e
  };
  let a = 0;
  for (const c of t)
    switch (c.key[0]) {
      case la.UNSIGNED_TX:
        if (mn("global", c.key, la.UNSIGNED_TX), a > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        a++;
        break;
      case la.GLOBAL_XPUB:
        o.globalXpub === void 0 && (o.globalXpub = []), o.globalXpub.push(L5.globalXpub.decode(c));
        break;
      default:
        o.unknownKeyVals || (o.unknownKeyVals = []), o.unknownKeyVals.push(c);
    }
  const i = r.length, s = n.length, u = [], l = [];
  for (const c of Dg(i)) {
    const f = {};
    for (const h of r[c])
      switch (Mr.checkPubkey(h), h.key[0]) {
        case _e.NON_WITNESS_UTXO:
          if (mn("input", h.key, _e.NON_WITNESS_UTXO), f.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          f.nonWitnessUtxo = Mr.nonWitnessUtxo.decode(h);
          break;
        case _e.WITNESS_UTXO:
          if (mn("input", h.key, _e.WITNESS_UTXO), f.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          f.witnessUtxo = Mr.witnessUtxo.decode(h);
          break;
        case _e.PARTIAL_SIG:
          f.partialSig === void 0 && (f.partialSig = []), f.partialSig.push(Mr.partialSig.decode(h));
          break;
        case _e.SIGHASH_TYPE:
          if (mn("input", h.key, _e.SIGHASH_TYPE), f.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          f.sighashType = Mr.sighashType.decode(h);
          break;
        case _e.REDEEM_SCRIPT:
          if (mn("input", h.key, _e.REDEEM_SCRIPT), f.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          f.redeemScript = Mr.redeemScript.decode(h);
          break;
        case _e.WITNESS_SCRIPT:
          if (mn("input", h.key, _e.WITNESS_SCRIPT), f.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          f.witnessScript = Mr.witnessScript.decode(h);
          break;
        case _e.BIP32_DERIVATION:
          f.bip32Derivation === void 0 && (f.bip32Derivation = []), f.bip32Derivation.push(
            Mr.bip32Derivation.decode(h)
          );
          break;
        case _e.FINAL_SCRIPTSIG:
          mn("input", h.key, _e.FINAL_SCRIPTSIG), f.finalScriptSig = Mr.finalScriptSig.decode(h);
          break;
        case _e.FINAL_SCRIPTWITNESS:
          mn("input", h.key, _e.FINAL_SCRIPTWITNESS), f.finalScriptWitness = Mr.finalScriptWitness.decode(
            h
          );
          break;
        case _e.POR_COMMITMENT:
          mn("input", h.key, _e.POR_COMMITMENT), f.porCommitment = Mr.porCommitment.decode(h);
          break;
        case _e.TAP_KEY_SIG:
          mn("input", h.key, _e.TAP_KEY_SIG), f.tapKeySig = Mr.tapKeySig.decode(h);
          break;
        case _e.TAP_SCRIPT_SIG:
          f.tapScriptSig === void 0 && (f.tapScriptSig = []), f.tapScriptSig.push(Mr.tapScriptSig.decode(h));
          break;
        case _e.TAP_LEAF_SCRIPT:
          f.tapLeafScript === void 0 && (f.tapLeafScript = []), f.tapLeafScript.push(Mr.tapLeafScript.decode(h));
          break;
        case _e.TAP_BIP32_DERIVATION:
          f.tapBip32Derivation === void 0 && (f.tapBip32Derivation = []), f.tapBip32Derivation.push(
            Mr.tapBip32Derivation.decode(h)
          );
          break;
        case _e.TAP_INTERNAL_KEY:
          mn("input", h.key, _e.TAP_INTERNAL_KEY), f.tapInternalKey = Mr.tapInternalKey.decode(h);
          break;
        case _e.TAP_MERKLE_ROOT:
          mn("input", h.key, _e.TAP_MERKLE_ROOT), f.tapMerkleRoot = Mr.tapMerkleRoot.decode(h);
          break;
        default:
          f.unknownKeyVals || (f.unknownKeyVals = []), f.unknownKeyVals.push(h);
      }
    u.push(f);
  }
  for (const c of Dg(s)) {
    const f = {};
    for (const h of n[c])
      switch (Ma.checkPubkey(h), h.key[0]) {
        case Sr.REDEEM_SCRIPT:
          if (mn("output", h.key, Sr.REDEEM_SCRIPT), f.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          f.redeemScript = Ma.redeemScript.decode(h);
          break;
        case Sr.WITNESS_SCRIPT:
          if (mn("output", h.key, Sr.WITNESS_SCRIPT), f.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          f.witnessScript = Ma.witnessScript.decode(h);
          break;
        case Sr.BIP32_DERIVATION:
          f.bip32Derivation === void 0 && (f.bip32Derivation = []), f.bip32Derivation.push(
            Ma.bip32Derivation.decode(h)
          );
          break;
        case Sr.TAP_INTERNAL_KEY:
          mn("output", h.key, Sr.TAP_INTERNAL_KEY), f.tapInternalKey = Ma.tapInternalKey.decode(h);
          break;
        case Sr.TAP_TREE:
          mn("output", h.key, Sr.TAP_TREE), f.tapTree = Ma.tapTree.decode(h);
          break;
        case Sr.TAP_BIP32_DERIVATION:
          f.tapBip32Derivation === void 0 && (f.tapBip32Derivation = []), f.tapBip32Derivation.push(
            Ma.tapBip32Derivation.decode(h)
          );
          break;
        default:
          f.unknownKeyVals || (f.unknownKeyVals = []), f.unknownKeyVals.push(h);
      }
    l.push(f);
  }
  return { globalMap: o, inputs: u, outputs: l };
}
function Xie({ globalMap: e, inputs: t, outputs: r }) {
  const { globalKeyVals: n, inputKeyVals: o, outputKeyVals: a } = Lv({
    globalMap: e,
    inputs: t,
    outputs: r
  }), i = D7(n), s = (f) => f.length === 0 ? [Uint8Array.from([0])] : f.map(D7), u = s(o), l = s(a), c = new Uint8Array(5);
  return c.set([112, 115, 98, 116, 255], 0), yr(
    [c, i].concat(u, l)
  );
}
const Yie = (e, t) => de(e.key, t.key);
function j2(e, t) {
  const r = /* @__PURE__ */ new Set(), n = Object.entries(e).reduce((a, [i, s]) => {
    if (i === "unknownKeyVals") return a;
    const u = t[i];
    if (u === void 0) return a;
    const l = (Array.isArray(s) ? s : [s]).map(
      u.encode
    );
    return l.map((c) => Ve(c.key)).forEach((c) => {
      if (r.has(c))
        throw new Error("Serialize Error: Duplicate key: " + c);
      r.add(c);
    }), a.concat(l);
  }, []), o = e.unknownKeyVals ? e.unknownKeyVals.filter((a) => !r.has(Ve(a.key))) : [];
  return n.concat(o).sort(Yie);
}
function Lv({ globalMap: e, inputs: t, outputs: r }) {
  return {
    globalKeyVals: j2(e, L5),
    inputKeyVals: t.map((n) => j2(n, Mr)),
    outputKeyVals: r.map((n) => j2(n, Ma))
  };
}
function Jie(e) {
  const t = e[0], r = Lv(t), n = e.slice(1);
  if (n.length === 0) throw new Error("Combine: Nothing to combine");
  const o = M7(t);
  if (o === void 0)
    throw new Error("Combine: Self missing transaction");
  const a = Rl(r.globalKeyVals), i = r.inputKeyVals.map(Rl), s = r.outputKeyVals.map(Rl);
  for (const u of n) {
    const l = M7(u);
    if (l === void 0 || de(l.toBuffer(), o.toBuffer()) !== 0)
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const c = Lv(u);
    Rl(c.globalKeyVals).forEach(
      L2(
        a,
        r.globalKeyVals,
        c.globalKeyVals
      )
    ), c.inputKeyVals.map(Rl).forEach(
      (f, h) => f.forEach(
        L2(
          i[h],
          r.inputKeyVals[h],
          c.inputKeyVals[h]
        )
      )
    ), c.outputKeyVals.map(Rl).forEach(
      (f, h) => f.forEach(
        L2(
          s[h],
          r.outputKeyVals[h],
          c.outputKeyVals[h]
        )
      )
    );
  }
  return YP(o, {
    globalMapKeyVals: r.globalKeyVals,
    inputKeyVals: r.inputKeyVals,
    outputKeyVals: r.outputKeyVals
  });
}
function L2(e, t, r) {
  return (n) => {
    if (e.has(n)) return;
    const o = r.filter((a) => Ve(a.key) === n)[0];
    t.push(o), e.add(n);
  };
}
function M7(e) {
  return e.globalMap.unsignedTx;
}
function Rl(e) {
  const t = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    const n = Ve(r.key);
    if (t.has(n))
      throw new Error("Combine: KeyValue Map keys should be unique");
    t.add(n);
  }), t;
}
function ln(e, t) {
  const r = e[t];
  if (r === void 0) throw new Error(`No input #${t}`);
  return r;
}
function Vh(e, t) {
  const r = e[t];
  if (r === void 0) throw new Error(`No output #${t}`);
  return r;
}
function H2(e, t, r) {
  if (e.key[0] < r)
    throw new Error(
      "Use the method for your specific key instead of addUnknownKeyVal*"
    );
  if (t && t.filter((n) => de(n.key, e.key) === 0).length !== 0)
    throw new Error(`Duplicate Key: ${Ve(e.key)}`);
}
function F2(e) {
  let t = 0;
  return Object.keys(e).forEach((r) => {
    Number(isNaN(Number(r))) && t++;
  }), t;
}
function Qie(e, t) {
  let r = !1;
  if (t.nonWitnessUtxo || t.witnessUtxo) {
    const n = !!t.redeemScript, o = !!t.witnessScript, a = !n || !!t.finalScriptSig, i = !o || !!t.finalScriptWitness, s = !!t.finalScriptSig || !!t.finalScriptWitness;
    r = a && i && s;
  }
  if (r === !1)
    throw new Error(
      `Input #${e} has too much or too little data to clean`
    );
}
function K7(e, t, r, n) {
  throw new Error(
    `Data for ${e} key ${t} is incorrect: Expected ${r} and got ${JSON.stringify(n)}`
  );
}
function H5(e) {
  return (t, r) => {
    for (const n of Object.keys(t)) {
      const o = t[n], { canAdd: a, canAddToArray: i, check: s, expected: u } = (
        // @ts-ignore
        Gie[e + "s"][n] || {}
      ), l = !!i;
      if (s)
        if (l) {
          if (!Array.isArray(o) || // @ts-ignore
          r[n] && !Array.isArray(r[n]))
            throw new Error(`Key type ${n} must be an array`);
          o.every(s) || K7(e, n, u, o);
          const c = r[n] || [], f = /* @__PURE__ */ new Set();
          if (!o.every((h) => i(c, h, f)))
            throw new Error("Can not add duplicate data to array");
          r[n] = c.concat(o);
        } else {
          if (s(o) || K7(e, n, u, o), !a(r, o))
            throw new Error(`Can not add duplicate data to ${e}`);
          r[n] = o;
        }
    }
  };
}
const eae = H5("global"), JP = H5("input"), QP = H5("output");
function tae(e, t) {
  const r = e.length - 1, n = ln(e, r);
  JP(t, n);
}
function rae(e, t) {
  const r = e.length - 1, n = Vh(e, r);
  QP(t, n);
}
let q7 = class {
  constructor(e) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: e
    };
  }
  static fromBase64(e, t) {
    const r = lP(e);
    return this.fromBuffer(r, t);
  }
  static fromHex(e, t) {
    const r = ys(e);
    return this.fromBuffer(r, t);
  }
  static fromBuffer(e, t) {
    const r = Wie(e, t), n = new this(r.globalMap.unsignedTx);
    return Object.assign(n, r), n;
  }
  toBase64() {
    const e = this.toBuffer();
    return Zre(e);
  }
  toHex() {
    const e = this.toBuffer();
    return Ve(e);
  }
  toBuffer() {
    return Xie(this);
  }
  updateGlobal(e) {
    return eae(e, this.globalMap), this;
  }
  updateInput(e, t) {
    const r = ln(this.inputs, e);
    return JP(t, r), this;
  }
  updateOutput(e, t) {
    const r = Vh(this.outputs, e);
    return QP(t, r), this;
  }
  addUnknownKeyValToGlobal(e) {
    return H2(
      e,
      this.globalMap.unknownKeyVals,
      F2(la)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(e), this;
  }
  addUnknownKeyValToInput(e, t) {
    const r = ln(this.inputs, e);
    return H2(t, r.unknownKeyVals, F2(_e)), r.unknownKeyVals || (r.unknownKeyVals = []), r.unknownKeyVals.push(t), this;
  }
  addUnknownKeyValToOutput(e, t) {
    const r = Vh(this.outputs, e);
    return H2(t, r.unknownKeyVals, F2(Sr)), r.unknownKeyVals || (r.unknownKeyVals = []), r.unknownKeyVals.push(t), this;
  }
  addInput(e) {
    this.globalMap.unsignedTx.addInput(e), this.inputs.push({
      unknownKeyVals: []
    });
    const t = e.unknownKeyVals || [], r = this.inputs.length - 1;
    if (!Array.isArray(t))
      throw new Error("unknownKeyVals must be an Array");
    return t.forEach(
      (n) => this.addUnknownKeyValToInput(r, n)
    ), tae(this.inputs, e), this;
  }
  addOutput(e) {
    this.globalMap.unsignedTx.addOutput(e), this.outputs.push({
      unknownKeyVals: []
    });
    const t = e.unknownKeyVals || [], r = this.outputs.length - 1;
    if (!Array.isArray(t))
      throw new Error("unknownKeyVals must be an Array");
    return t.forEach(
      (n) => this.addUnknownKeyValToOutput(r, n)
    ), rae(this.outputs, e), this;
  }
  clearFinalizedInput(e) {
    const t = ln(this.inputs, e);
    Qie(e, t);
    for (const r of Object.keys(t))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(r) || delete t[r];
    return this;
  }
  combine(...e) {
    const t = Jie([this].concat(e));
    return Object.assign(this, t), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
function bl(e) {
  return (t) => {
    try {
      return e({ output: t }), !0;
    } catch {
      return !1;
    }
  };
}
const nae = bl(zy), oae = bl(IP), iae = bl(Dp), Hy = bl(Mp), V7 = bl(Kp), eO = bl(dd), tO = bl(qp);
function Mg(e) {
  let t = new Uint8Array(0);
  function r(i) {
    t = yr([t, i]);
  }
  function n(i) {
    const s = t.length, u = Xo(i);
    t = yr([t, new Uint8Array(u)]), Lu(i, t, s);
  }
  function o(i) {
    n(i.length), r(i);
  }
  function a(i) {
    n(i.length), i.forEach(o);
  }
  return a(e), t;
}
function rO(e, t) {
  const r = es(e), n = e.slice(1, 33), o = dr(t);
  if (o === null) throw new Error("Unknown script error");
  return o.findIndex((a) => typeof a == "number" ? !1 : de(e, a) === 0 || de(r, a) === 0 || de(n, a) === 0);
}
function Fy(e, t) {
  return rO(e, t) !== -1;
}
function aae(e, t) {
  return sae(e).some(
    (r) => nO(r, ch.decode, t)
  );
}
function nO(e, t, r) {
  const { hashType: n } = t(e), o = [];
  switch (n & Ir.SIGHASH_ANYONECANPAY && o.push("addInput"), n & 31) {
    case Ir.SIGHASH_ALL:
      break;
    case Ir.SIGHASH_SINGLE:
    case Ir.SIGHASH_NONE:
      o.push("addOutput"), o.push("setInputSequence");
      break;
  }
  return o.indexOf(r) === -1;
}
function sae(e) {
  let t = [];
  if ((e.partialSig || []).length === 0) {
    if (!e.finalScriptSig && !e.finalScriptWitness) return [];
    t = uae(e);
  } else
    t = e.partialSig;
  return t.map((r) => r.signature);
}
function uae(e) {
  const t = e.finalScriptSig ? dr(e.finalScriptSig) || [] : [], r = e.finalScriptWitness ? dr(e.finalScriptWitness) || [] : [];
  return t.concat(r).filter((n) => n instanceof Uint8Array && cs(n)).map((n) => ({ signature: n }));
}
const Uc = (e) => e.length === 32 ? e : e.slice(1, 33);
function G7(e, t, r) {
  const n = kae(
    t,
    e,
    r
  );
  try {
    const o = vae(t, n).concat(n.script).concat(n.controlBlock);
    return { finalScriptWitness: Mg(o) };
  } catch (o) {
    throw new Error(`Can not finalize taproot input #${e}: ${o}`);
  }
}
function W0(e, t) {
  const r = t ? Uint8Array.from([t]) : Uint8Array.from([]);
  return yr([e, r]);
}
function ci(e) {
  return e && !!(e.tapInternalKey || e.tapMerkleRoot || e.tapLeafScript && e.tapLeafScript.length || e.tapBip32Derivation && e.tapBip32Derivation.length || e.witnessUtxo && tO(e.witnessUtxo.script));
}
function D2(e, t) {
  return e && !!(e.tapInternalKey || e.tapTree || e.tapBip32Derivation && e.tapBip32Derivation.length || t);
}
function Z7(e, t, r) {
  yae(e, t, r), wae(e, t, r);
}
function W7(e, t, r) {
  bae(e, t, r), cae(e, t);
}
function cae(e, t) {
  if (!t.tapTree && !t.tapInternalKey) return;
  const r = t.tapInternalKey || e.tapInternalKey, n = t.tapTree || e.tapTree;
  if (r) {
    const { script: o } = e, a = lae(r, n);
    if (o && de(a, o) !== 0)
      throw new Error("Error adding output. Script or address mismatch.");
  }
}
function lae(e, t) {
  const r = t && fae(t.leaves), { output: n } = qp({
    internalPubkey: e,
    scriptTree: r
  });
  return n;
}
function fae(e = []) {
  return e.length === 1 && e[0].depth === 0 ? {
    output: e[0].script,
    version: e[0].leafVersion
  } : mae(e);
}
function dae(e, t) {
  return pae(e).some(
    (r) => nO(r, hae, t)
  );
}
function hae(e) {
  return {
    signature: e.slice(0, 64),
    hashType: e.slice(64)[0] || Ir.SIGHASH_DEFAULT
  };
}
function pae(e) {
  const t = [];
  if (e.tapKeySig && t.push(e.tapKeySig), e.tapScriptSig && t.push(...e.tapScriptSig.map((r) => r.signature)), !t.length) {
    const r = gae(e.finalScriptWitness);
    r && t.push(r);
  }
  return t;
}
function gae(e) {
  if (!e) return;
  const t = e.slice(2);
  if (t.length === 64 || t.length === 65) return t;
}
function mae(e) {
  let t;
  for (const r of e)
    if (t = Hv(r, t), !t) throw new Error("No room left to insert tapleaf in tree");
  return t;
}
function Hv(e, t, r = 0) {
  if (r > soe) throw new Error("Max taptree depth exceeded.");
  if (e.depth === r)
    return t ? void 0 : {
      output: e.script,
      version: e.leafVersion
    };
  if (S5(t)) return;
  const n = Hv(e, t && t[0], r + 1);
  if (n) return [n, t && t[1]];
  const o = Hv(e, t && t[1], r + 1);
  if (o) return [t && t[0], o];
}
function yae(e, t, r) {
  const n = ci(e) && df(t), o = df(e) && ci(t), a = e === t && ci(t) && df(t);
  if (n || o || a)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function bae(e, t, r) {
  const n = D2(e) && df(t), o = df(e) && D2(t), a = e === t && D2(t) && df(t);
  if (n || o || a)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function wae(e, t, r) {
  if (t.tapMerkleRoot) {
    const n = (t.tapLeafScript || []).every(
      (a) => M2(a, t.tapMerkleRoot)
    ), o = (e.tapLeafScript || []).every(
      (a) => M2(a, t.tapMerkleRoot)
    );
    if (!n || !o)
      throw new Error(
        `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`
      );
  } else if (e.tapMerkleRoot && !(t.tapLeafScript || []).every(
    (n) => M2(n, e.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`
    );
}
function M2(e, t) {
  if (!t) return !0;
  const r = Xa({
    output: e.script,
    version: e.leafVersion
  }), n = Rv(e.controlBlock, r);
  return de(n, t) === 0;
}
function vae(e, t) {
  const r = Xa({
    output: t.script,
    version: t.leafVersion
  });
  return (e.tapScriptSig || []).filter((n) => de(n.leafHash, r) === 0).map((n) => Eae(t.script, n)).sort((n, o) => o.positionInScript - n.positionInScript).map((n) => n.signature);
}
function Eae(e, t) {
  return Object.assign(
    {
      positionInScript: rO(t.pubkey, e)
    },
    t
  );
}
function kae(e, t, r) {
  if (!e.tapScriptSig || !e.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${t}. No tapleaf script signature provided.`
    );
  const n = (e.tapLeafScript || []).sort((o, a) => o.controlBlock.length - a.controlBlock.length).find(
    (o) => xae(o, e.tapScriptSig, r)
  );
  if (!n)
    throw new Error(
      `Can not finalize taproot input #${t}. Signature for tapleaf script not found.`
    );
  return n;
}
function xae(e, t, r) {
  const n = Xa({
    output: e.script,
    version: e.leafVersion
  });
  return (!r || de(n, r) === 0) && t.find((o) => de(o.leafHash, n) === 0) !== void 0;
}
function df(e) {
  return e && !!(e.redeemScript || e.witnessScript || e.bip32Derivation && e.bip32Derivation.length);
}
const Aae = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: Ui,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Zt {
  constructor(t = {}, r = new q7(new oO())) {
    xe(this, "data"), xe(this, "__CACHE"), xe(this, "opts"), this.data = r, this.opts = Object.assign({}, Aae, t), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const n = (o, a, i, s) => Object.defineProperty(o, a, {
      enumerable: i,
      writable: s
    });
    n(this, "__CACHE", !1, !0), n(this, "opts", !1, !0);
  }
  static fromBase64(t, r = {}) {
    const n = lP(t);
    return this.fromBuffer(n, r);
  }
  static fromHex(t, r = {}) {
    const n = ys(t);
    return this.fromBuffer(n, r);
  }
  static fromBuffer(t, r = {}) {
    const n = q7.fromBuffer(t, Sae), o = new Zt(r, n);
    return Oae(o.__CACHE.__TX, o.__CACHE), o;
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(t) {
    this.setVersion(t);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(t) {
    this.setLocktime(t);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((t) => ({
      hash: z7(t.hash),
      index: t.index,
      sequence: t.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((t) => {
      let r;
      try {
        r = Vp(t.script, this.opts.network);
      } catch {
      }
      return {
        script: z7(t.script),
        value: t.value,
        address: r
      };
    });
  }
  combine(...t) {
    return this.data.combine(...t.map((r) => r.data)), this;
  }
  clone() {
    const t = Zt.fromBuffer(this.data.toBuffer());
    return t.opts = JSON.parse(JSON.stringify(this.opts)), t;
  }
  setMaximumFeeRate(t) {
    X0(t), this.opts.maximumFeeRate = t;
  }
  setVersion(t) {
    X0(t), Dd(this.data.inputs, "setVersion");
    const r = this.__CACHE;
    return r.__TX.version = t, r.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(t) {
    X0(t), Dd(this.data.inputs, "setLocktime");
    const r = this.__CACHE;
    return r.__TX.locktime = t, r.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(t, r) {
    X0(r), Dd(this.data.inputs, "setInputSequence");
    const n = this.__CACHE;
    if (n.__TX.ins.length <= t)
      throw new Error("Input index too high");
    return n.__TX.ins[t].sequence = r, n.__EXTRACTED_TX = void 0, this;
  }
  addInputs(t) {
    return t.forEach((r) => this.addInput(r)), this;
  }
  addInput(t) {
    if (arguments.length > 1 || !t || t.hash === void 0 || t.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    Z7(t, t, "addInput"), Dd(this.data.inputs, "addInput"), t.witnessScript && Kg(t.witnessScript);
    const r = this.__CACHE;
    this.data.addInput(t);
    const n = r.__TX.ins[r.__TX.ins.length - 1];
    sO(r, n);
    const o = this.data.inputs.length - 1, a = this.data.inputs[o];
    return a.nonWitnessUtxo && Dv(this.__CACHE, a, o), r.__FEE = void 0, r.__FEE_RATE = void 0, r.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(t) {
    return t.forEach((r) => this.addOutput(r)), this;
  }
  addOutput(t) {
    if (arguments.length > 1 || !t || t.value === void 0 || t.address === void 0 && t.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    Dd(this.data.inputs, "addOutput");
    const { address: r } = t;
    if (typeof r == "string") {
      const { network: o } = this.opts, a = Gp(r, o);
      t = Object.assign({}, t, { script: a });
    }
    W7(t, t, "addOutput");
    const n = this.__CACHE;
    return this.data.addOutput(t), n.__FEE = void 0, n.__FEE_RATE = void 0, n.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(t) {
    if (!this.data.inputs.every(iO)) throw new Error("Not finalized");
    const r = this.__CACHE;
    if (t || Iae(this, r, this.opts), r.__EXTRACTED_TX) return r.__EXTRACTED_TX;
    const n = r.__TX.clone();
    return hO(this.data.inputs, n, r, !0), n;
  }
  getFeeRate() {
    return e9(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return e9("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return ln(this.data.inputs, 0), Md(this.data.inputs.length).forEach((t) => this.finalizeInput(t)), this;
  }
  finalizeInput(t, r) {
    const n = ln(this.data.inputs, t);
    return ci(n) ? this._finalizeTaprootInput(
      t,
      n,
      void 0,
      r
    ) : this._finalizeInput(t, n, r);
  }
  finalizeTaprootInput(t, r, n = G7) {
    const o = ln(this.data.inputs, t);
    if (ci(o))
      return this._finalizeTaprootInput(
        t,
        o,
        r,
        n
      );
    throw new Error(`Cannot finalize input #${t}. Not Taproot.`);
  }
  _finalizeInput(t, r, n = $ae) {
    const { script: o, isP2SH: a, isP2WSH: i, isSegwit: s } = Uae(
      t,
      r,
      this.__CACHE
    );
    if (!o) throw new Error(`No script found for input #${t}`);
    Tae(r);
    const { finalScriptSig: u, finalScriptWitness: l } = n(
      t,
      r,
      o,
      s,
      a,
      i
    );
    if (u && this.data.updateInput(t, { finalScriptSig: u }), l && this.data.updateInput(t, { finalScriptWitness: l }), !u && !l)
      throw new Error(`Unknown error finalizing input #${t}`);
    return this.data.clearFinalizedInput(t), this;
  }
  _finalizeTaprootInput(t, r, n, o = G7) {
    if (!r.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${t}. Missing withness utxo.`
      );
    if (r.tapKeySig) {
      const a = qp({
        output: r.witnessUtxo.script,
        signature: r.tapKeySig
      }), i = Mg(a.witness);
      this.data.updateInput(t, { finalScriptWitness: i });
    } else {
      const { finalScriptWitness: a } = o(
        t,
        r,
        n
      );
      this.data.updateInput(t, { finalScriptWitness: a });
    }
    return this.data.clearFinalizedInput(t), this;
  }
  getInputType(t) {
    const r = ln(this.data.inputs, t), n = pO(t, r, this.__CACHE), o = My(
      n,
      t,
      "input",
      r.redeemScript || Hae(r.finalScriptSig),
      r.witnessScript || Fae(r.finalScriptWitness)
    ), a = o.type === "raw" ? "" : o.type + "-", i = mO(o.meaningfulScript);
    return a + i;
  }
  inputHasPubkey(t, r) {
    const n = ln(this.data.inputs, t);
    return jae(r, n, t, this.__CACHE);
  }
  inputHasHDKey(t, r) {
    const n = ln(this.data.inputs, t), o = Y7(r);
    return !!n.bip32Derivation && n.bip32Derivation.some(o);
  }
  outputHasPubkey(t, r) {
    const n = Vh(this.data.outputs, t);
    return Lae(r, n, t, this.__CACHE);
  }
  outputHasHDKey(t, r) {
    const n = Vh(this.data.outputs, t), o = Y7(r);
    return !!n.bip32Derivation && n.bip32Derivation.some(o);
  }
  validateSignaturesOfAllInputs(t) {
    return ln(this.data.inputs, 0), Md(this.data.inputs.length).map(
      (r) => this.validateSignaturesOfInput(r, t)
    ).reduce((r, n) => n === !0 && r, !0);
  }
  validateSignaturesOfInput(t, r, n) {
    const o = this.data.inputs[t];
    return ci(o) ? this.validateSignaturesOfTaprootInput(
      t,
      r,
      n
    ) : this._validateSignaturesOfInput(t, r, n);
  }
  _validateSignaturesOfInput(t, r, n) {
    const o = this.data.inputs[t], a = (o || {}).partialSig;
    if (!o || !a || a.length < 1)
      throw new Error("No signatures to validate");
    if (typeof r != "function")
      throw new Error("Need validator function to validate signatures");
    const i = n ? a.filter((f) => de(f.pubkey, n) === 0) : a;
    if (i.length < 1) throw new Error("No signatures for this pubkey");
    const s = [];
    let u, l, c;
    for (const f of i) {
      const h = ch.decode(f.signature), { hash: p, script: y } = c !== h.hashType ? cO(
        t,
        Object.assign({}, o, { sighashType: h.hashType }),
        this.__CACHE,
        !0
      ) : { hash: u, script: l };
      c = h.hashType, u = p, l = y, aO(f.pubkey, y, "verify"), s.push(r(f.pubkey, p, h.signature));
    }
    return s.every((f) => f === !0);
  }
  validateSignaturesOfTaprootInput(t, r, n) {
    const o = this.data.inputs[t], a = (o || {}).tapKeySig, i = (o || {}).tapScriptSig;
    if (!o && !a && !(i && !i.length))
      throw new Error("No signatures to validate");
    if (typeof r != "function")
      throw new Error("Need validator function to validate signatures");
    n = n && Uc(n);
    const s = n ? Fv(
      t,
      o,
      this.data.inputs,
      n,
      this.__CACHE
    ) : Bae(
      t,
      o,
      this.data.inputs,
      this.__CACHE
    );
    if (!s.length) throw new Error("No signatures for this pubkey");
    const u = s.find((c) => !c.leafHash);
    let l = 0;
    if (a && u) {
      if (!r(
        u.pubkey,
        u.hash,
        r9(a)
      )) return !1;
      l++;
    }
    if (i)
      for (const c of i) {
        const f = s.find(
          (h) => de(h.pubkey, c.pubkey) === 0
        );
        if (f) {
          if (!r(
            c.pubkey,
            f.hash,
            r9(c.signature)
          )) return !1;
          l++;
        }
      }
    return l > 0;
  }
  signAllInputsHD(t, r = [Ir.SIGHASH_ALL]) {
    if (!t || !t.publicKey || !t.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const n = [];
    for (const o of Md(this.data.inputs.length))
      try {
        this.signInputHD(o, t, r), n.push(!0);
      } catch {
        n.push(!1);
      }
    if (n.every((o) => o === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(t, r = [Ir.SIGHASH_ALL]) {
    return new Promise((n, o) => {
      if (!t || !t.publicKey || !t.fingerprint)
        return o(new Error("Need HDSigner to sign input"));
      const a = [], i = [];
      for (const s of Md(this.data.inputs.length))
        i.push(
          this.signInputHDAsync(s, t, r).then(
            () => {
              a.push(!0);
            },
            () => {
              a.push(!1);
            }
          )
        );
      return Promise.all(i).then(() => {
        if (a.every((s) => s === !1))
          return o(new Error("No inputs were signed"));
        n();
      });
    });
  }
  signInputHD(t, r, n = [Ir.SIGHASH_ALL]) {
    if (!r || !r.publicKey || !r.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return n9(t, this.data.inputs, r).forEach((o) => this.signInput(t, o, n)), this;
  }
  signInputHDAsync(t, r, n = [Ir.SIGHASH_ALL]) {
    return new Promise((o, a) => {
      if (!r || !r.publicKey || !r.fingerprint)
        return a(new Error("Need HDSigner to sign input"));
      const i = n9(t, this.data.inputs, r).map(
        (s) => this.signInputAsync(t, s, n)
      );
      return Promise.all(i).then(() => {
        o();
      }).catch(a);
    });
  }
  signAllInputs(t, r) {
    if (!t || !t.publicKey)
      throw new Error("Need Signer to sign input");
    const n = [];
    for (const o of Md(this.data.inputs.length))
      try {
        this.signInput(o, t, r), n.push(!0);
      } catch {
        n.push(!1);
      }
    if (n.every((o) => o === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(t, r) {
    return new Promise((n, o) => {
      if (!t || !t.publicKey)
        return o(new Error("Need Signer to sign input"));
      const a = [], i = [];
      for (const [s] of this.data.inputs.entries())
        i.push(
          this.signInputAsync(s, t, r).then(
            () => {
              a.push(!0);
            },
            () => {
              a.push(!1);
            }
          )
        );
      return Promise.all(i).then(() => {
        if (a.every((s) => s === !1))
          return o(new Error("No inputs were signed"));
        n();
      });
    });
  }
  signInput(t, r, n) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const o = ln(this.data.inputs, t);
    return ci(o) ? this._signTaprootInput(
      t,
      o,
      r,
      void 0,
      n
    ) : this._signInput(t, r, n);
  }
  signTaprootInput(t, r, n, o) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const a = ln(this.data.inputs, t);
    if (ci(a))
      return this._signTaprootInput(
        t,
        a,
        r,
        n,
        o
      );
    throw new Error(`Input #${t} is not of type Taproot.`);
  }
  _signInput(t, r, n = [Ir.SIGHASH_ALL]) {
    const { hash: o, sighashType: a } = t9(
      this.data.inputs,
      t,
      r.publicKey,
      this.__CACHE,
      n
    ), i = [
      {
        pubkey: r.publicKey,
        signature: ch.encode(r.sign(o), a)
      }
    ];
    return this.data.updateInput(t, { partialSig: i }), this;
  }
  _signTaprootInput(t, r, n, o, a = [Ir.SIGHASH_DEFAULT]) {
    const i = this.checkTaprootHashesForSig(
      t,
      r,
      n,
      o,
      a
    ), s = i.filter((l) => !l.leafHash).map(
      (l) => W0(
        n.signSchnorr(l.hash),
        r.sighashType
      )
    )[0], u = i.filter((l) => !!l.leafHash).map((l) => ({
      pubkey: Uc(n.publicKey),
      signature: W0(
        n.signSchnorr(l.hash),
        r.sighashType
      ),
      leafHash: l.leafHash
    }));
    return s && this.data.updateInput(t, { tapKeySig: s }), u.length && this.data.updateInput(t, { tapScriptSig: u }), this;
  }
  signInputAsync(t, r, n) {
    return Promise.resolve().then(() => {
      if (!r || !r.publicKey)
        throw new Error("Need Signer to sign input");
      const o = ln(this.data.inputs, t);
      return ci(o) ? this._signTaprootInputAsync(
        t,
        o,
        r,
        void 0,
        n
      ) : this._signInputAsync(t, r, n);
    });
  }
  signTaprootInputAsync(t, r, n, o) {
    return Promise.resolve().then(() => {
      if (!r || !r.publicKey)
        throw new Error("Need Signer to sign input");
      const a = ln(this.data.inputs, t);
      if (ci(a))
        return this._signTaprootInputAsync(
          t,
          a,
          r,
          n,
          o
        );
      throw new Error(`Input #${t} is not of type Taproot.`);
    });
  }
  _signInputAsync(t, r, n = [Ir.SIGHASH_ALL]) {
    const { hash: o, sighashType: a } = t9(
      this.data.inputs,
      t,
      r.publicKey,
      this.__CACHE,
      n
    );
    return Promise.resolve(r.sign(o)).then((i) => {
      const s = [
        {
          pubkey: r.publicKey,
          signature: ch.encode(i, a)
        }
      ];
      this.data.updateInput(t, { partialSig: s });
    });
  }
  async _signTaprootInputAsync(t, r, n, o, a = [Ir.SIGHASH_DEFAULT]) {
    const i = this.checkTaprootHashesForSig(
      t,
      r,
      n,
      o,
      a
    ), s = [], u = i.filter((c) => !c.leafHash)[0];
    if (u) {
      const c = Promise.resolve(
        n.signSchnorr(u.hash)
      ).then((f) => ({ tapKeySig: W0(f, r.sighashType) }));
      s.push(c);
    }
    const l = i.filter((c) => !!c.leafHash);
    if (l.length) {
      const c = l.map((f) => Promise.resolve(n.signSchnorr(f.hash)).then(
        (h) => ({ tapScriptSig: [
          {
            pubkey: Uc(n.publicKey),
            signature: W0(
              h,
              r.sighashType
            ),
            leafHash: f.leafHash
          }
        ] })
      ));
      s.push(...c);
    }
    return Promise.all(s).then((c) => {
      c.forEach((f) => this.data.updateInput(t, f));
    });
  }
  checkTaprootHashesForSig(t, r, n, o, a) {
    if (typeof n.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${t}.`
      );
    const i = Fv(
      t,
      r,
      this.data.inputs,
      n.publicKey,
      this.__CACHE,
      o,
      a
    );
    if (!i || !i.length)
      throw new Error(
        `Can not sign for input #${t} with the key ${Ve(n.publicKey)}`
      );
    return i;
  }
  toBuffer() {
    return K2(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return K2(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return K2(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(t) {
    return this.data.updateGlobal(t), this;
  }
  updateInput(t, r) {
    return r.witnessScript && Kg(r.witnessScript), Z7(
      this.data.inputs[t],
      r,
      "updateInput"
    ), this.data.updateInput(t, r), r.nonWitnessUtxo && Dv(
      this.__CACHE,
      this.data.inputs[t],
      t
    ), this;
  }
  updateOutput(t, r) {
    const n = this.data.outputs[t];
    return W7(n, r, "updateOutput"), this.data.updateOutput(t, r), this;
  }
  addUnknownKeyValToGlobal(t) {
    return this.data.addUnknownKeyValToGlobal(t), this;
  }
  addUnknownKeyValToInput(t, r) {
    return this.data.addUnknownKeyValToInput(t, r), this;
  }
  addUnknownKeyValToOutput(t, r) {
    return this.data.addUnknownKeyValToOutput(t, r), this;
  }
  clearFinalizedInput(t) {
    return this.data.clearFinalizedInput(t), this;
  }
}
const Sae = (e) => new oO(e);
class oO {
  constructor(t = Uint8Array.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    xe(this, "tx"), this.tx = Ir.fromBuffer(t), Pae(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(t) {
    if (t.hash === void 0 || t.index === void 0 || !(t.hash instanceof Uint8Array) && typeof t.hash != "string" || typeof t.index != "number")
      throw new Error("Error adding input.");
    const r = typeof t.hash == "string" ? U5(ys(t.hash)) : t.hash;
    this.tx.addInput(r, t.index, t.sequence);
  }
  addOutput(t) {
    if (t.script === void 0 || t.value === void 0 || !(t.script instanceof Uint8Array) || typeof t.value != "bigint")
      throw new Error("Error adding output.");
    this.tx.addOutput(t.script, t.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function _ae(e, t, r) {
  switch (r) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return X7(1, e.partialSig);
    case "multisig":
      const n = zy({ output: t });
      return X7(n.m, e.partialSig, n.pubkeys);
    default:
      return !1;
  }
}
function K2(e) {
  if (e.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function X7(e, t, r) {
  if (!t) return !1;
  let n;
  if (r ? n = r.map((o) => {
    const a = Dae(o);
    return t.find(
      (i) => de(i.pubkey, a) === 0
    );
  }).filter((o) => !!o) : n = t, n.length > e) throw new Error("Too many signatures");
  return n.length === e;
}
function iO(e) {
  return !!e.finalScriptSig || !!e.finalScriptWitness;
}
function Y7(e) {
  return (t) => !(de(e.fingerprint, t.masterFingerprint) || de(e.derivePath(t.path).publicKey, t.pubkey));
}
function X0(e) {
  if (typeof e != "number" || e !== Math.floor(e) || e > 4294967295 || e < 0)
    throw new Error("Invalid 32 bit integer");
}
function Iae(e, t, r) {
  const n = t.__FEE_RATE || e.getFeeRate(), o = t.__EXTRACTED_TX.virtualSize(), a = n * o;
  if (n >= r.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(a / 1e8).toFixed(8)} in fees, which is ${n} satoshi per byte for a transaction with a VSize of ${o} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function Dd(e, t) {
  e.forEach((r) => {
    if (ci(r) ? dae(r, t) : aae(r, t))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function Tae(e) {
  if (!e.sighashType || !e.partialSig) return;
  const { partialSig: t, sighashType: r } = e;
  t.forEach((n) => {
    const { hashType: o } = ch.decode(n.signature);
    if (r !== o)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function aO(e, t, r) {
  if (!Fy(e, t))
    throw new Error(
      `Can not ${r} for this input with the key ${Ve(e)}`
    );
}
function Pae(e) {
  if (!e.ins.every(
    (t) => t.script && t.script.length === 0 && t.witness && t.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function Oae(e, t) {
  e.ins.forEach((r) => {
    sO(t, r);
  });
}
function sO(e, t) {
  const r = Ve(U5(Uint8Array.from(t.hash))) + ":" + t.index;
  if (e.__TX_IN_CACHE[r]) throw new Error("Duplicate input detected.");
  e.__TX_IN_CACHE[r] = 1;
}
function uO(e, t) {
  return (r, n, o, a) => {
    const i = e({
      redeem: { output: o }
    }).output;
    if (de(n, i))
      throw new Error(
        `${t} for ${a} #${r} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const J7 = uO(dd, "Redeem script"), Q7 = uO(
  Kp,
  "Witness script"
);
function e9(e, t, r, n) {
  if (!r.every(iO))
    throw new Error(`PSBT must be finalized to calculate ${t}`);
  if (e === "__FEE_RATE" && n.__FEE_RATE) return n.__FEE_RATE;
  if (e === "__FEE" && n.__FEE) return n.__FEE;
  let o, a = !0;
  if (n.__EXTRACTED_TX ? (o = n.__EXTRACTED_TX, a = !1) : o = n.__TX.clone(), hO(r, o, n, a), e === "__FEE_RATE") return n.__FEE_RATE;
  if (e === "__FEE") return n.__FEE;
}
function $ae(e, t, r, n, o, a) {
  const i = mO(r);
  if (!_ae(t, r, i))
    throw new Error(`Can not finalize input #${e}`);
  return Cae(
    r,
    i,
    t.partialSig,
    n,
    o,
    a
  );
}
function Cae(e, t, r, n, o, a) {
  let i, s;
  const u = Nae(e, t, r), l = a ? Kp({ redeem: u }) : null, c = o ? dd({ redeem: l || u }) : null;
  return n ? (l ? s = Mg(l.witness) : s = Mg(u.witness), c && (i = c.input)) : c ? i = c.input : i = u.input, {
    finalScriptSig: i,
    finalScriptWitness: s
  };
}
function t9(e, t, r, n, o) {
  const a = ln(e, t), { hash: i, sighashType: s, script: u } = cO(
    t,
    a,
    n,
    !1,
    o
  );
  return aO(r, u, "sign"), {
    hash: i,
    sighashType: s
  };
}
function cO(e, t, r, n, o) {
  const a = r.__TX, i = t.sighashType || Ir.SIGHASH_ALL;
  fO(i, o);
  let s, u;
  if (t.nonWitnessUtxo) {
    const f = Dy(
      r,
      t,
      e
    ), h = a.ins[e].hash, p = f.getHash();
    if (de(h, p) !== 0)
      throw new Error(
        `Non-witness UTXO hash for input #${e} doesn't match the hash specified in the prevout`
      );
    const y = a.ins[e].index;
    u = f.outs[y];
  } else if (t.witnessUtxo)
    u = t.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: l, type: c } = My(
    u.script,
    e,
    "input",
    t.redeemScript,
    t.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(c) >= 0)
    s = a.hashForWitnessV0(
      e,
      l,
      u.value,
      i
    );
  else if (Hy(l)) {
    const f = Dp({
      hash: l.slice(2)
    }).output;
    s = a.hashForWitnessV0(
      e,
      f,
      u.value,
      i
    );
  } else {
    if (t.nonWitnessUtxo === void 0 && r.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${e} has witnessUtxo but non-segwit script: ${Ve(l)}`
      );
    !n && r.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), s = a.hashForSignature(
      e,
      l,
      i
    );
  }
  return {
    script: l,
    sighashType: i,
    hash: s
  };
}
function Bae(e, t, r, n) {
  const o = [];
  if (t.tapInternalKey) {
    const a = lO(e, t, n);
    a && o.push(a);
  }
  if (t.tapScriptSig) {
    const a = t.tapScriptSig.map((i) => i.pubkey);
    o.push(...a);
  }
  return o.map(
    (a) => Fv(e, t, r, a, n)
  ).flat();
}
function lO(e, t, r) {
  const { script: n } = F5(e, t, r);
  return tO(n) ? n.subarray(2, 34) : null;
}
function r9(e) {
  return e.length === 64 ? e : e.subarray(0, 64);
}
function Fv(e, t, r, n, o, a, i) {
  const s = o.__TX, u = t.sighashType || Ir.SIGHASH_DEFAULT;
  fO(u, i);
  const l = r.map(
    (y, m) => F5(m, y, o)
  ), c = l.map((y) => y.script), f = l.map((y) => y.value), h = [];
  if (t.tapInternalKey && !a) {
    const y = lO(e, t, o) || Uint8Array.from([]);
    if (de(Uc(n), y) === 0) {
      const m = s.hashForWitnessV1(
        e,
        c,
        f,
        u
      );
      h.push({ pubkey: n, hash: m });
    }
  }
  const p = (t.tapLeafScript || []).filter((y) => Fy(n, y.script)).map((y) => {
    const m = Xa({
      output: y.script,
      version: y.leafVersion
    });
    return Object.assign({ hash: m }, y);
  }).filter(
    (y) => !a || de(a, y.hash) === 0
  ).map((y) => {
    const m = s.hashForWitnessV1(
      e,
      c,
      f,
      u,
      y.hash
    );
    return {
      pubkey: n,
      hash: m,
      leafHash: y.hash
    };
  });
  return h.concat(p);
}
function fO(e, t) {
  if (t && t.indexOf(e) < 0) {
    const r = zae(e);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${r}`
    );
  }
}
function Nae(e, t, r) {
  let n;
  switch (t) {
    case "multisig":
      const o = Rae(e, r);
      n = zy({
        output: e,
        signatures: o
      });
      break;
    case "pubkey":
      n = IP({
        output: e,
        signature: r[0].signature
      });
      break;
    case "pubkeyhash":
      n = Dp({
        output: e,
        pubkey: r[0].pubkey,
        signature: r[0].signature
      });
      break;
    case "witnesspubkeyhash":
      n = Mp({
        output: e,
        pubkey: r[0].pubkey,
        signature: r[0].signature
      });
      break;
  }
  return n;
}
function Uae(e, t, r) {
  const n = r.__TX, o = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (o.isP2SH = !!t.redeemScript, o.isP2WSH = !!t.witnessScript, t.witnessScript)
    o.script = t.witnessScript;
  else if (t.redeemScript)
    o.script = t.redeemScript;
  else if (t.nonWitnessUtxo) {
    const a = Dy(
      r,
      t,
      e
    ), i = n.ins[e].index;
    o.script = a.outs[i].script;
  } else t.witnessUtxo && (o.script = t.witnessUtxo.script);
  return (t.witnessScript || Hy(o.script)) && (o.isSegwit = !0), o;
}
function n9(e, t, r) {
  const n = ln(t, e);
  if (!n.bip32Derivation || n.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const o = n.bip32Derivation.map((a) => {
    if (de(a.masterFingerprint, r.fingerprint) === 0)
      return a;
  }).filter((a) => !!a);
  if (o.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return o.map((a) => {
    const i = r.derivePath(a.path);
    if (de(a.pubkey, i.publicKey) !== 0)
      throw new Error("pubkey did not match bip32Derivation");
    return i;
  });
}
function Rae(e, t) {
  return zy({ output: e }).pubkeys.map((r) => (t.filter((n) => de(n.pubkey, r) === 0)[0] || {}).signature).filter((r) => !!r);
}
function dO(e) {
  let t = 0;
  function r(i) {
    return t += i, e.slice(t - i, t);
  }
  function n() {
    const i = hd(e, t);
    return t += Xo(i.bigintValue), i.numberValue;
  }
  function o() {
    return r(n());
  }
  function a() {
    const i = n(), s = [];
    for (let u = 0; u < i; u++) s.push(o());
    return s;
  }
  return a();
}
function zae(e) {
  let t = e & Ir.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (e & 31) {
    case Ir.SIGHASH_ALL:
      t += "SIGHASH_ALL";
      break;
    case Ir.SIGHASH_SINGLE:
      t += "SIGHASH_SINGLE";
      break;
    case Ir.SIGHASH_NONE:
      t += "SIGHASH_NONE";
      break;
  }
  return t;
}
function Dv(e, t, r) {
  e.__NON_WITNESS_UTXO_BUF_CACHE[r] = t.nonWitnessUtxo;
  const n = Ir.fromBuffer(t.nonWitnessUtxo);
  e.__NON_WITNESS_UTXO_TX_CACHE[r] = n;
  const o = e, a = r;
  delete t.nonWitnessUtxo, Object.defineProperty(t, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const i = o.__NON_WITNESS_UTXO_BUF_CACHE[a], s = o.__NON_WITNESS_UTXO_TX_CACHE[a];
      if (i !== void 0)
        return i;
      {
        const u = s.toBuffer();
        return o.__NON_WITNESS_UTXO_BUF_CACHE[a] = u, u;
      }
    },
    set(i) {
      o.__NON_WITNESS_UTXO_BUF_CACHE[a] = i;
    }
  });
}
function hO(e, t, r, n) {
  let o = 0n;
  e.forEach((u, l) => {
    if (n && u.finalScriptSig && (t.ins[l].script = u.finalScriptSig), n && u.finalScriptWitness && (t.ins[l].witness = dO(
      u.finalScriptWitness
    )), u.witnessUtxo)
      o += u.witnessUtxo.value;
    else if (u.nonWitnessUtxo) {
      const c = Dy(r, u, l), f = t.ins[l].index, h = c.outs[f];
      o += h.value;
    }
  });
  const a = t.outs.reduce((u, l) => u + l.value, 0n), i = o - a;
  if (i < 0)
    throw new Error("Outputs are spending more than Inputs");
  const s = t.virtualSize();
  r.__FEE = i, r.__EXTRACTED_TX = t, r.__FEE_RATE = Math.floor(Number(i / BigInt(s)));
}
function Dy(e, t, r) {
  const n = e.__NON_WITNESS_UTXO_TX_CACHE;
  return n[r] || Dv(e, t, r), n[r];
}
function pO(e, t, r) {
  const { script: n } = F5(e, t, r);
  return n;
}
function F5(e, t, r) {
  if (t.witnessUtxo !== void 0)
    return {
      script: t.witnessUtxo.script,
      value: t.witnessUtxo.value
    };
  if (t.nonWitnessUtxo !== void 0) {
    const n = Dy(
      r,
      t,
      e
    ).outs[r.__TX.ins[e].index];
    return { script: n.script, value: n.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function jae(e, t, r, n) {
  const o = pO(r, t, n), { meaningfulScript: a } = My(
    o,
    r,
    "input",
    t.redeemScript,
    t.witnessScript
  );
  return Fy(e, a);
}
function Lae(e, t, r, n) {
  const o = n.__TX.outs[r].script, { meaningfulScript: a } = My(
    o,
    r,
    "output",
    t.redeemScript,
    t.witnessScript
  );
  return Fy(e, a);
}
function Hae(e) {
  if (!e) return;
  const t = dr(e);
  if (!t) return;
  const r = t[t.length - 1];
  if (!(!(r instanceof Uint8Array) || gO(r) || Mae(r) || !dr(r)))
    return r;
}
function Fae(e) {
  if (!e) return;
  const t = dO(e), r = t[t.length - 1];
  if (!(gO(r) || !dr(r)))
    return r;
}
function Dae(e) {
  if (e.length === 65) {
    const t = e[64] & 1, r = e.slice(0, 33);
    return r[0] = 2 | t, r;
  }
  return e.slice();
}
function gO(e) {
  return e.length === 33 && yne(e);
}
function Mae(e) {
  return cs(e);
}
function My(e, t, r, n, o) {
  const a = eO(e), i = a && n && V7(n), s = V7(e);
  if (a && n === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((s || i) && o === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let u;
  return i ? (u = o, J7(t, e, n, r), Q7(t, n, o, r), Kg(u)) : s ? (u = o, Q7(t, e, o, r), Kg(u)) : a ? (u = n, J7(t, e, n, r)) : u = e, {
    meaningfulScript: u,
    type: i ? "p2sh-p2wsh" : a ? "p2sh" : s ? "p2wsh" : "raw"
  };
}
function Kg(e) {
  if (Hy(e) || eO(e))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function mO(e) {
  return Hy(e) ? "witnesspubkeyhash" : iae(e) ? "pubkeyhash" : nae(e) ? "multisig" : oae(e) ? "pubkey" : "nonstandard";
}
function Md(e) {
  return [...Array(e).keys()];
}
let yO = class extends TP {
  constructor(e, t) {
    super(), this.finished = !1, this.destroyed = !1, wne(e);
    const r = T5(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const n = this.blockLen, o = new Uint8Array(n);
    o.set(r.length > n ? e.create().update(r).digest() : r);
    for (let a = 0; a < o.length; a++)
      o[a] ^= 54;
    this.iHash.update(o), this.oHash = e.create();
    for (let a = 0; a < o.length; a++)
      o[a] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(e) {
    return Lg(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Lg(this), jy(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: r, finished: n, destroyed: o, blockLen: a, outputLen: i } = this;
    return e = e, e.finished = n, e.destroyed = o, e.blockLen = a, e.outputLen = i, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const D5 = (e, t, r) => new yO(e, t).update(r).digest();
D5.create = (e, t) => new yO(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const M5 = /* @__PURE__ */ BigInt(0), Ky = /* @__PURE__ */ BigInt(1), Kae = /* @__PURE__ */ BigInt(2);
function Wc(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function Zp(e) {
  if (!Wc(e))
    throw new Error("Uint8Array expected");
}
function Bf(e, t) {
  if (typeof t != "boolean")
    throw new Error(`${e} must be valid boolean, got "${t}".`);
}
const qae = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Nf(e) {
  Zp(e);
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += qae[e[r]];
  return t;
}
function Jl(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function K5(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
const Ua = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function o9(e) {
  if (e >= Ua._0 && e <= Ua._9)
    return e - Ua._0;
  if (e >= Ua._A && e <= Ua._F)
    return e - (Ua._A - 10);
  if (e >= Ua._a && e <= Ua._f)
    return e - (Ua._a - 10);
}
function Uf(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(r);
  for (let o = 0, a = 0; o < r; o++, a += 2) {
    const i = o9(e.charCodeAt(a)), s = o9(e.charCodeAt(a + 1));
    if (i === void 0 || s === void 0) {
      const u = e[a] + e[a + 1];
      throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + a);
    }
    n[o] = i * 16 + s;
  }
  return n;
}
function Rc(e) {
  return K5(Nf(e));
}
function q5(e) {
  return Zp(e), K5(Nf(Uint8Array.from(e).reverse()));
}
function Rf(e, t) {
  return Uf(e.toString(16).padStart(t * 2, "0"));
}
function V5(e, t) {
  return Rf(e, t).reverse();
}
function Vae(e) {
  return Uf(Jl(e));
}
function ai(e, t, r) {
  let n;
  if (typeof t == "string")
    try {
      n = Uf(t);
    } catch (a) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${a}`);
    }
  else if (Wc(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const o = n.length;
  if (typeof r == "number" && o !== r)
    throw new Error(`${e} expected ${r} bytes, got ${o}`);
  return n;
}
function Gh(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const o = e[n];
    Zp(o), t += o.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, o = 0; n < e.length; n++) {
    const a = e[n];
    r.set(a, o), o += a.length;
  }
  return r;
}
function Gae(e, t) {
  if (e.length !== t.length)
    return !1;
  let r = 0;
  for (let n = 0; n < e.length; n++)
    r |= e[n] ^ t[n];
  return r === 0;
}
function Zae(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
const q2 = (e) => typeof e == "bigint" && M5 <= e;
function qy(e, t, r) {
  return q2(e) && q2(t) && q2(r) && t <= e && e < r;
}
function zc(e, t, r, n) {
  if (!qy(t, r, n))
    throw new Error(`expected valid ${e}: ${r} <= n < ${n}, got ${typeof t} ${t}`);
}
function bO(e) {
  let t;
  for (t = 0; e > M5; e >>= Ky, t += 1)
    ;
  return t;
}
function Wae(e, t) {
  return e >> BigInt(t) & Ky;
}
function Xae(e, t, r) {
  return e | (r ? Ky : M5) << BigInt(t);
}
const G5 = (e) => (Kae << BigInt(e - 1)) - Ky, V2 = (e) => new Uint8Array(e), i9 = (e) => Uint8Array.from(e);
function wO(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = V2(e), o = V2(e), a = 0;
  const i = () => {
    n.fill(1), o.fill(0), a = 0;
  }, s = (...c) => r(o, n, ...c), u = (c = V2()) => {
    o = s(i9([0]), c), n = s(), c.length !== 0 && (o = s(i9([1]), c), n = s());
  }, l = () => {
    if (a++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let c = 0;
    const f = [];
    for (; c < t; ) {
      n = s();
      const h = n.slice();
      f.push(h), c += n.length;
    }
    return Gh(...f);
  };
  return (c, f) => {
    i(), u(c);
    let h;
    for (; !(h = f(l())); )
      u();
    return i(), h;
  };
}
const Yae = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || Wc(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function Wp(e, t, r = {}) {
  const n = (o, a, i) => {
    const s = Yae[a];
    if (typeof s != "function")
      throw new Error(`Invalid validator "${a}", expected function`);
    const u = e[o];
    if (!(i && u === void 0) && !s(u, e))
      throw new Error(`Invalid param ${String(o)}=${u} (${typeof u}), expected ${a}`);
  };
  for (const [o, a] of Object.entries(t))
    n(o, a, !1);
  for (const [o, a] of Object.entries(r))
    n(o, a, !0);
  return e;
}
const Jae = () => {
  throw new Error("not implemented");
};
function Mv(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...n) => {
    const o = t.get(r);
    if (o !== void 0)
      return o;
    const a = e(r, ...n);
    return t.set(r, a), a;
  };
}
const Qae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aInRange: zc,
  abool: Bf,
  abytes: Zp,
  bitGet: Wae,
  bitLen: bO,
  bitMask: G5,
  bitSet: Xae,
  bytesToHex: Nf,
  bytesToNumberBE: Rc,
  bytesToNumberLE: q5,
  concatBytes: Gh,
  createHmacDrbg: wO,
  ensureBytes: ai,
  equalBytes: Gae,
  hexToBytes: Uf,
  hexToNumber: K5,
  inRange: qy,
  isBytes: Wc,
  memoized: Mv,
  notImplemented: Jae,
  numberToBytesBE: Rf,
  numberToBytesLE: V5,
  numberToHexUnpadded: Jl,
  numberToVarBytesBE: Vae,
  utf8ToBytes: Zae,
  validateObject: Wp
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const an = BigInt(0), Or = BigInt(1), mc = BigInt(2), ese = BigInt(3), Kv = BigInt(4), a9 = BigInt(5), s9 = BigInt(8);
BigInt(9);
BigInt(16);
function On(e, t) {
  const r = e % t;
  return r >= an ? r : t + r;
}
function tse(e, t, r) {
  if (r <= an || t < an)
    throw new Error("Expected power/modulo > 0");
  if (r === Or)
    return an;
  let n = Or;
  for (; t > an; )
    t & Or && (n = n * e % r), e = e * e % r, t >>= Or;
  return n;
}
function Lo(e, t, r) {
  let n = e;
  for (; t-- > an; )
    n *= n, n %= r;
  return n;
}
function qv(e, t) {
  if (e === an || t <= an)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = On(e, t), n = t, o = an, a = Or;
  for (; r !== an; ) {
    const i = n / r, s = n % r, u = o - a * i;
    n = r, r = s, o = a, a = u;
  }
  if (n !== Or)
    throw new Error("invert: does not exist");
  return On(o, t);
}
function rse(e) {
  const t = (e - Or) / mc;
  let r, n, o;
  for (r = e - Or, n = 0; r % mc === an; r /= mc, n++)
    ;
  for (o = mc; o < e && tse(o, t, e) !== e - Or; o++)
    ;
  if (n === 1) {
    const i = (e + Or) / Kv;
    return function(s, u) {
      const l = s.pow(u, i);
      if (!s.eql(s.sqr(l), u))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  const a = (r + Or) / mc;
  return function(i, s) {
    if (i.pow(s, t) === i.neg(i.ONE))
      throw new Error("Cannot find square root");
    let u = n, l = i.pow(i.mul(i.ONE, o), r), c = i.pow(s, a), f = i.pow(s, r);
    for (; !i.eql(f, i.ONE); ) {
      if (i.eql(f, i.ZERO))
        return i.ZERO;
      let h = 1;
      for (let y = i.sqr(f); h < u && !i.eql(y, i.ONE); h++)
        y = i.sqr(y);
      const p = i.pow(l, Or << BigInt(u - h - 1));
      l = i.sqr(p), c = i.mul(c, p), f = i.mul(f, l), u = h;
    }
    return c;
  };
}
function nse(e) {
  if (e % Kv === ese) {
    const t = (e + Or) / Kv;
    return function(r, n) {
      const o = r.pow(n, t);
      if (!r.eql(r.sqr(o), n))
        throw new Error("Cannot find square root");
      return o;
    };
  }
  if (e % s9 === a9) {
    const t = (e - a9) / s9;
    return function(r, n) {
      const o = r.mul(n, mc), a = r.pow(o, t), i = r.mul(n, a), s = r.mul(r.mul(i, mc), a), u = r.mul(i, r.sub(s, r.ONE));
      if (!r.eql(r.sqr(u), n))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return rse(e);
}
const ose = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function ise(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = ose.reduce((n, o) => (n[o] = "function", n), t);
  return Wp(e, r);
}
function ase(e, t, r) {
  if (r < an)
    throw new Error("Expected power > 0");
  if (r === an)
    return e.ONE;
  if (r === Or)
    return t;
  let n = e.ONE, o = t;
  for (; r > an; )
    r & Or && (n = e.mul(n, o)), o = e.sqr(o), r >>= Or;
  return n;
}
function sse(e, t) {
  const r = new Array(t.length), n = t.reduce((a, i, s) => e.is0(i) ? a : (r[s] = a, e.mul(a, i)), e.ONE), o = e.inv(n);
  return t.reduceRight((a, i, s) => e.is0(i) ? a : (r[s] = e.mul(a, r[s]), e.mul(a, i)), o), r;
}
function vO(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function Z5(e, t, r = !1, n = {}) {
  if (e <= an)
    throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: o, nByteLength: a } = vO(e, t);
  if (a > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const i = nse(e), s = Object.freeze({
    ORDER: e,
    BITS: o,
    BYTES: a,
    MASK: G5(o),
    ZERO: an,
    ONE: Or,
    create: (u) => On(u, e),
    isValid: (u) => {
      if (typeof u != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof u}`);
      return an <= u && u < e;
    },
    is0: (u) => u === an,
    isOdd: (u) => (u & Or) === Or,
    neg: (u) => On(-u, e),
    eql: (u, l) => u === l,
    sqr: (u) => On(u * u, e),
    add: (u, l) => On(u + l, e),
    sub: (u, l) => On(u - l, e),
    mul: (u, l) => On(u * l, e),
    pow: (u, l) => ase(s, u, l),
    div: (u, l) => On(u * qv(l, e), e),
    // Same as above, but doesn't normalize
    sqrN: (u) => u * u,
    addN: (u, l) => u + l,
    subN: (u, l) => u - l,
    mulN: (u, l) => u * l,
    inv: (u) => qv(u, e),
    sqrt: n.sqrt || ((u) => i(s, u)),
    invertBatch: (u) => sse(s, u),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (u, l, c) => c ? l : u,
    toBytes: (u) => r ? V5(u, a) : Rf(u, a),
    fromBytes: (u) => {
      if (u.length !== a)
        throw new Error(`Fp.fromBytes: expected ${a}, got ${u.length}`);
      return r ? q5(u) : Rc(u);
    }
  });
  return Object.freeze(s);
}
function EO(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function kO(e) {
  const t = EO(e);
  return t + Math.ceil(t / 2);
}
function use(e, t, r = !1) {
  const n = e.length, o = EO(t), a = kO(t);
  if (n < 16 || n < a || n > 1024)
    throw new Error(`expected ${a}-1024 bytes of input, got ${n}`);
  const i = r ? Rc(e) : q5(e), s = On(i, t - Or) + Or;
  return r ? V5(s, o) : Rf(s, o);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const cse = BigInt(0), G2 = BigInt(1), Z2 = /* @__PURE__ */ new WeakMap(), u9 = /* @__PURE__ */ new WeakMap();
function lse(e, t) {
  const r = (a, i) => {
    const s = i.negate();
    return a ? s : i;
  }, n = (a) => {
    if (!Number.isSafeInteger(a) || a <= 0 || a > t)
      throw new Error(`Wrong window size=${a}, should be [1..${t}]`);
  }, o = (a) => {
    n(a);
    const i = Math.ceil(t / a) + 1, s = 2 ** (a - 1);
    return { windows: i, windowSize: s };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(a, i) {
      let s = e.ZERO, u = a;
      for (; i > cse; )
        i & G2 && (s = s.add(u)), u = u.double(), i >>= G2;
      return s;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(a, i) {
      const { windows: s, windowSize: u } = o(i), l = [];
      let c = a, f = c;
      for (let h = 0; h < s; h++) {
        f = c, l.push(f);
        for (let p = 1; p < u; p++)
          f = f.add(c), l.push(f);
        c = f.double();
      }
      return l;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(a, i, s) {
      const { windows: u, windowSize: l } = o(a);
      let c = e.ZERO, f = e.BASE;
      const h = BigInt(2 ** a - 1), p = 2 ** a, y = BigInt(a);
      for (let m = 0; m < u; m++) {
        const b = m * l;
        let v = Number(s & h);
        s >>= y, v > l && (v -= p, s += G2);
        const k = b, E = b + Math.abs(v) - 1, A = m % 2 !== 0, S = v < 0;
        v === 0 ? f = f.add(r(A, i[k])) : c = c.add(r(S, i[E]));
      }
      return { p: c, f };
    },
    wNAFCached(a, i, s) {
      const u = u9.get(a) || 1;
      let l = Z2.get(a);
      return l || (l = this.precomputeWindow(a, u), u !== 1 && Z2.set(a, s(l))), this.wNAF(u, l, i);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(a, i) {
      n(i), u9.set(a, i), Z2.delete(a);
    }
  };
}
function fse(e, t, r, n) {
  if (!Array.isArray(r) || !Array.isArray(n) || n.length !== r.length)
    throw new Error("arrays of points and scalars must have equal length");
  n.forEach((c, f) => {
    if (!t.isValid(c))
      throw new Error(`wrong scalar at index ${f}`);
  }), r.forEach((c, f) => {
    if (!(c instanceof e))
      throw new Error(`wrong point at index ${f}`);
  });
  const o = bO(BigInt(r.length)), a = o > 12 ? o - 3 : o > 4 ? o - 2 : o ? 2 : 1, i = (1 << a) - 1, s = new Array(i + 1).fill(e.ZERO), u = Math.floor((t.BITS - 1) / a) * a;
  let l = e.ZERO;
  for (let c = u; c >= 0; c -= a) {
    s.fill(e.ZERO);
    for (let h = 0; h < n.length; h++) {
      const p = n[h], y = Number(p >> BigInt(c) & BigInt(i));
      s[y] = s[y].add(r[h]);
    }
    let f = e.ZERO;
    for (let h = s.length - 1, p = e.ZERO; h > 0; h--)
      p = p.add(s[h]), f = f.add(p);
    if (l = l.add(f), c !== 0)
      for (let h = 0; h < a; h++)
        l = l.double();
  }
  return l;
}
function xO(e) {
  return ise(e.Fp), Wp(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...vO(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function c9(e) {
  e.lowS !== void 0 && Bf("lowS", e.lowS), e.prehash !== void 0 && Bf("prehash", e.prehash);
}
function dse(e) {
  const t = xO(e);
  Wp(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: n, a: o } = t;
  if (r) {
    if (!n.eql(o, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: hse, hexToBytes: pse } = Qae, Va = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: r } = Va;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const n = t.length / 2, o = Jl(n);
      if (o.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const a = n > 127 ? Jl(o.length / 2 | 128) : "";
      return `${Jl(e)}${a}${o}${t}`;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: r } = Va;
      let n = 0;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[n++] !== e)
        throw new r("tlv.decode: wrong tlv");
      const o = t[n++], a = !!(o & 128);
      let i = 0;
      if (!a)
        i = o;
      else {
        const u = o & 127;
        if (!u)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (u > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const l = t.subarray(n, n + u);
        if (l.length !== u)
          throw new r("tlv.decode: length bytes not complete");
        if (l[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const c of l)
          i = i << 8 | c;
        if (n += u, i < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const s = t.subarray(n, n + i);
      if (s.length !== i)
        throw new r("tlv.decode: wrong value length");
      return { v: s, l: t.subarray(n + i) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = Va;
      if (e < Za)
        throw new t("integer: negative integers are not allowed");
      let r = Jl(e);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected assertion");
      return r;
    },
    decode(e) {
      const { Err: t } = Va;
      if (e[0] & 128)
        throw new t("Invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("Invalid signature integer: unnecessary leading zero");
      return hse(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: r, _tlv: n } = Va, o = typeof e == "string" ? pse(e) : e;
    Zp(o);
    const { v: a, l: i } = n.decode(48, o);
    if (i.length)
      throw new t("Invalid signature: left bytes after parsing");
    const { v: s, l: u } = n.decode(2, a), { v: l, l: c } = n.decode(2, u);
    if (c.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: r.decode(s), s: r.decode(l) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: r } = Va, n = `${t.encode(2, r.encode(e.r))}${t.encode(2, r.encode(e.s))}`;
    return t.encode(48, n);
  }
}, Za = BigInt(0), Yr = BigInt(1);
BigInt(2);
const l9 = BigInt(3);
BigInt(4);
function gse(e) {
  const t = dse(e), { Fp: r } = t, n = Z5(t.n, t.nBitLength), o = t.toBytes || ((m, b, v) => {
    const k = b.toAffine();
    return Gh(Uint8Array.from([4]), r.toBytes(k.x), r.toBytes(k.y));
  }), a = t.fromBytes || ((m) => {
    const b = m.subarray(1), v = r.fromBytes(b.subarray(0, r.BYTES)), k = r.fromBytes(b.subarray(r.BYTES, 2 * r.BYTES));
    return { x: v, y: k };
  });
  function i(m) {
    const { a: b, b: v } = t, k = r.sqr(m), E = r.mul(k, m);
    return r.add(r.add(E, r.mul(m, b)), v);
  }
  if (!r.eql(r.sqr(t.Gy), i(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function s(m) {
    return qy(m, Yr, t.n);
  }
  function u(m) {
    const { allowedPrivateKeyLengths: b, nByteLength: v, wrapPrivateKey: k, n: E } = t;
    if (b && typeof m != "bigint") {
      if (Wc(m) && (m = Nf(m)), typeof m != "string" || !b.includes(m.length))
        throw new Error("Invalid key");
      m = m.padStart(v * 2, "0");
    }
    let A;
    try {
      A = typeof m == "bigint" ? m : Rc(ai("private key", m, v));
    } catch {
      throw new Error(`private key must be ${v} bytes, hex or bigint, not ${typeof m}`);
    }
    return k && (A = On(A, E)), zc("private key", A, Yr, E), A;
  }
  function l(m) {
    if (!(m instanceof h))
      throw new Error("ProjectivePoint expected");
  }
  const c = Mv((m, b) => {
    const { px: v, py: k, pz: E } = m;
    if (r.eql(E, r.ONE))
      return { x: v, y: k };
    const A = m.is0();
    b == null && (b = A ? r.ONE : r.inv(E));
    const S = r.mul(v, b), _ = r.mul(k, b), I = r.mul(E, b);
    if (A)
      return { x: r.ZERO, y: r.ZERO };
    if (!r.eql(I, r.ONE))
      throw new Error("invZ was invalid");
    return { x: S, y: _ };
  }), f = Mv((m) => {
    if (m.is0()) {
      if (t.allowInfinityPoint && !r.is0(m.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: b, y: v } = m.toAffine();
    if (!r.isValid(b) || !r.isValid(v))
      throw new Error("bad point: x or y not FE");
    const k = r.sqr(v), E = i(b);
    if (!r.eql(k, E))
      throw new Error("bad point: equation left != right");
    if (!m.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  class h {
    constructor(b, v, k) {
      if (this.px = b, this.py = v, this.pz = k, b == null || !r.isValid(b))
        throw new Error("x required");
      if (v == null || !r.isValid(v))
        throw new Error("y required");
      if (k == null || !r.isValid(k))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(b) {
      const { x: v, y: k } = b || {};
      if (!b || !r.isValid(v) || !r.isValid(k))
        throw new Error("invalid affine point");
      if (b instanceof h)
        throw new Error("projective point not allowed");
      const E = (A) => r.eql(A, r.ZERO);
      return E(v) && E(k) ? h.ZERO : new h(v, k, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(b) {
      const v = r.invertBatch(b.map((k) => k.pz));
      return b.map((k, E) => k.toAffine(v[E])).map(h.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(b) {
      const v = h.fromAffine(a(ai("pointHex", b)));
      return v.assertValidity(), v;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(b) {
      return h.BASE.multiply(u(b));
    }
    // Multiscalar Multiplication
    static msm(b, v) {
      return fse(h, n, b, v);
    }
    // "Private method", don't use it directly
    _setWindowSize(b) {
      y.setWindowSize(this, b);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      f(this);
    }
    hasEvenY() {
      const { y: b } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(b);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(b) {
      l(b);
      const { px: v, py: k, pz: E } = this, { px: A, py: S, pz: _ } = b, I = r.eql(r.mul(v, _), r.mul(A, E)), O = r.eql(r.mul(k, _), r.mul(S, E));
      return I && O;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new h(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: b, b: v } = t, k = r.mul(v, l9), { px: E, py: A, pz: S } = this;
      let _ = r.ZERO, I = r.ZERO, O = r.ZERO, z = r.mul(E, E), D = r.mul(A, A), G = r.mul(S, S), U = r.mul(E, A);
      return U = r.add(U, U), O = r.mul(E, S), O = r.add(O, O), _ = r.mul(b, O), I = r.mul(k, G), I = r.add(_, I), _ = r.sub(D, I), I = r.add(D, I), I = r.mul(_, I), _ = r.mul(U, _), O = r.mul(k, O), G = r.mul(b, G), U = r.sub(z, G), U = r.mul(b, U), U = r.add(U, O), O = r.add(z, z), z = r.add(O, z), z = r.add(z, G), z = r.mul(z, U), I = r.add(I, z), G = r.mul(A, S), G = r.add(G, G), z = r.mul(G, U), _ = r.sub(_, z), O = r.mul(G, D), O = r.add(O, O), O = r.add(O, O), new h(_, I, O);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(b) {
      l(b);
      const { px: v, py: k, pz: E } = this, { px: A, py: S, pz: _ } = b;
      let I = r.ZERO, O = r.ZERO, z = r.ZERO;
      const D = t.a, G = r.mul(t.b, l9);
      let U = r.mul(v, A), V = r.mul(k, S), F = r.mul(E, _), C = r.add(v, k), R = r.add(A, S);
      C = r.mul(C, R), R = r.add(U, V), C = r.sub(C, R), R = r.add(v, E);
      let M = r.add(A, _);
      return R = r.mul(R, M), M = r.add(U, F), R = r.sub(R, M), M = r.add(k, E), I = r.add(S, _), M = r.mul(M, I), I = r.add(V, F), M = r.sub(M, I), z = r.mul(D, R), I = r.mul(G, F), z = r.add(I, z), I = r.sub(V, z), z = r.add(V, z), O = r.mul(I, z), V = r.add(U, U), V = r.add(V, U), F = r.mul(D, F), R = r.mul(G, R), V = r.add(V, F), F = r.sub(U, F), F = r.mul(D, F), R = r.add(R, F), U = r.mul(V, R), O = r.add(O, U), U = r.mul(M, R), I = r.mul(C, I), I = r.sub(I, U), U = r.mul(C, V), z = r.mul(M, z), z = r.add(z, U), new h(I, O, z);
    }
    subtract(b) {
      return this.add(b.negate());
    }
    is0() {
      return this.equals(h.ZERO);
    }
    wNAF(b) {
      return y.wNAFCached(this, b, h.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(b) {
      zc("scalar", b, Za, t.n);
      const v = h.ZERO;
      if (b === Za)
        return v;
      if (b === Yr)
        return this;
      const { endo: k } = t;
      if (!k)
        return y.unsafeLadder(this, b);
      let { k1neg: E, k1: A, k2neg: S, k2: _ } = k.splitScalar(b), I = v, O = v, z = this;
      for (; A > Za || _ > Za; )
        A & Yr && (I = I.add(z)), _ & Yr && (O = O.add(z)), z = z.double(), A >>= Yr, _ >>= Yr;
      return E && (I = I.negate()), S && (O = O.negate()), O = new h(r.mul(O.px, k.beta), O.py, O.pz), I.add(O);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(b) {
      const { endo: v, n: k } = t;
      zc("scalar", b, Yr, k);
      let E, A;
      if (v) {
        const { k1neg: S, k1: _, k2neg: I, k2: O } = v.splitScalar(b);
        let { p: z, f: D } = this.wNAF(_), { p: G, f: U } = this.wNAF(O);
        z = y.constTimeNegate(S, z), G = y.constTimeNegate(I, G), G = new h(r.mul(G.px, v.beta), G.py, G.pz), E = z.add(G), A = D.add(U);
      } else {
        const { p: S, f: _ } = this.wNAF(b);
        E = S, A = _;
      }
      return h.normalizeZ([E, A])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(b, v, k) {
      const E = h.BASE, A = (_, I) => I === Za || I === Yr || !_.equals(E) ? _.multiplyUnsafe(I) : _.multiply(I), S = A(this, v).add(A(b, k));
      return S.is0() ? void 0 : S;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(b) {
      return c(this, b);
    }
    isTorsionFree() {
      const { h: b, isTorsionFree: v } = t;
      if (b === Yr)
        return !0;
      if (v)
        return v(h, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: b, clearCofactor: v } = t;
      return b === Yr ? this : v ? v(h, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(b = !0) {
      return Bf("isCompressed", b), this.assertValidity(), o(h, this, b);
    }
    toHex(b = !0) {
      return Bf("isCompressed", b), Nf(this.toRawBytes(b));
    }
  }
  h.BASE = new h(t.Gx, t.Gy, r.ONE), h.ZERO = new h(r.ZERO, r.ONE, r.ZERO);
  const p = t.nBitLength, y = lse(h, t.endo ? Math.ceil(p / 2) : p);
  return {
    CURVE: t,
    ProjectivePoint: h,
    normPrivateKeyToScalar: u,
    weierstrassEquation: i,
    isWithinCurveOrder: s
  };
}
function mse(e) {
  const t = xO(e);
  return Wp(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function yse(e) {
  const t = mse(e), { Fp: r, n } = t, o = r.BYTES + 1, a = 2 * r.BYTES + 1;
  function i(F) {
    return On(F, n);
  }
  function s(F) {
    return qv(F, n);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: l, weierstrassEquation: c, isWithinCurveOrder: f } = gse({
    ...t,
    toBytes(F, C, R) {
      const M = C.toAffine(), re = r.toBytes(M.x), W = Gh;
      return Bf("isCompressed", R), R ? W(Uint8Array.from([C.hasEvenY() ? 2 : 3]), re) : W(Uint8Array.from([4]), re, r.toBytes(M.y));
    },
    fromBytes(F) {
      const C = F.length, R = F[0], M = F.subarray(1);
      if (C === o && (R === 2 || R === 3)) {
        const re = Rc(M);
        if (!qy(re, Yr, r.ORDER))
          throw new Error("Point is not on curve");
        const W = c(re);
        let ne;
        try {
          ne = r.sqrt(W);
        } catch (se) {
          const K = se instanceof Error ? ": " + se.message : "";
          throw new Error("Point is not on curve" + K);
        }
        const oe = (ne & Yr) === Yr;
        return (R & 1) === 1 !== oe && (ne = r.neg(ne)), { x: re, y: ne };
      } else if (C === a && R === 4) {
        const re = r.fromBytes(M.subarray(0, r.BYTES)), W = r.fromBytes(M.subarray(r.BYTES, 2 * r.BYTES));
        return { x: re, y: W };
      } else
        throw new Error(`Point of length ${C} was invalid. Expected ${o} compressed bytes or ${a} uncompressed bytes`);
    }
  }), h = (F) => Nf(Rf(F, t.nByteLength));
  function p(F) {
    const C = n >> Yr;
    return F > C;
  }
  function y(F) {
    return p(F) ? i(-F) : F;
  }
  const m = (F, C, R) => Rc(F.slice(C, R));
  class b {
    constructor(C, R, M) {
      this.r = C, this.s = R, this.recovery = M, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(C) {
      const R = t.nByteLength;
      return C = ai("compactSignature", C, R * 2), new b(m(C, 0, R), m(C, R, 2 * R));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(C) {
      const { r: R, s: M } = Va.toSig(ai("DER", C));
      return new b(R, M);
    }
    assertValidity() {
      zc("r", this.r, Yr, n), zc("s", this.s, Yr, n);
    }
    addRecoveryBit(C) {
      return new b(this.r, this.s, C);
    }
    recoverPublicKey(C) {
      const { r: R, s: M, recovery: re } = this, W = _(ai("msgHash", C));
      if (re == null || ![0, 1, 2, 3].includes(re))
        throw new Error("recovery id invalid");
      const ne = re === 2 || re === 3 ? R + t.n : R;
      if (ne >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const oe = re & 1 ? "03" : "02", se = u.fromHex(oe + h(ne)), K = s(ne), he = i(-W * K), Ae = i(M * K), ye = u.BASE.multiplyAndAddUnsafe(se, he, Ae);
      if (!ye)
        throw new Error("point at infinify");
      return ye.assertValidity(), ye;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return p(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new b(this.r, i(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Uf(this.toDERHex());
    }
    toDERHex() {
      return Va.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Uf(this.toCompactHex());
    }
    toCompactHex() {
      return h(this.r) + h(this.s);
    }
  }
  const v = {
    isValidPrivateKey(F) {
      try {
        return l(F), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: l,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const F = kO(t.n);
      return use(t.randomBytes(F), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(F = 8, C = u.BASE) {
      return C._setWindowSize(F), C.multiply(BigInt(3)), C;
    }
  };
  function k(F, C = !0) {
    return u.fromPrivateKey(F).toRawBytes(C);
  }
  function E(F) {
    const C = Wc(F), R = typeof F == "string", M = (C || R) && F.length;
    return C ? M === o || M === a : R ? M === 2 * o || M === 2 * a : F instanceof u;
  }
  function A(F, C, R = !0) {
    if (E(F))
      throw new Error("first arg must be private key");
    if (!E(C))
      throw new Error("second arg must be public key");
    return u.fromHex(C).multiply(l(F)).toRawBytes(R);
  }
  const S = t.bits2int || function(F) {
    const C = Rc(F), R = F.length * 8 - t.nBitLength;
    return R > 0 ? C >> BigInt(R) : C;
  }, _ = t.bits2int_modN || function(F) {
    return i(S(F));
  }, I = G5(t.nBitLength);
  function O(F) {
    return zc(`num < 2^${t.nBitLength}`, F, Za, I), Rf(F, t.nByteLength);
  }
  function z(F, C, R = D) {
    if (["recovered", "canonical"].some((Ge) => Ge in R))
      throw new Error("sign() legacy options not supported");
    const { hash: M, randomBytes: re } = t;
    let { lowS: W, prehash: ne, extraEntropy: oe } = R;
    W == null && (W = !0), F = ai("msgHash", F), c9(R), ne && (F = ai("prehashed msgHash", M(F)));
    const se = _(F), K = l(C), he = [O(K), O(se)];
    if (oe != null && oe !== !1) {
      const Ge = oe === !0 ? re(r.BYTES) : oe;
      he.push(ai("extraEntropy", Ge));
    }
    const Ae = Gh(...he), ye = se;
    function Et(Ge) {
      const be = S(Ge);
      if (!f(be))
        return;
      const st = s(be), Ze = u.BASE.multiply(be).toAffine(), We = i(Ze.x);
      if (We === Za)
        return;
      const Re = i(st * i(ye + We * K));
      if (Re === Za)
        return;
      let Tt = (Ze.x === We ? 0 : 2) | Number(Ze.y & Yr), xr = Re;
      return W && p(Re) && (xr = y(Re), Tt ^= 1), new b(We, xr, Tt);
    }
    return { seed: Ae, k2sig: Et };
  }
  const D = { lowS: t.lowS, prehash: !1 }, G = { lowS: t.lowS, prehash: !1 };
  function U(F, C, R = D) {
    const { seed: M, k2sig: re } = z(F, C, R), W = t;
    return wO(W.hash.outputLen, W.nByteLength, W.hmac)(M, re);
  }
  u.BASE._setWindowSize(8);
  function V(F, C, R, M = G) {
    var re;
    const W = F;
    if (C = ai("msgHash", C), R = ai("publicKey", R), "strict" in M)
      throw new Error("options.strict was renamed to lowS");
    c9(M);
    const { lowS: ne, prehash: oe } = M;
    let se, K;
    try {
      if (typeof W == "string" || Wc(W))
        try {
          se = b.fromDER(W);
        } catch (Ze) {
          if (!(Ze instanceof Va.Err))
            throw Ze;
          se = b.fromCompact(W);
        }
      else if (typeof W == "object" && typeof W.r == "bigint" && typeof W.s == "bigint") {
        const { r: Ze, s: We } = W;
        se = new b(Ze, We);
      } else
        throw new Error("PARSE");
      K = u.fromHex(R);
    } catch (Ze) {
      if (Ze.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (ne && se.hasHighS())
      return !1;
    oe && (C = t.hash(C));
    const { r: he, s: Ae } = se, ye = _(C), Et = s(Ae), Ge = i(ye * Et), be = i(he * Et), st = (re = u.BASE.multiplyAndAddUnsafe(K, Ge, be)) == null ? void 0 : re.toAffine();
    return st ? i(st.x) === he : !1;
  }
  return {
    CURVE: t,
    getPublicKey: k,
    getSharedSecret: A,
    sign: U,
    verify: V,
    ProjectivePoint: u,
    Signature: b,
    utils: v
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function bse(e) {
  return {
    hash: e,
    hmac: (t, ...r) => D5(e, t, kne(...r)),
    randomBytes: xne
  };
}
function wse(e, t) {
  const r = (n) => yse({ ...e, ...bse(n) });
  return Object.freeze({ ...r(t), create: r });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const AO = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), f9 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), vse = BigInt(1), Vv = BigInt(2), d9 = (e, t) => (e + t / Vv) / t;
function Ese(e) {
  const t = AO, r = BigInt(3), n = BigInt(6), o = BigInt(11), a = BigInt(22), i = BigInt(23), s = BigInt(44), u = BigInt(88), l = e * e * e % t, c = l * l * e % t, f = Lo(c, r, t) * c % t, h = Lo(f, r, t) * c % t, p = Lo(h, Vv, t) * l % t, y = Lo(p, o, t) * p % t, m = Lo(y, a, t) * y % t, b = Lo(m, s, t) * m % t, v = Lo(b, u, t) * b % t, k = Lo(v, s, t) * m % t, E = Lo(k, r, t) * c % t, A = Lo(E, i, t) * y % t, S = Lo(A, n, t) * l % t, _ = Lo(S, Vv, t);
  if (!Gv.eql(Gv.sqr(_), e))
    throw new Error("Cannot find square root");
  return _;
}
const Gv = Z5(AO, void 0, void 0, { sqrt: Ese }), Xc = wse({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Gv,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: f9,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = f9, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -vse * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), a = r, i = BigInt("0x100000000000000000000000000000000"), s = d9(a * e, t), u = d9(-n * e, t);
      let l = On(e - s * r - u * o, t), c = On(-s * n - u * a, t);
      const f = l > i, h = c > i;
      if (f && (l = t - l), h && (c = t - c), l > i || c > i)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: f, k1: l, k2neg: h, k2: c };
    }
  }
}, tn);
BigInt(0);
Xc.ProjectivePoint;
function kse(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function h9(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function xse(e, t) {
  kse(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ase = (e) => e instanceof Uint8Array, W2 = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Gi = (e, t) => e << 32 - t | e >>> t, Sse = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Sse)
  throw new Error("Non little-endian hardware is not supported");
function _se(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function SO(e) {
  if (typeof e == "string" && (e = _se(e)), !Ase(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
let Ise = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function Tse(e) {
  const t = (n) => e().update(SO(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function Pse(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
let Ose = class extends Ise {
  constructor(e, t, r, n) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = W2(this.buffer);
  }
  update(e) {
    h9(this);
    const { view: t, buffer: r, blockLen: n } = this;
    e = SO(e);
    const o = e.length;
    for (let a = 0; a < o; ) {
      const i = Math.min(n - this.pos, o - a);
      if (i === n) {
        const s = W2(e);
        for (; n <= o - a; a += n)
          this.process(s, a);
        continue;
      }
      r.set(e.subarray(a, a + i), this.pos), this.pos += i, a += i, this.pos === n && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    h9(this), xse(e, this), this.finished = !0;
    const { buffer: t, view: r, blockLen: n, isLE: o } = this;
    let { pos: a } = this;
    t[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > n - a && (this.process(r, 0), a = 0);
    for (let c = a; c < n; c++)
      t[c] = 0;
    Pse(r, n - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const i = W2(e), s = this.outputLen;
    if (s % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = s / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let c = 0; c < u; c++)
      i.setUint32(4 * c, l[c], o);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: n, finished: o, destroyed: a, pos: i } = this;
    return e.length = n, e.pos = i, e.finished = o, e.destroyed = a, n % t && e.buffer.set(r), e;
  }
};
const $se = (e, t, r) => e & t ^ ~e & r, Cse = (e, t, r) => e & t ^ e & r ^ t & r, Bse = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Ws = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Xs = /* @__PURE__ */ new Uint32Array(64);
let Nse = class extends Ose {
  constructor() {
    super(64, 32, 8, !1), this.A = Ws[0] | 0, this.B = Ws[1] | 0, this.C = Ws[2] | 0, this.D = Ws[3] | 0, this.E = Ws[4] | 0, this.F = Ws[5] | 0, this.G = Ws[6] | 0, this.H = Ws[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: n, E: o, F: a, G: i, H: s } = this;
    return [e, t, r, n, o, a, i, s];
  }
  // prettier-ignore
  set(e, t, r, n, o, a, i, s) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = o | 0, this.F = a | 0, this.G = i | 0, this.H = s | 0;
  }
  process(e, t) {
    for (let c = 0; c < 16; c++, t += 4)
      Xs[c] = e.getUint32(t, !1);
    for (let c = 16; c < 64; c++) {
      const f = Xs[c - 15], h = Xs[c - 2], p = Gi(f, 7) ^ Gi(f, 18) ^ f >>> 3, y = Gi(h, 17) ^ Gi(h, 19) ^ h >>> 10;
      Xs[c] = y + Xs[c - 7] + p + Xs[c - 16] | 0;
    }
    let { A: r, B: n, C: o, D: a, E: i, F: s, G: u, H: l } = this;
    for (let c = 0; c < 64; c++) {
      const f = Gi(i, 6) ^ Gi(i, 11) ^ Gi(i, 25), h = l + f + $se(i, s, u) + Bse[c] + Xs[c] | 0, p = (Gi(r, 2) ^ Gi(r, 13) ^ Gi(r, 22)) + Cse(r, n, o) | 0;
      l = u, u = s, s = i, i = a + h | 0, a = o, o = n, n = r, r = h + p | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, i = i + this.E | 0, s = s + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, n, o, a, i, s, u, l);
  }
  roundClean() {
    Xs.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const Zv = /* @__PURE__ */ Tse(() => new Nse());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// @__NO_SIDE_EFFECTS__
function Xp(...e) {
  const t = (o, a) => (i) => o(a(i)), r = Array.from(e).reverse().reduce((o, a) => o ? t(o, a.encode) : a.encode, void 0), n = e.reduce((o, a) => o ? t(o, a.decode) : a.decode, void 0);
  return { encode: r, decode: n };
}
// @__NO_SIDE_EFFECTS__
function Vy(e) {
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return t.map((r) => {
        if (r < 0 || r >= e.length)
          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
        return e[r];
      });
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return t.map((r) => {
        if (typeof r != "string")
          throw new Error(`alphabet.decode: not string element=${r}`);
        const n = e.indexOf(r);
        if (n === -1)
          throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
        return n;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function Gy(e = "") {
  if (typeof e != "string")
    throw new Error("join separator should be string");
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let r of t)
        if (typeof r != "string")
          throw new Error(`join.encode: non-string input=${r}`);
      return t.join(e);
    },
    decode: (t) => {
      if (typeof t != "string")
        throw new Error("join.decode input should be string");
      return t.split(e);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function _O(e, t = "=") {
  if (typeof t != "string")
    throw new Error("padding chr should be string");
  return {
    encode(r) {
      if (!Array.isArray(r) || r.length && typeof r[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let n of r)
        if (typeof n != "string")
          throw new Error(`padding.encode: non-string input=${n}`);
      for (; r.length * e % 8; )
        r.push(t);
      return r;
    },
    decode(r) {
      if (!Array.isArray(r) || r.length && typeof r[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let o of r)
        if (typeof o != "string")
          throw new Error(`padding.decode: non-string input=${o}`);
      let n = r.length;
      if (n * e % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; n > 0 && r[n - 1] === t; n--)
        if (!((n - 1) * e % 8))
          throw new Error("Invalid padding: string has too much padding");
      return r.slice(0, n);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function p9(e, t, r) {
  if (t < 2)
    throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
  if (!Array.isArray(e))
    throw new Error("convertRadix: data should be array");
  if (!e.length)
    return [];
  let n = 0;
  const o = [], a = Array.from(e);
  for (a.forEach((i) => {
    if (i < 0 || i >= t)
      throw new Error(`Wrong integer: ${i}`);
  }); ; ) {
    let i = 0, s = !0;
    for (let u = n; u < a.length; u++) {
      const l = a[u], c = t * i + l;
      if (!Number.isSafeInteger(c) || t * i / t !== i || c - l !== t * i)
        throw new Error("convertRadix: carry overflow");
      i = c % r;
      const f = Math.floor(c / r);
      if (a[u] = f, !Number.isSafeInteger(f) || f * r + i !== c)
        throw new Error("convertRadix: carry overflow");
      if (s)
        f ? s = !1 : n = u;
      else continue;
    }
    if (o.push(i), s)
      break;
  }
  for (let i = 0; i < e.length - 1 && e[i] === 0; i++)
    o.push(0);
  return o.reverse();
}
const IO = /* @__NO_SIDE_EFFECTS__ */ (e, t) => t ? /* @__PURE__ */ IO(t, e % t) : e, qg = /* @__NO_SIDE_EFFECTS__ */ (e, t) => e + (t - /* @__PURE__ */ IO(e, t));
// @__NO_SIDE_EFFECTS__
function Wv(e, t, r, n) {
  if (!Array.isArray(e))
    throw new Error("convertRadix2: data should be array");
  if (t <= 0 || t > 32)
    throw new Error(`convertRadix2: wrong from=${t}`);
  if (r <= 0 || r > 32)
    throw new Error(`convertRadix2: wrong to=${r}`);
  if (/* @__PURE__ */ qg(t, r) > 32)
    throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${/* @__PURE__ */ qg(t, r)}`);
  let o = 0, a = 0;
  const i = 2 ** r - 1, s = [];
  for (const u of e) {
    if (u >= 2 ** t)
      throw new Error(`convertRadix2: invalid data word=${u} from=${t}`);
    if (o = o << t | u, a + t > 32)
      throw new Error(`convertRadix2: carry overflow pos=${a} from=${t}`);
    for (a += t; a >= r; a -= r)
      s.push((o >> a - r & i) >>> 0);
    o &= 2 ** a - 1;
  }
  if (o = o << r - a & i, !n && a >= t)
    throw new Error("Excess padding");
  if (!n && o)
    throw new Error(`Non-zero padding: ${o}`);
  return n && a > 0 && s.push(o >>> 0), s;
}
// @__NO_SIDE_EFFECTS__
function Use(e) {
  return {
    encode: (t) => {
      if (!(t instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ p9(Array.from(t), 2 ** 8, e);
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(/* @__PURE__ */ p9(t, e, 2 ** 8));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function W5(e, t = !1) {
  if (e <= 0 || e > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ qg(8, e) > 32 || /* @__PURE__ */ qg(e, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (r) => {
      if (!(r instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return /* @__PURE__ */ Wv(Array.from(r), 8, e, !t);
    },
    decode: (r) => {
      if (!Array.isArray(r) || r.length && typeof r[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(/* @__PURE__ */ Wv(r, e, 8, t));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function g9(e) {
  if (typeof e != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...t) {
    try {
      return e.apply(null, t);
    } catch {
    }
  };
}
// @__NO_SIDE_EFFECTS__
function Rse(e, t) {
  if (typeof t != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(r) {
      if (!(r instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const n = t(r).slice(0, e), o = new Uint8Array(r.length + e);
      return o.set(r), o.set(n, r.length), o;
    },
    decode(r) {
      if (!(r instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const n = r.slice(0, -e), o = t(n).slice(0, e), a = r.slice(-e);
      for (let i = 0; i < e; i++)
        if (o[i] !== a[i])
          throw new Error("Invalid checksum");
      return n;
    }
  };
}
const m9 = /* @__PURE__ */ Xp(/* @__PURE__ */ W5(6), /* @__PURE__ */ Vy("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ _O(6), /* @__PURE__ */ Gy("")), y9 = /* @__PURE__ */ Xp(/* @__PURE__ */ W5(6), /* @__PURE__ */ Vy("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ _O(6), /* @__PURE__ */ Gy("")), zse = (e) => /* @__PURE__ */ Xp(/* @__PURE__ */ Use(58), /* @__PURE__ */ Vy(e), /* @__PURE__ */ Gy("")), jse = /* @__PURE__ */ zse("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), b9 = (e) => /* @__PURE__ */ Xp(/* @__PURE__ */ Rse(4, (t) => e(e(t))), jse), Xv = /* @__PURE__ */ Xp(/* @__PURE__ */ Vy("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ Gy("")), w9 = [996825010, 642813549, 513874426, 1027748829, 705979059];
// @__NO_SIDE_EFFECTS__
function Kd(e) {
  const t = e >> 25;
  let r = (e & 33554431) << 5;
  for (let n = 0; n < w9.length; n++)
    (t >> n & 1) === 1 && (r ^= w9[n]);
  return r;
}
// @__NO_SIDE_EFFECTS__
function v9(e, t, r = 1) {
  const n = e.length;
  let o = 1;
  for (let a = 0; a < n; a++) {
    const i = e.charCodeAt(a);
    if (i < 33 || i > 126)
      throw new Error(`Invalid prefix (${e})`);
    o = /* @__PURE__ */ Kd(o) ^ i >> 5;
  }
  o = /* @__PURE__ */ Kd(o);
  for (let a = 0; a < n; a++)
    o = /* @__PURE__ */ Kd(o) ^ e.charCodeAt(a) & 31;
  for (let a of t)
    o = /* @__PURE__ */ Kd(o) ^ a;
  for (let a = 0; a < 6; a++)
    o = /* @__PURE__ */ Kd(o);
  return o ^= r, Xv.encode(/* @__PURE__ */ Wv([o % 2 ** 30], 30, 5, !1));
}
// @__NO_SIDE_EFFECTS__
function TO(e) {
  const t = e === "bech32" ? 1 : 734539939, r = /* @__PURE__ */ W5(5), n = r.decode, o = r.encode, a = /* @__PURE__ */ g9(n);
  function i(c, f, h = 90) {
    if (typeof c != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof c}`);
    if (!Array.isArray(f) || f.length && typeof f[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof f}`);
    const p = c.length + 7 + f.length;
    if (h !== !1 && p > h)
      throw new TypeError(`Length ${p} exceeds limit ${h}`);
    const y = c.toLowerCase(), m = /* @__PURE__ */ v9(y, f, t);
    return `${y}1${Xv.encode(f)}${m}`;
  }
  function s(c, f = 90) {
    if (typeof c != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof c}`);
    if (c.length < 8 || f !== !1 && c.length > f)
      throw new TypeError(`Wrong string length: ${c.length} (${c}). Expected (8..${f})`);
    const h = c.toLowerCase();
    if (c !== h && c !== c.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    c = h;
    const p = c.lastIndexOf("1");
    if (p === 0 || p === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const y = c.slice(0, p), m = c.slice(p + 1);
    if (m.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const b = Xv.decode(m).slice(0, -6), v = /* @__PURE__ */ v9(y, b, t);
    if (!m.endsWith(v))
      throw new Error(`Invalid checksum in ${c}: expected "${v}"`);
    return { prefix: y, words: b };
  }
  const u = /* @__PURE__ */ g9(s);
  function l(c) {
    const { prefix: f, words: h } = s(c, !1);
    return { prefix: f, words: h, bytes: n(h) };
  }
  return { encode: i, decode: s, decodeToBytes: l, decodeUnsafe: u, fromWords: n, fromWordsUnsafe: a, toWords: o };
}
const Y0 = /* @__PURE__ */ TO("bech32"), J0 = /* @__PURE__ */ TO("bech32m"), aa = {
  b58chk: {
    encode: (e) => b9(Zv).encode(e),
    decode: (e) => b9(Zv).decode(e)
  },
  base64: {
    encode: (e) => m9.encode(e),
    decode: (e) => m9.decode(e)
  },
  b64url: {
    encode: (e) => y9.encode(e),
    decode: (e) => y9.decode(e)
  },
  bech32: {
    to_words: Y0.toWords,
    to_bytes: Y0.fromWords,
    encode: (e, t, r = !1) => Y0.encode(e, t, r),
    decode: (e, t = !1) => {
      const { prefix: r, words: n } = Y0.decode(e, t);
      return { prefix: r, words: n };
    }
  },
  bech32m: {
    to_words: J0.toWords,
    to_bytes: J0.fromWords,
    encode: (e, t, r = !1) => J0.encode(e, t, r),
    decode: (e, t = !1) => {
      const { prefix: r, words: n } = J0.decode(e, t);
      return { prefix: r, words: n };
    }
  }
};
function Lse(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function Hse(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function Fse(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
function PO(e, t) {
  if (e !== t)
    throw new TypeError(`Bech32 prefix does not match: ${e} !== ${t}`);
}
const Dse = BigInt(0), Mse = BigInt(255), OO = BigInt(256);
function Kse(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function qse(e, t, r = "be") {
  t === void 0 && (t = Kse(e));
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (; e > Dse; ) {
    const s = e & Mse, u = Number(s);
    n ? a.setUint8(i++, u) : a.setUint8(i--, u), e = (e - s) / OO;
  }
  return new Uint8Array(o);
}
function Vse(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * OO + BigInt(e[r]);
  return BigInt(t);
}
function Gse(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, o = 0; n < t.length; n += 8, o++) {
    let a = 0;
    for (let i = 0; i < 8; i++)
      a |= t[n + i] << 7 - i;
    r[o] = a;
  }
  return r;
}
function Zse(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let o = 7; o >= 0; o--, r++)
      t[r] = n >> o & 1;
  }
  return t.join("");
}
function Wse(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function Xse(e, t, r = "be") {
  t === void 0 && (t = Wse(e));
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (; e > 0; ) {
    const s = e & 255;
    n ? a.setUint8(i++, e) : a.setUint8(i--, e), e = (e - s) / 256;
  }
  return new Uint8Array(o);
}
function Yse(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], Fse(t);
  return t;
}
const Jse = new TextEncoder(), Qse = new TextDecoder();
function X5(e) {
  return Jse.encode(e);
}
function X2(e) {
  return Qse.decode(e);
}
function eue(e, t) {
  Hse(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function tue(e, t, r = "le") {
  t = eue(e, t);
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (let s = 0; s < e.length; s += 2) {
    const u = e.substring(s, s + 2), l = parseInt(u, 16);
    n ? a.setUint8(i++, l) : a.setUint8(i--, l);
  }
  return new Uint8Array(o);
}
function rue(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
const { getRandomValues: nue } = crypto ?? globalThis.crypto ?? window.crypto;
function oue(e = 32) {
  if (typeof nue == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function $O(e) {
  return e.match(/[^a-fA-f0-9]/) === null && e.length % 2 === 0;
}
function iue(e) {
  return typeof e == "string" && $O(e) || typeof e == "number" || typeof e == "bigint" || e instanceof Uint8Array ? !0 : !!(Array.isArray(e) && e.every((t) => typeof t == "number"));
}
function aue(e, t, r = "be") {
  t === void 0 && (t = e.length), Lse(e, t);
  const n = new Uint8Array(t).fill(0), o = r === "be" ? 0 : t - e.length;
  return n.set(e, o), n;
}
function CO(e) {
  let t, r = 0;
  const n = e.reduce((a, i) => a + i.length, 0), o = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const a = e[t];
    o.set(a, r), r += a.length;
  }
  return o;
}
function sue(e, t) {
  return typeof t == "bigint" ? `${t}n` : t;
}
function uue(e, t) {
  return typeof t == "string" && /n$/.test(t) ? BigInt(t.slice(0, -1)) : t;
}
function cue(e, t, r) {
  const n = e.length, o = r / t;
  if (r % t !== 0)
    throw new TypeError(`Invalid parameters: ${r} % ${t} !== 0`);
  if (n !== r)
    throw new TypeError(`Invalid data stream: ${n} !== ${r}`);
  if (n % t !== 0)
    throw new TypeError(`Invalid data stream: ${n} % ${t} !== 0`);
  const a = new Array(o);
  for (let i = 0; i < o; i++) {
    const s = i * t;
    a[i] = e.subarray(s, s + t);
  }
  return a;
}
function Y5(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return aue(e, t, r);
  if (Array.isArray(e)) {
    const n = e.map((o) => Y5(o, t, r));
    return CO(n);
  } else {
    if (typeof e == "string")
      return tue(e, t, r);
    if (typeof e == "bigint")
      return qse(e, t, r);
    if (typeof e == "number")
      return Xse(e, t, r);
    if (typeof e == "boolean")
      return Uint8Array.of(e ? 1 : 0);
  }
  throw new TypeError("Unsupported format:" + typeof e);
}
var Je;
let Mt = (Je = class extends Uint8Array {
  static random(e = 32) {
    const t = oue(e);
    return new Je(t, e);
  }
  static now(e = 4) {
    const t = Math.floor(Date.now() / 1e3);
    return new Je(t, e);
  }
  constructor(e, t, r) {
    if (e instanceof Je && t === void 0)
      return e;
    const n = Y5(e, t, r);
    super(n);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.to_num();
  }
  get big() {
    return this.to_big();
  }
  get str() {
    return this.to_str();
  }
  get hex() {
    return this.to_hex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.to_bin();
  }
  get b58chk() {
    return this.to_b58chk();
  }
  get base64() {
    return this.to_base64();
  }
  get b64url() {
    return this.to_b64url();
  }
  get digest() {
    return this.to_hash();
  }
  get id() {
    return this.to_hash().hex;
  }
  get stream() {
    return new xue(this);
  }
  to_num(e = "be") {
    const t = e === "be" ? this.reverse() : this;
    return Yse(t);
  }
  to_big(e = "be") {
    const t = e === "be" ? this.reverse() : this;
    return Vse(t);
  }
  to_bin() {
    return Zse(this);
  }
  to_hash() {
    const e = Zv(this);
    return new Je(e);
  }
  to_json(e) {
    e === void 0 && (e = uue);
    const t = X2(this);
    return JSON.parse(t, e);
  }
  to_bech32(e, t) {
    const { encode: r, to_words: n } = aa.bech32, o = n(this);
    return r(e, o, t);
  }
  to_bech32m(e, t) {
    const { encode: r, to_words: n } = aa.bech32m, o = n(this);
    return r(e, o, t);
  }
  to_str() {
    return X2(this);
  }
  to_hex() {
    return rue(this);
  }
  to_bytes() {
    return new Uint8Array(this);
  }
  to_b58chk() {
    return aa.b58chk.encode(this);
  }
  to_base64() {
    return aa.base64.encode(this);
  }
  to_b64url() {
    return aa.b64url.encode(this);
  }
  append(e) {
    return Je.join([this, Je.bytes(e)]);
  }
  prepend(e) {
    return Je.join([Je.bytes(e), this]);
  }
  reverse() {
    const e = new Uint8Array(this).reverse();
    return new Je(e);
  }
  slice(e, t) {
    const r = new Uint8Array(this).slice(e, t);
    return new Je(r);
  }
  set(e, t) {
    this.set(e, t);
  }
  subarray(e, t) {
    const r = new Uint8Array(this).subarray(e, t);
    return new Je(r);
  }
  write(e, t) {
    const r = Je.bytes(e);
    this.set(r, t);
  }
  add_varint(e) {
    const t = Je.calc_varint(this.length, e);
    return Je.join([t, this]);
  }
  static from(e) {
    return new Je(Uint8Array.from(e));
  }
  static of(...e) {
    return new Je(Uint8Array.of(...e));
  }
  static join(e) {
    const t = e.map((n) => Je.bytes(n)), r = CO(t);
    return new Je(r);
  }
  static sort(e, t) {
    const r = e.map((n) => E9(n, t).hex);
    return r.sort(), r.map((n) => Je.hex(n, t));
  }
  static calc_varint(e, t) {
    if (e < 253)
      return Je.num(e, 1);
    if (e < 65536)
      return Je.of(253, ...Je.num(e, 2, t));
    if (e < 4294967296)
      return Je.of(254, ...Je.num(e, 4, t));
    if (BigInt(e) < 0x10000000000000000n)
      return Je.of(255, ...Je.num(e, 8, t));
    throw new Error(`Value is too large: ${e}`);
  }
}, Je.num = lue, Je.big = due, Je.bin = fue, Je.raw = hue, Je.str = pue, Je.hex = gue, Je.bytes = E9, Je.json = mue, Je.base64 = yue, Je.b64url = bue, Je.bech32 = wue, Je.bech32m = vue, Je.b58chk = Eue, Je.encode = X5, Je.decode = X2, Je.parse = kue, Je.is_bytes = iue, Je.is_hex = $O, Je);
function lue(e, t, r) {
  return new Mt(e, t, r);
}
function fue(e, t, r) {
  return new Mt(Gse(e), t, r);
}
function due(e, t, r) {
  return new Mt(e, t, r);
}
function hue(e, t, r) {
  return new Mt(e, t, r);
}
function pue(e, t, r) {
  return new Mt(X5(e), t, r);
}
function gue(e, t, r) {
  return new Mt(e, t, r);
}
function mue(e, t) {
  t === void 0 && (t = sue);
  const r = JSON.stringify(e, t);
  return new Mt(X5(r));
}
function yue(e) {
  return new Mt(aa.base64.decode(e));
}
function bue(e) {
  return new Mt(aa.b64url.decode(e));
}
function wue(e, t, r) {
  const { decode: n, to_bytes: o } = aa.bech32, { prefix: a, words: i } = n(e, t), s = o(i);
  return typeof r == "string" && PO(a, r), new Mt(s);
}
function vue(e, t, r) {
  const { decode: n, to_bytes: o } = aa.bech32m, { prefix: a, words: i } = n(e, t), s = o(i);
  return typeof r == "string" && PO(a, r), new Mt(s);
}
function Eue(e) {
  return new Mt(aa.b58chk.decode(e));
}
function kue(e, t, r) {
  const n = Y5(e);
  return cue(n, t, r).map((o) => Mt.bytes(o));
}
let xue = class {
  constructor(e) {
    this.data = Mt.bytes(e), this.size = this.data.length;
  }
  peek(e) {
    if (e > this.size)
      throw new Error(`Size greater than stream: ${e} > ${this.size}`);
    return new Mt(this.data.slice(0, e));
  }
  read(e) {
    const t = this.peek(e);
    return this.data = this.data.slice(e), this.size = this.data.length, t;
  }
  read_varint(e) {
    const t = this.read(1).num;
    switch (!0) {
      case (t >= 0 && t < 253):
        return t;
      case t === 253:
        return this.read(2).to_num(e);
      case t === 254:
        return this.read(4).to_num(e);
      case t === 255:
        return this.read(8).to_num(e);
      default:
        throw new Error(`Varint is out of range: ${t}`);
    }
  }
};
function E9(e, t, r) {
  return new Mt(e, t, r);
}
const Vg = Xc.CURVE, Zy = Vg.n, Aue = Vg.p, k9 = { x: Vg.Gx, y: Vg.Gy }, Sue = BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(4);
const _ue = (e) => On(e, Zy);
function BO(e, t = !1) {
  if (!t)
    return !1;
  throw new Error(e);
}
function Iue(e, t, r) {
  const n = Mt.bytes(e);
  return n.length !== t ? BO(`Invalid byte size: ${n.hex} !== ${t}`, r) : !0;
}
function Tue(e, t) {
  return typeof e == "bigint" && Sue < e && e < Zy || BO("x value is not in the field!", t), !0;
}
const Pue = Z5(Zy, 32, !0), x9 = Xc.ProjectivePoint, qd = Pue;
var ar;
let zf = (ar = class extends Uint8Array {
  static add(e) {
    return e.map((t) => ar.mod(t)).reduce((t, r) => t.add(r));
  }
  static mod(e) {
    return new ar(e);
  }
  static mul(e) {
    return e.map((t) => ar.mod(t)).reduce((t, r) => t.mul(r));
  }
  static is_valid(e, t) {
    const r = Mt.bytes(e, 32).big;
    return Tue(r, t);
  }
  constructor(e) {
    const t = _ue(Oue(e));
    ar.is_valid(t, !0), super(Mt.big(t, 32), 32);
  }
  get buff() {
    return new Mt(this);
  }
  get raw() {
    return this.buff.raw;
  }
  get big() {
    return this.buff.big;
  }
  get hex() {
    return this.buff.hex;
  }
  get point() {
    return this.generate();
  }
  get hasOddY() {
    return this.point.hasOddY;
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  gt(e) {
    return new ar(e).big > this.big;
  }
  lt(e) {
    return new ar(e).big < this.big;
  }
  eq(e) {
    return new ar(e).big === this.big;
  }
  ne(e) {
    return new ar(e).big !== this.big;
  }
  add(e) {
    const t = ar.mod(e), r = qd.add(this.big, t.big);
    return new ar(r);
  }
  sub(e) {
    const t = ar.mod(e), r = qd.sub(this.big, t.big);
    return new ar(r);
  }
  mul(e) {
    const t = ar.mod(e), r = qd.mul(this.big, t.big);
    return new ar(r);
  }
  pow(e) {
    const t = ar.mod(e), r = qd.pow(this.big, t.big);
    return new ar(r);
  }
  div(e) {
    const t = ar.mod(e), r = qd.div(this.big, t.big);
    return new ar(r);
  }
  negate() {
    return new ar(ar.N - this.big);
  }
  generate() {
    const e = Xc.ProjectivePoint.BASE.multiply(this.big);
    return J5.import(e);
  }
}, ar.N = Zy, ar);
var Ft;
let J5 = (Ft = class {
  static from_x(e, t = !1) {
    let r = $ue(e);
    r.length === 32 ? r = r.prepend(2) : t && (r[0] = 2), Iue(r, 33);
    const n = x9.fromHex(r.hex);
    return n.assertValidity(), new Ft(n.x, n.y);
  }
  static generate(e) {
    const t = zf.mod(e), r = Ft.base.multiply(t.big);
    return Ft.import(r);
  }
  static import(e) {
    const t = e instanceof Ft ? { x: e.x.big, y: e.y.big } : { x: e.x, y: e.y };
    return new Ft(t.x, t.y);
  }
  constructor(e, t) {
    this._p = new x9(e, t, 1n), this.p.assertValidity();
  }
  get p() {
    return this._p;
  }
  get x() {
    return Mt.big(this.p.x, 32);
  }
  get y() {
    return Mt.big(this.p.y, 32);
  }
  get buff() {
    return Mt.raw(this.p.toRawBytes(!0));
  }
  get raw() {
    return this.buff.raw;
  }
  get hex() {
    return this.buff.hex;
  }
  get hasEvenY() {
    return this.p.hasEvenY();
  }
  get hasOddY() {
    return !this.p.hasEvenY();
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  eq(e) {
    const t = e instanceof Ft ? e : Ft.from_x(e);
    return this.x.big === t.x.big && this.y.big === t.y.big;
  }
  add(e) {
    return e instanceof Ft ? Ft.import(this.p.add(e.p)) : Ft.import(this.p.add(Ft.generate(e).p));
  }
  sub(e) {
    return e instanceof Ft ? Ft.import(this.p.subtract(e.p)) : Ft.import(this.p.subtract(Ft.generate(e).p));
  }
  mul(e) {
    return e instanceof Ft ? Ft.import(this.p.multiply(e.x.big)) : Ft.import(this.p.multiply(zf.mod(e).big));
  }
  negate() {
    return Ft.import(this.p.negate());
  }
}, Ft.P = Aue, Ft.G = new Ft(k9.x, k9.y), Ft.curve = Xc.CURVE, Ft.base = Xc.ProjectivePoint.BASE, Ft.mul = Ft.generate, Ft);
function Oue(e) {
  if (e instanceof zf)
    return e.big;
  if (e instanceof J5)
    return e.x.big;
  if (e instanceof Uint8Array)
    return Mt.raw(e).big;
  if (typeof e == "string")
    return Mt.hex(e).big;
  if (typeof e == "number")
    return Mt.num(e).big;
  if (typeof e == "bigint")
    return BigInt(e);
  throw TypeError("Invalid input type:" + typeof e);
}
function $ue(e) {
  if (e instanceof zf)
    return e.point.buff;
  if (e instanceof J5)
    return e.buff;
  if (e instanceof Uint8Array || typeof e == "string")
    return Mt.bytes(e);
  if (typeof e == "number" || typeof e == "bigint")
    return Mt.bytes(e, 32);
  throw new TypeError(`Unknown type: ${typeof e}`);
}
const Q0 = /* @__PURE__ */ BigInt(2 ** 32 - 1), Yv = /* @__PURE__ */ BigInt(32);
function NO(e, t = !1) {
  return t ? { h: Number(e & Q0), l: Number(e >> Yv & Q0) } : { h: Number(e >> Yv & Q0) | 0, l: Number(e & Q0) | 0 };
}
function Cue(e, t = !1) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: a, l: i } = NO(e[o], t);
    [r[o], n[o]] = [a, i];
  }
  return [r, n];
}
const Bue = (e, t) => BigInt(e >>> 0) << Yv | BigInt(t >>> 0), Nue = (e, t, r) => e >>> r, Uue = (e, t, r) => e << 32 - r | t >>> r, Rue = (e, t, r) => e >>> r | t << 32 - r, zue = (e, t, r) => e << 32 - r | t >>> r, jue = (e, t, r) => e << 64 - r | t >>> r - 32, Lue = (e, t, r) => e >>> r - 32 | t << 64 - r, Hue = (e, t) => t, Fue = (e, t) => e, Due = (e, t, r) => e << r | t >>> 32 - r, Mue = (e, t, r) => t << r | e >>> 32 - r, Kue = (e, t, r) => t << r - 32 | e >>> 64 - r, que = (e, t, r) => e << r - 32 | t >>> 64 - r;
function Vue(e, t, r, n) {
  const o = (t >>> 0) + (n >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
const Gue = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0), Zue = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0, Wue = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), Xue = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0, Yue = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0), Jue = (e, t, r, n, o, a) => t + r + n + o + a + (e / 2 ** 32 | 0) | 0, bt = {
  fromBig: NO,
  split: Cue,
  toBig: Bue,
  shrSH: Nue,
  shrSL: Uue,
  rotrSH: Rue,
  rotrSL: zue,
  rotrBH: jue,
  rotrBL: Lue,
  rotr32H: Hue,
  rotr32L: Fue,
  rotlSH: Due,
  rotlSL: Mue,
  rotlBH: Kue,
  rotlBL: que,
  add: Vue,
  add3L: Gue,
  add3H: Zue,
  add4L: Wue,
  add4H: Xue,
  add5H: Jue,
  add5L: Yue
}, [Que, ece] = bt.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))), Ys = /* @__PURE__ */ new Uint32Array(80), Js = /* @__PURE__ */ new Uint32Array(80);
let tce = class extends O5 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: t, Bh: r, Bl: n, Ch: o, Cl: a, Dh: i, Dl: s, Eh: u, El: l, Fh: c, Fl: f, Gh: h, Gl: p, Hh: y, Hl: m } = this;
    return [e, t, r, n, o, a, i, s, u, l, c, f, h, p, y, m];
  }
  // prettier-ignore
  set(e, t, r, n, o, a, i, s, u, l, c, f, h, p, y, m) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = r | 0, this.Bl = n | 0, this.Ch = o | 0, this.Cl = a | 0, this.Dh = i | 0, this.Dl = s | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = c | 0, this.Fl = f | 0, this.Gh = h | 0, this.Gl = p | 0, this.Hh = y | 0, this.Hl = m | 0;
  }
  process(e, t) {
    for (let k = 0; k < 16; k++, t += 4)
      Ys[k] = e.getUint32(t), Js[k] = e.getUint32(t += 4);
    for (let k = 16; k < 80; k++) {
      const E = Ys[k - 15] | 0, A = Js[k - 15] | 0, S = bt.rotrSH(E, A, 1) ^ bt.rotrSH(E, A, 8) ^ bt.shrSH(E, A, 7), _ = bt.rotrSL(E, A, 1) ^ bt.rotrSL(E, A, 8) ^ bt.shrSL(E, A, 7), I = Ys[k - 2] | 0, O = Js[k - 2] | 0, z = bt.rotrSH(I, O, 19) ^ bt.rotrBH(I, O, 61) ^ bt.shrSH(I, O, 6), D = bt.rotrSL(I, O, 19) ^ bt.rotrBL(I, O, 61) ^ bt.shrSL(I, O, 6), G = bt.add4L(_, D, Js[k - 7], Js[k - 16]), U = bt.add4H(G, S, z, Ys[k - 7], Ys[k - 16]);
      Ys[k] = U | 0, Js[k] = G | 0;
    }
    let { Ah: r, Al: n, Bh: o, Bl: a, Ch: i, Cl: s, Dh: u, Dl: l, Eh: c, El: f, Fh: h, Fl: p, Gh: y, Gl: m, Hh: b, Hl: v } = this;
    for (let k = 0; k < 80; k++) {
      const E = bt.rotrSH(c, f, 14) ^ bt.rotrSH(c, f, 18) ^ bt.rotrBH(c, f, 41), A = bt.rotrSL(c, f, 14) ^ bt.rotrSL(c, f, 18) ^ bt.rotrBL(c, f, 41), S = c & h ^ ~c & y, _ = f & p ^ ~f & m, I = bt.add5L(v, A, _, ece[k], Js[k]), O = bt.add5H(I, b, E, S, Que[k], Ys[k]), z = I | 0, D = bt.rotrSH(r, n, 28) ^ bt.rotrBH(r, n, 34) ^ bt.rotrBH(r, n, 39), G = bt.rotrSL(r, n, 28) ^ bt.rotrBL(r, n, 34) ^ bt.rotrBL(r, n, 39), U = r & o ^ r & i ^ o & i, V = n & a ^ n & s ^ a & s;
      b = y | 0, v = m | 0, y = h | 0, m = p | 0, h = c | 0, p = f | 0, { h: c, l: f } = bt.add(u | 0, l | 0, O | 0, z | 0), u = i | 0, l = s | 0, i = o | 0, s = a | 0, o = r | 0, a = n | 0;
      const F = bt.add3L(z, G, V);
      r = bt.add3H(F, O, D, U), n = F | 0;
    }
    ({ h: r, l: n } = bt.add(this.Ah | 0, this.Al | 0, r | 0, n | 0)), { h: o, l: a } = bt.add(this.Bh | 0, this.Bl | 0, o | 0, a | 0), { h: i, l: s } = bt.add(this.Ch | 0, this.Cl | 0, i | 0, s | 0), { h: u, l } = bt.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h: c, l: f } = bt.add(this.Eh | 0, this.El | 0, c | 0, f | 0), { h, l: p } = bt.add(this.Fh | 0, this.Fl | 0, h | 0, p | 0), { h: y, l: m } = bt.add(this.Gh | 0, this.Gl | 0, y | 0, m | 0), { h: b, l: v } = bt.add(this.Hh | 0, this.Hl | 0, b | 0, v | 0), this.set(r, n, o, a, i, s, u, l, c, f, h, p, y, m, b, v);
  }
  roundClean() {
    Ys.fill(0), Js.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const rce = /* @__PURE__ */ P5(() => new tce());
function nce(e, t = !1) {
  const r = zf.mod(e);
  return t ? r.negated.buff : r.buff;
}
function UO(e, t = !1) {
  const r = zf.mod(e).point;
  return t ? r.x : r.buff;
}
Xc.ProjectivePoint;
function Jv(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function oce(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function RO(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function ice(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Jv(e.outputLen), Jv(e.blockLen);
}
function ace(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function sce(e, t) {
  RO(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const uce = {
  number: Jv,
  bool: oce,
  bytes: RO,
  hash: ice,
  exists: ace,
  output: sce
};
var Y2 = uce;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const J2 = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Zi = (e, t) => e << 32 - t | e >>> t, cce = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!cce)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function lce(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function zO(e) {
  if (typeof e == "string" && (e = lce(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let fce = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function jO(e) {
  const t = (n) => e().update(zO(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function dce(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
let hce = class extends fce {
  constructor(e, t, r, n) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = J2(this.buffer);
  }
  update(e) {
    Y2.exists(this);
    const { view: t, buffer: r, blockLen: n } = this;
    e = zO(e);
    const o = e.length;
    for (let a = 0; a < o; ) {
      const i = Math.min(n - this.pos, o - a);
      if (i === n) {
        const s = J2(e);
        for (; n <= o - a; a += n)
          this.process(s, a);
        continue;
      }
      r.set(e.subarray(a, a + i), this.pos), this.pos += i, a += i, this.pos === n && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Y2.exists(this), Y2.output(e, this), this.finished = !0;
    const { buffer: t, view: r, blockLen: n, isLE: o } = this;
    let { pos: a } = this;
    t[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > n - a && (this.process(r, 0), a = 0);
    for (let c = a; c < n; c++)
      t[c] = 0;
    dce(r, n - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const i = J2(e), s = this.outputLen;
    if (s % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = s / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let c = 0; c < u; c++)
      i.setUint32(4 * c, l[c], o);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: n, finished: o, destroyed: a, pos: i } = this;
    return e.length = n, e.pos = i, e.finished = o, e.destroyed = a, n % t && e.buffer.set(r), e;
  }
};
const pce = (e, t, r) => e & t ^ ~e & r, gce = (e, t, r) => e & t ^ e & r ^ t & r, mce = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Qs = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), eu = new Uint32Array(64);
let LO = class extends hce {
  constructor() {
    super(64, 32, 8, !1), this.A = Qs[0] | 0, this.B = Qs[1] | 0, this.C = Qs[2] | 0, this.D = Qs[3] | 0, this.E = Qs[4] | 0, this.F = Qs[5] | 0, this.G = Qs[6] | 0, this.H = Qs[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: n, E: o, F: a, G: i, H: s } = this;
    return [e, t, r, n, o, a, i, s];
  }
  // prettier-ignore
  set(e, t, r, n, o, a, i, s) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = o | 0, this.F = a | 0, this.G = i | 0, this.H = s | 0;
  }
  process(e, t) {
    for (let c = 0; c < 16; c++, t += 4)
      eu[c] = e.getUint32(t, !1);
    for (let c = 16; c < 64; c++) {
      const f = eu[c - 15], h = eu[c - 2], p = Zi(f, 7) ^ Zi(f, 18) ^ f >>> 3, y = Zi(h, 17) ^ Zi(h, 19) ^ h >>> 10;
      eu[c] = y + eu[c - 7] + p + eu[c - 16] | 0;
    }
    let { A: r, B: n, C: o, D: a, E: i, F: s, G: u, H: l } = this;
    for (let c = 0; c < 64; c++) {
      const f = Zi(i, 6) ^ Zi(i, 11) ^ Zi(i, 25), h = l + f + pce(i, s, u) + mce[c] + eu[c] | 0, p = (Zi(r, 2) ^ Zi(r, 13) ^ Zi(r, 22)) + gce(r, n, o) | 0;
      l = u, u = s, s = i, i = a + h | 0, a = o, o = n, n = r, r = h + p | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, i = i + this.E | 0, s = s + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, n, o, a, i, s, u, l);
  }
  roundClean() {
    eu.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, yce = class extends LO {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const Qv = jO(() => new LO());
jO(() => new yce());
function bce(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function wce(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function vce(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
const { getRandomValues: Ece } = crypto ?? globalThis.crypto ?? window.crypto;
function kce(e = 32) {
  if (typeof Ece == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function xce(e, t, r = "be") {
  t === void 0 && (t = e.length), bce(e, t);
  const n = new Uint8Array(t).fill(0), o = r === "be" ? 0 : t - e.length;
  return n.set(e, o), n;
}
function HO(e) {
  let t, r = 0;
  const n = e.reduce((a, i) => a + i.length, 0), o = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const a = e[t];
    o.set(a, r), r += a.length;
  }
  return o;
}
const Ace = new TextEncoder(), Sce = [
  {
    name: "base58",
    charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }
];
function FO(e) {
  for (const t of Sce)
    if (t.name === e)
      return t.charset;
  throw TypeError("Charset does not exist: " + e);
}
function _ce(e, t, r = !1) {
  typeof e == "string" && (e = Ace.encode(e));
  const n = FO(t), o = n.length, a = [];
  let i = "", s, u = 0, l, c;
  for (s = 0; s < e.length; s++)
    for (u = 0, l = e[s], i += l > 0 || (i.length ^ s) > 0 ? "" : "1"; u in a || l > 0; )
      c = a[u], c = c > 0 ? c * 256 + l : l, l = c / o | 0, a[u] = c % o, u++;
  for (; u-- > 0; )
    i += n[a[u]];
  return r && i.length % 4 > 0 ? i + "=".repeat(4 - i.length % 4) : i;
}
function Ice(e, t) {
  const r = FO(t), n = r.length, o = [], a = [];
  e = e.replace("=", "");
  let i, s = 0, u, l;
  for (i = 0; i < e.length; i++) {
    if (s = 0, u = r.indexOf(e[i]), u < 0)
      throw new Error(`Character range out of bounds: ${u}`);
    for (u > 0 || (a.length ^ i) > 0 || a.push(0); s in o || u > 0; )
      l = o[s], l = l > 0 ? l * n + u : u, u = l >> 8, o[s] = l % 256, s++;
  }
  for (; s-- > 0; )
    a.push(o[s]);
  return new Uint8Array(a);
}
function DO(e) {
  return Qv(Qv(e));
}
function Tce(e) {
  const t = DO(e);
  return HO([e, t.slice(0, 4)]);
}
function Pce(e) {
  const t = e.slice(0, -4), r = e.slice(-4);
  if (DO(t).slice(0, 4).toString() !== r.toString())
    throw new Error("Invalid checksum!");
  return t;
}
const A9 = {
  encode: _ce,
  decode: Ice
}, MO = {
  encode: (e) => {
    const t = Tce(e);
    return A9.encode(t, "base58");
  },
  decode: (e) => {
    const t = A9.decode(e, "base58");
    return Pce(t);
  }
}, KO = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", Oce = [996825010, 642813549, 513874426, 1027748829, 705979059], Gg = [
  { version: 0, name: "bech32", const: 1 },
  { version: 1, name: "bech32m", const: 734539939 }
];
function qO(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = t >> 25;
    t = (t & 33554431) << 5 ^ e[r];
    for (let o = 0; o < 5; ++o)
      n >> o & 1 && (t ^= Oce[o]);
  }
  return t;
}
function VO(e) {
  const t = [];
  let r;
  for (r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) >> 5);
  for (t.push(0), r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) & 31);
  return t;
}
function $ce(e, t, r) {
  const n = VO(e).concat(t);
  return qO(n) === r.const;
}
function Cce(e, t, r) {
  const n = VO(e).concat(t).concat([0, 0, 0, 0, 0, 0]), o = qO(n) ^ r.const, a = [];
  for (let i = 0; i < 6; ++i)
    a.push(o >> 5 * (5 - i) & 31);
  return a;
}
function GO(e, t, r, n = !0) {
  const o = [];
  let a = 0, i = 0;
  const s = (1 << r) - 1, u = (1 << t + r - 1) - 1;
  for (const l of e) {
    if (l < 0 || l >> t > 0)
      throw new Error("Failed to perform base conversion. Invalid value: " + String(l));
    for (a = (a << t | l) & u, i += t; i >= r; )
      i -= r, o.push(a >> i & s);
  }
  if (n)
    i > 0 && o.push(a << r - i & s);
  else if (i >= t || (a << r - i & s) > 0)
    throw new Error("Failed to perform base conversion. Invalid Size!");
  return o;
}
function Bce(e, t, r) {
  const n = t.concat(Cce(e, t, r));
  let o = e + "1";
  for (let a = 0; a < n.length; ++a)
    o += KO.charAt(n[a]);
  return o;
}
function ZO(e) {
  if (!Nce(e))
    throw new Error("Encoded string goes out of bounds!");
  if (e = e.toLowerCase(), !Uce(e))
    throw new Error("Encoded string has invalid separator!");
  const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
  for (let a = r + 1; a < e.length; ++a) {
    const i = KO.indexOf(e.charAt(a));
    if (i === -1)
      throw new Error("Character idx out of bounds: " + String(a));
    t.push(i);
  }
  const o = Gg.find((a) => a.version === t[0]) ?? Gg[0];
  if (!$ce(n, t, o))
    throw new Error("Checksum verification failed!");
  return [n, t.slice(0, t.length - 6)];
}
function Nce(e) {
  let t, r, n = !1, o = !1;
  for (t = 0; t < e.length; ++t) {
    if (r = e.charCodeAt(t), r < 33 || r > 126)
      return !1;
    r >= 97 && r <= 122 && (n = !0), r >= 65 && r <= 90 && (o = !0);
  }
  return !(n && o);
}
function Uce(e) {
  const t = e.lastIndexOf("1");
  return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function Rce(e, t = "bc", r = 0) {
  const n = [r, ...GO([...e], 8, 5)], o = Gg.find((i) => i.version === r) ?? Gg[0], a = Bce(t, n, o);
  return WO(a), a;
}
function WO(e) {
  e = e.toLowerCase();
  const t = e.split("1", 1)[0], [r, n] = ZO(e), o = GO(n.slice(1), 5, 8, !1), a = o.length;
  switch (!0) {
    case t !== r:
      throw new Error("Returned hrp string is invalid.");
    case (o === null || a < 2 || a > 40):
      throw new Error("Decoded string is invalid or out of spec.");
    case n[0] > 16:
      throw new Error("Returned version bit is out of range.");
    default:
      return Uint8Array.from(o);
  }
}
function zce(e) {
  e = e.toLowerCase();
  const [t, r] = ZO(e);
  return r[0];
}
const XO = {
  encode: Rce,
  decode: WO,
  version: zce
}, YO = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", JO = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", jce = new TextEncoder();
function QO(e, t = !1, r = !0) {
  typeof e == "string" && (e = jce.encode(e));
  const n = t ? JO : YO;
  let o = "", a = 0, i = 0;
  for (let s = 0; s < e.length; s++)
    for (i = i << 8 | e[s], a += 8; a >= 6; )
      a -= 6, o += n[i >> a & 63];
  if (a > 0)
    for (i <<= 6 - a, o += n[i & 63]; a < 6; )
      o += r ? "=" : "", a += 2;
  return o;
}
function e$(e, t = !1) {
  const r = t || e.includes("-") || e.includes("_") ? JO.split("") : YO.split("");
  e = e.replace(/=+$/, "");
  const n = e.split("");
  let o = 0, a = 0;
  const i = [];
  for (let s = 0; s < n.length; s++) {
    const u = n[s], l = r.indexOf(u);
    if (l === -1)
      throw new Error("Invalid character: " + u);
    o += 6, a <<= 6, a |= l, o >= 8 && (o -= 8, i.push(a >>> o & 255));
  }
  return new Uint8Array(i);
}
const t$ = {
  encode: QO,
  decode: e$
}, r$ = {
  encode: (e) => QO(e, !0, !1),
  decode: (e) => e$(e, !0)
}, Lce = BigInt(0), Hce = BigInt(255), n$ = BigInt(256);
function Fce(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function Dce(e, t, r = "be") {
  t === void 0 && (t = Fce(e));
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (; e > Lce; ) {
    const s = e & Hce, u = Number(s);
    n ? a.setUint8(i++, u) : a.setUint8(i--, u), e = (e - s) / n$;
  }
  return new Uint8Array(o);
}
function Mce(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * n$ + BigInt(e[r]);
  return BigInt(t);
}
function Kce(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, o = 0; n < t.length; n += 8, o++) {
    let a = 0;
    for (let i = 0; i < 8; i++)
      a |= t[n + i] << 7 - i;
    r[o] = a;
  }
  return r;
}
function qce(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let o = 7; o >= 0; o--, r++)
      t[r] = n >> o & 1;
  }
  return t.join("");
}
function Vce(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function Gce(e, t, r = "be") {
  t === void 0 && (t = Vce(e));
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (; e > 0; ) {
    const s = e & 255;
    n ? a.setUint8(i++, e) : a.setUint8(i--, e), e = (e - s) / 256;
  }
  return new Uint8Array(o);
}
function Zce(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], vce(t);
  return t;
}
const Wce = new TextEncoder(), Xce = new TextDecoder();
function Q5(e) {
  return Wce.encode(e);
}
function Q2(e) {
  return Xce.decode(e);
}
function Yce(e, t) {
  wce(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function Jce(e, t, r = "le") {
  t = Yce(e, t);
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (let s = 0; s < e.length; s += 2) {
    const u = e.substring(s, s + 2), l = parseInt(u, 16);
    n ? a.setUint8(i++, l) : a.setUint8(i--, l);
  }
  return new Uint8Array(o);
}
function Qce(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function ele(e) {
  const t = JSON.stringify(e, (r, n) => typeof n == "bigint" ? `${n}n` : n);
  return Q5(t);
}
function tle(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return xce(e, t, r);
  if (typeof e == "string")
    return Jce(e, t, r);
  if (typeof e == "bigint")
    return Dce(e, t, r);
  if (typeof e == "number")
    return Gce(e, t, r);
  if (typeof e == "boolean")
    return Uint8Array.of(e ? 1 : 0);
  throw TypeError("Unsupported format:" + typeof e);
}
var St;
let J = (St = class extends Uint8Array {
  static random(e = 32) {
    const t = kce(e);
    return new St(t, e);
  }
  constructor(e, t, r) {
    const n = tle(e, t, r);
    super(n);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.toNum();
  }
  get big() {
    return this.toBig();
  }
  get str() {
    return this.toStr();
  }
  get hex() {
    return this.toHex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.toBin();
  }
  get b58chk() {
    return this.tob58chk();
  }
  get base64() {
    return this.toBase64();
  }
  get b64url() {
    return this.toB64url();
  }
  get digest() {
    return this.toHash();
  }
  get id() {
    return this.toHash().hex;
  }
  get stream() {
    return new pd(this);
  }
  toNum(e = "be") {
    const t = e === "be" ? this.reverse() : this;
    return Zce(t);
  }
  toBin() {
    return qce(this);
  }
  toBig(e = "be") {
    const t = e === "be" ? this.reverse() : this;
    return Mce(t);
  }
  toHash() {
    const e = Qv(this);
    return new St(e);
  }
  toJson() {
    const e = Q2(this);
    return JSON.parse(e);
  }
  toBech32(e, t = 0) {
    return XO.encode(this, e, t);
  }
  toStr() {
    return Q2(this);
  }
  toHex() {
    return Qce(this);
  }
  toBytes() {
    return new Uint8Array(this);
  }
  tob58chk() {
    return MO.encode(this);
  }
  toBase64() {
    return t$.encode(this);
  }
  toB64url() {
    return r$.encode(this);
  }
  prepend(e) {
    return St.join([St.bytes(e), this]);
  }
  append(e) {
    return St.join([this, St.bytes(e)]);
  }
  slice(e, t) {
    const r = new Uint8Array(this).slice(e, t);
    return new St(r);
  }
  subarray(e, t) {
    const r = new Uint8Array(this).subarray(e, t);
    return new St(r);
  }
  reverse() {
    const e = new Uint8Array(this).reverse();
    return new St(e);
  }
  write(e, t) {
    const r = St.bytes(e);
    this.set(r, t);
  }
  prefixSize(e) {
    const t = St.varInt(this.length, e);
    return St.join([t, this]);
  }
  static from(e) {
    return new St(Uint8Array.from(e));
  }
  static of(...e) {
    return new St(Uint8Array.of(...e));
  }
  static join(e) {
    const t = e.map((n) => St.bytes(n)), r = HO(t);
    return new St(r);
  }
  static varInt(e, t) {
    if (e < 253)
      return St.num(e, 1);
    if (e < 65536)
      return St.of(253, ...St.num(e, 2, t));
    if (e < 4294967296)
      return St.of(254, ...St.num(e, 4, t));
    if (BigInt(e) < 0x10000000000000000n)
      return St.of(255, ...St.num(e, 8, t));
    throw new Error(`Value is too large: ${e}`);
  }
}, St.num = rle, St.big = ole, St.bin = nle, St.raw = ile, St.str = ale, St.hex = sle, St.bytes = ule, St.json = cle, St.base64 = lle, St.b64url = fle, St.bech32 = dle, St.b58chk = hle, St.encode = Q5, St.decode = Q2, St);
function rle(e, t, r) {
  return new J(e, t, r);
}
function nle(e, t, r) {
  return new J(Kce(e), t, r);
}
function ole(e, t, r) {
  return new J(e, t, r);
}
function ile(e, t, r) {
  return new J(e, t, r);
}
function ale(e, t, r) {
  return new J(Q5(e), t, r);
}
function sle(e, t, r) {
  return new J(e, t, r);
}
function ule(e, t, r) {
  return new J(e, t, r);
}
function cle(e) {
  return new J(ele(e));
}
function lle(e) {
  return new J(t$.decode(e));
}
function fle(e) {
  return new J(r$.decode(e));
}
function dle(e) {
  return new J(XO.decode(e));
}
function hle(e) {
  return new J(MO.decode(e));
}
let pd = class {
  constructor(e) {
    this.data = J.bytes(e), this.size = this.data.length;
  }
  peek(e) {
    if (e > this.size)
      throw new Error(`Size greater than stream: ${e} > ${this.size}`);
    return new J(this.data.slice(0, e));
  }
  read(e) {
    e = e ?? this.readSize();
    const t = this.peek(e);
    return this.data = this.data.slice(e), this.size = this.data.length, t;
  }
  readSize(e) {
    const t = this.read(1).num;
    switch (!0) {
      case (t >= 0 && t < 253):
        return t;
      case t === 253:
        return this.read(2).toNum(e);
      case t === 254:
        return this.read(4).toNum(e);
      case t === 255:
        return this.read(8).toNum(e);
      default:
        throw new Error(`Varint is out of range: ${t}`);
    }
  }
};
function ba(e, t) {
  const r = J.bytes(e);
  if (r.length !== t)
    throw new Error(`Invalid input size: ${r.hex} !== ${t}`);
}
function vn(e, t) {
  if (t)
    throw new Error(e);
  return !1;
}
function O1(e, ...t) {
  const r = J.str(e).digest.raw, n = t.map((o) => J.bytes(o));
  return J.join([r, r, J.join(n)]).digest;
}
const o$ = {
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_SUCCESS80: 80,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_SUCCESS98: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_SUCCESS126: 126,
  OP_SUCCESS127: 127,
  OP_SUCCESS128: 128,
  OP_SUCCESS129: 129,
  OP_SIZE: 130,
  OP_SUCCESS131: 131,
  OP_SUCCESS132: 132,
  OP_SUCCESS133: 133,
  OP_SUCCESS134: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_SUCCESS137: 137,
  OP_SUCCESS138: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_SUCCESS141: 141,
  OP_SUCCESS142: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_SUCCESS149: 149,
  OP_SUCCESS150: 150,
  OP_SUCCESS151: 151,
  OP_SUCCESS152: 152,
  OP_SUCCESS153: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186
};
function ple(e) {
  if (e > 186 && e < 255)
    return "OP_SUCCESS" + String(e);
  for (const [t, r] of Object.entries(o$))
    if (r === e)
      return t;
  throw new Error("OPCODE not found:" + String(e));
}
function gle(e) {
  for (const [t, r] of Object.entries(o$))
    if (t === e)
      return Number(r);
  throw new Error("OPCODE not found:" + e);
}
function mle(e) {
  switch (!0) {
    case e === 0:
      return "opcode";
    case (e >= 1 && e <= 75):
      return "varint";
    case e === 76:
      return "pushdata1";
    case e === 77:
      return "pushdata2";
    case e === 78:
      return "pushdata4";
    case e <= 254:
      return "opcode";
    default:
      throw new Error(`Invalid word range: ${e}`);
  }
}
function yle(e) {
  const t = [];
  switch (!0) {
    case typeof e != "number":
      return !1;
    case e === 0:
      return !0;
    case t.includes(e):
      return !1;
    case (75 < e && e < 254):
      return !0;
    default:
      return !1;
  }
}
function bs(e) {
  return typeof e == "string" && e.length % 2 === 0 && /[0-9a-fA-F]/.test(e);
}
function i$(e) {
  return bs(e) || e instanceof Uint8Array;
}
const Zg = 520;
function wl(e = [], t = !0) {
  let r = J.num(0);
  return Array.isArray(e) && (r = J.raw(a$(e))), bs(e) && (r = J.hex(e)), e instanceof Uint8Array && (r = J.raw(e)), t && (r = r.prefixSize("le")), r;
}
function a$(e) {
  const t = [];
  for (const r of e)
    t.push(ble(r));
  return t.length > 0 ? J.join(t) : new Uint8Array();
}
function ble(e) {
  let t = new Uint8Array();
  if (typeof e == "string") {
    if (e.startsWith("OP_"))
      return J.num(gle(e), 1);
    bs(e) ? t = J.hex(e) : t = J.str(e);
  } else if (t = J.bytes(e), t.length === 1 && t[0] <= 16)
    return t[0] !== 0 && (t[0] += 80), t;
  if (t.length > Zg) {
    const r = vle(t);
    return a$(r);
  }
  return J.join([wle(t.length), t]);
}
function wle(e) {
  const t = J.num(76, 1), r = J.num(77, 1);
  switch (!0) {
    case e <= 75:
      return J.num(e);
    case (e > 75 && e < 256):
      return J.join([t, J.num(e, 1, "le")]);
    case (e >= 256 && e <= Zg):
      return J.join([r, J.num(e, 2, "le")]);
    default:
      throw new Error("Invalid word size:" + e.toString());
  }
}
function vle(e) {
  const t = [], r = new pd(e);
  for (; r.size > Zg; )
    t.push(r.read(Zg));
  return t.push(r.read(r.size)), t;
}
function e4(e, t = !1) {
  let r = J.bytes(e);
  if (t) {
    const n = r.stream.readSize("le");
    if (r = r.slice(1), r.length !== n)
      throw new Error(`Varint does not match stream size: ${n} !== ${r.length}`);
  }
  return Ele(r);
}
function Ele(e) {
  const t = new pd(e), r = [], n = t.size;
  let o, a, i, s = 0;
  for (; s < n; )
    switch (o = t.read(1).num, a = mle(o), s++, a) {
      case "varint":
        r.push(t.read(o).hex), s += o;
        break;
      case "pushdata1":
        i = t.read(1).reverse().num, r.push(t.read(i).hex), s += i + 1;
        break;
      case "pushdata2":
        i = t.read(2).reverse().num, r.push(t.read(i).hex), s += i + 2;
        break;
      case "pushdata4":
        i = t.read(4).reverse().num, r.push(t.read(i).hex), s += i + 4;
        break;
      case "opcode":
        if (!yle(o))
          throw new Error(`Invalid OPCODE: ${o}`);
        r.push(ple(o));
        break;
      default:
        throw new Error(`Word type undefined: ${o}`);
    }
  return r;
}
function kle(e, t) {
  if (Array.isArray(e) && (e = wl(e, t)), e instanceof Uint8Array || bs(e))
    return e4(e, t);
  throw new Error("Invalid format: " + typeof e);
}
function xle(e, t) {
  if ((e instanceof Uint8Array || bs(e)) && (e = e4(e, t)), Array.isArray(e))
    return wl(e, t);
  throw new Error("Invalid format: " + typeof e);
}
function Ale(e) {
  if (!Array.isArray(e))
    return J.bytes(e);
  throw new Error("Invalid format: " + typeof e);
}
const Sle = {
  toAsm: kle,
  toBytes: xle,
  toParam: Ale
}, Dn = {
  encode: wl,
  decode: e4,
  fmt: Sle
};
function e8(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function _le(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function s$(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Ile(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  e8(e.outputLen), e8(e.blockLen);
}
function Tle(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function Ple(e, t) {
  s$(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const Ole = {
  number: e8,
  bool: _le,
  bytes: s$,
  hash: Ile,
  exists: Tle,
  output: Ple
};
var Sc = Ole;
const ew = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const tw = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Wi = (e, t) => e << 32 - t | e >>> t, $le = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!$le)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Cle(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function t4(e) {
  if (typeof e == "string" && (e = Cle(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
function Ble(...e) {
  if (!e.every((n) => n instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (e.length === 1)
    return e[0];
  const t = e.reduce((n, o) => n + o.length, 0), r = new Uint8Array(t);
  for (let n = 0, o = 0; n < e.length; n++) {
    const a = e[n];
    r.set(a, o), o += a.length;
  }
  return r;
}
let u$ = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function c$(e) {
  const t = (n) => e().update(t4(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function l$(e = 32) {
  if (ew && typeof ew.getRandomValues == "function")
    return ew.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined");
}
function Nle(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
let Ule = class extends u$ {
  constructor(e, t, r, n) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = tw(this.buffer);
  }
  update(e) {
    Sc.exists(this);
    const { view: t, buffer: r, blockLen: n } = this;
    e = t4(e);
    const o = e.length;
    for (let a = 0; a < o; ) {
      const i = Math.min(n - this.pos, o - a);
      if (i === n) {
        const s = tw(e);
        for (; n <= o - a; a += n)
          this.process(s, a);
        continue;
      }
      r.set(e.subarray(a, a + i), this.pos), this.pos += i, a += i, this.pos === n && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Sc.exists(this), Sc.output(e, this), this.finished = !0;
    const { buffer: t, view: r, blockLen: n, isLE: o } = this;
    let { pos: a } = this;
    t[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > n - a && (this.process(r, 0), a = 0);
    for (let c = a; c < n; c++)
      t[c] = 0;
    Nle(r, n - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const i = tw(e), s = this.outputLen;
    if (s % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = s / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let c = 0; c < u; c++)
      i.setUint32(4 * c, l[c], o);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: n, finished: o, destroyed: a, pos: i } = this;
    return e.length = n, e.pos = i, e.finished = o, e.destroyed = a, n % t && e.buffer.set(r), e;
  }
};
const Rle = (e, t, r) => e & t ^ ~e & r, zle = (e, t, r) => e & t ^ e & r ^ t & r, jle = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), tu = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), ru = new Uint32Array(64);
let f$ = class extends Ule {
  constructor() {
    super(64, 32, 8, !1), this.A = tu[0] | 0, this.B = tu[1] | 0, this.C = tu[2] | 0, this.D = tu[3] | 0, this.E = tu[4] | 0, this.F = tu[5] | 0, this.G = tu[6] | 0, this.H = tu[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: n, E: o, F: a, G: i, H: s } = this;
    return [e, t, r, n, o, a, i, s];
  }
  // prettier-ignore
  set(e, t, r, n, o, a, i, s) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = o | 0, this.F = a | 0, this.G = i | 0, this.H = s | 0;
  }
  process(e, t) {
    for (let c = 0; c < 16; c++, t += 4)
      ru[c] = e.getUint32(t, !1);
    for (let c = 16; c < 64; c++) {
      const f = ru[c - 15], h = ru[c - 2], p = Wi(f, 7) ^ Wi(f, 18) ^ f >>> 3, y = Wi(h, 17) ^ Wi(h, 19) ^ h >>> 10;
      ru[c] = y + ru[c - 7] + p + ru[c - 16] | 0;
    }
    let { A: r, B: n, C: o, D: a, E: i, F: s, G: u, H: l } = this;
    for (let c = 0; c < 64; c++) {
      const f = Wi(i, 6) ^ Wi(i, 11) ^ Wi(i, 25), h = l + f + Rle(i, s, u) + jle[c] + ru[c] | 0, p = (Wi(r, 2) ^ Wi(r, 13) ^ Wi(r, 22)) + zle(r, n, o) | 0;
      l = u, u = s, s = i, i = a + h | 0, a = o, o = n, n = r, r = h + p | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, i = i + this.E | 0, s = s + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, n, o, a, i, s, u, l);
  }
  roundClean() {
    ru.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, Lle = class extends f$ {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const Wg = c$(() => new f$());
c$(() => new Lle());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Hle = BigInt(0), r4 = BigInt(1), Fle = BigInt(2), Wy = (e) => e instanceof Uint8Array, Dle = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function jf(e) {
  if (!Wy(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += Dle[e[r]];
  return t;
}
function d$(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function n4(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
function Lf(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (e.length % 2)
    throw new Error("hex string is invalid: unpadded " + e.length);
  const t = new Uint8Array(e.length / 2);
  for (let r = 0; r < t.length; r++) {
    const n = r * 2, o = e.slice(n, n + 2), a = Number.parseInt(o, 16);
    if (Number.isNaN(a) || a < 0)
      throw new Error("invalid byte sequence");
    t[r] = a;
  }
  return t;
}
function jn(e) {
  return n4(jf(e));
}
function o4(e) {
  if (!Wy(e))
    throw new Error("Uint8Array expected");
  return n4(jf(Uint8Array.from(e).reverse()));
}
const Ou = (e, t) => Lf(e.toString(16).padStart(t * 2, "0")), h$ = (e, t) => Ou(e, t).reverse(), Mle = (e) => Lf(d$(e));
function dn(e, t, r) {
  let n;
  if (typeof t == "string")
    try {
      n = Lf(t);
    } catch (a) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${a}`);
    }
  else if (Wy(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const o = n.length;
  if (typeof r == "number" && o !== r)
    throw new Error(`${e} expected ${r} bytes, got ${o}`);
  return n;
}
function bo(...e) {
  const t = new Uint8Array(e.reduce((n, o) => n + o.length, 0));
  let r = 0;
  return e.forEach((n) => {
    if (!Wy(n))
      throw new Error("Uint8Array expected");
    t.set(n, r), r += n.length;
  }), t;
}
function Kle(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function Xy(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function qle(e) {
  let t;
  for (t = 0; e > 0n; e >>= r4, t += 1)
    ;
  return t;
}
const Vle = (e, t) => e >> BigInt(t) & 1n, Gle = (e, t, r) => e | (r ? r4 : Hle) << BigInt(t), i4 = (e) => (Fle << BigInt(e - 1)) - r4, rw = (e) => new Uint8Array(e), S9 = (e) => Uint8Array.from(e);
function p$(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = rw(e), o = rw(e), a = 0;
  const i = () => {
    n.fill(1), o.fill(0), a = 0;
  }, s = (...c) => r(o, n, ...c), u = (c = rw()) => {
    o = s(S9([0]), c), n = s(), c.length !== 0 && (o = s(S9([1]), c), n = s());
  }, l = () => {
    if (a++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let c = 0;
    const f = [];
    for (; c < t; ) {
      n = s();
      const h = n.slice();
      f.push(h), c += n.length;
    }
    return bo(...f);
  };
  return (c, f) => {
    i(), u(c);
    let h;
    for (; !(h = f(l())); )
      u();
    return i(), h;
  };
}
const Zle = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function gd(e, t, r = {}) {
  const n = (o, a, i) => {
    const s = Zle[a];
    if (typeof s != "function")
      throw new Error(`Invalid validator "${a}", expected function`);
    const u = e[o];
    if (!(i && u === void 0) && !s(u, e))
      throw new Error(`Invalid param ${String(o)}=${u} (${typeof u}), expected ${a}`);
  };
  for (const [o, a] of Object.entries(t))
    n(o, a, !1);
  for (const [o, a] of Object.entries(r))
    n(o, a, !0);
  return e;
}
var Wle = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  bitGet: Vle,
  bitLen: qle,
  bitMask: i4,
  bitSet: Gle,
  bytesToHex: jf,
  bytesToNumberBE: jn,
  bytesToNumberLE: o4,
  concatBytes: bo,
  createHmacDrbg: p$,
  ensureBytes: dn,
  equalBytes: Kle,
  hexToBytes: Lf,
  hexToNumber: n4,
  numberToBytesBE: Ou,
  numberToBytesLE: h$,
  numberToHexUnpadded: d$,
  numberToVarBytesBE: Mle,
  utf8ToBytes: Xy,
  validateObject: gd
});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sn = BigInt(0), $r = BigInt(1), yc = BigInt(2), Xle = BigInt(3), t8 = BigInt(4), _9 = BigInt(5), I9 = BigInt(8);
BigInt(9);
BigInt(16);
function Wr(e, t) {
  const r = e % t;
  return r >= sn ? r : t + r;
}
function Yle(e, t, r) {
  if (r <= sn || t < sn)
    throw new Error("Expected power/modulo > 0");
  if (r === $r)
    return sn;
  let n = $r;
  for (; t > sn; )
    t & $r && (n = n * e % r), e = e * e % r, t >>= $r;
  return n;
}
function Ho(e, t, r) {
  let n = e;
  for (; t-- > sn; )
    n *= n, n %= r;
  return n;
}
function r8(e, t) {
  if (e === sn || t <= sn)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Wr(e, t), n = t, o = sn, a = $r;
  for (; r !== sn; ) {
    const i = n / r, s = n % r, u = o - a * i;
    n = r, r = s, o = a, a = u;
  }
  if (n !== $r)
    throw new Error("invert: does not exist");
  return Wr(o, t);
}
function Jle(e) {
  const t = (e - $r) / yc;
  let r, n, o;
  for (r = e - $r, n = 0; r % yc === sn; r /= yc, n++)
    ;
  for (o = yc; o < e && Yle(o, t, e) !== e - $r; o++)
    ;
  if (n === 1) {
    const i = (e + $r) / t8;
    return function(s, u) {
      const l = s.pow(u, i);
      if (!s.eql(s.sqr(l), u))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  const a = (r + $r) / yc;
  return function(i, s) {
    if (i.pow(s, t) === i.neg(i.ONE))
      throw new Error("Cannot find square root");
    let u = n, l = i.pow(i.mul(i.ONE, o), r), c = i.pow(s, a), f = i.pow(s, r);
    for (; !i.eql(f, i.ONE); ) {
      if (i.eql(f, i.ZERO))
        return i.ZERO;
      let h = 1;
      for (let y = i.sqr(f); h < u && !i.eql(y, i.ONE); h++)
        y = i.sqr(y);
      const p = i.pow(l, $r << BigInt(u - h - 1));
      l = i.sqr(p), c = i.mul(c, p), f = i.mul(f, l), u = h;
    }
    return c;
  };
}
function Qle(e) {
  if (e % t8 === Xle) {
    const t = (e + $r) / t8;
    return function(r, n) {
      const o = r.pow(n, t);
      if (!r.eql(r.sqr(o), n))
        throw new Error("Cannot find square root");
      return o;
    };
  }
  if (e % I9 === _9) {
    const t = (e - _9) / I9;
    return function(r, n) {
      const o = r.mul(n, yc), a = r.pow(o, t), i = r.mul(n, a), s = r.mul(r.mul(i, yc), a), u = r.mul(i, r.sub(s, r.ONE));
      if (!r.eql(r.sqr(u), n))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return Jle(e);
}
const efe = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function g$(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = efe.reduce((n, o) => (n[o] = "function", n), t);
  return gd(e, r);
}
function tfe(e, t, r) {
  if (r < sn)
    throw new Error("Expected power > 0");
  if (r === sn)
    return e.ONE;
  if (r === $r)
    return t;
  let n = e.ONE, o = t;
  for (; r > sn; )
    r & $r && (n = e.mul(n, o)), o = e.sqr(o), r >>= $r;
  return n;
}
function rfe(e, t) {
  const r = new Array(t.length), n = t.reduce((a, i, s) => e.is0(i) ? a : (r[s] = a, e.mul(a, i)), e.ONE), o = e.inv(n);
  return t.reduceRight((a, i, s) => e.is0(i) ? a : (r[s] = e.mul(a, r[s]), e.mul(a, i)), o), r;
}
function a4(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function m$(e, t, r = !1, n = {}) {
  if (e <= sn)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: o, nByteLength: a } = a4(e, t);
  if (a > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const i = Qle(e), s = Object.freeze({
    ORDER: e,
    BITS: o,
    BYTES: a,
    MASK: i4(o),
    ZERO: sn,
    ONE: $r,
    create: (u) => Wr(u, e),
    isValid: (u) => {
      if (typeof u != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof u}`);
      return sn <= u && u < e;
    },
    is0: (u) => u === sn,
    isOdd: (u) => (u & $r) === $r,
    neg: (u) => Wr(-u, e),
    eql: (u, l) => u === l,
    sqr: (u) => Wr(u * u, e),
    add: (u, l) => Wr(u + l, e),
    sub: (u, l) => Wr(u - l, e),
    mul: (u, l) => Wr(u * l, e),
    pow: (u, l) => tfe(s, u, l),
    div: (u, l) => Wr(u * r8(l, e), e),
    // Same as above, but doesn't normalize
    sqrN: (u) => u * u,
    addN: (u, l) => u + l,
    subN: (u, l) => u - l,
    mulN: (u, l) => u * l,
    inv: (u) => r8(u, e),
    sqrt: n.sqrt || ((u) => i(s, u)),
    invertBatch: (u) => rfe(s, u),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (u, l, c) => c ? l : u,
    toBytes: (u) => r ? h$(u, a) : Ou(u, a),
    fromBytes: (u) => {
      if (u.length !== a)
        throw new Error(`Fp.fromBytes: expected ${a}, got ${u.length}`);
      return r ? o4(u) : jn(u);
    }
  });
  return Object.freeze(s);
}
function nfe(e, t, r = !1) {
  e = dn("privateHash", e);
  const n = e.length, o = a4(t).nByteLength + 8;
  if (o < 24 || n < o || n > 1024)
    throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${n}`);
  const a = r ? o4(e) : jn(e);
  return Wr(a, t - $r) + $r;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ofe = BigInt(0), nw = BigInt(1);
function ife(e, t) {
  const r = (o, a) => {
    const i = a.negate();
    return o ? i : a;
  }, n = (o) => {
    const a = Math.ceil(t / o) + 1, i = 2 ** (o - 1);
    return { windows: a, windowSize: i };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(o, a) {
      let i = e.ZERO, s = o;
      for (; a > ofe; )
        a & nw && (i = i.add(s)), s = s.double(), a >>= nw;
      return i;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(o, a) {
      const { windows: i, windowSize: s } = n(a), u = [];
      let l = o, c = l;
      for (let f = 0; f < i; f++) {
        c = l, u.push(c);
        for (let h = 1; h < s; h++)
          c = c.add(l), u.push(c);
        l = c.double();
      }
      return u;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(o, a, i) {
      const { windows: s, windowSize: u } = n(o);
      let l = e.ZERO, c = e.BASE;
      const f = BigInt(2 ** o - 1), h = 2 ** o, p = BigInt(o);
      for (let y = 0; y < s; y++) {
        const m = y * u;
        let b = Number(i & f);
        i >>= p, b > u && (b -= h, i += nw);
        const v = m, k = m + Math.abs(b) - 1, E = y % 2 !== 0, A = b < 0;
        b === 0 ? c = c.add(r(E, a[v])) : l = l.add(r(A, a[k]));
      }
      return { p: l, f: c };
    },
    wNAFCached(o, a, i, s) {
      const u = o._WINDOW_SIZE || 1;
      let l = a.get(o);
      return l || (l = this.precomputeWindow(o, u), u !== 1 && a.set(o, s(l))), this.wNAF(u, l, i);
    }
  };
}
function y$(e) {
  return g$(e.Fp), gd(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...a4(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function afe(e) {
  const t = y$(e);
  gd(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: n, a: o } = t;
  if (r) {
    if (!n.eql(o, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: sfe, hexToBytes: ufe } = Wle, _c = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  _parseInt(e) {
    const { Err: t } = _c;
    if (e.length < 2 || e[0] !== 2)
      throw new t("Invalid signature integer tag");
    const r = e[1], n = e.subarray(2, r + 2);
    if (!r || n.length !== r)
      throw new t("Invalid signature integer: wrong length");
    if (n[0] === 0 && n[1] <= 127)
      throw new t("Invalid signature integer: trailing length");
    return { d: sfe(n), l: e.subarray(r + 2) };
  },
  toSig(e) {
    const { Err: t } = _c, r = typeof e == "string" ? ufe(e) : e;
    if (!(r instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = r.length;
    if (n < 2 || r[0] != 48)
      throw new t("Invalid signature tag");
    if (r[1] !== n - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: o, l: a } = _c._parseInt(r.subarray(2)), { d: i, l: s } = _c._parseInt(a);
    if (s.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: o, s: i };
  },
  hexFromSig(e) {
    const t = (l) => Number.parseInt(l[0], 16) >= 8 ? "00" + l : l, r = (l) => {
      const c = l.toString(16);
      return c.length & 1 ? `0${c}` : c;
    }, n = t(r(e.s)), o = t(r(e.r)), a = n.length / 2, i = o.length / 2, s = r(a), u = r(i);
    return `30${r(i + a + 4)}02${u}${o}02${s}${n}`;
  }
}, fi = BigInt(0), qr = BigInt(1), Ra = BigInt(2), Xg = BigInt(3), T9 = BigInt(4);
function cfe(e) {
  const t = afe(e), { Fp: r } = t, n = t.toBytes || ((y, m, b) => {
    const v = m.toAffine();
    return bo(Uint8Array.from([4]), r.toBytes(v.x), r.toBytes(v.y));
  }), o = t.fromBytes || ((y) => {
    const m = y.subarray(1), b = r.fromBytes(m.subarray(0, r.BYTES)), v = r.fromBytes(m.subarray(r.BYTES, 2 * r.BYTES));
    return { x: b, y: v };
  });
  function a(y) {
    const { a: m, b } = t, v = r.sqr(y), k = r.mul(v, y);
    return r.add(r.add(k, r.mul(y, m)), b);
  }
  function i(y) {
    return typeof y == "bigint" && fi < y && y < t.n;
  }
  function s(y) {
    if (!i(y))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function u(y) {
    const { allowedPrivateKeyLengths: m, nByteLength: b, wrapPrivateKey: v, n: k } = t;
    if (m && typeof y != "bigint") {
      if (y instanceof Uint8Array && (y = jf(y)), typeof y != "string" || !m.includes(y.length))
        throw new Error("Invalid key");
      y = y.padStart(b * 2, "0");
    }
    let E;
    try {
      E = typeof y == "bigint" ? y : jn(dn("private key", y, b));
    } catch {
      throw new Error(`private key must be ${b} bytes, hex or bigint, not ${typeof y}`);
    }
    return v && (E = Wr(E, k)), s(E), E;
  }
  const l = /* @__PURE__ */ new Map();
  function c(y) {
    if (!(y instanceof f))
      throw new Error("ProjectivePoint expected");
  }
  class f {
    constructor(m, b, v) {
      if (this.px = m, this.py = b, this.pz = v, m == null || !r.isValid(m))
        throw new Error("x required");
      if (b == null || !r.isValid(b))
        throw new Error("y required");
      if (v == null || !r.isValid(v))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(m) {
      const { x: b, y: v } = m || {};
      if (!m || !r.isValid(b) || !r.isValid(v))
        throw new Error("invalid affine point");
      if (m instanceof f)
        throw new Error("projective point not allowed");
      const k = (E) => r.eql(E, r.ZERO);
      return k(b) && k(v) ? f.ZERO : new f(b, v, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(m) {
      const b = r.invertBatch(m.map((v) => v.pz));
      return m.map((v, k) => v.toAffine(b[k])).map(f.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(m) {
      const b = f.fromAffine(o(dn("pointHex", m)));
      return b.assertValidity(), b;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(m) {
      return f.BASE.multiply(u(m));
    }
    // "Private method", don't use it directly
    _setWindowSize(m) {
      this._WINDOW_SIZE = m, l.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: m, y: b } = this.toAffine();
      if (!r.isValid(m) || !r.isValid(b))
        throw new Error("bad point: x or y not FE");
      const v = r.sqr(b), k = a(m);
      if (!r.eql(v, k))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: m } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(m);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(m) {
      c(m);
      const { px: b, py: v, pz: k } = this, { px: E, py: A, pz: S } = m, _ = r.eql(r.mul(b, S), r.mul(E, k)), I = r.eql(r.mul(v, S), r.mul(A, k));
      return _ && I;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new f(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: m, b } = t, v = r.mul(b, Xg), { px: k, py: E, pz: A } = this;
      let S = r.ZERO, _ = r.ZERO, I = r.ZERO, O = r.mul(k, k), z = r.mul(E, E), D = r.mul(A, A), G = r.mul(k, E);
      return G = r.add(G, G), I = r.mul(k, A), I = r.add(I, I), S = r.mul(m, I), _ = r.mul(v, D), _ = r.add(S, _), S = r.sub(z, _), _ = r.add(z, _), _ = r.mul(S, _), S = r.mul(G, S), I = r.mul(v, I), D = r.mul(m, D), G = r.sub(O, D), G = r.mul(m, G), G = r.add(G, I), I = r.add(O, O), O = r.add(I, O), O = r.add(O, D), O = r.mul(O, G), _ = r.add(_, O), D = r.mul(E, A), D = r.add(D, D), O = r.mul(D, G), S = r.sub(S, O), I = r.mul(D, z), I = r.add(I, I), I = r.add(I, I), new f(S, _, I);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(m) {
      c(m);
      const { px: b, py: v, pz: k } = this, { px: E, py: A, pz: S } = m;
      let _ = r.ZERO, I = r.ZERO, O = r.ZERO;
      const z = t.a, D = r.mul(t.b, Xg);
      let G = r.mul(b, E), U = r.mul(v, A), V = r.mul(k, S), F = r.add(b, v), C = r.add(E, A);
      F = r.mul(F, C), C = r.add(G, U), F = r.sub(F, C), C = r.add(b, k);
      let R = r.add(E, S);
      return C = r.mul(C, R), R = r.add(G, V), C = r.sub(C, R), R = r.add(v, k), _ = r.add(A, S), R = r.mul(R, _), _ = r.add(U, V), R = r.sub(R, _), O = r.mul(z, C), _ = r.mul(D, V), O = r.add(_, O), _ = r.sub(U, O), O = r.add(U, O), I = r.mul(_, O), U = r.add(G, G), U = r.add(U, G), V = r.mul(z, V), C = r.mul(D, C), U = r.add(U, V), V = r.sub(G, V), V = r.mul(z, V), C = r.add(C, V), G = r.mul(U, C), I = r.add(I, G), G = r.mul(R, C), _ = r.mul(F, _), _ = r.sub(_, G), G = r.mul(F, U), O = r.mul(R, O), O = r.add(O, G), new f(_, I, O);
    }
    subtract(m) {
      return this.add(m.negate());
    }
    is0() {
      return this.equals(f.ZERO);
    }
    wNAF(m) {
      return p.wNAFCached(this, l, m, (b) => {
        const v = r.invertBatch(b.map((k) => k.pz));
        return b.map((k, E) => k.toAffine(v[E])).map(f.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(m) {
      const b = f.ZERO;
      if (m === fi)
        return b;
      if (s(m), m === qr)
        return this;
      const { endo: v } = t;
      if (!v)
        return p.unsafeLadder(this, m);
      let { k1neg: k, k1: E, k2neg: A, k2: S } = v.splitScalar(m), _ = b, I = b, O = this;
      for (; E > fi || S > fi; )
        E & qr && (_ = _.add(O)), S & qr && (I = I.add(O)), O = O.double(), E >>= qr, S >>= qr;
      return k && (_ = _.negate()), A && (I = I.negate()), I = new f(r.mul(I.px, v.beta), I.py, I.pz), _.add(I);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(m) {
      s(m);
      let b = m, v, k;
      const { endo: E } = t;
      if (E) {
        const { k1neg: A, k1: S, k2neg: _, k2: I } = E.splitScalar(b);
        let { p: O, f: z } = this.wNAF(S), { p: D, f: G } = this.wNAF(I);
        O = p.constTimeNegate(A, O), D = p.constTimeNegate(_, D), D = new f(r.mul(D.px, E.beta), D.py, D.pz), v = O.add(D), k = z.add(G);
      } else {
        const { p: A, f: S } = this.wNAF(b);
        v = A, k = S;
      }
      return f.normalizeZ([v, k])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(m, b, v) {
      const k = f.BASE, E = (S, _) => _ === fi || _ === qr || !S.equals(k) ? S.multiplyUnsafe(_) : S.multiply(_), A = E(this, b).add(E(m, v));
      return A.is0() ? void 0 : A;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(m) {
      const { px: b, py: v, pz: k } = this, E = this.is0();
      m == null && (m = E ? r.ONE : r.inv(k));
      const A = r.mul(b, m), S = r.mul(v, m), _ = r.mul(k, m);
      if (E)
        return { x: r.ZERO, y: r.ZERO };
      if (!r.eql(_, r.ONE))
        throw new Error("invZ was invalid");
      return { x: A, y: S };
    }
    isTorsionFree() {
      const { h: m, isTorsionFree: b } = t;
      if (m === qr)
        return !0;
      if (b)
        return b(f, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: m, clearCofactor: b } = t;
      return m === qr ? this : b ? b(f, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(m = !0) {
      return this.assertValidity(), n(f, this, m);
    }
    toHex(m = !0) {
      return jf(this.toRawBytes(m));
    }
  }
  f.BASE = new f(t.Gx, t.Gy, r.ONE), f.ZERO = new f(r.ZERO, r.ONE, r.ZERO);
  const h = t.nBitLength, p = ife(f, t.endo ? Math.ceil(h / 2) : h);
  return {
    CURVE: t,
    ProjectivePoint: f,
    normPrivateKeyToScalar: u,
    weierstrassEquation: a,
    isWithinCurveOrder: i
  };
}
function lfe(e) {
  const t = y$(e);
  return gd(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function ffe(e) {
  const t = lfe(e), { Fp: r, n } = t, o = r.BYTES + 1, a = 2 * r.BYTES + 1;
  function i(C) {
    return fi < C && C < r.ORDER;
  }
  function s(C) {
    return Wr(C, n);
  }
  function u(C) {
    return r8(C, n);
  }
  const { ProjectivePoint: l, normPrivateKeyToScalar: c, weierstrassEquation: f, isWithinCurveOrder: h } = cfe({
    ...t,
    toBytes(C, R, M) {
      const re = R.toAffine(), W = r.toBytes(re.x), ne = bo;
      return M ? ne(Uint8Array.from([R.hasEvenY() ? 2 : 3]), W) : ne(Uint8Array.from([4]), W, r.toBytes(re.y));
    },
    fromBytes(C) {
      const R = C.length, M = C[0], re = C.subarray(1);
      if (R === o && (M === 2 || M === 3)) {
        const W = jn(re);
        if (!i(W))
          throw new Error("Point is not on curve");
        const ne = f(W);
        let oe = r.sqrt(ne);
        const se = (oe & qr) === qr;
        return (M & 1) === 1 !== se && (oe = r.neg(oe)), { x: W, y: oe };
      } else if (R === a && M === 4) {
        const W = r.fromBytes(re.subarray(0, r.BYTES)), ne = r.fromBytes(re.subarray(r.BYTES, 2 * r.BYTES));
        return { x: W, y: ne };
      } else
        throw new Error(`Point of length ${R} was invalid. Expected ${o} compressed bytes or ${a} uncompressed bytes`);
    }
  }), p = (C) => jf(Ou(C, t.nByteLength));
  function y(C) {
    const R = n >> qr;
    return C > R;
  }
  function m(C) {
    return y(C) ? s(-C) : C;
  }
  const b = (C, R, M) => jn(C.slice(R, M));
  class v {
    constructor(R, M, re) {
      this.r = R, this.s = M, this.recovery = re, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(R) {
      const M = t.nByteLength;
      return R = dn("compactSignature", R, M * 2), new v(b(R, 0, M), b(R, M, 2 * M));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(R) {
      const { r: M, s: re } = _c.toSig(dn("DER", R));
      return new v(M, re);
    }
    assertValidity() {
      if (!h(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!h(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(R) {
      return new v(this.r, this.s, R);
    }
    recoverPublicKey(R) {
      const { r: M, s: re, recovery: W } = this, ne = I(dn("msgHash", R));
      if (W == null || ![0, 1, 2, 3].includes(W))
        throw new Error("recovery id invalid");
      const oe = W === 2 || W === 3 ? M + t.n : M;
      if (oe >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const se = W & 1 ? "03" : "02", K = l.fromHex(se + p(oe)), he = u(oe), Ae = s(-ne * he), ye = s(re * he), Et = l.BASE.multiplyAndAddUnsafe(K, Ae, ye);
      if (!Et)
        throw new Error("point at infinify");
      return Et.assertValidity(), Et;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return y(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new v(this.r, s(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Lf(this.toDERHex());
    }
    toDERHex() {
      return _c.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Lf(this.toCompactHex());
    }
    toCompactHex() {
      return p(this.r) + p(this.s);
    }
  }
  const k = {
    isValidPrivateKey(C) {
      try {
        return c(C), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: c,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const C = t.randomBytes(r.BYTES + 8), R = nfe(C, n);
      return Ou(R, t.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(C = 8, R = l.BASE) {
      return R._setWindowSize(C), R.multiply(BigInt(3)), R;
    }
  };
  function E(C, R = !0) {
    return l.fromPrivateKey(C).toRawBytes(R);
  }
  function A(C) {
    const R = C instanceof Uint8Array, M = typeof C == "string", re = (R || M) && C.length;
    return R ? re === o || re === a : M ? re === 2 * o || re === 2 * a : C instanceof l;
  }
  function S(C, R, M = !0) {
    if (A(C))
      throw new Error("first arg must be private key");
    if (!A(R))
      throw new Error("second arg must be public key");
    return l.fromHex(R).multiply(c(C)).toRawBytes(M);
  }
  const _ = t.bits2int || function(C) {
    const R = jn(C), M = C.length * 8 - t.nBitLength;
    return M > 0 ? R >> BigInt(M) : R;
  }, I = t.bits2int_modN || function(C) {
    return s(_(C));
  }, O = i4(t.nBitLength);
  function z(C) {
    if (typeof C != "bigint")
      throw new Error("bigint expected");
    if (!(fi <= C && C < O))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return Ou(C, t.nByteLength);
  }
  function D(C, R, M = G) {
    if (["recovered", "canonical"].some((be) => be in M))
      throw new Error("sign() legacy options not supported");
    const { hash: re, randomBytes: W } = t;
    let { lowS: ne, prehash: oe, extraEntropy: se } = M;
    ne == null && (ne = !0), C = dn("msgHash", C), oe && (C = dn("prehashed msgHash", re(C)));
    const K = I(C), he = c(R), Ae = [z(he), z(K)];
    if (se != null) {
      const be = se === !0 ? W(r.BYTES) : se;
      Ae.push(dn("extraEntropy", be, r.BYTES));
    }
    const ye = bo(...Ae), Et = K;
    function Ge(be) {
      const st = _(be);
      if (!h(st))
        return;
      const Ze = u(st), We = l.BASE.multiply(st).toAffine(), Re = s(We.x);
      if (Re === fi)
        return;
      const Tt = s(Ze * s(Et + Re * he));
      if (Tt === fi)
        return;
      let xr = (We.x === Re ? 0 : 2) | Number(We.y & qr), Wt = Tt;
      return ne && y(Tt) && (Wt = m(Tt), xr ^= 1), new v(Re, Wt, xr);
    }
    return { seed: ye, k2sig: Ge };
  }
  const G = { lowS: t.lowS, prehash: !1 }, U = { lowS: t.lowS, prehash: !1 };
  function V(C, R, M = G) {
    const { seed: re, k2sig: W } = D(C, R, M);
    return p$(t.hash.outputLen, t.nByteLength, t.hmac)(re, W);
  }
  l.BASE._setWindowSize(8);
  function F(C, R, M, re = U) {
    var W;
    const ne = C;
    if (R = dn("msgHash", R), M = dn("publicKey", M), "strict" in re)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: oe, prehash: se } = re;
    let K, he;
    try {
      if (typeof ne == "string" || ne instanceof Uint8Array)
        try {
          K = v.fromDER(ne);
        } catch (We) {
          if (!(We instanceof _c.Err))
            throw We;
          K = v.fromCompact(ne);
        }
      else if (typeof ne == "object" && typeof ne.r == "bigint" && typeof ne.s == "bigint") {
        const { r: We, s: Re } = ne;
        K = new v(We, Re);
      } else
        throw new Error("PARSE");
      he = l.fromHex(M);
    } catch (We) {
      if (We.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (oe && K.hasHighS())
      return !1;
    se && (R = t.hash(R));
    const { r: Ae, s: ye } = K, Et = I(R), Ge = u(ye), be = s(Et * Ge), st = s(Ae * Ge), Ze = (W = l.BASE.multiplyAndAddUnsafe(he, be, st)) == null ? void 0 : W.toAffine();
    return Ze ? s(Ze.x) === Ae : !1;
  }
  return {
    CURVE: t,
    getPublicKey: E,
    getSharedSecret: S,
    sign: V,
    verify: F,
    ProjectivePoint: l,
    Signature: v,
    utils: k
  };
}
function dfe(e, t) {
  const r = e.ORDER;
  let n = fi;
  for (let h = r - qr; h % Ra === fi; h /= Ra)
    n += qr;
  const o = n, a = (r - qr) / Ra ** o, i = (a - qr) / Ra, s = Ra ** o - qr, u = Ra ** (o - qr), l = e.pow(t, a), c = e.pow(t, (a + qr) / Ra);
  let f = (h, p) => {
    let y = l, m = e.pow(p, s), b = e.sqr(m);
    b = e.mul(b, p);
    let v = e.mul(h, b);
    v = e.pow(v, i), v = e.mul(v, m), m = e.mul(v, p), b = e.mul(v, h);
    let k = e.mul(b, m);
    v = e.pow(k, u);
    let E = e.eql(v, e.ONE);
    m = e.mul(b, c), v = e.mul(k, y), b = e.cmov(m, b, E), k = e.cmov(v, k, E);
    for (let A = o; A > 1; A--) {
      let S = Ra ** (A - Ra), _ = e.pow(k, S);
      const I = e.eql(_, e.ONE);
      m = e.mul(b, y), y = e.mul(y, y), _ = e.mul(k, y), b = e.cmov(m, b, I), k = e.cmov(_, k, I);
    }
    return { isValid: E, value: b };
  };
  if (e.ORDER % T9 === Xg) {
    const h = (e.ORDER - Xg) / T9, p = e.sqrt(e.neg(t));
    f = (y, m) => {
      let b = e.sqr(m);
      const v = e.mul(y, m);
      b = e.mul(b, v);
      let k = e.pow(b, h);
      k = e.mul(k, v);
      const E = e.mul(k, p), A = e.mul(e.sqr(k), m), S = e.eql(A, y);
      let _ = e.cmov(E, k, S);
      return { isValid: S, value: _ };
    };
  }
  return f;
}
function hfe(e, t) {
  if (g$(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const r = dfe(e, t.Z);
  if (!e.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (n) => {
    let o, a, i, s, u, l, c, f;
    o = e.sqr(n), o = e.mul(o, t.Z), a = e.sqr(o), a = e.add(a, o), i = e.add(a, e.ONE), i = e.mul(i, t.B), s = e.cmov(t.Z, e.neg(a), !e.eql(a, e.ZERO)), s = e.mul(s, t.A), a = e.sqr(i), l = e.sqr(s), u = e.mul(l, t.A), a = e.add(a, u), a = e.mul(a, i), l = e.mul(l, s), u = e.mul(l, t.B), a = e.add(a, u), c = e.mul(o, i);
    const { isValid: h, value: p } = r(a, l);
    f = e.mul(o, n), f = e.mul(f, p), c = e.cmov(c, i, h), f = e.cmov(f, p, h);
    const y = e.isOdd(n) === e.isOdd(f);
    return f = e.cmov(e.neg(f), f, y), c = e.div(c, s), { x: c, y: f };
  };
}
function pfe(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return Xy(e);
  throw new Error("DST must be Uint8Array or string");
}
const gfe = jn;
function ku(e, t) {
  if (e < 0 || e >= 1 << 8 * t)
    throw new Error(`bad I2OSP call: value=${e} length=${t}`);
  const r = Array.from({ length: t }).fill(0);
  for (let n = t - 1; n >= 0; n--)
    r[n] = e & 255, e >>>= 8;
  return new Uint8Array(r);
}
function mfe(e, t) {
  const r = new Uint8Array(e.length);
  for (let n = 0; n < e.length; n++)
    r[n] = e[n] ^ t[n];
  return r;
}
function Zh(e) {
  if (!(e instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function s4(e) {
  if (!Number.isSafeInteger(e))
    throw new Error("number expected");
}
function yfe(e, t, r, n) {
  Zh(e), Zh(t), s4(r), t.length > 255 && (t = n(bo(Xy("H2C-OVERSIZE-DST-"), t)));
  const { outputLen: o, blockLen: a } = n, i = Math.ceil(r / o);
  if (i > 255)
    throw new Error("Invalid xmd length");
  const s = bo(t, ku(t.length, 1)), u = ku(0, a), l = ku(r, 2), c = new Array(i), f = n(bo(u, e, l, ku(0, 1), s));
  c[0] = n(bo(f, ku(1, 1), s));
  for (let h = 1; h <= i; h++) {
    const p = [mfe(f, c[h - 1]), ku(h + 1, 1), s];
    c[h] = n(bo(...p));
  }
  return bo(...c).slice(0, r);
}
function bfe(e, t, r, n, o) {
  if (Zh(e), Zh(t), s4(r), t.length > 255) {
    const a = Math.ceil(2 * n / 8);
    t = o.create({ dkLen: a }).update(Xy("H2C-OVERSIZE-DST-")).update(t).digest();
  }
  if (r > 65535 || t.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return o.create({ dkLen: r }).update(e).update(ku(r, 2)).update(t).update(ku(t.length, 1)).digest();
}
function P9(e, t, r) {
  gd(r, {
    DST: "string",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: n, k: o, m: a, hash: i, expand: s, DST: u } = r;
  Zh(e), s4(t);
  const l = pfe(u), c = n.toString(2).length, f = Math.ceil((c + o) / 8), h = t * a * f;
  let p;
  if (s === "xmd")
    p = yfe(e, l, h, i);
  else if (s === "xof")
    p = bfe(e, l, h, o, i);
  else if (s === void 0)
    p = e;
  else
    throw new Error('expand must be "xmd", "xof" or undefined');
  const y = new Array(t);
  for (let m = 0; m < t; m++) {
    const b = new Array(a);
    for (let v = 0; v < a; v++) {
      const k = f * (v + m * a), E = p.subarray(k, k + f);
      b[v] = Wr(gfe(E), n);
    }
    y[m] = b;
  }
  return y;
}
function wfe(e, t) {
  const r = t.map((n) => Array.from(n).reverse());
  return (n, o) => {
    const [a, i, s, u] = r.map((l) => l.reduce((c, f) => e.add(e.mul(c, n), f)));
    return n = e.div(a, i), o = e.mul(o, e.div(s, u)), { x: n, y: o };
  };
}
function vfe(e, t, r) {
  if (typeof t != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    hashToCurve(n, o) {
      const a = P9(n, 2, { ...r, DST: r.DST, ...o }), i = e.fromAffine(t(a[0])), s = e.fromAffine(t(a[1])), u = i.add(s).clearCofactor();
      return u.assertValidity(), u;
    },
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    encodeToCurve(n, o) {
      const a = P9(n, 1, { ...r, DST: r.encodeDST, ...o }), i = e.fromAffine(t(a[0])).clearCofactor();
      return i.assertValidity(), i;
    }
  };
}
let b$ = class extends u$ {
  constructor(e, t) {
    super(), this.finished = !1, this.destroyed = !1, Sc.hash(e);
    const r = t4(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const n = this.blockLen, o = new Uint8Array(n);
    o.set(r.length > n ? e.create().update(r).digest() : r);
    for (let a = 0; a < o.length; a++)
      o[a] ^= 54;
    this.iHash.update(o), this.oHash = e.create();
    for (let a = 0; a < o.length; a++)
      o[a] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(e) {
    return Sc.exists(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Sc.exists(this), Sc.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: r, finished: n, destroyed: o, blockLen: a, outputLen: i } = this;
    return e = e, e.finished = n, e.destroyed = o, e.blockLen = a, e.outputLen = i, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const w$ = (e, t, r) => new b$(e, t).update(r).digest();
w$.create = (e, t) => new b$(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Efe(e) {
  return {
    hash: e,
    hmac: (t, ...r) => w$(e, t, Ble(...r)),
    randomBytes: l$
  };
}
function kfe(e, t) {
  const r = (n) => ffe({ ...e, ...Efe(n) });
  return Object.freeze({ ...r(t), create: r });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Yy = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), Yg = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), v$ = BigInt(1), Jg = BigInt(2), O9 = (e, t) => (e + t / Jg) / t;
function E$(e) {
  const t = Yy, r = BigInt(3), n = BigInt(6), o = BigInt(11), a = BigInt(22), i = BigInt(23), s = BigInt(44), u = BigInt(88), l = e * e * e % t, c = l * l * e % t, f = Ho(c, r, t) * c % t, h = Ho(f, r, t) * c % t, p = Ho(h, Jg, t) * l % t, y = Ho(p, o, t) * p % t, m = Ho(y, a, t) * y % t, b = Ho(m, s, t) * m % t, v = Ho(b, u, t) * b % t, k = Ho(v, s, t) * m % t, E = Ho(k, r, t) * c % t, A = Ho(E, i, t) * y % t, S = Ho(A, n, t) * l % t, _ = Ho(S, Jg, t);
  if (!Hu.eql(Hu.sqr(_), e))
    throw new Error("Cannot find square root");
  return _;
}
const Hu = m$(Yy, void 0, void 0, { sqrt: E$ }), wa = kfe({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Hu,
  n: Yg,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = Yg, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -v$ * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), a = r, i = BigInt("0x100000000000000000000000000000000"), s = O9(a * e, t), u = O9(-n * e, t);
      let l = Wr(e - s * r - u * o, t), c = Wr(-s * n - u * a, t);
      const f = l > i, h = c > i;
      if (f && (l = t - l), h && (c = t - c), l > i || c > i)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: f, k1: l, k2neg: h, k2: c };
    }
  }
}, Wg), Jy = BigInt(0), k$ = (e) => typeof e == "bigint" && Jy < e && e < Yy, xfe = (e) => typeof e == "bigint" && Jy < e && e < Yg, $9 = {};
function Qg(e, ...t) {
  let r = $9[e];
  if (r === void 0) {
    const n = Wg(Uint8Array.from(e, (o) => o.charCodeAt(0)));
    r = bo(n, n), $9[e] = r;
  }
  return Wg(bo(r, ...t));
}
const u4 = (e) => e.toRawBytes(!0).slice(1), n8 = (e) => Ou(e, 32), ow = (e) => Wr(e, Yy), Wh = (e) => Wr(e, Yg), c4 = wa.ProjectivePoint, Afe = (e, t, r) => c4.BASE.multiplyAndAddUnsafe(e, t, r);
function o8(e) {
  let t = wa.utils.normPrivateKeyToScalar(e), r = c4.fromPrivateKey(t);
  return { scalar: r.hasEvenY() ? t : Wh(-t), bytes: u4(r) };
}
function x$(e) {
  if (!k$(e))
    throw new Error("bad x: need 0 < x < p");
  const t = ow(e * e), r = ow(t * e + BigInt(7));
  let n = E$(r);
  n % Jg !== Jy && (n = ow(-n));
  const o = new c4(e, n, v$);
  return o.assertValidity(), o;
}
function A$(...e) {
  return Wh(jn(Qg("BIP0340/challenge", ...e)));
}
function Sfe(e) {
  return o8(e).bytes;
}
function _fe(e, t, r = l$(32)) {
  const n = dn("message", e), { bytes: o, scalar: a } = o8(t), i = dn("auxRand", r, 32), s = n8(a ^ jn(Qg("BIP0340/aux", i))), u = Qg("BIP0340/nonce", s, o, n), l = Wh(jn(u));
  if (l === Jy)
    throw new Error("sign failed: k is zero");
  const { bytes: c, scalar: f } = o8(l), h = A$(c, o, n), p = new Uint8Array(64);
  if (p.set(c, 0), p.set(n8(Wh(f + h * a)), 32), !S$(p, n, o))
    throw new Error("sign: Invalid signature produced");
  return p;
}
function S$(e, t, r) {
  const n = dn("signature", e, 64), o = dn("message", t), a = dn("publicKey", r, 32);
  try {
    const i = x$(jn(a)), s = jn(n.subarray(0, 32));
    if (!k$(s))
      return !1;
    const u = jn(n.subarray(32, 64));
    if (!xfe(u))
      return !1;
    const l = A$(n8(s), u4(i), o), c = Afe(i, u, Wh(-l));
    return !(!c || !c.hasEvenY() || c.toAffine().x !== s);
  } catch {
    return !1;
  }
}
const Ife = {
  getPublicKey: Sfe,
  sign: _fe,
  verify: S$,
  utils: {
    randomPrivateKey: wa.utils.randomPrivateKey,
    lift_x: x$,
    pointToBytes: u4,
    numberToBytesBE: Ou,
    bytesToNumberBE: jn,
    taggedHash: Qg,
    mod: Wr
  }
}, Tfe = wfe(Hu, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((e) => e.map((t) => BigInt(t)))), Pfe = hfe(Hu, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Hu.create(BigInt("-11"))
});
vfe(wa.ProjectivePoint, (e) => {
  const { x: t, y: r } = Pfe(Hu.create(e[0]));
  return Tfe(t, r);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Hu.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: Wg
});
function i8(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function Ofe(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function _$(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function $fe(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  i8(e.outputLen), i8(e.blockLen);
}
function Cfe(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function Bfe(e, t) {
  _$(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const Nfe = {
  number: i8,
  bool: Ofe,
  bytes: _$,
  hash: $fe,
  exists: Cfe,
  output: Bfe
};
var iw = Nfe;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const aw = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Xi = (e, t) => e << 32 - t | e >>> t, Ufe = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Ufe)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Rfe(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function I$(e) {
  if (typeof e == "string" && (e = Rfe(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let zfe = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function T$(e) {
  const t = (n) => e().update(I$(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function jfe(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
let Lfe = class extends zfe {
  constructor(e, t, r, n) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = aw(this.buffer);
  }
  update(e) {
    iw.exists(this);
    const { view: t, buffer: r, blockLen: n } = this;
    e = I$(e);
    const o = e.length;
    for (let a = 0; a < o; ) {
      const i = Math.min(n - this.pos, o - a);
      if (i === n) {
        const s = aw(e);
        for (; n <= o - a; a += n)
          this.process(s, a);
        continue;
      }
      r.set(e.subarray(a, a + i), this.pos), this.pos += i, a += i, this.pos === n && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    iw.exists(this), iw.output(e, this), this.finished = !0;
    const { buffer: t, view: r, blockLen: n, isLE: o } = this;
    let { pos: a } = this;
    t[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > n - a && (this.process(r, 0), a = 0);
    for (let c = a; c < n; c++)
      t[c] = 0;
    jfe(r, n - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const i = aw(e), s = this.outputLen;
    if (s % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = s / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let c = 0; c < u; c++)
      i.setUint32(4 * c, l[c], o);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: n, finished: o, destroyed: a, pos: i } = this;
    return e.length = n, e.pos = i, e.finished = o, e.destroyed = a, n % t && e.buffer.set(r), e;
  }
};
const Hfe = (e, t, r) => e & t ^ ~e & r, Ffe = (e, t, r) => e & t ^ e & r ^ t & r, Dfe = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), nu = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), ou = new Uint32Array(64);
let P$ = class extends Lfe {
  constructor() {
    super(64, 32, 8, !1), this.A = nu[0] | 0, this.B = nu[1] | 0, this.C = nu[2] | 0, this.D = nu[3] | 0, this.E = nu[4] | 0, this.F = nu[5] | 0, this.G = nu[6] | 0, this.H = nu[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: n, E: o, F: a, G: i, H: s } = this;
    return [e, t, r, n, o, a, i, s];
  }
  // prettier-ignore
  set(e, t, r, n, o, a, i, s) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = o | 0, this.F = a | 0, this.G = i | 0, this.H = s | 0;
  }
  process(e, t) {
    for (let c = 0; c < 16; c++, t += 4)
      ou[c] = e.getUint32(t, !1);
    for (let c = 16; c < 64; c++) {
      const f = ou[c - 15], h = ou[c - 2], p = Xi(f, 7) ^ Xi(f, 18) ^ f >>> 3, y = Xi(h, 17) ^ Xi(h, 19) ^ h >>> 10;
      ou[c] = y + ou[c - 7] + p + ou[c - 16] | 0;
    }
    let { A: r, B: n, C: o, D: a, E: i, F: s, G: u, H: l } = this;
    for (let c = 0; c < 64; c++) {
      const f = Xi(i, 6) ^ Xi(i, 11) ^ Xi(i, 25), h = l + f + Hfe(i, s, u) + Dfe[c] + ou[c] | 0, p = (Xi(r, 2) ^ Xi(r, 13) ^ Xi(r, 22)) + Ffe(r, n, o) | 0;
      l = u, u = s, s = i, i = a + h | 0, a = o, o = n, n = r, r = h + p | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, i = i + this.E | 0, s = s + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, n, o, a, i, s, u, l);
  }
  roundClean() {
    ou.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, Mfe = class extends P$ {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const a8 = T$(() => new P$());
T$(() => new Mfe());
function Kfe(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function qfe(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function Vfe(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
const { getRandomValues: Gfe } = crypto ?? globalThis.crypto ?? window.crypto;
function Zfe(e = 32) {
  if (typeof Gfe == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function Wfe(e, t, r = "be") {
  t === void 0 && (t = e.length), Kfe(e, t);
  const n = new Uint8Array(t).fill(0), o = r === "be" ? 0 : t - e.length;
  return n.set(e, o), n;
}
function O$(e) {
  let t, r = 0;
  const n = e.reduce((a, i) => a + i.length, 0), o = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const a = e[t];
    o.set(a, r), r += a.length;
  }
  return o;
}
const Xfe = new TextEncoder(), Yfe = [
  {
    name: "base58",
    charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }
];
function $$(e) {
  for (const t of Yfe)
    if (t.name === e)
      return t.charset;
  throw TypeError("Charset does not exist: " + e);
}
function Jfe(e, t, r = !1) {
  typeof e == "string" && (e = Xfe.encode(e));
  const n = $$(t), o = n.length, a = [];
  let i = "", s, u = 0, l, c;
  for (s = 0; s < e.length; s++)
    for (u = 0, l = e[s], i += l > 0 || (i.length ^ s) > 0 ? "" : "1"; u in a || l > 0; )
      c = a[u], c = c > 0 ? c * 256 + l : l, l = c / o | 0, a[u] = c % o, u++;
  for (; u-- > 0; )
    i += n[a[u]];
  return r && i.length % 4 > 0 ? i + "=".repeat(4 - i.length % 4) : i;
}
function Qfe(e, t) {
  const r = $$(t), n = r.length, o = [], a = [];
  e = e.replace("=", "");
  let i, s = 0, u, l;
  for (i = 0; i < e.length; i++) {
    if (s = 0, u = r.indexOf(e[i]), u < 0)
      throw new Error(`Character range out of bounds: ${u}`);
    for (u > 0 || (a.length ^ i) > 0 || a.push(0); s in o || u > 0; )
      l = o[s], l = l > 0 ? l * n + u : u, u = l >> 8, o[s] = l % 256, s++;
  }
  for (; s-- > 0; )
    a.push(o[s]);
  return new Uint8Array(a);
}
function C$(e) {
  return a8(a8(e));
}
function ede(e) {
  const t = C$(e);
  return O$([e, t.slice(0, 4)]);
}
function tde(e) {
  const t = e.slice(0, -4), r = e.slice(-4);
  if (C$(t).slice(0, 4).toString() !== r.toString())
    throw new Error("Invalid checksum!");
  return t;
}
const C9 = {
  encode: Jfe,
  decode: Qfe
}, B$ = {
  encode: (e) => {
    const t = ede(e);
    return C9.encode(t, "base58");
  },
  decode: (e) => {
    const t = C9.decode(e, "base58");
    return tde(t);
  }
}, N$ = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", rde = [996825010, 642813549, 513874426, 1027748829, 705979059], em = [
  { version: 0, name: "bech32", const: 1 },
  { version: 1, name: "bech32m", const: 734539939 }
];
function U$(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = t >> 25;
    t = (t & 33554431) << 5 ^ e[r];
    for (let o = 0; o < 5; ++o)
      n >> o & 1 && (t ^= rde[o]);
  }
  return t;
}
function R$(e) {
  const t = [];
  let r;
  for (r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) >> 5);
  for (t.push(0), r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) & 31);
  return t;
}
function nde(e, t, r) {
  const n = R$(e).concat(t);
  return U$(n) === r.const;
}
function ode(e, t, r) {
  const n = R$(e).concat(t).concat([0, 0, 0, 0, 0, 0]), o = U$(n) ^ r.const, a = [];
  for (let i = 0; i < 6; ++i)
    a.push(o >> 5 * (5 - i) & 31);
  return a;
}
function z$(e, t, r, n = !0) {
  const o = [];
  let a = 0, i = 0;
  const s = (1 << r) - 1, u = (1 << t + r - 1) - 1;
  for (const l of e) {
    if (l < 0 || l >> t > 0)
      throw new Error("Failed to perform base conversion. Invalid value: " + String(l));
    for (a = (a << t | l) & u, i += t; i >= r; )
      i -= r, o.push(a >> i & s);
  }
  if (n)
    i > 0 && o.push(a << r - i & s);
  else if (i >= t || (a << r - i & s) > 0)
    throw new Error("Failed to perform base conversion. Invalid Size!");
  return o;
}
function ide(e, t, r) {
  const n = t.concat(ode(e, t, r));
  let o = e + "1";
  for (let a = 0; a < n.length; ++a)
    o += N$.charAt(n[a]);
  return o;
}
function j$(e) {
  if (!ade(e))
    throw new Error("Encoded string goes out of bounds!");
  if (e = e.toLowerCase(), !sde(e))
    throw new Error("Encoded string has invalid separator!");
  const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
  for (let a = r + 1; a < e.length; ++a) {
    const i = N$.indexOf(e.charAt(a));
    if (i === -1)
      throw new Error("Character idx out of bounds: " + String(a));
    t.push(i);
  }
  const o = em.find((a) => a.version === t[0]) ?? em[0];
  if (!nde(n, t, o))
    throw new Error("Checksum verification failed!");
  return [n, t.slice(0, t.length - 6)];
}
function ade(e) {
  let t, r, n = !1, o = !1;
  for (t = 0; t < e.length; ++t) {
    if (r = e.charCodeAt(t), r < 33 || r > 126)
      return !1;
    r >= 97 && r <= 122 && (n = !0), r >= 65 && r <= 90 && (o = !0);
  }
  return !(n && o);
}
function sde(e) {
  const t = e.lastIndexOf("1");
  return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function ude(e, t = "bc", r = 0) {
  const n = [r, ...z$([...e], 8, 5)], o = em.find((i) => i.version === r) ?? em[0], a = ide(t, n, o);
  return L$(a), a;
}
function L$(e) {
  e = e.toLowerCase();
  const t = e.split("1", 1)[0], [r, n] = j$(e), o = z$(n.slice(1), 5, 8, !1), a = o.length;
  switch (!0) {
    case t !== r:
      throw new Error("Returned hrp string is invalid.");
    case (o === null || a < 2 || a > 40):
      throw new Error("Decoded string is invalid or out of spec.");
    case n[0] > 16:
      throw new Error("Returned version bit is out of range.");
    default:
      return Uint8Array.from(o);
  }
}
function cde(e) {
  e = e.toLowerCase();
  const [t, r] = j$(e);
  return r[0];
}
const H$ = {
  encode: ude,
  decode: L$,
  version: cde
}, F$ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", D$ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", lde = new TextEncoder();
function M$(e, t = !1, r = !0) {
  typeof e == "string" && (e = lde.encode(e));
  const n = t ? D$ : F$;
  let o = "", a = 0, i = 0;
  for (let s = 0; s < e.length; s++)
    for (i = i << 8 | e[s], a += 8; a >= 6; )
      a -= 6, o += n[i >> a & 63];
  if (a > 0)
    for (i <<= 6 - a, o += n[i & 63]; a < 6; )
      o += r ? "=" : "", a += 2;
  return o;
}
function K$(e, t = !1) {
  const r = t || e.includes("-") || e.includes("_") ? D$.split("") : F$.split("");
  e = e.replace(/=+$/, "");
  const n = e.split("");
  let o = 0, a = 0;
  const i = [];
  for (let s = 0; s < n.length; s++) {
    const u = n[s], l = r.indexOf(u);
    if (l === -1)
      throw new Error("Invalid character: " + u);
    o += 6, a <<= 6, a |= l, o >= 8 && (o -= 8, i.push(a >>> o & 255));
  }
  return new Uint8Array(i);
}
const q$ = {
  encode: M$,
  decode: K$
}, V$ = {
  encode: (e) => M$(e, !0, !1),
  decode: (e) => K$(e, !0)
}, fde = BigInt(0), dde = BigInt(255), G$ = BigInt(256);
function hde(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function pde(e, t, r = "be") {
  t === void 0 && (t = hde(e));
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (; e > fde; ) {
    const s = e & dde, u = Number(s);
    n ? a.setUint8(i++, u) : a.setUint8(i--, u), e = (e - s) / G$;
  }
  return new Uint8Array(o);
}
function gde(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * G$ + BigInt(e[r]);
  return BigInt(t);
}
function mde(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, o = 0; n < t.length; n += 8, o++) {
    let a = 0;
    for (let i = 0; i < 8; i++)
      a |= t[n + i] << 7 - i;
    r[o] = a;
  }
  return r;
}
function yde(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let o = 7; o >= 0; o--, r++)
      t[r] = n >> o & 1;
  }
  return t.join("");
}
function bde(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function wde(e, t, r = "be") {
  t === void 0 && (t = bde(e));
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (; e > 0; ) {
    const s = e & 255;
    n ? a.setUint8(i++, e) : a.setUint8(i--, e), e = (e - s) / 256;
  }
  return new Uint8Array(o);
}
function vde(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], Vfe(t);
  return t;
}
const Ede = new TextEncoder(), kde = new TextDecoder();
function l4(e) {
  return Ede.encode(e);
}
function s8(e) {
  return kde.decode(e);
}
function xde(e, t) {
  qfe(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function Ade(e, t, r = "le") {
  t = xde(e, t);
  const n = r === "le", o = new ArrayBuffer(t), a = new DataView(o);
  let i = n ? 0 : t - 1;
  for (let s = 0; s < e.length; s += 2) {
    const u = e.substring(s, s + 2), l = parseInt(u, 16);
    n ? a.setUint8(i++, l) : a.setUint8(i--, l);
  }
  return new Uint8Array(o);
}
function Sde(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function _de(e) {
  const t = JSON.stringify(e, (r, n) => typeof n == "bigint" ? `${n}n` : n);
  return l4(t);
}
function Ide(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return Wfe(e, t, r);
  if (typeof e == "string")
    return Ade(e, t, r);
  if (typeof e == "bigint")
    return pde(e, t, r);
  if (typeof e == "number")
    return wde(e, t, r);
  if (typeof e == "boolean")
    return Uint8Array.of(e ? 1 : 0);
  throw TypeError("Unsupported format:" + typeof e);
}
const Tn = class Qt extends Uint8Array {
  static random(t = 32) {
    const r = Zfe(t);
    return new Qt(r, t);
  }
  constructor(t, r, n) {
    const o = Ide(t, r, n);
    super(o);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.toNum();
  }
  get big() {
    return this.toBig();
  }
  get str() {
    return this.toStr();
  }
  get hex() {
    return this.toHex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.toBin();
  }
  get b58chk() {
    return this.tob58chk();
  }
  get base64() {
    return this.toBase64();
  }
  get b64url() {
    return this.toB64url();
  }
  get digest() {
    return this.toHash();
  }
  get id() {
    return this.toHash().hex;
  }
  get stream() {
    return new Hde(this);
  }
  toNum(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return vde(r);
  }
  toBin() {
    return yde(this);
  }
  toBig(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return gde(r);
  }
  toHash() {
    const t = a8(this);
    return new Qt(t);
  }
  toJson() {
    const t = s8(this);
    return JSON.parse(t);
  }
  toBech32(t, r = 0) {
    return H$.encode(this, t, r);
  }
  toStr() {
    return s8(this);
  }
  toHex() {
    return Sde(this);
  }
  toBytes() {
    return new Uint8Array(this);
  }
  tob58chk() {
    return B$.encode(this);
  }
  toBase64() {
    return q$.encode(this);
  }
  toB64url() {
    return V$.encode(this);
  }
  prepend(t) {
    return Qt.join([Qt.bytes(t), this]);
  }
  append(t) {
    return Qt.join([this, Qt.bytes(t)]);
  }
  slice(t, r) {
    const n = new Uint8Array(this).slice(t, r);
    return new Qt(n);
  }
  subarray(t, r) {
    const n = new Uint8Array(this).subarray(t, r);
    return new Qt(n);
  }
  reverse() {
    const t = new Uint8Array(this).reverse();
    return new Qt(t);
  }
  write(t, r) {
    const n = Qt.bytes(t);
    this.set(n, r);
  }
  prefixSize(t) {
    const r = Qt.varInt(this.length, t);
    return Qt.join([r, this]);
  }
  static from(t) {
    return new Qt(Uint8Array.from(t));
  }
  static of(...t) {
    return new Qt(Uint8Array.of(...t));
  }
  static join(t) {
    const r = t.map((o) => Qt.bytes(o)), n = O$(r);
    return new Qt(n);
  }
  static varInt(t, r) {
    if (t < 253)
      return Qt.num(t, 1);
    if (t < 65536)
      return Qt.of(253, ...Qt.num(t, 2, r));
    if (t < 4294967296)
      return Qt.of(254, ...Qt.num(t, 4, r));
    if (BigInt(t) < 0x10000000000000000n)
      return Qt.of(255, ...Qt.num(t, 8, r));
    throw new Error(`Value is too large: ${t}`);
  }
};
Tn.num = Tde, Tn.big = Ode, Tn.bin = Pde, Tn.raw = $de, Tn.str = Cde, Tn.hex = Bde, Tn.bytes = Nde, Tn.json = Ude, Tn.base64 = Rde, Tn.b64url = zde, Tn.bech32 = jde, Tn.b58chk = Lde, Tn.encode = l4, Tn.decode = s8;
let et = Tn;
function Tde(e, t, r) {
  return new et(e, t, r);
}
function Pde(e, t, r) {
  return new et(mde(e), t, r);
}
function Ode(e, t, r) {
  return new et(e, t, r);
}
function $de(e, t, r) {
  return new et(e, t, r);
}
function Cde(e, t, r) {
  return new et(l4(e), t, r);
}
function Bde(e, t, r) {
  return new et(e, t, r);
}
function Nde(e, t, r) {
  return new et(e, t, r);
}
function Ude(e) {
  return new et(_de(e));
}
function Rde(e) {
  return new et(q$.decode(e));
}
function zde(e) {
  return new et(V$.decode(e));
}
function jde(e) {
  return new et(H$.decode(e));
}
function Lde(e) {
  return new et(B$.decode(e));
}
class Hde {
  constructor(t) {
    this.data = et.bytes(t), this.size = this.data.length;
  }
  peek(t) {
    if (t > this.size)
      throw new Error(`Size greater than stream: ${t} > ${this.size}`);
    return new et(this.data.slice(0, t));
  }
  read(t) {
    t = t ?? this.readSize();
    const r = this.peek(t);
    return this.data = this.data.slice(t), this.size = this.data.length, r;
  }
  readSize(t) {
    const r = this.read(1).num;
    switch (!0) {
      case (r >= 0 && r < 253):
        return r;
      case r === 253:
        return this.read(2).toNum(t);
      case r === 254:
        return this.read(4).toNum(t);
      case r === 255:
        return this.read(8).toNum(t);
      default:
        throw new Error(`Varint is out of range: ${r}`);
    }
  }
}
const tm = wa.CURVE, f4 = tm.n, Fde = tm.p, Dde = { x: tm.Gx, y: tm.Gy }, Mde = BigInt(0), Kde = BigInt(1), qde = BigInt(2), Vde = BigInt(3), Gde = BigInt(4), u8 = { N: f4, P: Fde, G: Dde, _0n: Mde, _1n: Kde, _2n: qde, _3n: Vde, _4n: Gde }, Vd = m$(f4, 32, !0), Z$ = (e) => Wr(e, f4);
function d4(e, t = !1) {
  if (t)
    throw new Error(e);
  return !1;
}
function W$(e) {
  return et.random(e);
}
function Zde(e) {
  const t = et.bytes(e).big;
  return et.big(Z$(t), 32);
}
var Wde = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fail: d4,
  mod_bytes: Zde,
  random: W$
});
const { N: Xde, P: j5e, _0n: Yde } = u8;
function Jde(e, t, r) {
  const n = et.bytes(e);
  return n.length !== t ? d4(`Invalid byte size: ${n.hex} !== ${t}`, r) : !0;
}
function Qde(e, t) {
  return typeof e == "bigint" && Yde < e && e < Xde || d4("x value is not in the field!", t), !0;
}
const B9 = wa.ProjectivePoint, X$ = class Fr extends Uint8Array {
  static mod(t) {
    return new Fr(t);
  }
  static is_valid(t, r) {
    const n = et.bytes(t, 32).big;
    return Qde(n, r);
  }
  constructor(t) {
    let r = ehe(t);
    r = Z$(r), Fr.is_valid(r, !0), super(et.big(r, 32), 32);
  }
  get buff() {
    return new et(this);
  }
  get raw() {
    return this.buff.raw;
  }
  get big() {
    return this.buff.big;
  }
  get hex() {
    return this.buff.hex;
  }
  get point() {
    return this.generate();
  }
  get hasOddY() {
    return this.point.hasOddY;
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  gt(t) {
    return new Fr(t).big > this.big;
  }
  lt(t) {
    return new Fr(t).big < this.big;
  }
  eq(t) {
    return new Fr(t).big === this.big;
  }
  ne(t) {
    return new Fr(t).big !== this.big;
  }
  add(t) {
    const r = Fr.mod(t), n = Vd.add(this.big, r.big);
    return new Fr(n);
  }
  sub(t) {
    const r = Fr.mod(t), n = Vd.sub(this.big, r.big);
    return new Fr(n);
  }
  mul(t) {
    const r = Fr.mod(t), n = Vd.mul(this.big, r.big);
    return new Fr(n);
  }
  pow(t) {
    const r = Fr.mod(t), n = Vd.pow(this.big, r.big);
    return new Fr(n);
  }
  div(t) {
    const r = Fr.mod(t), n = Vd.div(this.big, r.big);
    return new Fr(n);
  }
  negate() {
    return new Fr(Fr.N - this.big);
  }
  generate() {
    const t = wa.ProjectivePoint.BASE.multiply(this.big);
    return vl.import(t);
  }
};
X$.N = wa.CURVE.n;
let Un = X$;
const $1 = class Nr {
  static from_x(t) {
    let r = the(t);
    r.length === 32 && (r = r.prepend(2)), Jde(r, 33);
    const n = B9.fromHex(r.hex);
    return n.assertValidity(), new Nr(n.x, n.y);
  }
  static generate(t) {
    const r = Un.mod(t), n = Nr.base.multiply(r.big);
    return Nr.import(n);
  }
  static import(t) {
    const r = t instanceof Nr ? { x: t.x.big, y: t.y.big } : { x: t.x, y: t.y };
    return new Nr(r.x, r.y);
  }
  constructor(t, r) {
    this._p = new B9(t, r, 1n), this.p.assertValidity();
  }
  get p() {
    return this._p;
  }
  get x() {
    return et.big(this.p.x, 32);
  }
  get y() {
    return et.big(this.p.y, 32);
  }
  get buff() {
    return et.raw(this.p.toRawBytes(!0));
  }
  get raw() {
    return this.buff.raw;
  }
  get hex() {
    return this.buff.hex;
  }
  get hasEvenY() {
    return this.p.hasEvenY();
  }
  get hasOddY() {
    return !this.p.hasEvenY();
  }
  eq(t) {
    const r = t instanceof Nr ? t : Nr.from_x(t);
    return this.x.big === r.x.big && this.y.big === r.y.big;
  }
  add(t) {
    return t instanceof Nr ? Nr.import(this.p.add(t.p)) : Nr.import(this.p.add(Nr.generate(t).p));
  }
  sub(t) {
    return t instanceof Nr ? Nr.import(this.p.subtract(t.p)) : Nr.import(this.p.subtract(Nr.generate(t).p));
  }
  mul(t) {
    return t instanceof Nr ? Nr.import(this.p.multiply(t.x.big)) : Nr.import(this.p.multiply(Un.mod(t).big));
  }
  negate() {
    return Nr.import(this.p.negate());
  }
};
$1.P = u8.P, $1.G = u8.G, $1.base = wa.ProjectivePoint.BASE;
let vl = $1;
function ehe(e) {
  if (e instanceof Un)
    return e.big;
  if (e instanceof vl)
    return e.x.big;
  if (e instanceof Uint8Array)
    return et.raw(e).big;
  if (typeof e == "string")
    return et.hex(e).big;
  if (typeof e == "number")
    return et.num(e).big;
  if (typeof e == "bigint")
    return BigInt(e);
  throw TypeError("Invalid input type:" + typeof e);
}
function the(e) {
  if (e instanceof Un)
    return e.point.buff;
  if (e instanceof vl)
    return e.buff;
  if (e instanceof Uint8Array || typeof e == "string")
    return et.bytes(e);
  if (typeof e == "number" || typeof e == "bigint")
    return et.bytes(e, 32);
  throw new TypeError(`Unknown type: ${typeof e}`);
}
function c8(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function rhe(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function Y$(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function nhe(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  c8(e.outputLen), c8(e.blockLen);
}
function ohe(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function ihe(e, t) {
  Y$(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const ahe = {
  number: c8,
  bool: rhe,
  bytes: Y$,
  hash: nhe,
  exists: ohe,
  output: ihe
};
var Ic = ahe;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const she = (e) => e instanceof Uint8Array, sw = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Yi = (e, t) => e << 32 - t | e >>> t, uhe = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!uhe)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function che(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function h4(e) {
  if (typeof e == "string" && (e = che(e)), !she(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
class J$ {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function El(e) {
  const t = (n) => e().update(h4(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function lhe(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
class p4 extends J$ {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = sw(this.buffer);
  }
  update(t) {
    Ic.exists(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = h4(t);
    const a = t.length;
    for (let i = 0; i < a; ) {
      const s = Math.min(o - this.pos, a - i);
      if (s === o) {
        const u = sw(t);
        for (; o <= a - i; i += o)
          this.process(u, i);
        continue;
      }
      n.set(t.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Ic.exists(this), Ic.output(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: o, isLE: a } = this;
    let { pos: i } = this;
    r[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > o - i && (this.process(n, 0), i = 0);
    for (let f = i; f < o; f++)
      r[f] = 0;
    lhe(n, o - 8, BigInt(this.length * 8), a), this.process(n, 0);
    const s = sw(t), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, c = this.get();
    if (l > c.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < l; f++)
      s.setUint32(4 * f, c[f], a);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: a, destroyed: i, pos: s } = this;
    return t.length = o, t.pos = s, t.finished = a, t.destroyed = i, o % r && t.buffer.set(n), t;
  }
}
const fhe = (e, t, r) => e & t ^ ~e & r, dhe = (e, t, r) => e & t ^ e & r ^ t & r, hhe = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), iu = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), au = new Uint32Array(64);
let Q$ = class extends p4 {
  constructor() {
    super(64, 32, 8, !1), this.A = iu[0] | 0, this.B = iu[1] | 0, this.C = iu[2] | 0, this.D = iu[3] | 0, this.E = iu[4] | 0, this.F = iu[5] | 0, this.G = iu[6] | 0, this.H = iu[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: n, E: o, F: a, G: i, H: s } = this;
    return [e, t, r, n, o, a, i, s];
  }
  // prettier-ignore
  set(e, t, r, n, o, a, i, s) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = o | 0, this.F = a | 0, this.G = i | 0, this.H = s | 0;
  }
  process(e, t) {
    for (let c = 0; c < 16; c++, t += 4)
      au[c] = e.getUint32(t, !1);
    for (let c = 16; c < 64; c++) {
      const f = au[c - 15], h = au[c - 2], p = Yi(f, 7) ^ Yi(f, 18) ^ f >>> 3, y = Yi(h, 17) ^ Yi(h, 19) ^ h >>> 10;
      au[c] = y + au[c - 7] + p + au[c - 16] | 0;
    }
    let { A: r, B: n, C: o, D: a, E: i, F: s, G: u, H: l } = this;
    for (let c = 0; c < 64; c++) {
      const f = Yi(i, 6) ^ Yi(i, 11) ^ Yi(i, 25), h = l + f + fhe(i, s, u) + hhe[c] + au[c] | 0, p = (Yi(r, 2) ^ Yi(r, 13) ^ Yi(r, 22)) + dhe(r, n, o) | 0;
      l = u, u = s, s = i, i = a + h | 0, a = o, o = n, n = r, r = h + p | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, i = i + this.E | 0, s = s + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, n, o, a, i, s, u, l);
  }
  roundClean() {
    au.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, phe = class extends Q$ {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const rm = El(() => new Q$());
El(() => new phe());
const e1 = BigInt(2 ** 32 - 1), l8 = BigInt(32);
function eC(e, t = !1) {
  return t ? { h: Number(e & e1), l: Number(e >> l8 & e1) } : { h: Number(e >> l8 & e1) | 0, l: Number(e & e1) | 0 };
}
function ghe(e, t = !1) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: a, l: i } = eC(e[o], t);
    [r[o], n[o]] = [a, i];
  }
  return [r, n];
}
const mhe = (e, t) => BigInt(e >>> 0) << l8 | BigInt(t >>> 0), yhe = (e, t, r) => e >>> r, bhe = (e, t, r) => e << 32 - r | t >>> r, whe = (e, t, r) => e >>> r | t << 32 - r, vhe = (e, t, r) => e << 32 - r | t >>> r, Ehe = (e, t, r) => e << 64 - r | t >>> r - 32, khe = (e, t, r) => e >>> r - 32 | t << 64 - r, xhe = (e, t) => t, Ahe = (e, t) => e, She = (e, t, r) => e << r | t >>> 32 - r, _he = (e, t, r) => t << r | e >>> 32 - r, Ihe = (e, t, r) => t << r - 32 | e >>> 64 - r, The = (e, t, r) => e << r - 32 | t >>> 64 - r;
function Phe(e, t, r, n) {
  const o = (t >>> 0) + (n >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
const Ohe = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0), $he = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0, Che = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), Bhe = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0, Nhe = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0), Uhe = (e, t, r, n, o, a) => t + r + n + o + a + (e / 2 ** 32 | 0) | 0, Rhe = {
  fromBig: eC,
  split: ghe,
  toBig: mhe,
  shrSH: yhe,
  shrSL: bhe,
  rotrSH: whe,
  rotrSL: vhe,
  rotrBH: Ehe,
  rotrBL: khe,
  rotr32H: xhe,
  rotr32L: Ahe,
  rotlSH: She,
  rotlSL: _he,
  rotlBH: Ihe,
  rotlBL: The,
  add: Phe,
  add3L: Ohe,
  add3H: $he,
  add4L: Che,
  add4H: Bhe,
  add5H: Uhe,
  add5L: Nhe
};
var wt = Rhe;
const [zhe, jhe] = wt.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))), su = new Uint32Array(80), uu = new Uint32Array(80);
let Qy = class extends p4 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: t, Bh: r, Bl: n, Ch: o, Cl: a, Dh: i, Dl: s, Eh: u, El: l, Fh: c, Fl: f, Gh: h, Gl: p, Hh: y, Hl: m } = this;
    return [e, t, r, n, o, a, i, s, u, l, c, f, h, p, y, m];
  }
  // prettier-ignore
  set(e, t, r, n, o, a, i, s, u, l, c, f, h, p, y, m) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = r | 0, this.Bl = n | 0, this.Ch = o | 0, this.Cl = a | 0, this.Dh = i | 0, this.Dl = s | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = c | 0, this.Fl = f | 0, this.Gh = h | 0, this.Gl = p | 0, this.Hh = y | 0, this.Hl = m | 0;
  }
  process(e, t) {
    for (let k = 0; k < 16; k++, t += 4)
      su[k] = e.getUint32(t), uu[k] = e.getUint32(t += 4);
    for (let k = 16; k < 80; k++) {
      const E = su[k - 15] | 0, A = uu[k - 15] | 0, S = wt.rotrSH(E, A, 1) ^ wt.rotrSH(E, A, 8) ^ wt.shrSH(E, A, 7), _ = wt.rotrSL(E, A, 1) ^ wt.rotrSL(E, A, 8) ^ wt.shrSL(E, A, 7), I = su[k - 2] | 0, O = uu[k - 2] | 0, z = wt.rotrSH(I, O, 19) ^ wt.rotrBH(I, O, 61) ^ wt.shrSH(I, O, 6), D = wt.rotrSL(I, O, 19) ^ wt.rotrBL(I, O, 61) ^ wt.shrSL(I, O, 6), G = wt.add4L(_, D, uu[k - 7], uu[k - 16]), U = wt.add4H(G, S, z, su[k - 7], su[k - 16]);
      su[k] = U | 0, uu[k] = G | 0;
    }
    let { Ah: r, Al: n, Bh: o, Bl: a, Ch: i, Cl: s, Dh: u, Dl: l, Eh: c, El: f, Fh: h, Fl: p, Gh: y, Gl: m, Hh: b, Hl: v } = this;
    for (let k = 0; k < 80; k++) {
      const E = wt.rotrSH(c, f, 14) ^ wt.rotrSH(c, f, 18) ^ wt.rotrBH(c, f, 41), A = wt.rotrSL(c, f, 14) ^ wt.rotrSL(c, f, 18) ^ wt.rotrBL(c, f, 41), S = c & h ^ ~c & y, _ = f & p ^ ~f & m, I = wt.add5L(v, A, _, jhe[k], uu[k]), O = wt.add5H(I, b, E, S, zhe[k], su[k]), z = I | 0, D = wt.rotrSH(r, n, 28) ^ wt.rotrBH(r, n, 34) ^ wt.rotrBH(r, n, 39), G = wt.rotrSL(r, n, 28) ^ wt.rotrBL(r, n, 34) ^ wt.rotrBL(r, n, 39), U = r & o ^ r & i ^ o & i, V = n & a ^ n & s ^ a & s;
      b = y | 0, v = m | 0, y = h | 0, m = p | 0, h = c | 0, p = f | 0, { h: c, l: f } = wt.add(u | 0, l | 0, O | 0, z | 0), u = i | 0, l = s | 0, i = o | 0, s = a | 0, o = r | 0, a = n | 0;
      const F = wt.add3L(z, G, V);
      r = wt.add3H(F, O, D, U), n = F | 0;
    }
    ({ h: r, l: n } = wt.add(this.Ah | 0, this.Al | 0, r | 0, n | 0)), { h: o, l: a } = wt.add(this.Bh | 0, this.Bl | 0, o | 0, a | 0), { h: i, l: s } = wt.add(this.Ch | 0, this.Cl | 0, i | 0, s | 0), { h: u, l } = wt.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h: c, l: f } = wt.add(this.Eh | 0, this.El | 0, c | 0, f | 0), { h, l: p } = wt.add(this.Fh | 0, this.Fl | 0, h | 0, p | 0), { h: y, l: m } = wt.add(this.Gh | 0, this.Gl | 0, y | 0, m | 0), { h: b, l: v } = wt.add(this.Hh | 0, this.Hl | 0, b | 0, v | 0), this.set(r, n, o, a, i, s, u, l, c, f, h, p, y, m, b, v);
  }
  roundClean() {
    su.fill(0), uu.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}, Lhe = class extends Qy {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}, Hhe = class extends Qy {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}, Fhe = class extends Qy {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
const Dhe = El(() => new Qy());
El(() => new Lhe());
El(() => new Hhe());
El(() => new Fhe());
const Mhe = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), tC = Uint8Array.from({ length: 16 }, (e, t) => t), Khe = tC.map((e) => (9 * e + 5) % 16);
let g4 = [tC], m4 = [Khe];
for (let e = 0; e < 4; e++)
  for (let t of [g4, m4])
    t.push(t[e].map((r) => Mhe[r]));
const rC = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => new Uint8Array(e)), qhe = g4.map((e, t) => e.map((r) => rC[t][r])), Vhe = m4.map((e, t) => e.map((r) => rC[t][r])), Ghe = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]), Zhe = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]), t1 = (e, t) => e << t | e >>> 32 - t;
function N9(e, t, r, n) {
  return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const r1 = new Uint32Array(16);
class Whe extends p4 {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: t, h1: r, h2: n, h3: o, h4: a } = this;
    return [t, r, n, o, a];
  }
  set(t, r, n, o, a) {
    this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = o | 0, this.h4 = a | 0;
  }
  process(t, r) {
    for (let p = 0; p < 16; p++, r += 4)
      r1[p] = t.getUint32(r, !0);
    let n = this.h0 | 0, o = n, a = this.h1 | 0, i = a, s = this.h2 | 0, u = s, l = this.h3 | 0, c = l, f = this.h4 | 0, h = f;
    for (let p = 0; p < 5; p++) {
      const y = 4 - p, m = Ghe[p], b = Zhe[p], v = g4[p], k = m4[p], E = qhe[p], A = Vhe[p];
      for (let S = 0; S < 16; S++) {
        const _ = t1(n + N9(p, a, s, l) + r1[v[S]] + m, E[S]) + f | 0;
        n = f, f = l, l = t1(s, 10) | 0, s = a, a = _;
      }
      for (let S = 0; S < 16; S++) {
        const _ = t1(o + N9(y, i, u, c) + r1[k[S]] + b, A[S]) + h | 0;
        o = h, h = c, c = t1(u, 10) | 0, u = i, i = _;
      }
    }
    this.set(this.h1 + s + c | 0, this.h2 + l + h | 0, this.h3 + f + o | 0, this.h4 + n + i | 0, this.h0 + a + u | 0);
  }
  roundClean() {
    r1.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
const Xhe = El(() => new Whe());
class nC extends J$ {
  constructor(t, r) {
    super(), this.finished = !1, this.destroyed = !1, Ic.hash(t);
    const n = h4(r);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o = this.blockLen, a = new Uint8Array(o);
    a.set(n.length > o ? t.create().update(n).digest() : n);
    for (let i = 0; i < a.length; i++)
      a[i] ^= 54;
    this.iHash.update(a), this.oHash = t.create();
    for (let i = 0; i < a.length; i++)
      a[i] ^= 106;
    this.oHash.update(a), a.fill(0);
  }
  update(t) {
    return Ic.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Ic.exists(this), Ic.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: o, destroyed: a, blockLen: i, outputLen: s } = this;
    return t = t, t.finished = o, t.destroyed = a, t.blockLen = i, t.outputLen = s, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const oC = (e, t, r) => new nC(e, t).update(r).digest();
oC.create = (e, t) => new nC(e, t);
function Yhe(e) {
  const t = et.bytes(e);
  return et.raw(rm(t));
}
function Hf(e) {
  const t = et.bytes(e);
  return et.raw(rm(rm(t)));
}
function y4(e) {
  const t = et.bytes(e);
  return et.raw(Xhe(rm(t)));
}
function Jhe(e, t) {
  const r = et.bytes(e), n = et.bytes(t);
  return et.raw(oC(Dhe, r, n));
}
function Qhe(e) {
  const t = et.str(e).digest;
  return et.join([t, t]);
}
function epe(e = 32) {
  return b4(W$(e));
}
function b4(e) {
  return Un.mod(e).buff;
}
function iC(e, t = !1) {
  const r = Un.mod(e).point;
  return t ? r.x : r.buff;
}
function aC(e, t) {
  const r = vl.from_x(t), n = Un.mod(e);
  return r.mul(n).buff;
}
function tpe(e, t, r = "ecdh/code") {
  const n = Qhe(r), o = b4(e), a = iC(o), i = et.bytes(t), s = aC(o, i), u = [a.hex, i.hex];
  return u.sort(), Jhe(s, et.join([n, ...u]));
}
function rpe(e) {
  const t = et.bytes(e);
  switch (!0) {
    case t.length === 32:
      return !0;
    case (t.length === 33 && t[0] === 2):
      return !0;
    case (t.length === 33 && t[0] === 3):
      return !1;
    default:
      throw new TypeError(`Invalid public key: ${t.hex}`);
  }
}
function npe(e) {
  const t = et.bytes(e);
  switch (t.length) {
    case 32:
      return t;
    case 33:
      return t.slice(1, 33);
    default:
      throw new Error(`Invalid key length: ${t.length}`);
  }
}
var ope = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  genSecretKey: epe,
  getPublicKey: iC,
  getSecretKey: b4,
  getSharedCode: tpe,
  getSharedKey: aC,
  is_even_pub: rpe,
  xonly_pub: npe
});
et.random(32);
const sC = { secp: wa, schnorr: Ife }, f8 = { ...ope, ...Wde };
function eb(e) {
  const t = J.bytes(e);
  return ba(t, 33), y4(t);
}
function uC(e) {
  const t = Dn.fmt.toBytes(e, !1);
  return y4(t);
}
function cC(e) {
  const t = Dn.fmt.toBytes(e, !1);
  return Yhe(t);
}
function lC(e, t = "main") {
  const r = t === "main" ? ["1"] : ["m", "n"];
  for (const n of r)
    if (e.startsWith(n))
      return !0;
  return !1;
}
function fC(e, t = "main") {
  const r = J.bytes(e), n = t === "main" ? J.num(0) : J.num(111);
  return ba(e, 20), r.prepend(n).tob58chk();
}
function ipe(e, t = "main") {
  if (!lC(e, t))
    throw new TypeError("Invalid p2pkh address!");
  return J.b58chk(e).slice(1);
}
function ape(e) {
  const t = J.bytes(e);
  return ba(t, 20), ["OP_DUP", "OP_HASH160", t.hex, "OP_EQUALVERIFY", "OP_CHECKSIG"];
}
function spe(e, t) {
  const r = eb(e);
  return fC(r, t);
}
const dC = { check: lC, encode: fC, decode: ipe, hash: eb, scriptPubKey: ape, fromPubKey: spe };
function hC(e, t = "main") {
  const r = t === "main" ? ["3"] : ["2"];
  for (const n of r)
    if (e.startsWith(n))
      return !0;
  return !1;
}
function pC(e, t = "main") {
  const r = t === "main" ? J.num(5) : J.num(196), n = J.bytes(e);
  return ba(n, 20), n.prepend(r).tob58chk();
}
function upe(e, t = "main") {
  if (!hC(e, t))
    throw new TypeError(`Invalid p2sh address for network ${t}:` + e);
  return J.b58chk(e).slice(1);
}
function cpe(e) {
  return ["OP_HASH160", J.bytes(e).hex, "OP_EQUAL"];
}
function lpe(e, t) {
  const r = uC(e);
  return pC(r, t);
}
const gC = { check: hC, encode: pC, decode: upe, hash: uC, scriptPubKey: cpe, fromScript: lpe }, w4 = {
  main: "bc",
  testnet: "tb",
  signet: "tb",
  regtest: "bcrt"
}, fpe = ["bc1q", "tb1q", "bcrt1q"];
function mC(e) {
  for (const t of fpe)
    if (e.startsWith(t))
      return !0;
  return !1;
}
function yC(e, t = "main") {
  const r = w4[t], n = J.bytes(e);
  return ba(n, 20), n.toBech32(r, 0);
}
function dpe(e) {
  if (!mC(e))
    throw new TypeError("Invalid segwit address!");
  return J.bech32(e);
}
function hpe(e) {
  const t = J.bytes(e);
  return ba(t, 20), ["OP_0", t.hex];
}
function ppe(e, t) {
  const r = eb(e);
  return yC(r, t);
}
const bC = { check: mC, encode: yC, decode: dpe, hash: eb, scriptPubKey: hpe, fromPubKey: ppe }, gpe = ["bc1q", "tb1q", "bcrt1q"];
function wC(e) {
  for (const t of gpe)
    if (e.startsWith(t))
      return !0;
  return !1;
}
function vC(e, t = "main") {
  const r = w4[t], n = J.bytes(e);
  return ba(n, 32), n.toBech32(r, 0);
}
function mpe(e) {
  if (!wC(e))
    throw new TypeError("Invalid segwit address!");
  return J.bech32(e);
}
function ype(e) {
  const t = J.bytes(e);
  return ba(t, 32), ["OP_0", t.hex];
}
function bpe(e, t) {
  const r = cC(e);
  return vC(r, t);
}
const EC = { check: wC, encode: vC, decode: mpe, hash: cC, scriptPubKey: ype, fromScript: bpe };
function Yc(e) {
  const t = J.bytes(e);
  return t.length > 32 ? t.slice(1, 33) : t;
}
const wpe = ["bc1p", "tb1p", "bcrt1p"];
function kC(e) {
  for (const t of wpe)
    if (e.startsWith(t))
      return !0;
  return !1;
}
function xC(e, t = "main") {
  const r = w4[t], n = J.bytes(e);
  return ba(n, 32), n.toBech32(r, 1);
}
function vpe(e) {
  if (!kC(e))
    throw new TypeError("Invalid taproot address!");
  return J.bech32(e);
}
function Epe(e) {
  const t = J.bytes(e);
  return ba(t, 32), ["OP_1", t.hex];
}
function kpe(e, t) {
  const r = Yc(e);
  return xC(r, t);
}
const AC = { check: kC, encode: xC, decode: vpe, scriptPubKey: Epe, fromPubKey: kpe }, xpe = {
  version: 2,
  vin: [],
  vout: [],
  locktime: 0
}, Ape = {
  scriptSig: [],
  sequence: 4294967293,
  witness: []
}, Spe = {
  value: 0n,
  scriptPubKey: []
};
function v4(e) {
  const t = { ...xpe, ...e };
  return t.vin = t.vin.map((r) => ({ ...Ape, ...r })), t.vout = t.vout.map((r) => ({ ...Spe, ...r })), t;
}
function Ff(e, t) {
  const { version: r, vin: n, vout: o, locktime: a } = v4(e), i = t !== !0 && _pe(n), s = [E4(r)];
  i && s.push(J.hex("0001")), s.push(Ipe(n)), s.push(Tpe(o));
  for (const u of n)
    i && s.push(Ope(u.witness));
  return s.push(k4(a)), J.join(s);
}
function _pe(e) {
  for (const t of e) {
    const { witness: r } = t;
    if (typeof r == "string" || r instanceof Uint8Array || Array.isArray(r) && r.length > 0)
      return !0;
  }
  return !1;
}
function E4(e) {
  return J.num(e, 4).reverse();
}
function Yp(e) {
  return J.hex(e, 32).reverse();
}
function Jp(e) {
  return J.num(e, 4).reverse();
}
function Qp(e) {
  if (typeof e == "string")
    return J.hex(e, 4).reverse();
  if (typeof e == "number")
    return J.num(e, 4).reverse();
  throw new Error("Unrecognized format: " + String(e));
}
function Ipe(e) {
  const t = [J.varInt(e.length, "le")];
  for (const r of e) {
    const { txid: n, vout: o, scriptSig: a, sequence: i } = r;
    t.push(Yp(n)), t.push(Jp(o)), t.push(wl(a, !0)), t.push(Qp(i));
  }
  return J.join(t);
}
function Fu(e) {
  if (typeof e == "number") {
    if (e % 1 !== 0)
      throw new Error("Value must be an integer:" + String(e));
    return J.num(e, 8).reverse();
  }
  return J.big(e, 8).reverse();
}
function Tpe(e) {
  const t = [J.varInt(e.length, "le")];
  for (const r of e)
    t.push(Ppe(r));
  return J.join(t);
}
function Ppe(e) {
  const { value: t, scriptPubKey: r } = e, n = [];
  return n.push(Fu(t)), n.push(wl(r, !0)), J.join(n);
}
function Ope(e = []) {
  const t = [];
  if (Array.isArray(e)) {
    const r = J.varInt(e.length);
    t.push(r);
    for (const n of e)
      t.push($pe(n));
    return J.join(t);
  } else
    return J.bytes(e);
}
function $pe(e) {
  return Cpe(e) ? new J(0) : wl(e, !0);
}
function Cpe(e) {
  if (Array.isArray(e))
    return e.length === 0;
  if (typeof e == "string" && e === "")
    return !0;
  const t = J.bytes(e);
  return t.length === 1 && t[0] === 0;
}
function k4(e) {
  if (typeof e == "string")
    return J.hex(e, 4);
  if (typeof e == "number")
    return J.num(e, 4).reverse();
  throw new Error("Unrecognized format: " + String(e));
}
function x4(e) {
  typeof e == "string" && (e = J.hex(e).raw);
  const t = new pd(e), r = Bpe(t), n = Npe(t), o = Upe(t), a = zpe(t);
  if (n)
    for (const s of o)
      s.witness = Lpe(t);
  const i = Hpe(t);
  return { version: r, vin: o, vout: a, locktime: i };
}
function Bpe(e) {
  return e.read(4).reverse().toNum();
}
function Npe(e) {
  const [t, r] = [...e.peek(2)];
  if (t === 0) {
    if (e.read(2), r === 1)
      return !0;
    throw new Error(`Invalid witness flag: ${r}`);
  }
  return !1;
}
function Upe(e) {
  const t = [], r = e.readSize("le");
  for (let n = 0; n < r; n++)
    t.push(Rpe(e));
  return t;
}
function Rpe(e) {
  return {
    txid: e.read(32).reverse().toHex(),
    vout: e.read(4).reverse().toNum(),
    scriptSig: _C(e),
    sequence: e.read(4).reverse().toHex(),
    witness: []
  };
}
function zpe(e) {
  const t = [], r = e.readSize("le");
  for (let n = 0; n < r; n++)
    t.push(jpe(e));
  return t;
}
function jpe(e) {
  return {
    value: e.read(8).reverse().big,
    scriptPubKey: _C(e)
  };
}
function Lpe(e) {
  const t = [], r = e.readSize();
  for (let n = 0; n < r; n++) {
    const o = SC(e);
    t.push(o ?? "");
  }
  return t;
}
function SC(e, t) {
  const r = e.readSize("le");
  return r > 0 ? e.read(r).hex : null;
}
function _C(e, t) {
  const r = SC(e);
  return r !== null ? r : [];
}
function Hpe(e) {
  return e.read(4).reverse().toNum();
}
function Fpe(e) {
  if (i$(e))
    return x4(e);
  if (typeof e == "object" && !(e instanceof Uint8Array))
    return Ff(e), v4(e);
  throw new Error("Invalid format: " + typeof e);
}
function Dpe(e) {
  if (i$(e))
    return x4(e), J.bytes(e);
  if (typeof e == "object")
    return Ff(e);
  throw new Error("Invalid format: " + typeof e);
}
const A4 = {
  toBytes: Dpe,
  toJson: Fpe
}, Mpe = [
  ["p2pkh", /^76a914(?<hash>\w{40})88ac$/],
  ["p2sh", /^a914(?<hash>\w{40})87$/],
  ["p2w-pkh", /^0014(?<hash>\w{40})$/],
  ["p2w-sh", /^0020(?<hash>\w{64})$/],
  ["p2tr", /^5120(?<hash>\w{64})$/]
], Kpe = [
  192,
  194,
  196,
  198,
  200,
  202,
  204,
  206,
  208,
  210,
  212,
  214,
  216,
  218,
  220,
  222,
  224,
  226,
  228,
  230,
  232,
  234,
  236,
  238,
  240,
  242,
  244,
  246,
  248,
  250,
  252,
  254,
  102,
  126,
  128,
  132,
  150,
  152,
  186,
  188,
  190
];
function qpe(e) {
  let t = e.at(-1);
  return bs(t) && (t = J.hex(t)), e.length > 1 && t instanceof Uint8Array && t[0] === 80 ? (e.pop(), J.raw(t)) : null;
}
function Vpe(e) {
  let t = e.at(-1);
  return bs(t) && (t = J.hex(t)), e.length > 1 && t instanceof Uint8Array && t.length > 32 && Kpe.includes(t[0] & 254) ? (e.pop(), J.raw(t)) : null;
}
function Gpe(e) {
  if (e.length > 1) {
    const t = e.at(-1);
    try {
      const r = Dn.fmt.toBytes(t);
      return e.pop(), r;
    } catch {
      return null;
    }
  }
  return null;
}
function Zpe(e) {
  const t = [];
  for (const r of e)
    if (bs(r) || r instanceof Uint8Array || typeof r == "number")
      t.push(J.bytes(r));
    else
      throw new Error("unrecognized value: " + String(r));
  return t;
}
function Wpe(e = []) {
  const t = [...e], r = qpe(t), n = Vpe(t), o = Gpe(t), a = Zpe(t);
  return { annex: r, cblock: n, script: o, params: a };
}
function Xpe(e) {
  const t = Dn.fmt.toBytes(e, !1).hex;
  for (const [r, n] of Mpe) {
    const o = r, { groups: a } = n.exec(t) ?? {}, { hash: i } = a ?? {};
    if (bs(i))
      return { type: o, data: J.hex(i) };
  }
  return { type: "raw", data: J.hex(t) };
}
function Ype(e) {
  const t = A4.toJson(e), r = Ff(t, !0);
  return Hf(r).reverse().hex;
}
function Jpe(e) {
  const t = A4.toJson(e), r = Ff(t, !0).length, n = Ff(t, !1).length, o = r * 3 + n, a = o % 4 > 0 ? 1 : 0, i = Math.floor(o / 4) + a;
  return { size: n, bsize: r, vsize: i, weight: o };
}
const wi = {
  create: v4,
  encode: Ff,
  decode: x4,
  fmt: A4,
  util: {
    getTxSize: Jpe,
    getTxid: Ype,
    readScriptPubKey: Xpe,
    readWitness: Wpe
  }
}, Qpe = [
  ["1", "p2pkh", "main", 20, "base58"],
  ["3", "p2sh", "main", 20, "base58"],
  ["m", "p2pkh", "testnet", 20, "base58"],
  ["n", "p2pkh", "testnet", 20, "base58"],
  ["2", "p2sh", "testnet", 20, "base58"],
  ["bc1q", "p2w-pkh", "main", 20, "bech32"],
  ["tb1q", "p2w-pkh", "testnet", 20, "bech32"],
  ["bcrt1q", "p2w-pkh", "regtest", 20, "bech32"],
  ["bc1q", "p2w-sh", "main", 32, "bech32"],
  ["tb1q", "p2w-sh", "testnet", 32, "bech32"],
  ["bcrt1q", "p2w-sh", "regtest", 32, "bech32"],
  ["bc1p", "p2tr", "main", 32, "bech32m"],
  ["tb1p", "p2tr", "testnet", 32, "bech32m"],
  ["bcrt1p", "p2tr", "regtest", 32, "bech32m"]
];
function e0e(e, t) {
  switch (t) {
    case "base58":
      return J.b58chk(e).slice(1);
    case "bech32":
      return J.bech32(e);
    case "bech32m":
      return J.bech32(e);
    default:
      throw new Error("Invalid address format: " + t);
  }
}
function t0e(e) {
  for (const t of Qpe) {
    const [r, n, o, a, i] = t;
    if (e.startsWith(r) && e0e(e, i).length === a)
      return t;
  }
  throw new Error("Invalid address: " + e);
}
function IC(e) {
  switch (e) {
    case "p2pkh":
      return dC;
    case "p2sh":
      return gC;
    case "p2w-pkh":
      return bC;
    case "p2w-sh":
      return EC;
    case "p2tr":
      return AC;
    default:
      throw new Error("Invalid address type: " + e);
  }
}
function TC(e) {
  const [t, r, n] = t0e(e), o = IC(r), a = o.decode(e, n), i = o.scriptPubKey(a);
  return { prefix: t, type: r, network: n, data: a, script: i };
}
function r0e(e, t) {
  const { type: r, data: n } = wi.util.readScriptPubKey(e);
  return IC(r).encode(n, t);
}
function n0e(e) {
  const { script: t } = TC(e);
  return Dn.fmt.toAsm(t, !1);
}
const PC = {
  p2pkh: dC,
  p2sh: gC,
  p2wpkh: bC,
  p2wsh: EC,
  p2tr: AC,
  decode: TC,
  fromScriptPubKey: r0e,
  toScriptPubKey: n0e
}, o0e = [1, 2, 3];
function S4(e, t, r = {}) {
  const { sigflag: n = 1 } = r, o = (n & 128) === 128, a = n % 128;
  if (!o0e.includes(a))
    throw new Error("Invalid hash type: " + String(n));
  const i = wi.fmt.toJson(e), { version: s, vin: u, vout: l, locktime: c } = i, { txid: f, vout: h, prevout: p, sequence: y } = u[t], { value: m } = p ?? {};
  if (m === void 0)
    throw new Error("Prevout value is empty!");
  let b = r.script;
  if (b === void 0 && r.pubkey !== void 0 && (b = `76a914${y4(r.pubkey).hex}88ac`), b === void 0)
    throw new Error("No pubkey / script has been set!");
  if (Dn.fmt.toAsm(b).includes("OP_CODESEPARATOR"))
    throw new Error("This library does not currently support the use of OP_CODESEPARATOR in segwit scripts.");
  const v = [
    E4(s),
    i0e(u, o),
    a0e(u, a, o),
    Yp(f),
    Jp(h),
    Dn.encode(b, !0),
    Fu(m),
    Qp(y),
    s0e(l, t, a),
    k4(c),
    J.num(n, 4).reverse()
  ];
  return Hf(J.join(v));
}
function i0e(e, t) {
  if (t === !0)
    return J.num(0, 32);
  const r = [];
  for (const { txid: n, vout: o } of e)
    r.push(Yp(n)), r.push(Jp(o));
  return Hf(J.join(r));
}
function a0e(e, t, r) {
  if (r || t !== 1)
    return J.num(0, 32);
  const n = [];
  for (const { sequence: o } of e)
    n.push(Qp(o));
  return Hf(J.join(n));
}
function s0e(e, t, r) {
  const n = [];
  if (r === 1) {
    for (const { value: o, scriptPubKey: a } of e)
      n.push(Fu(o)), n.push(Dn.encode(a, !0));
    return Hf(J.join(n));
  }
  if (r === 3 && t < e.length) {
    const { value: o, scriptPubKey: a } = e[t];
    return n.push(Fu(o)), n.push(Dn.encode(a, !0)), Hf(J.join(n));
  }
  return J.num(0, 32);
}
function u0e(e, t, r, n = {}) {
  const { sigflag: o = 1 } = n, a = S4(t, r, n), i = sC.secp.sign(a, e).toDERRawBytes(!0);
  return J.join([i, o]);
}
function c0e(e, t, r = {}) {
  const n = wi.fmt.toJson(e), { throws: o = !1 } = r, { witness: a = [] } = n.vin[t], i = wi.util.readWitness(a), { script: s, params: u } = i;
  let l = null;
  if (u.length < 1)
    return vn("Invalid witness data: " + String(a), o);
  if (r.script === void 0 && s !== null && (r.script = s), r.pubkey !== void 0)
    l = J.bytes(r.pubkey);
  else if (u.length > 1 && u[1].length === 33)
    l = J.bytes(u[1]);
  else
    return vn("No pubkey provided!", o);
  const c = Dn.fmt.toParam(u[0]), f = c.slice(0, -1), h = c.slice(-1)[0], p = S4(n, t, { ...r, sigflag: h });
  return sC.secp.verify(f, p, l) ? !0 : vn("Invalid signature!", o);
}
const l0e = {
  hash: S4,
  sign: u0e,
  verify: c0e
}, f0e = [0, 1, 2, 3, 129, 130, 131];
function _4(e, t, r = {}) {
  const { extension: n, sigflag: o = 0, extflag: a = 0, key_version: i = 0, separator_pos: s = 4294967295 } = r, u = wi.fmt.toJson(e), { version: l, vin: c, vout: f, locktime: h } = u;
  if (t >= c.length)
    throw new Error("Index out of bounds: " + String(t));
  if (!f0e.includes(o))
    throw new Error("Invalid hash type: " + String(o));
  if (a < 0 || a > 127)
    throw new Error("Extention flag out of range: " + String(a));
  const { txid: p, vout: y, sequence: m, witness: b = [] } = c[t], v = (o & 128) === 128, k = b0e(b), E = k !== void 0 ? 1 : 0, A = (a + (n !== void 0 ? 1 : 0)) * 2 + E, S = J.str("TapSighash").digest, _ = [
    S,
    S,
    J.num(0, 1),
    J.num(o, 1),
    E4(l),
    k4(h)
  ];
  if (!v) {
    const I = c.map((O) => U9(O));
    _.push(d0e(c), p0e(I), g0e(I), h0e(c));
  }
  if (((o & 3) < 2 || (o & 3) > 3) && _.push(m0e(f)), _.push(J.num(A, 1)), v) {
    const { value: I, scriptPubKey: O } = U9(c[t]);
    _.push(Yp(p), Jp(y), Fu(I), Dn.encode(O, !0), Qp(m));
  } else
    _.push(J.num(t, 4).reverse());
  return k !== void 0 && _.push(k), (o & 3) === 3 && _.push(y0e(f[t])), n !== void 0 && _.push(J.bytes(n), J.num(i), J.num(s, 4)), J.join(_).digest;
}
function d0e(e) {
  const t = [];
  for (const { txid: r, vout: n } of e)
    t.push(Yp(r)), t.push(Jp(n));
  return J.join(t).digest;
}
function h0e(e) {
  const t = [];
  for (const { sequence: r } of e)
    t.push(Qp(r));
  return J.join(t).digest;
}
function p0e(e) {
  const t = [];
  for (const { value: r } of e)
    t.push(Fu(r));
  return J.join(t).digest;
}
function g0e(e) {
  const t = [];
  for (const { scriptPubKey: r } of e)
    t.push(wl(r, !0));
  return J.join(t).digest;
}
function m0e(e) {
  const t = [];
  for (const { value: r, scriptPubKey: n } of e)
    t.push(Fu(r)), t.push(Dn.encode(n, !0));
  return J.join(t).digest;
}
function y0e(e) {
  return J.join([
    Fu(e.value),
    Dn.encode(e.scriptPubKey, !0)
  ]).digest;
}
function b0e(e) {
  if (e === void 0 || e.length < 2)
    return;
  let t = e.at(-1);
  if (typeof t == "string" && (t = J.hex(t)), t instanceof Uint8Array && t[0] === 80)
    return J.raw(t).prefixSize("be").digest;
}
function U9(e) {
  if (e.prevout === void 0)
    throw new Error("Prevout data missing for input: " + String(e.txid));
  return e.prevout;
}
const w0e = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn, v0e = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
function E0e(e, t, r, n = {}) {
  const { sigflag: o = 0 } = n, a = _4(t, r, n), i = k0e(e, a);
  return o === 0 ? J.raw(i) : J.join([i, o]);
}
function k0e(e, t, r = J.random(32)) {
  const n = J.bytes(t), o = new Un(e), a = o.point, i = a.hasEvenY ? o.big : o.negated.big, s = O1("BIP0340/aux", J.bytes(r)), u = i ^ s.big, l = O1("BIP0340/nonce", u, a.x.raw, n), c = new Un(l), f = c.point, h = f.hasEvenY ? c.big : c.negated.big, p = new Un(O1("BIP0340/challenge", f.x.raw, a.x.raw, n)), y = new Un(h + p.big * i);
  return J.join([f.x.raw, y.raw]);
}
function x0e(e, t, r, n = !1) {
  const o = vl.from_x(Yc(r)), a = J.bytes(t), i = J.bytes(e).stream;
  i.size < 64 && vn("Signature length is too small: " + String(i.size), n);
  const s = i.read(32);
  s.big > w0e && vn("Signature r value greater than field size!", n);
  const u = i.read(32);
  u.big > v0e && vn("Signature s value greater than curve order!", n);
  const l = new Un(O1("BIP0340/challenge", s.raw, o.x.raw, a)), c = new Un(u).point, f = o.mul(l.big), h = c.sub(f);
  return h.hasOddY && vn("Signature R value has odd Y coordinate!", n), h.x.big === 0n && vn("Signature R value is infinite!", n), h.x.big === s.big;
}
const A0e = 192;
function tb(e) {
  const t = J.str(e).digest;
  return J.join([t, t]);
}
function I4(e, t = A0e) {
  return J.join([
    tb("TapLeaf"),
    I0e(t),
    J.bytes(e)
  ]).digest.hex;
}
function S0e(e, t) {
  return I4(Dn.fmt.toBytes(e), t);
}
function T4(e, t) {
  return t < e && ([e, t] = [t, e]), J.join([
    tb("TapBranch"),
    J.hex(e).raw,
    J.hex(t).raw
  ]).digest.hex;
}
function _0e(e) {
  return J.hex(nm(e)[0]);
}
function nm(e, t, r = []) {
  const n = [], o = [];
  if (e.length < 1)
    throw new Error("Tree is empty!");
  for (let a = 0; a < e.length; a++) {
    const i = e[a];
    if (Array.isArray(i)) {
      const [s, u, l] = nm(i, t);
      t = u, n.push(s);
      for (const c of l)
        r.push(c);
    } else
      n.push(i);
  }
  if (n.length === 1)
    return [n[0], t, r];
  n.sort(), n.length % 2 !== 0 && n.push(n[n.length - 1]);
  for (let a = 0; a < n.length - 1; a += 2) {
    const i = T4(n[a], n[a + 1]);
    o.push(i), typeof t == "string" && (t === n[a] ? (r.push(n[a + 1]), t = i) : t === n[a + 1] && (r.push(n[a]), t = i));
  }
  return nm(o, t, r);
}
function I0e(e = 192) {
  return e & 254;
}
function OC(e, t = new Uint8Array(), r = !1) {
  const n = r ? new Un(e).point.x.raw : Yc(e);
  return J.join([tb("TapTweak"), n, J.bytes(t)]).digest;
}
function hf(e, t, r = !1) {
  t === void 0 && (t = new Uint8Array());
  const n = J.bytes(e), o = OC(e, t, r);
  return r ? $C(n, o) : CC(n, o);
}
function T0e(e, t) {
  return hf(e, t);
}
function P0e(e, t) {
  return hf(e, t, !0);
}
function $C(e, t) {
  let r = new Un(e);
  return r.point.hasOddY && (r = r.negate()), J.raw(r.add(t).raw);
}
function CC(e, t) {
  e = Yc(e);
  const r = vl.from_x(e).add(t);
  return J.raw(r.raw);
}
function O0e() {
  const e = J.hex("0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8");
  return vl.from_x(e.digest).x;
}
const $0e = O0e(), C0e = 192;
function B0e(e, t = {}) {
  return BC(e, { ...t, isPrivate: !0 });
}
function N0e(e, t = {}) {
  return BC(e, { ...t, isPrivate: !1 });
}
function BC(e, t = {}) {
  const { isPrivate: r = !1, tree: n = [], version: o = C0e } = t, a = r ? f8.getPublicKey(e, !0) : Yc(e);
  let { target: i } = t;
  i !== void 0 && (i = J.bytes(i).hex);
  let s, u = [];
  if (n.length > 0) {
    const [h, p, y] = nm(n, i);
    u = y, s = hf(e, h, r);
  } else
    i !== void 0 ? s = hf(e, i, r) : s = hf(e, void 0, r);
  const l = r ? f8.getPublicKey(s)[0] : s[0], c = [J.num(o + UC(l)), a];
  u.length > 0 && u.forEach((h) => c.push(J.hex(h)));
  const f = J.join(c);
  if (i !== void 0 && !P4(s, i, f, t))
    throw new Error("Path checking failed! Unable to generate path.");
  return [Yc(s).hex, f.hex];
}
function P4(e, t, r, n = {}) {
  const { isPrivate: o = !1, throws: a = !1 } = n, { parity: i, paths: s, intkey: u } = NC(r), l = o ? f8.getPublicKey(e, !0) : Yc(e), c = J.join([i, l]);
  if (c.length !== 33)
    return vn("Invalid tapkey: " + c.hex, a);
  let f = J.bytes(t).hex;
  for (const p of s)
    f = T4(f, p);
  const h = hf(u, f);
  return J.raw(h).hex === J.raw(c).hex;
}
function NC(e) {
  const t = new pd(J.bytes(e)), r = t.read(1).num, n = t.read(32), [o, a] = r % 2 === 0 ? [r, 2] : [r - 1, 3], i = [];
  for (; t.size >= 32; )
    i.push(t.read(32).hex);
  if (t.size !== 0)
    throw new Error("Non-empty buffer on control block: " + String(t));
  return { intkey: n, paths: i, parity: a, version: o };
}
function UC(e = 2) {
  if (e === 0 || e === 1)
    return e;
  if (e === 2 || e === "02")
    return 0;
  if (e === 3 || e === "03")
    return 1;
  throw new Error("Invalid parity bit: " + String(e));
}
function U0e(e, t, r = {}) {
  const n = wi.fmt.toJson(e), { throws: o = !1 } = r, { prevout: a, witness: i = [] } = n.vin[t], s = wi.util.readWitness(i), { cblock: u, script: l, params: c } = s;
  let f;
  if (c.length < 1)
    return vn("Invalid witness data: " + String(i), o);
  const { scriptPubKey: h } = a ?? {};
  if (h === void 0)
    return vn("Prevout scriptPubKey is empty!", o);
  const { type: p, data: y } = wi.util.readScriptPubKey(h);
  if (p !== "p2tr")
    return vn("Prevout script is not a valid taproot output:" + y.hex, o);
  if (y.length !== 32)
    return vn("Invalid tapkey length: " + String(y.length), o);
  if (u !== null && l !== null) {
    const E = u[0] & 254, A = I4(l, E);
    if (r.extension = A, !P4(y, A, u, { throws: o }))
      return vn("cblock verification failed!", o);
  }
  r.pubkey !== void 0 ? f = J.bytes(r.pubkey) : c.length > 1 && c[1].length === 32 ? f = J.bytes(c[1]) : f = J.bytes(y);
  const m = Dn.fmt.toParam(c[0]), b = new pd(m), v = b.read(64).raw;
  if (b.size === 1 && (r.sigflag = b.read(1).num, r.sigflag === 0))
    return vn("0x00 is not a valid appended sigflag!", o);
  const k = _4(n, t, r);
  return x0e(v, k, f, o) ? !0 : vn("Invalid signature!", o);
}
const R0e = {
  hash: _4,
  sign: E0e,
  verify: U0e
}, z0e = {
  segwit: l0e,
  taproot: R0e
}, j0e = {
  getTag: tb,
  getLeaf: I4,
  getBranch: T4,
  getRoot: _0e
}, L0e = {
  readCtrlBlock: NC,
  readParityBit: UC
}, H0e = {
  getPubKey: T0e,
  getSecKey: P0e,
  getTweak: OC,
  tweakSecKey: $C,
  tweakPubKey: CC
}, om = {
  getPubKey: N0e,
  getSecKey: B0e,
  encodeScript: S0e,
  checkPath: P4,
  tree: j0e,
  tweak: H0e,
  util: L0e,
  SCRIPT_PUBKEY: $0e
};
var Nt;
(function(e) {
  e.assertEqual = (o) => o;
  function t(o) {
  }
  e.assertIs = t;
  function r(o) {
    throw new Error();
  }
  e.assertNever = r, e.arrayToEnum = (o) => {
    const a = {};
    for (const i of o)
      a[i] = i;
    return a;
  }, e.getValidEnumValues = (o) => {
    const a = e.objectKeys(o).filter((s) => typeof o[o[s]] != "number"), i = {};
    for (const s of a)
      i[s] = o[s];
    return e.objectValues(i);
  }, e.objectValues = (o) => e.objectKeys(o).map(function(a) {
    return o[a];
  }), e.objectKeys = typeof Object.keys == "function" ? (o) => Object.keys(o) : (o) => {
    const a = [];
    for (const i in o)
      Object.prototype.hasOwnProperty.call(o, i) && a.push(i);
    return a;
  }, e.find = (o, a) => {
    for (const i of o)
      if (a(i))
        return i;
  }, e.isInteger = typeof Number.isInteger == "function" ? (o) => Number.isInteger(o) : (o) => typeof o == "number" && isFinite(o) && Math.floor(o) === o;
  function n(o, a = " | ") {
    return o.map((i) => typeof i == "string" ? `'${i}'` : i).join(a);
  }
  e.joinValues = n, e.jsonStringifyReplacer = (o, a) => typeof a == "bigint" ? a.toString() : a;
})(Nt || (Nt = {}));
var d8;
(function(e) {
  e.mergeShapes = (t, r) => ({
    ...t,
    ...r
    // second overwrites first
  });
})(d8 || (d8 = {}));
const me = Nt.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Tu = (e) => {
  switch (typeof e) {
    case "undefined":
      return me.undefined;
    case "string":
      return me.string;
    case "number":
      return isNaN(e) ? me.nan : me.number;
    case "boolean":
      return me.boolean;
    case "function":
      return me.function;
    case "bigint":
      return me.bigint;
    case "symbol":
      return me.symbol;
    case "object":
      return Array.isArray(e) ? me.array : e === null ? me.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? me.promise : typeof Map < "u" && e instanceof Map ? me.map : typeof Set < "u" && e instanceof Set ? me.set : typeof Date < "u" && e instanceof Date ? me.date : me.object;
    default:
      return me.unknown;
  }
}, ce = Nt.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), F0e = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class vi extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(a) {
      return a.message;
    }, n = { _errors: [] }, o = (a) => {
      for (const i of a.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(o);
        else if (i.code === "invalid_return_type")
          o(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          o(i.argumentsError);
        else if (i.path.length === 0)
          n._errors.push(r(i));
        else {
          let s = n, u = 0;
          for (; u < i.path.length; ) {
            const l = i.path[u];
            u === i.path.length - 1 ? (s[l] = s[l] || { _errors: [] }, s[l]._errors.push(r(i))) : s[l] = s[l] || { _errors: [] }, s = s[l], u++;
          }
        }
    };
    return o(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Nt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, n = [];
    for (const o of this.issues)
      o.path.length > 0 ? (r[o.path[0]] = r[o.path[0]] || [], r[o.path[0]].push(t(o))) : n.push(t(o));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
vi.create = (e) => new vi(e);
const Xh = (e, t) => {
  let r;
  switch (e.code) {
    case ce.invalid_type:
      e.received === me.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case ce.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, Nt.jsonStringifyReplacer)}`;
      break;
    case ce.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Nt.joinValues(e.keys, ", ")}`;
      break;
    case ce.invalid_union:
      r = "Invalid input";
      break;
    case ce.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Nt.joinValues(e.options)}`;
      break;
    case ce.invalid_enum_value:
      r = `Invalid enum value. Expected ${Nt.joinValues(e.options)}, received '${e.received}'`;
      break;
    case ce.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case ce.invalid_return_type:
      r = "Invalid function return type";
      break;
    case ce.invalid_date:
      r = "Invalid date";
      break;
    case ce.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : Nt.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case ce.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case ce.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case ce.custom:
      r = "Invalid input";
      break;
    case ce.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case ce.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case ce.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, Nt.assertNever(e);
  }
  return { message: r };
};
let RC = Xh;
function D0e(e) {
  RC = e;
}
function im() {
  return RC;
}
const am = (e) => {
  const { data: t, path: r, errorMaps: n, issueData: o } = e, a = [...r, ...o.path || []], i = {
    ...o,
    path: a
  };
  let s = "";
  const u = n.filter((l) => !!l).slice().reverse();
  for (const l of u)
    s = l(i, { data: t, defaultError: s }).message;
  return {
    ...o,
    path: a,
    message: o.message || s
  };
}, M0e = [];
function Ee(e, t) {
  const r = am({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      im(),
      Xh
      // then global default map
    ].filter((n) => !!n)
  });
  e.common.issues.push(r);
}
class An {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, r) {
    const n = [];
    for (const o of r) {
      if (o.status === "aborted")
        return ot;
      o.status === "dirty" && t.dirty(), n.push(o.value);
    }
    return { status: t.value, value: n };
  }
  static async mergeObjectAsync(t, r) {
    const n = [];
    for (const o of r)
      n.push({
        key: await o.key,
        value: await o.value
      });
    return An.mergeObjectSync(t, n);
  }
  static mergeObjectSync(t, r) {
    const n = {};
    for (const o of r) {
      const { key: a, value: i } = o;
      if (a.status === "aborted" || i.status === "aborted")
        return ot;
      a.status === "dirty" && t.dirty(), i.status === "dirty" && t.dirty(), (typeof i.value < "u" || o.alwaysSet) && (n[a.value] = i.value);
    }
    return { status: t.value, value: n };
  }
}
const ot = Object.freeze({
  status: "aborted"
}), zC = (e) => ({ status: "dirty", value: e }), Mn = (e) => ({ status: "valid", value: e }), h8 = (e) => e.status === "aborted", p8 = (e) => e.status === "dirty", sm = (e) => e.status === "valid", um = (e) => typeof Promise < "u" && e instanceof Promise;
var Ue;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(Ue || (Ue = {}));
class da {
  constructor(t, r, n, o) {
    this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = o;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const R9 = (e, t) => {
  if (sm(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new vi(e.common.issues);
      return this._error = r, this._error;
    }
  };
};
function pt(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: r, required_error: n, description: o } = e;
  if (t && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: o } : { errorMap: (a, i) => a.code !== "invalid_type" ? { message: i.defaultError } : typeof i.data > "u" ? { message: n ?? i.defaultError } : { message: r ?? i.defaultError }, description: o };
}
class It {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Tu(t.data);
  }
  _getOrReturnCtx(t, r) {
    return r || {
      common: t.parent.common,
      data: t.data,
      parsedType: Tu(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new An(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Tu(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const r = this._parse(t);
    if (um(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(t) {
    const r = this._parse(t);
    return Promise.resolve(r);
  }
  parse(t, r) {
    const n = this.safeParse(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(t, r) {
    var n;
    const o = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Tu(t)
    }, a = this._parseSync({ data: t, path: o.path, parent: o });
    return R9(o, a);
  }
  async parseAsync(t, r) {
    const n = await this.safeParseAsync(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(t, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: !0
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Tu(t)
    }, o = this._parse({ data: t, path: n.path, parent: n }), a = await (um(o) ? o : Promise.resolve(o));
    return R9(n, a);
  }
  refine(t, r) {
    const n = (o) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(o) : r;
    return this._refinement((o, a) => {
      const i = t(o), s = () => a.addIssue({
        code: ce.custom,
        ...n(o)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((u) => u ? !0 : (s(), !1)) : i ? !0 : (s(), !1);
    });
  }
  refinement(t, r) {
    return this._refinement((n, o) => t(n) ? !0 : (o.addIssue(typeof r == "function" ? r(n, o) : r), !1));
  }
  _refinement(t) {
    return new Ti({
      schema: this,
      typeName: De.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return ts.create(this, this._def);
  }
  nullable() {
    return el.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Ei.create(this, this._def);
  }
  promise() {
    return Mf.create(this, this._def);
  }
  or(t) {
    return ep.create([this, t], this._def);
  }
  and(t) {
    return tp.create(this, t, this._def);
  }
  transform(t) {
    return new Ti({
      ...pt(this._def),
      schema: this,
      typeName: De.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const r = typeof t == "function" ? t : () => t;
    return new ap({
      ...pt(this._def),
      innerType: this,
      defaultValue: r,
      typeName: De.ZodDefault
    });
  }
  brand() {
    return new LC({
      typeName: De.ZodBranded,
      type: this,
      ...pt(this._def)
    });
  }
  catch(t) {
    const r = typeof t == "function" ? t : () => t;
    return new dm({
      ...pt(this._def),
      innerType: this,
      catchValue: r,
      typeName: De.ZodCatch
    });
  }
  describe(t) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return e0.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const K0e = /^c[^\s-]{8,}$/i, q0e = /^[a-z][a-z0-9]*$/, V0e = /[0-9A-HJKMNP-TV-Z]{26}/, G0e = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, Z0e = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, W0e = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u"), X0e = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Y0e = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, J0e = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function Q0e(e, t) {
  return !!((t === "v4" || !t) && X0e.test(e) || (t === "v6" || !t) && Y0e.test(e));
}
class di extends It {
  constructor() {
    super(...arguments), this._regex = (t, r, n) => this.refinement((o) => t.test(o), {
      validation: r,
      code: ce.invalid_string,
      ...Ue.errToObj(n)
    }), this.nonempty = (t) => this.min(1, Ue.errToObj(t)), this.trim = () => new di({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new di({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new di({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== me.string) {
      const o = this._getOrReturnCtx(t);
      return Ee(
        o,
        {
          code: ce.invalid_type,
          expected: me.string,
          received: o.parsedType
        }
        //
      ), ot;
    }
    const r = new An();
    let n;
    for (const o of this._def.checks)
      if (o.kind === "min")
        t.data.length < o.value && (n = this._getOrReturnCtx(t, n), Ee(n, {
          code: ce.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), r.dirty());
      else if (o.kind === "max")
        t.data.length > o.value && (n = this._getOrReturnCtx(t, n), Ee(n, {
          code: ce.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), r.dirty());
      else if (o.kind === "length") {
        const a = t.data.length > o.value, i = t.data.length < o.value;
        (a || i) && (n = this._getOrReturnCtx(t, n), a ? Ee(n, {
          code: ce.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }) : i && Ee(n, {
          code: ce.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }), r.dirty());
      } else if (o.kind === "email")
        Z0e.test(t.data) || (n = this._getOrReturnCtx(t, n), Ee(n, {
          validation: "email",
          code: ce.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "emoji")
        W0e.test(t.data) || (n = this._getOrReturnCtx(t, n), Ee(n, {
          validation: "emoji",
          code: ce.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "uuid")
        G0e.test(t.data) || (n = this._getOrReturnCtx(t, n), Ee(n, {
          validation: "uuid",
          code: ce.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "cuid")
        K0e.test(t.data) || (n = this._getOrReturnCtx(t, n), Ee(n, {
          validation: "cuid",
          code: ce.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "cuid2")
        q0e.test(t.data) || (n = this._getOrReturnCtx(t, n), Ee(n, {
          validation: "cuid2",
          code: ce.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "ulid")
        V0e.test(t.data) || (n = this._getOrReturnCtx(t, n), Ee(n, {
          validation: "ulid",
          code: ce.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "url")
        try {
          new URL(t.data);
        } catch {
          n = this._getOrReturnCtx(t, n), Ee(n, {
            validation: "url",
            code: ce.invalid_string,
            message: o.message
          }), r.dirty();
        }
      else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (n = this._getOrReturnCtx(t, n), Ee(n, {
        validation: "regex",
        code: ce.invalid_string,
        message: o.message
      }), r.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (n = this._getOrReturnCtx(t, n), Ee(n, {
        code: ce.invalid_string,
        validation: { includes: o.value, position: o.position },
        message: o.message
      }), r.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (n = this._getOrReturnCtx(t, n), Ee(n, {
        code: ce.invalid_string,
        validation: { startsWith: o.value },
        message: o.message
      }), r.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (n = this._getOrReturnCtx(t, n), Ee(n, {
        code: ce.invalid_string,
        validation: { endsWith: o.value },
        message: o.message
      }), r.dirty()) : o.kind === "datetime" ? J0e(o).test(t.data) || (n = this._getOrReturnCtx(t, n), Ee(n, {
        code: ce.invalid_string,
        validation: "datetime",
        message: o.message
      }), r.dirty()) : o.kind === "ip" ? Q0e(t.data, o.version) || (n = this._getOrReturnCtx(t, n), Ee(n, {
        validation: "ip",
        code: ce.invalid_string,
        message: o.message
      }), r.dirty()) : Nt.assertNever(o);
    return { status: r.value, value: t.data };
  }
  _addCheck(t) {
    return new di({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Ue.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Ue.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Ue.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Ue.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Ue.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Ue.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Ue.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Ue.errToObj(t) });
  }
  datetime(t) {
    var r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
      ...Ue.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, r) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...Ue.errToObj(r)
    });
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r == null ? void 0 : r.position,
      ...Ue.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(t, r) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...Ue.errToObj(r)
    });
  }
  endsWith(t, r) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...Ue.errToObj(r)
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...Ue.errToObj(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...Ue.errToObj(r)
    });
  }
  length(t, r) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...Ue.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
di.create = (e) => {
  var t;
  return new di({
    checks: [],
    typeName: De.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...pt(e)
  });
};
function e1e(e, t) {
  const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, o = r > n ? r : n, a = parseInt(e.toFixed(o).replace(".", "")), i = parseInt(t.toFixed(o).replace(".", ""));
  return a % i / Math.pow(10, o);
}
class Du extends It {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== me.number) {
      const o = this._getOrReturnCtx(t);
      return Ee(o, {
        code: ce.invalid_type,
        expected: me.number,
        received: o.parsedType
      }), ot;
    }
    let r;
    const n = new An();
    for (const o of this._def.checks)
      o.kind === "int" ? Nt.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: ce.invalid_type,
        expected: "integer",
        received: "float",
        message: o.message
      }), n.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: ce.too_small,
        minimum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), n.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: ce.too_big,
        maximum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), n.dirty()) : o.kind === "multipleOf" ? e1e(t.data, o.value) !== 0 && (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: ce.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), n.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: ce.not_finite,
        message: o.message
      }), n.dirty()) : Nt.assertNever(o);
    return { status: n.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, Ue.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, Ue.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, Ue.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, Ue.toString(r));
  }
  setLimit(t, r, n, o) {
    return new Du({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: Ue.toString(o)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Du({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: Ue.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Ue.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Ue.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Ue.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Ue.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Ue.toString(r)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: Ue.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Ue.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Ue.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && Nt.isInteger(t.value));
  }
  get isFinite() {
    let t = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(t);
  }
}
Du.create = (e) => new Du({
  checks: [],
  typeName: De.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...pt(e)
});
class Mu extends It {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== me.bigint) {
      const o = this._getOrReturnCtx(t);
      return Ee(o, {
        code: ce.invalid_type,
        expected: me.bigint,
        received: o.parsedType
      }), ot;
    }
    let r;
    const n = new An();
    for (const o of this._def.checks)
      o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: ce.too_small,
        type: "bigint",
        minimum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), n.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: ce.too_big,
        type: "bigint",
        maximum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), n.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: ce.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), n.dirty()) : Nt.assertNever(o);
    return { status: n.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, Ue.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, Ue.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, Ue.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, Ue.toString(r));
  }
  setLimit(t, r, n, o) {
    return new Mu({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: Ue.toString(o)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Mu({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Ue.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Ue.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Ue.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Ue.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Ue.toString(r)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
Mu.create = (e) => {
  var t;
  return new Mu({
    checks: [],
    typeName: De.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...pt(e)
  });
};
class Yh extends It {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== me.boolean) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: ce.invalid_type,
        expected: me.boolean,
        received: r.parsedType
      }), ot;
    }
    return Mn(t.data);
  }
}
Yh.create = (e) => new Yh({
  typeName: De.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...pt(e)
});
class Jc extends It {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== me.date) {
      const o = this._getOrReturnCtx(t);
      return Ee(o, {
        code: ce.invalid_type,
        expected: me.date,
        received: o.parsedType
      }), ot;
    }
    if (isNaN(t.data.getTime())) {
      const o = this._getOrReturnCtx(t);
      return Ee(o, {
        code: ce.invalid_date
      }), ot;
    }
    const r = new An();
    let n;
    for (const o of this._def.checks)
      o.kind === "min" ? t.data.getTime() < o.value && (n = this._getOrReturnCtx(t, n), Ee(n, {
        code: ce.too_small,
        message: o.message,
        inclusive: !0,
        exact: !1,
        minimum: o.value,
        type: "date"
      }), r.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (n = this._getOrReturnCtx(t, n), Ee(n, {
        code: ce.too_big,
        message: o.message,
        inclusive: !0,
        exact: !1,
        maximum: o.value,
        type: "date"
      }), r.dirty()) : Nt.assertNever(o);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Jc({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Ue.toString(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Ue.toString(r)
    });
  }
  get minDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
}
Jc.create = (e) => new Jc({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: De.ZodDate,
  ...pt(e)
});
class cm extends It {
  _parse(t) {
    if (this._getType(t) !== me.symbol) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: ce.invalid_type,
        expected: me.symbol,
        received: r.parsedType
      }), ot;
    }
    return Mn(t.data);
  }
}
cm.create = (e) => new cm({
  typeName: De.ZodSymbol,
  ...pt(e)
});
class Jh extends It {
  _parse(t) {
    if (this._getType(t) !== me.undefined) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: ce.invalid_type,
        expected: me.undefined,
        received: r.parsedType
      }), ot;
    }
    return Mn(t.data);
  }
}
Jh.create = (e) => new Jh({
  typeName: De.ZodUndefined,
  ...pt(e)
});
class Qh extends It {
  _parse(t) {
    if (this._getType(t) !== me.null) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: ce.invalid_type,
        expected: me.null,
        received: r.parsedType
      }), ot;
    }
    return Mn(t.data);
  }
}
Qh.create = (e) => new Qh({
  typeName: De.ZodNull,
  ...pt(e)
});
class Df extends It {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Mn(t.data);
  }
}
Df.create = (e) => new Df({
  typeName: De.ZodAny,
  ...pt(e)
});
class jc extends It {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Mn(t.data);
  }
}
jc.create = (e) => new jc({
  typeName: De.ZodUnknown,
  ...pt(e)
});
class ls extends It {
  _parse(t) {
    const r = this._getOrReturnCtx(t);
    return Ee(r, {
      code: ce.invalid_type,
      expected: me.never,
      received: r.parsedType
    }), ot;
  }
}
ls.create = (e) => new ls({
  typeName: De.ZodNever,
  ...pt(e)
});
class lm extends It {
  _parse(t) {
    if (this._getType(t) !== me.undefined) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: ce.invalid_type,
        expected: me.void,
        received: r.parsedType
      }), ot;
    }
    return Mn(t.data);
  }
}
lm.create = (e) => new lm({
  typeName: De.ZodVoid,
  ...pt(e)
});
class Ei extends It {
  _parse(t) {
    const { ctx: r, status: n } = this._processInputParams(t), o = this._def;
    if (r.parsedType !== me.array)
      return Ee(r, {
        code: ce.invalid_type,
        expected: me.array,
        received: r.parsedType
      }), ot;
    if (o.exactLength !== null) {
      const i = r.data.length > o.exactLength.value, s = r.data.length < o.exactLength.value;
      (i || s) && (Ee(r, {
        code: i ? ce.too_big : ce.too_small,
        minimum: s ? o.exactLength.value : void 0,
        maximum: i ? o.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: o.exactLength.message
      }), n.dirty());
    }
    if (o.minLength !== null && r.data.length < o.minLength.value && (Ee(r, {
      code: ce.too_small,
      minimum: o.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: o.minLength.message
    }), n.dirty()), o.maxLength !== null && r.data.length > o.maxLength.value && (Ee(r, {
      code: ce.too_big,
      maximum: o.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: o.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((i, s) => o.type._parseAsync(new da(r, i, r.path, s)))).then((i) => An.mergeArray(n, i));
    const a = [...r.data].map((i, s) => o.type._parseSync(new da(r, i, r.path, s)));
    return An.mergeArray(n, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, r) {
    return new Ei({
      ...this._def,
      minLength: { value: t, message: Ue.toString(r) }
    });
  }
  max(t, r) {
    return new Ei({
      ...this._def,
      maxLength: { value: t, message: Ue.toString(r) }
    });
  }
  length(t, r) {
    return new Ei({
      ...this._def,
      exactLength: { value: t, message: Ue.toString(r) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Ei.create = (e, t) => new Ei({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: De.ZodArray,
  ...pt(t)
});
function ql(e) {
  if (e instanceof ur) {
    const t = {};
    for (const r in e.shape) {
      const n = e.shape[r];
      t[r] = ts.create(ql(n));
    }
    return new ur({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof Ei ? new Ei({
    ...e._def,
    type: ql(e.element)
  }) : e instanceof ts ? ts.create(ql(e.unwrap())) : e instanceof el ? el.create(ql(e.unwrap())) : e instanceof ha ? ha.create(e.items.map((t) => ql(t))) : e;
}
class ur extends It {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), r = Nt.objectKeys(t);
    return this._cached = { shape: t, keys: r };
  }
  _parse(t) {
    if (this._getType(t) !== me.object) {
      const u = this._getOrReturnCtx(t);
      return Ee(u, {
        code: ce.invalid_type,
        expected: me.object,
        received: u.parsedType
      }), ot;
    }
    const { status: r, ctx: n } = this._processInputParams(t), { shape: o, keys: a } = this._getCached(), i = [];
    if (!(this._def.catchall instanceof ls && this._def.unknownKeys === "strip"))
      for (const u in n.data)
        a.includes(u) || i.push(u);
    const s = [];
    for (const u of a) {
      const l = o[u], c = n.data[u];
      s.push({
        key: { status: "valid", value: u },
        value: l._parse(new da(n, c, n.path, u)),
        alwaysSet: u in n.data
      });
    }
    if (this._def.catchall instanceof ls) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of i)
          s.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: n.data[l] }
          });
      else if (u === "strict")
        i.length > 0 && (Ee(n, {
          code: ce.unrecognized_keys,
          keys: i
        }), r.dirty());
      else if (u !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of i) {
        const c = n.data[l];
        s.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new da(n, c, n.path, l)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l in n.data
        });
      }
    }
    return n.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of s) {
        const c = await l.key;
        u.push({
          key: c,
          value: await l.value,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => An.mergeObjectSync(r, u)) : An.mergeObjectSync(r, s);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return new ur({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (r, n) => {
          var o, a, i, s;
          const u = (i = (a = (o = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(o, r, n).message) !== null && i !== void 0 ? i : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (s = Ue.errToObj(t).message) !== null && s !== void 0 ? s : u
          } : {
            message: u
          };
        }
      } : {}
    });
  }
  strip() {
    return new ur({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ur({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new ur({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new ur({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: De.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, r) {
    return this.augment({ [t]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new ur({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const r = {};
    return Nt.objectKeys(t).forEach((n) => {
      t[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new ur({
      ...this._def,
      shape: () => r
    });
  }
  omit(t) {
    const r = {};
    return Nt.objectKeys(this.shape).forEach((n) => {
      t[n] || (r[n] = this.shape[n]);
    }), new ur({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return ql(this);
  }
  partial(t) {
    const r = {};
    return Nt.objectKeys(this.shape).forEach((n) => {
      const o = this.shape[n];
      t && !t[n] ? r[n] = o : r[n] = o.optional();
    }), new ur({
      ...this._def,
      shape: () => r
    });
  }
  required(t) {
    const r = {};
    return Nt.objectKeys(this.shape).forEach((n) => {
      if (t && !t[n])
        r[n] = this.shape[n];
      else {
        let o = this.shape[n];
        for (; o instanceof ts; )
          o = o._def.innerType;
        r[n] = o;
      }
    }), new ur({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return jC(Nt.objectKeys(this.shape));
  }
}
ur.create = (e, t) => new ur({
  shape: () => e,
  unknownKeys: "strip",
  catchall: ls.create(),
  typeName: De.ZodObject,
  ...pt(t)
});
ur.strictCreate = (e, t) => new ur({
  shape: () => e,
  unknownKeys: "strict",
  catchall: ls.create(),
  typeName: De.ZodObject,
  ...pt(t)
});
ur.lazycreate = (e, t) => new ur({
  shape: e,
  unknownKeys: "strip",
  catchall: ls.create(),
  typeName: De.ZodObject,
  ...pt(t)
});
class ep extends It {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = this._def.options;
    function o(a) {
      for (const s of a)
        if (s.result.status === "valid")
          return s.result;
      for (const s of a)
        if (s.result.status === "dirty")
          return r.common.issues.push(...s.ctx.common.issues), s.result;
      const i = a.map((s) => new vi(s.ctx.common.issues));
      return Ee(r, {
        code: ce.invalid_union,
        unionErrors: i
      }), ot;
    }
    if (r.common.async)
      return Promise.all(n.map(async (a) => {
        const i = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: r.data,
            path: r.path,
            parent: i
          }),
          ctx: i
        };
      })).then(o);
    {
      let a;
      const i = [];
      for (const u of n) {
        const l = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, c = u._parseSync({
          data: r.data,
          path: r.path,
          parent: l
        });
        if (c.status === "valid")
          return c;
        c.status === "dirty" && !a && (a = { result: c, ctx: l }), l.common.issues.length && i.push(l.common.issues);
      }
      if (a)
        return r.common.issues.push(...a.ctx.common.issues), a.result;
      const s = i.map((u) => new vi(u));
      return Ee(r, {
        code: ce.invalid_union,
        unionErrors: s
      }), ot;
    }
  }
  get options() {
    return this._def.options;
  }
}
ep.create = (e, t) => new ep({
  options: e,
  typeName: De.ZodUnion,
  ...pt(t)
});
const C1 = (e) => e instanceof np ? C1(e.schema) : e instanceof Ti ? C1(e.innerType()) : e instanceof op ? [e.value] : e instanceof Ku ? e.options : e instanceof ip ? Object.keys(e.enum) : e instanceof ap ? C1(e._def.innerType) : e instanceof Jh ? [void 0] : e instanceof Qh ? [null] : null;
class rb extends It {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== me.object)
      return Ee(r, {
        code: ce.invalid_type,
        expected: me.object,
        received: r.parsedType
      }), ot;
    const n = this.discriminator, o = r.data[n], a = this.optionsMap.get(o);
    return a ? r.common.async ? a._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : a._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (Ee(r, {
      code: ce.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), ot);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, r, n) {
    const o = /* @__PURE__ */ new Map();
    for (const a of r) {
      const i = C1(a.shape[t]);
      if (!i)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const s of i) {
        if (o.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        o.set(s, a);
      }
    }
    return new rb({
      typeName: De.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: o,
      ...pt(n)
    });
  }
}
function g8(e, t) {
  const r = Tu(e), n = Tu(t);
  if (e === t)
    return { valid: !0, data: e };
  if (r === me.object && n === me.object) {
    const o = Nt.objectKeys(t), a = Nt.objectKeys(e).filter((s) => o.indexOf(s) !== -1), i = { ...e, ...t };
    for (const s of a) {
      const u = g8(e[s], t[s]);
      if (!u.valid)
        return { valid: !1 };
      i[s] = u.data;
    }
    return { valid: !0, data: i };
  } else if (r === me.array && n === me.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const o = [];
    for (let a = 0; a < e.length; a++) {
      const i = e[a], s = t[a], u = g8(i, s);
      if (!u.valid)
        return { valid: !1 };
      o.push(u.data);
    }
    return { valid: !0, data: o };
  } else return r === me.date && n === me.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class tp extends It {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), o = (a, i) => {
      if (h8(a) || h8(i))
        return ot;
      const s = g8(a.value, i.value);
      return s.valid ? ((p8(a) || p8(i)) && r.dirty(), { status: r.value, value: s.data }) : (Ee(n, {
        code: ce.invalid_intersection_types
      }), ot);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([a, i]) => o(a, i)) : o(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
tp.create = (e, t, r) => new tp({
  left: e,
  right: t,
  typeName: De.ZodIntersection,
  ...pt(r)
});
class ha extends It {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== me.array)
      return Ee(n, {
        code: ce.invalid_type,
        expected: me.array,
        received: n.parsedType
      }), ot;
    if (n.data.length < this._def.items.length)
      return Ee(n, {
        code: ce.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), ot;
    !this._def.rest && n.data.length > this._def.items.length && (Ee(n, {
      code: ce.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const o = [...n.data].map((a, i) => {
      const s = this._def.items[i] || this._def.rest;
      return s ? s._parse(new da(n, a, n.path, i)) : null;
    }).filter((a) => !!a);
    return n.common.async ? Promise.all(o).then((a) => An.mergeArray(r, a)) : An.mergeArray(r, o);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new ha({
      ...this._def,
      rest: t
    });
  }
}
ha.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ha({
    items: e,
    typeName: De.ZodTuple,
    rest: null,
    ...pt(t)
  });
};
class rp extends It {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== me.object)
      return Ee(n, {
        code: ce.invalid_type,
        expected: me.object,
        received: n.parsedType
      }), ot;
    const o = [], a = this._def.keyType, i = this._def.valueType;
    for (const s in n.data)
      o.push({
        key: a._parse(new da(n, s, n.path, s)),
        value: i._parse(new da(n, n.data[s], n.path, s))
      });
    return n.common.async ? An.mergeObjectAsync(r, o) : An.mergeObjectSync(r, o);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, r, n) {
    return r instanceof It ? new rp({
      keyType: t,
      valueType: r,
      typeName: De.ZodRecord,
      ...pt(n)
    }) : new rp({
      keyType: di.create(),
      valueType: t,
      typeName: De.ZodRecord,
      ...pt(r)
    });
  }
}
class fm extends It {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== me.map)
      return Ee(n, {
        code: ce.invalid_type,
        expected: me.map,
        received: n.parsedType
      }), ot;
    const o = this._def.keyType, a = this._def.valueType, i = [...n.data.entries()].map(([s, u], l) => ({
      key: o._parse(new da(n, s, n.path, [l, "key"])),
      value: a._parse(new da(n, u, n.path, [l, "value"]))
    }));
    if (n.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const u of i) {
          const l = await u.key, c = await u.value;
          if (l.status === "aborted" || c.status === "aborted")
            return ot;
          (l.status === "dirty" || c.status === "dirty") && r.dirty(), s.set(l.value, c.value);
        }
        return { status: r.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const u of i) {
        const l = u.key, c = u.value;
        if (l.status === "aborted" || c.status === "aborted")
          return ot;
        (l.status === "dirty" || c.status === "dirty") && r.dirty(), s.set(l.value, c.value);
      }
      return { status: r.value, value: s };
    }
  }
}
fm.create = (e, t, r) => new fm({
  valueType: t,
  keyType: e,
  typeName: De.ZodMap,
  ...pt(r)
});
class Qc extends It {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== me.set)
      return Ee(n, {
        code: ce.invalid_type,
        expected: me.set,
        received: n.parsedType
      }), ot;
    const o = this._def;
    o.minSize !== null && n.data.size < o.minSize.value && (Ee(n, {
      code: ce.too_small,
      minimum: o.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: o.minSize.message
    }), r.dirty()), o.maxSize !== null && n.data.size > o.maxSize.value && (Ee(n, {
      code: ce.too_big,
      maximum: o.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: o.maxSize.message
    }), r.dirty());
    const a = this._def.valueType;
    function i(u) {
      const l = /* @__PURE__ */ new Set();
      for (const c of u) {
        if (c.status === "aborted")
          return ot;
        c.status === "dirty" && r.dirty(), l.add(c.value);
      }
      return { status: r.value, value: l };
    }
    const s = [...n.data.values()].map((u, l) => a._parse(new da(n, u, n.path, l)));
    return n.common.async ? Promise.all(s).then((u) => i(u)) : i(s);
  }
  min(t, r) {
    return new Qc({
      ...this._def,
      minSize: { value: t, message: Ue.toString(r) }
    });
  }
  max(t, r) {
    return new Qc({
      ...this._def,
      maxSize: { value: t, message: Ue.toString(r) }
    });
  }
  size(t, r) {
    return this.min(t, r).max(t, r);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Qc.create = (e, t) => new Qc({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: De.ZodSet,
  ...pt(t)
});
class pf extends It {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== me.function)
      return Ee(r, {
        code: ce.invalid_type,
        expected: me.function,
        received: r.parsedType
      }), ot;
    function n(s, u) {
      return am({
        data: s,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          im(),
          Xh
        ].filter((l) => !!l),
        issueData: {
          code: ce.invalid_arguments,
          argumentsError: u
        }
      });
    }
    function o(s, u) {
      return am({
        data: s,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          im(),
          Xh
        ].filter((l) => !!l),
        issueData: {
          code: ce.invalid_return_type,
          returnTypeError: u
        }
      });
    }
    const a = { errorMap: r.common.contextualErrorMap }, i = r.data;
    return this._def.returns instanceof Mf ? Mn(async (...s) => {
      const u = new vi([]), l = await this._def.args.parseAsync(s, a).catch((f) => {
        throw u.addIssue(n(s, f)), u;
      }), c = await i(...l);
      return await this._def.returns._def.type.parseAsync(c, a).catch((f) => {
        throw u.addIssue(o(c, f)), u;
      });
    }) : Mn((...s) => {
      const u = this._def.args.safeParse(s, a);
      if (!u.success)
        throw new vi([n(s, u.error)]);
      const l = i(...u.data), c = this._def.returns.safeParse(l, a);
      if (!c.success)
        throw new vi([o(l, c.error)]);
      return c.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new pf({
      ...this._def,
      args: ha.create(t).rest(jc.create())
    });
  }
  returns(t) {
    return new pf({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, r, n) {
    return new pf({
      args: t || ha.create([]).rest(jc.create()),
      returns: r || jc.create(),
      typeName: De.ZodFunction,
      ...pt(n)
    });
  }
}
class np extends It {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
np.create = (e, t) => new np({
  getter: e,
  typeName: De.ZodLazy,
  ...pt(t)
});
class op extends It {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        received: r.data,
        code: ce.invalid_literal,
        expected: this._def.value
      }), ot;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
op.create = (e, t) => new op({
  value: e,
  typeName: De.ZodLiteral,
  ...pt(t)
});
function jC(e, t) {
  return new Ku({
    values: e,
    typeName: De.ZodEnum,
    ...pt(t)
  });
}
class Ku extends It {
  _parse(t) {
    if (typeof t.data != "string") {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return Ee(r, {
        expected: Nt.joinValues(n),
        received: r.parsedType,
        code: ce.invalid_type
      }), ot;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return Ee(r, {
        received: r.data,
        code: ce.invalid_enum_value,
        options: n
      }), ot;
    }
    return Mn(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Values() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  extract(t) {
    return Ku.create(t);
  }
  exclude(t) {
    return Ku.create(this.options.filter((r) => !t.includes(r)));
  }
}
Ku.create = jC;
class ip extends It {
  _parse(t) {
    const r = Nt.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
    if (n.parsedType !== me.string && n.parsedType !== me.number) {
      const o = Nt.objectValues(r);
      return Ee(n, {
        expected: Nt.joinValues(o),
        received: n.parsedType,
        code: ce.invalid_type
      }), ot;
    }
    if (r.indexOf(t.data) === -1) {
      const o = Nt.objectValues(r);
      return Ee(n, {
        received: n.data,
        code: ce.invalid_enum_value,
        options: o
      }), ot;
    }
    return Mn(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
ip.create = (e, t) => new ip({
  values: e,
  typeName: De.ZodNativeEnum,
  ...pt(t)
});
class Mf extends It {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== me.promise && r.common.async === !1)
      return Ee(r, {
        code: ce.invalid_type,
        expected: me.promise,
        received: r.parsedType
      }), ot;
    const n = r.parsedType === me.promise ? r.data : Promise.resolve(r.data);
    return Mn(n.then((o) => this._def.type.parseAsync(o, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
Mf.create = (e, t) => new Mf({
  type: e,
  typeName: De.ZodPromise,
  ...pt(t)
});
class Ti extends It {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === De.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), o = this._def.effect || null;
    if (o.type === "preprocess") {
      const i = o.transform(n.data);
      return n.common.async ? Promise.resolve(i).then((s) => this._def.schema._parseAsync({
        data: s,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: i,
        path: n.path,
        parent: n
      });
    }
    const a = {
      addIssue: (i) => {
        Ee(n, i), i.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), o.type === "refinement") {
      const i = (s) => {
        const u = o.refinement(s, a);
        if (n.common.async)
          return Promise.resolve(u);
        if (u instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      };
      if (n.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? ot : (s.status === "dirty" && r.dirty(), i(s.value), { status: r.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((s) => s.status === "aborted" ? ot : (s.status === "dirty" && r.dirty(), i(s.value).then(() => ({ status: r.value, value: s.value }))));
    }
    if (o.type === "transform")
      if (n.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!sm(i))
          return i;
        const s = o.transform(i.value, a);
        if (s instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((i) => sm(i) ? Promise.resolve(o.transform(i.value, a)).then((s) => ({ status: r.value, value: s })) : i);
    Nt.assertNever(o);
  }
}
Ti.create = (e, t, r) => new Ti({
  schema: e,
  typeName: De.ZodEffects,
  effect: t,
  ...pt(r)
});
Ti.createWithPreprocess = (e, t, r) => new Ti({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: De.ZodEffects,
  ...pt(r)
});
class ts extends It {
  _parse(t) {
    return this._getType(t) === me.undefined ? Mn(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ts.create = (e, t) => new ts({
  innerType: e,
  typeName: De.ZodOptional,
  ...pt(t)
});
class el extends It {
  _parse(t) {
    return this._getType(t) === me.null ? Mn(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
el.create = (e, t) => new el({
  innerType: e,
  typeName: De.ZodNullable,
  ...pt(t)
});
class ap extends It {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    let n = r.data;
    return r.parsedType === me.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ap.create = (e, t) => new ap({
  innerType: e,
  typeName: De.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...pt(t)
});
class dm extends It {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, o = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return um(o) ? o.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new vi(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: o.status === "valid" ? o.value : this._def.catchValue({
        get error() {
          return new vi(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
dm.create = (e, t) => new dm({
  innerType: e,
  typeName: De.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...pt(t)
});
class hm extends It {
  _parse(t) {
    if (this._getType(t) !== me.nan) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: ce.invalid_type,
        expected: me.nan,
        received: r.parsedType
      }), ot;
    }
    return { status: "valid", value: t.data };
  }
}
hm.create = (e) => new hm({
  typeName: De.ZodNaN,
  ...pt(e)
});
const t1e = Symbol("zod_brand");
class LC extends It {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class e0 extends It {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.common.async)
      return (async () => {
        const o = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? ot : o.status === "dirty" ? (r.dirty(), zC(o.value)) : this._def.out._parseAsync({
          data: o.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const o = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return o.status === "aborted" ? ot : o.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: o.value
      }) : this._def.out._parseSync({
        data: o.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(t, r) {
    return new e0({
      in: t,
      out: r,
      typeName: De.ZodPipeline
    });
  }
}
const HC = (e, t = {}, r) => e ? Df.create().superRefine((n, o) => {
  var a, i;
  if (!e(n)) {
    const s = typeof t == "function" ? t(n) : typeof t == "string" ? { message: t } : t, u = (i = (a = s.fatal) !== null && a !== void 0 ? a : r) !== null && i !== void 0 ? i : !0, l = typeof s == "string" ? { message: s } : s;
    o.addIssue({ code: "custom", ...l, fatal: u });
  }
}) : Df.create(), r1e = {
  object: ur.lazycreate
};
var De;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(De || (De = {}));
const n1e = (e, t = {
  message: `Input not instance of ${e.name}`
}) => HC((r) => r instanceof e, t), FC = di.create, DC = Du.create, o1e = hm.create, i1e = Mu.create, MC = Yh.create, a1e = Jc.create, s1e = cm.create, u1e = Jh.create, c1e = Qh.create, l1e = Df.create, f1e = jc.create, d1e = ls.create, h1e = lm.create, p1e = Ei.create, g1e = ur.create, m1e = ur.strictCreate, y1e = ep.create, b1e = rb.create, w1e = tp.create, v1e = ha.create, E1e = rp.create, k1e = fm.create, x1e = Qc.create, A1e = pf.create, S1e = np.create, _1e = op.create, I1e = Ku.create, T1e = ip.create, P1e = Mf.create, z9 = Ti.create, O1e = ts.create, $1e = el.create, C1e = Ti.createWithPreprocess, B1e = e0.create, N1e = () => FC().optional(), U1e = () => DC().optional(), R1e = () => MC().optional(), z1e = {
  string: (e) => di.create({ ...e, coerce: !0 }),
  number: (e) => Du.create({ ...e, coerce: !0 }),
  boolean: (e) => Yh.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Mu.create({ ...e, coerce: !0 }),
  date: (e) => Jc.create({ ...e, coerce: !0 })
}, j1e = ot;
var Ln = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Xh,
  setErrorMap: D0e,
  getErrorMap: im,
  makeIssue: am,
  EMPTY_PATH: M0e,
  addIssueToContext: Ee,
  ParseStatus: An,
  INVALID: ot,
  DIRTY: zC,
  OK: Mn,
  isAborted: h8,
  isDirty: p8,
  isValid: sm,
  isAsync: um,
  get util() {
    return Nt;
  },
  get objectUtil() {
    return d8;
  },
  ZodParsedType: me,
  getParsedType: Tu,
  ZodType: It,
  ZodString: di,
  ZodNumber: Du,
  ZodBigInt: Mu,
  ZodBoolean: Yh,
  ZodDate: Jc,
  ZodSymbol: cm,
  ZodUndefined: Jh,
  ZodNull: Qh,
  ZodAny: Df,
  ZodUnknown: jc,
  ZodNever: ls,
  ZodVoid: lm,
  ZodArray: Ei,
  ZodObject: ur,
  ZodUnion: ep,
  ZodDiscriminatedUnion: rb,
  ZodIntersection: tp,
  ZodTuple: ha,
  ZodRecord: rp,
  ZodMap: fm,
  ZodSet: Qc,
  ZodFunction: pf,
  ZodLazy: np,
  ZodLiteral: op,
  ZodEnum: Ku,
  ZodNativeEnum: ip,
  ZodPromise: Mf,
  ZodEffects: Ti,
  ZodTransformer: Ti,
  ZodOptional: ts,
  ZodNullable: el,
  ZodDefault: ap,
  ZodCatch: dm,
  ZodNaN: hm,
  BRAND: t1e,
  ZodBranded: LC,
  ZodPipeline: e0,
  custom: HC,
  Schema: It,
  ZodSchema: It,
  late: r1e,
  get ZodFirstPartyTypeKind() {
    return De;
  },
  coerce: z1e,
  any: l1e,
  array: p1e,
  bigint: i1e,
  boolean: MC,
  date: a1e,
  discriminatedUnion: b1e,
  effect: z9,
  enum: I1e,
  function: A1e,
  instanceof: n1e,
  intersection: w1e,
  lazy: S1e,
  literal: _1e,
  map: k1e,
  nan: o1e,
  nativeEnum: T1e,
  never: d1e,
  null: c1e,
  nullable: $1e,
  number: DC,
  object: g1e,
  oboolean: R1e,
  onumber: U1e,
  optional: O1e,
  ostring: N1e,
  pipeline: B1e,
  preprocess: C1e,
  promise: P1e,
  record: E1e,
  set: x1e,
  strictObject: m1e,
  string: FC,
  symbol: s1e,
  transformer: z9,
  tuple: v1e,
  undefined: u1e,
  union: y1e,
  unknown: f1e,
  void: h1e,
  NEVER: j1e,
  ZodIssueCode: ce,
  quotelessJson: F0e,
  ZodError: vi
});
const KC = Ln.string().regex(/^[a-fA-F0-9]$/), L1e = Ln.string().regex(/^[a-fA-F0-9]{64}$/), Kf = Ln.number().min(0).max(4294967295), H1e = Ln.bigint(), qC = Ln.instanceof(Uint8Array), F1e = Ln.union([KC, Kf, Ln.string(), qC]).array(), O4 = Ln.union([F1e, KC, qC]), D1e = Ln.array(O4), VC = Ln.object({
  value: Ln.union([Kf, H1e]),
  scriptPubKey: O4
}), M1e = Ln.object({
  txid: L1e,
  vout: Kf,
  scriptSig: O4,
  sequence: Kf,
  prevout: VC.optional(),
  witness: D1e
});
Ln.object({
  version: Kf,
  vin: Ln.array(M1e),
  vout: Ln.array(VC),
  locktime: Kf
});
var br = {}, $4 = {};
const K1e = {}, q1e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: K1e
}, Symbol.toStringTag, { value: "Module" })), GC = /* @__PURE__ */ Dne(q1e);
(function(e) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.utils = e.schnorr = e.verify = e.signSync = e.sign = e.getSharedSecret = e.recoverPublicKey = e.getPublicKey = e.Signature = e.Point = e.CURVE = void 0;
  const t = GC, r = BigInt(0), n = BigInt(1), o = BigInt(2), a = BigInt(3), i = BigInt(8), s = Object.freeze({
    a: r,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: n,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  e.CURVE = s;
  const u = (P, x) => (P + x / o) / x, l = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(P) {
      const { n: x } = s, T = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), B = -n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), j = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), q = T, X = BigInt("0x100000000000000000000000000000000"), Q = u(q * P, x), ae = u(-B * P, x);
      let ie = K(P - Q * T - ae * j, x), le = K(-Q * B - ae * q, x);
      const pe = ie > X, we = le > X;
      if (pe && (ie = x - ie), we && (le = x - le), ie > X || le > X)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + P);
      return { k1neg: pe, k1: ie, k2neg: we, k2: le };
    }
  }, c = 32, f = 32, h = 32, p = c + 1, y = 2 * c + 1;
  function m(P) {
    const { a: x, b: T } = s, B = K(P * P), j = K(B * P);
    return K(j + x * P + T);
  }
  const b = s.a === r;
  class v extends Error {
    constructor(x) {
      super(x);
    }
  }
  function k(P) {
    if (!(P instanceof E))
      throw new TypeError("JacobianPoint expected");
  }
  class E {
    constructor(x, T, B) {
      this.x = x, this.y = T, this.z = B;
    }
    static fromAffine(x) {
      if (!(x instanceof _))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return x.equals(_.ZERO) ? E.ZERO : new E(x.x, x.y, n);
    }
    static toAffineBatch(x) {
      const T = Et(x.map((B) => B.z));
      return x.map((B, j) => B.toAffine(T[j]));
    }
    static normalizeZ(x) {
      return E.toAffineBatch(x).map(E.fromAffine);
    }
    equals(x) {
      k(x);
      const { x: T, y: B, z: j } = this, { x: q, y: X, z: Q } = x, ae = K(j * j), ie = K(Q * Q), le = K(T * ie), pe = K(q * ae), we = K(K(B * Q) * ie), kt = K(K(X * j) * ae);
      return le === pe && we === kt;
    }
    negate() {
      return new E(this.x, K(-this.y), this.z);
    }
    double() {
      const { x, y: T, z: B } = this, j = K(x * x), q = K(T * T), X = K(q * q), Q = x + q, ae = K(o * (K(Q * Q) - j - X)), ie = K(a * j), le = K(ie * ie), pe = K(le - o * ae), we = K(ie * (ae - pe) - i * X), kt = K(o * T * B);
      return new E(pe, we, kt);
    }
    add(x) {
      k(x);
      const { x: T, y: B, z: j } = this, { x: q, y: X, z: Q } = x;
      if (q === r || X === r)
        return this;
      if (T === r || B === r)
        return x;
      const ae = K(j * j), ie = K(Q * Q), le = K(T * ie), pe = K(q * ae), we = K(K(B * Q) * ie), kt = K(K(X * j) * ae), xt = K(pe - le), zr = K(kt - we);
      if (xt === r)
        return zr === r ? this.double() : E.ZERO;
      const fo = K(xt * xt), ho = K(xt * fo), po = K(le * fo), _a = K(zr * zr - ho - o * po), nc = K(zr * (po - _a) - we * ho), Qo = K(j * Q * xt);
      return new E(_a, nc, Qo);
    }
    subtract(x) {
      return this.add(x.negate());
    }
    multiplyUnsafe(x) {
      const T = E.ZERO;
      if (typeof x == "bigint" && x === r)
        return T;
      let B = se(x);
      if (B === n)
        return this;
      if (!b) {
        let pe = T, we = this;
        for (; B > r; )
          B & n && (pe = pe.add(we)), we = we.double(), B >>= n;
        return pe;
      }
      let { k1neg: j, k1: q, k2neg: X, k2: Q } = l.splitScalar(B), ae = T, ie = T, le = this;
      for (; q > r || Q > r; )
        q & n && (ae = ae.add(le)), Q & n && (ie = ie.add(le)), le = le.double(), q >>= n, Q >>= n;
      return j && (ae = ae.negate()), X && (ie = ie.negate()), ie = new E(K(ie.x * l.beta), ie.y, ie.z), ae.add(ie);
    }
    precomputeWindow(x) {
      const T = b ? 128 / x + 1 : 256 / x + 1, B = [];
      let j = this, q = j;
      for (let X = 0; X < T; X++) {
        q = j, B.push(q);
        for (let Q = 1; Q < 2 ** (x - 1); Q++)
          q = q.add(j), B.push(q);
        j = q.double();
      }
      return B;
    }
    wNAF(x, T) {
      !T && this.equals(E.BASE) && (T = _.BASE);
      const B = T && T._WINDOW_SIZE || 1;
      if (256 % B)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let j = T && S.get(T);
      j || (j = this.precomputeWindow(B), T && B !== 1 && (j = E.normalizeZ(j), S.set(T, j)));
      let q = E.ZERO, X = E.BASE;
      const Q = 1 + (b ? 128 / B : 256 / B), ae = 2 ** (B - 1), ie = BigInt(2 ** B - 1), le = 2 ** B, pe = BigInt(B);
      for (let we = 0; we < Q; we++) {
        const kt = we * ae;
        let xt = Number(x & ie);
        x >>= pe, xt > ae && (xt -= le, x += n);
        const zr = kt, fo = kt + Math.abs(xt) - 1, ho = we % 2 !== 0, po = xt < 0;
        xt === 0 ? X = X.add(A(ho, j[zr])) : q = q.add(A(po, j[fo]));
      }
      return { p: q, f: X };
    }
    multiply(x, T) {
      let B = se(x), j, q;
      if (b) {
        const { k1neg: X, k1: Q, k2neg: ae, k2: ie } = l.splitScalar(B);
        let { p: le, f: pe } = this.wNAF(Q, T), { p: we, f: kt } = this.wNAF(ie, T);
        le = A(X, le), we = A(ae, we), we = new E(K(we.x * l.beta), we.y, we.z), j = le.add(we), q = pe.add(kt);
      } else {
        const { p: X, f: Q } = this.wNAF(B, T);
        j = X, q = Q;
      }
      return E.normalizeZ([j, q])[0];
    }
    toAffine(x) {
      const { x: T, y: B, z: j } = this, q = this.equals(E.ZERO);
      x == null && (x = q ? i : ye(j));
      const X = x, Q = K(X * X), ae = K(Q * X), ie = K(T * Q), le = K(B * ae), pe = K(j * X);
      if (q)
        return _.ZERO;
      if (pe !== n)
        throw new Error("invZ was invalid");
      return new _(ie, le);
    }
  }
  E.BASE = new E(s.Gx, s.Gy, n), E.ZERO = new E(r, n, r);
  function A(P, x) {
    const T = x.negate();
    return P ? T : x;
  }
  const S = /* @__PURE__ */ new WeakMap();
  class _ {
    constructor(x, T) {
      this.x = x, this.y = T;
    }
    _setWindowSize(x) {
      this._WINDOW_SIZE = x, S.delete(this);
    }
    hasEvenY() {
      return this.y % o === r;
    }
    static fromCompressedHex(x) {
      const T = x.length === 32, B = ne(T ? x : x.subarray(1));
      if (!Tt(B))
        throw new Error("Point is not on curve");
      const j = m(B);
      let q = Ae(j);
      const X = (q & n) === n;
      T ? X && (q = K(-q)) : (x[0] & 1) === 1 !== X && (q = K(-q));
      const Q = new _(B, q);
      return Q.assertValidity(), Q;
    }
    static fromUncompressedHex(x) {
      const T = ne(x.subarray(1, c + 1)), B = ne(x.subarray(c + 1, c * 2 + 1)), j = new _(T, B);
      return j.assertValidity(), j;
    }
    static fromHex(x) {
      const T = oe(x), B = T.length, j = T[0];
      if (B === c)
        return this.fromCompressedHex(T);
      if (B === p && (j === 2 || j === 3))
        return this.fromCompressedHex(T);
      if (B === y && j === 4)
        return this.fromUncompressedHex(T);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${p} compressed bytes or ${y} uncompressed bytes, not ${B}`);
    }
    static fromPrivateKey(x) {
      return _.BASE.multiply(Wt(x));
    }
    static fromSignature(x, T, B) {
      const { r: j, s: q } = ka(T);
      if (![0, 1, 2, 3].includes(B))
        throw new Error("Cannot recover: invalid recovery bit");
      const X = be(oe(x)), { n: Q } = s, ae = B === 2 || B === 3 ? j + Q : j, ie = ye(ae, Q), le = K(-X * ie, Q), pe = K(q * ie, Q), we = B & 1 ? "03" : "02", kt = _.fromHex(we + C(ae)), xt = _.BASE.multiplyAndAddUnsafe(kt, le, pe);
      if (!xt)
        throw new Error("Cannot recover signature: point at infinify");
      return xt.assertValidity(), xt;
    }
    toRawBytes(x = !1) {
      return W(this.toHex(x));
    }
    toHex(x = !1) {
      const T = C(this.x);
      return x ? `${this.hasEvenY() ? "02" : "03"}${T}` : `04${T}${C(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const x = "Point is not on elliptic curve", { x: T, y: B } = this;
      if (!Tt(T) || !Tt(B))
        throw new Error(x);
      const j = K(B * B), q = m(T);
      if (K(j - q) !== r)
        throw new Error(x);
    }
    equals(x) {
      return this.x === x.x && this.y === x.y;
    }
    negate() {
      return new _(this.x, K(-this.y));
    }
    double() {
      return E.fromAffine(this).double().toAffine();
    }
    add(x) {
      return E.fromAffine(this).add(E.fromAffine(x)).toAffine();
    }
    subtract(x) {
      return this.add(x.negate());
    }
    multiply(x) {
      return E.fromAffine(this).multiply(x, this).toAffine();
    }
    multiplyAndAddUnsafe(x, T, B) {
      const j = E.fromAffine(this), q = T === r || T === n || this !== _.BASE ? j.multiplyUnsafe(T) : j.multiply(T), X = E.fromAffine(x).multiplyUnsafe(B), Q = q.add(X);
      return Q.equals(E.ZERO) ? void 0 : Q.toAffine();
    }
  }
  e.Point = _, _.BASE = new _(s.Gx, s.Gy), _.ZERO = new _(r, r);
  function I(P) {
    return Number.parseInt(P[0], 16) >= 8 ? "00" + P : P;
  }
  function O(P) {
    if (P.length < 2 || P[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${V(P)}`);
    const x = P[1], T = P.subarray(2, x + 2);
    if (!x || T.length !== x)
      throw new Error("Invalid signature integer: wrong length");
    if (T[0] === 0 && T[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: ne(T), left: P.subarray(x + 2) };
  }
  function z(P) {
    if (P.length < 2 || P[0] != 48)
      throw new Error(`Invalid signature tag: ${V(P)}`);
    if (P[1] !== P.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: x, left: T } = O(P.subarray(2)), { data: B, left: j } = O(T);
    if (j.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${V(j)}`);
    return { r: x, s: B };
  }
  class D {
    constructor(x, T) {
      this.r = x, this.s = T, this.assertValidity();
    }
    static fromCompact(x) {
      const T = x instanceof Uint8Array, B = "Signature.fromCompact";
      if (typeof x != "string" && !T)
        throw new TypeError(`${B}: Expected string or Uint8Array`);
      const j = T ? V(x) : x;
      if (j.length !== 128)
        throw new Error(`${B}: Expected 64-byte hex`);
      return new D(re(j.slice(0, 64)), re(j.slice(64, 128)));
    }
    static fromDER(x) {
      const T = x instanceof Uint8Array;
      if (typeof x != "string" && !T)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: B, s: j } = z(T ? x : W(x));
      return new D(B, j);
    }
    static fromHex(x) {
      return this.fromDER(x);
    }
    assertValidity() {
      const { r: x, s: T } = this;
      if (!Re(x))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!Re(T))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const x = s.n >> n;
      return this.s > x;
    }
    normalizeS() {
      return this.hasHighS() ? new D(this.r, K(-this.s, s.n)) : this;
    }
    toDERRawBytes() {
      return W(this.toDERHex());
    }
    toDERHex() {
      const x = I(M(this.s)), T = I(M(this.r)), B = x.length / 2, j = T.length / 2, q = M(B), X = M(j);
      return `30${M(j + B + 4)}02${X}${T}02${q}${x}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return W(this.toCompactHex());
    }
    toCompactHex() {
      return C(this.r) + C(this.s);
    }
  }
  e.Signature = D;
  function G(...P) {
    if (!P.every((B) => B instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (P.length === 1)
      return P[0];
    const x = P.reduce((B, j) => B + j.length, 0), T = new Uint8Array(x);
    for (let B = 0, j = 0; B < P.length; B++) {
      const q = P[B];
      T.set(q, j), j += q.length;
    }
    return T;
  }
  const U = Array.from({ length: 256 }, (P, x) => x.toString(16).padStart(2, "0"));
  function V(P) {
    if (!(P instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let x = "";
    for (let T = 0; T < P.length; T++)
      x += U[P[T]];
    return x;
  }
  const F = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function C(P) {
    if (typeof P != "bigint")
      throw new Error("Expected bigint");
    if (!(r <= P && P < F))
      throw new Error("Expected number 0 <= n < 2^256");
    return P.toString(16).padStart(64, "0");
  }
  function R(P) {
    const x = W(C(P));
    if (x.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return x;
  }
  function M(P) {
    const x = P.toString(16);
    return x.length & 1 ? `0${x}` : x;
  }
  function re(P) {
    if (typeof P != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof P);
    return BigInt(`0x${P}`);
  }
  function W(P) {
    if (typeof P != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof P);
    if (P.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + P.length);
    const x = new Uint8Array(P.length / 2);
    for (let T = 0; T < x.length; T++) {
      const B = T * 2, j = P.slice(B, B + 2), q = Number.parseInt(j, 16);
      if (Number.isNaN(q) || q < 0)
        throw new Error("Invalid byte sequence");
      x[T] = q;
    }
    return x;
  }
  function ne(P) {
    return re(V(P));
  }
  function oe(P) {
    return P instanceof Uint8Array ? Uint8Array.from(P) : W(P);
  }
  function se(P) {
    if (typeof P == "number" && Number.isSafeInteger(P) && P > 0)
      return BigInt(P);
    if (typeof P == "bigint" && Re(P))
      return P;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function K(P, x = s.P) {
    const T = P % x;
    return T >= r ? T : x + T;
  }
  function he(P, x) {
    const { P: T } = s;
    let B = P;
    for (; x-- > r; )
      B *= B, B %= T;
    return B;
  }
  function Ae(P) {
    const { P: x } = s, T = BigInt(6), B = BigInt(11), j = BigInt(22), q = BigInt(23), X = BigInt(44), Q = BigInt(88), ae = P * P * P % x, ie = ae * ae * P % x, le = he(ie, a) * ie % x, pe = he(le, a) * ie % x, we = he(pe, o) * ae % x, kt = he(we, B) * we % x, xt = he(kt, j) * kt % x, zr = he(xt, X) * xt % x, fo = he(zr, Q) * zr % x, ho = he(fo, X) * xt % x, po = he(ho, a) * ie % x, _a = he(po, q) * kt % x, nc = he(_a, T) * ae % x, Qo = he(nc, o);
    if (Qo * Qo % x !== P)
      throw new Error("Cannot find square root");
    return Qo;
  }
  function ye(P, x = s.P) {
    if (P === r || x <= r)
      throw new Error(`invert: expected positive integers, got n=${P} mod=${x}`);
    let T = K(P, x), B = x, j = r, q = n;
    for (; T !== r; ) {
      const X = B / T, Q = B % T, ae = j - q * X;
      B = T, T = Q, j = q, q = ae;
    }
    if (B !== n)
      throw new Error("invert: does not exist");
    return K(j, x);
  }
  function Et(P, x = s.P) {
    const T = new Array(P.length), B = P.reduce((q, X, Q) => X === r ? q : (T[Q] = q, K(q * X, x)), n), j = ye(B, x);
    return P.reduceRight((q, X, Q) => X === r ? q : (T[Q] = K(q * T[Q], x), K(q * X, x)), j), T;
  }
  function Ge(P) {
    const x = P.length * 8 - f * 8, T = ne(P);
    return x > 0 ? T >> BigInt(x) : T;
  }
  function be(P, x = !1) {
    const T = Ge(P);
    if (x)
      return T;
    const { n: B } = s;
    return T >= B ? T - B : T;
  }
  let st, Ze;
  class We {
    constructor(x, T) {
      if (this.hashLen = x, this.qByteLen = T, typeof x != "number" || x < 2)
        throw new Error("hashLen must be a number");
      if (typeof T != "number" || T < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(x).fill(1), this.k = new Uint8Array(x).fill(0), this.counter = 0;
    }
    hmac(...x) {
      return e.utils.hmacSha256(this.k, ...x);
    }
    hmacSync(...x) {
      return Ze(this.k, ...x);
    }
    checkSync() {
      if (typeof Ze != "function")
        throw new v("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(x = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), x), this.v = await this.hmac(this.v), x.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), x), this.v = await this.hmac(this.v));
    }
    reseedSync(x = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), x), this.v = this.hmacSync(this.v), x.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), x), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let x = 0;
      const T = [];
      for (; x < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const B = this.v.slice();
        T.push(B), x += this.v.length;
      }
      return G(...T);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let x = 0;
      const T = [];
      for (; x < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const B = this.v.slice();
        T.push(B), x += this.v.length;
      }
      return G(...T);
    }
  }
  function Re(P) {
    return r < P && P < s.n;
  }
  function Tt(P) {
    return r < P && P < s.P;
  }
  function xr(P, x, T, B = !0) {
    const { n: j } = s, q = be(P, !0);
    if (!Re(q))
      return;
    const X = ye(q, j), Q = _.BASE.multiply(q), ae = K(Q.x, j);
    if (ae === r)
      return;
    const ie = K(X * K(x + T * ae, j), j);
    if (ie === r)
      return;
    let le = new D(ae, ie), pe = (Q.x === le.r ? 0 : 2) | Number(Q.y & n);
    return B && le.hasHighS() && (le = le.normalizeS(), pe ^= 1), { sig: le, recovery: pe };
  }
  function Wt(P) {
    let x;
    if (typeof P == "bigint")
      x = P;
    else if (typeof P == "number" && Number.isSafeInteger(P) && P > 0)
      x = BigInt(P);
    else if (typeof P == "string") {
      if (P.length !== 2 * f)
        throw new Error("Expected 32 bytes of private key");
      x = re(P);
    } else if (P instanceof Uint8Array) {
      if (P.length !== f)
        throw new Error("Expected 32 bytes of private key");
      x = ne(P);
    } else
      throw new TypeError("Expected valid private key");
    if (!Re(x))
      throw new Error("Expected private key: 0 < key < n");
    return x;
  }
  function Sn(P) {
    return P instanceof _ ? (P.assertValidity(), P) : _.fromHex(P);
  }
  function ka(P) {
    if (P instanceof D)
      return P.assertValidity(), P;
    try {
      return D.fromDER(P);
    } catch {
      return D.fromCompact(P);
    }
  }
  function tc(P, x = !1) {
    return _.fromPrivateKey(P).toRawBytes(x);
  }
  e.getPublicKey = tc;
  function xa(P, x, T, B = !1) {
    return _.fromSignature(P, x, T).toRawBytes(B);
  }
  e.recoverPublicKey = xa;
  function _n(P) {
    const x = P instanceof Uint8Array, T = typeof P == "string", B = (x || T) && P.length;
    return x ? B === p || B === y : T ? B === p * 2 || B === y * 2 : P instanceof _;
  }
  function Xt(P, x, T = !1) {
    if (_n(P))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!_n(x))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const B = Sn(x);
    return B.assertValidity(), B.multiply(Wt(P)).toRawBytes(T);
  }
  e.getSharedSecret = Xt;
  function lo(P) {
    const x = P.length > c ? P.slice(0, c) : P;
    return ne(x);
  }
  function rc(P) {
    const x = lo(P), T = K(x, s.n);
    return or(T < r ? x : T);
  }
  function or(P) {
    return R(P);
  }
  function Aa(P, x, T) {
    if (P == null)
      throw new Error(`sign: expected valid message hash, not "${P}"`);
    const B = oe(P), j = Wt(x), q = [or(j), rc(B)];
    if (T != null) {
      T === !0 && (T = e.utils.randomBytes(c));
      const ae = oe(T);
      if (ae.length !== c)
        throw new Error(`sign: Expected ${c} bytes of extra data`);
      q.push(ae);
    }
    const X = G(...q), Q = lo(B);
    return { seed: X, m: Q, d: j };
  }
  function d(P, x) {
    const { sig: T, recovery: B } = P, { der: j, recovered: q } = Object.assign({ canonical: !0, der: !0 }, x), X = j ? T.toDERRawBytes() : T.toCompactRawBytes();
    return q ? [X, B] : X;
  }
  async function g(P, x, T = {}) {
    const { seed: B, m: j, d: q } = Aa(P, x, T.extraEntropy), X = new We(h, f);
    await X.reseed(B);
    let Q;
    for (; !(Q = xr(await X.generate(), j, q, T.canonical)); )
      await X.reseed();
    return d(Q, T);
  }
  e.sign = g;
  function w(P, x, T = {}) {
    const { seed: B, m: j, d: q } = Aa(P, x, T.extraEntropy), X = new We(h, f);
    X.reseedSync(B);
    let Q;
    for (; !(Q = xr(X.generateSync(), j, q, T.canonical)); )
      X.reseedSync();
    return d(Q, T);
  }
  e.signSync = w;
  const $ = { strict: !0 };
  function N(P, x, T, B = $) {
    let j;
    try {
      j = ka(P), x = oe(x);
    } catch {
      return !1;
    }
    const { r: q, s: X } = j;
    if (B.strict && j.hasHighS())
      return !1;
    const Q = be(x);
    let ae;
    try {
      ae = Sn(T);
    } catch {
      return !1;
    }
    const { n: ie } = s, le = ye(X, ie), pe = K(Q * le, ie), we = K(q * le, ie), kt = _.BASE.multiplyAndAddUnsafe(ae, pe, we);
    return kt ? K(kt.x, ie) === q : !1;
  }
  e.verify = N;
  function H(P) {
    return K(ne(P), s.n);
  }
  class Z {
    constructor(x, T) {
      this.r = x, this.s = T, this.assertValidity();
    }
    static fromHex(x) {
      const T = oe(x);
      if (T.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${T.length}`);
      const B = ne(T.subarray(0, 32)), j = ne(T.subarray(32, 64));
      return new Z(B, j);
    }
    assertValidity() {
      const { r: x, s: T } = this;
      if (!Tt(x) || !Re(T))
        throw new Error("Invalid signature");
    }
    toHex() {
      return C(this.r) + C(this.s);
    }
    toRawBytes() {
      return W(this.toHex());
    }
  }
  function Te(P) {
    return _.fromPrivateKey(P).toRawX();
  }
  class ut {
    constructor(x, T, B = e.utils.randomBytes()) {
      if (x == null)
        throw new TypeError(`sign: Expected valid message, not "${x}"`);
      this.m = oe(x);
      const { x: j, scalar: q } = this.getScalar(Wt(T));
      if (this.px = j, this.d = q, this.rand = oe(B), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(x) {
      const T = _.fromPrivateKey(x), B = T.hasEvenY() ? x : s.n - x;
      return { point: T, scalar: B, x: T.toRawX() };
    }
    initNonce(x, T) {
      return R(x ^ ne(T));
    }
    finalizeNonce(x) {
      const T = K(ne(x), s.n);
      if (T === r)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: B, x: j, scalar: q } = this.getScalar(T);
      return { R: B, rx: j, k: q };
    }
    finalizeSig(x, T, B, j) {
      return new Z(x.x, K(T + B * j, s.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: x, d: T, px: B, rand: j } = this, q = e.utils.taggedHash, X = this.initNonce(T, await q(un.aux, j)), { R: Q, rx: ae, k: ie } = this.finalizeNonce(await q(un.nonce, X, B, x)), le = H(await q(un.challenge, ae, B, x)), pe = this.finalizeSig(Q, ie, le, T);
      return await Td(pe, x, B) || this.error(), pe;
    }
    calcSync() {
      const { m: x, d: T, px: B, rand: j } = this, q = e.utils.taggedHashSync, X = this.initNonce(T, q(un.aux, j)), { R: Q, rx: ae, k: ie } = this.finalizeNonce(q(un.nonce, X, B, x)), le = H(q(un.challenge, ae, B, x)), pe = this.finalizeSig(Q, ie, le, T);
      return Pd(pe, x, B) || this.error(), pe;
    }
  }
  async function Be(P, x, T) {
    return new ut(P, x, T).calc();
  }
  function Ie(P, x, T) {
    return new ut(P, x, T).calcSync();
  }
  function Xe(P, x, T) {
    const B = P instanceof Z, j = B ? P : Z.fromHex(P);
    return B && j.assertValidity(), {
      ...j,
      m: oe(x),
      P: Sn(T)
    };
  }
  function Id(P, x, T, B) {
    const j = _.BASE.multiplyAndAddUnsafe(x, Wt(T), K(-B, s.n));
    return !(!j || !j.hasEvenY() || j.x !== P);
  }
  async function Td(P, x, T) {
    try {
      const { r: B, s: j, m: q, P: X } = Xe(P, x, T), Q = H(await e.utils.taggedHash(un.challenge, R(B), X.toRawX(), q));
      return Id(B, X, j, Q);
    } catch {
      return !1;
    }
  }
  function Pd(P, x, T) {
    try {
      const { r: B, s: j, m: q, P: X } = Xe(P, x, T), Q = H(e.utils.taggedHashSync(un.challenge, R(B), X.toRawX(), q));
      return Id(B, X, j, Q);
    } catch (B) {
      if (B instanceof v)
        throw B;
      return !1;
    }
  }
  e.schnorr = {
    Signature: Z,
    getPublicKey: Te,
    sign: Be,
    verify: Td,
    signSync: Ie,
    verifySync: Pd
  }, _.BASE._setWindowSize(8);
  const Kt = {
    node: t,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, un = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, Sa = {};
  e.utils = {
    bytesToHex: V,
    hexToBytes: W,
    concatBytes: G,
    mod: K,
    invert: ye,
    isValidPrivateKey(P) {
      try {
        return Wt(P), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: R,
    _normalizePrivateKey: Wt,
    hashToPrivateKey: (P) => {
      P = oe(P);
      const x = f + 8;
      if (P.length < x || P.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const T = K(ne(P), s.n - n) + n;
      return R(T);
    },
    randomBytes: (P = 32) => {
      if (Kt.web)
        return Kt.web.getRandomValues(new Uint8Array(P));
      if (Kt.node) {
        const { randomBytes: x } = Kt.node;
        return Uint8Array.from(x(P));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => e.utils.hashToPrivateKey(e.utils.randomBytes(f + 8)),
    precompute(P = 8, x = _.BASE) {
      const T = x === _.BASE ? x : new _(x.x, x.y);
      return T._setWindowSize(P), T.multiply(a), T;
    },
    sha256: async (...P) => {
      if (Kt.web) {
        const x = await Kt.web.subtle.digest("SHA-256", G(...P));
        return new Uint8Array(x);
      } else if (Kt.node) {
        const { createHash: x } = Kt.node, T = x("sha256");
        return P.forEach((B) => T.update(B)), Uint8Array.from(T.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (P, ...x) => {
      if (Kt.web) {
        const T = await Kt.web.subtle.importKey("raw", P, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), B = G(...x), j = await Kt.web.subtle.sign("HMAC", T, B);
        return new Uint8Array(j);
      } else if (Kt.node) {
        const { createHmac: T } = Kt.node, B = T("sha256", P);
        return x.forEach((j) => B.update(j)), Uint8Array.from(B.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (P, ...x) => {
      let T = Sa[P];
      if (T === void 0) {
        const B = await e.utils.sha256(Uint8Array.from(P, (j) => j.charCodeAt(0)));
        T = G(B, B), Sa[P] = T;
      }
      return e.utils.sha256(T, ...x);
    },
    taggedHashSync: (P, ...x) => {
      if (typeof st != "function")
        throw new v("sha256Sync is undefined, you need to set it");
      let T = Sa[P];
      if (T === void 0) {
        const B = st(Uint8Array.from(P, (j) => j.charCodeAt(0)));
        T = G(B, B), Sa[P] = T;
      }
      return st(T, ...x);
    },
    _JacobianPoint: E
  }, Object.defineProperties(e.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return st;
      },
      set(P) {
        st || (st = P);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Ze;
      },
      set(P) {
        Ze || (Ze = P);
      }
    }
  });
})($4);
var nb = {}, $o = {};
Object.defineProperty($o, "__esModule", { value: !0 });
$o.isBytes = WC;
$o.number = pm;
$o.bool = ZC;
$o.bytes = C4;
$o.hash = XC;
$o.exists = YC;
$o.output = JC;
function pm(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function ZC(e) {
  if (typeof e != "boolean")
    throw new Error(`boolean expected, not ${e}`);
}
function WC(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function C4(e, ...t) {
  if (!WC(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function XC(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  pm(e.outputLen), pm(e.blockLen);
}
function YC(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function JC(e, t) {
  C4(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const V1e = { number: pm, bool: ZC, bytes: C4, hash: XC, exists: YC, output: JC };
$o.default = V1e;
var Yu = {}, ob = {};
Object.defineProperty(ob, "__esModule", { value: !0 });
ob.crypto = void 0;
ob.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Hash = e.nextTick = e.byteSwapIfBE = e.byteSwap = e.isLE = e.rotl = e.rotr = e.createView = e.u32 = e.u8 = void 0, e.isBytes = n, e.byteSwap32 = c, e.bytesToHex = h, e.hexToBytes = m, e.asyncLoop = v, e.utf8ToBytes = k, e.toBytes = E, e.concatBytes = A, e.checkOpts = I, e.wrapConstructor = O, e.wrapConstructorWithOpts = z, e.wrapXOFConstructorWithOpts = D, e.randomBytes = G;
  const t = ob, r = $o;
  function n(U) {
    return U instanceof Uint8Array || U != null && typeof U == "object" && U.constructor.name === "Uint8Array";
  }
  const o = (U) => new Uint8Array(U.buffer, U.byteOffset, U.byteLength);
  e.u8 = o;
  const a = (U) => new Uint32Array(U.buffer, U.byteOffset, Math.floor(U.byteLength / 4));
  e.u32 = a;
  const i = (U) => new DataView(U.buffer, U.byteOffset, U.byteLength);
  e.createView = i;
  const s = (U, V) => U << 32 - V | U >>> V;
  e.rotr = s;
  const u = (U, V) => U << V | U >>> 32 - V >>> 0;
  e.rotl = u, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  const l = (U) => U << 24 & 4278190080 | U << 8 & 16711680 | U >>> 8 & 65280 | U >>> 24 & 255;
  e.byteSwap = l, e.byteSwapIfBE = e.isLE ? (U) => U : (U) => (0, e.byteSwap)(U);
  function c(U) {
    for (let V = 0; V < U.length; V++)
      U[V] = (0, e.byteSwap)(U[V]);
  }
  const f = /* @__PURE__ */ Array.from({ length: 256 }, (U, V) => V.toString(16).padStart(2, "0"));
  function h(U) {
    (0, r.bytes)(U);
    let V = "";
    for (let F = 0; F < U.length; F++)
      V += f[U[F]];
    return V;
  }
  const p = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function y(U) {
    if (U >= p._0 && U <= p._9)
      return U - p._0;
    if (U >= p._A && U <= p._F)
      return U - (p._A - 10);
    if (U >= p._a && U <= p._f)
      return U - (p._a - 10);
  }
  function m(U) {
    if (typeof U != "string")
      throw new Error("hex string expected, got " + typeof U);
    const V = U.length, F = V / 2;
    if (V % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + V);
    const C = new Uint8Array(F);
    for (let R = 0, M = 0; R < F; R++, M += 2) {
      const re = y(U.charCodeAt(M)), W = y(U.charCodeAt(M + 1));
      if (re === void 0 || W === void 0) {
        const ne = U[M] + U[M + 1];
        throw new Error('hex string expected, got non-hex character "' + ne + '" at index ' + M);
      }
      C[R] = re * 16 + W;
    }
    return C;
  }
  const b = async () => {
  };
  e.nextTick = b;
  async function v(U, V, F) {
    let C = Date.now();
    for (let R = 0; R < U; R++) {
      F(R);
      const M = Date.now() - C;
      M >= 0 && M < V || (await (0, e.nextTick)(), C += M);
    }
  }
  function k(U) {
    if (typeof U != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof U}`);
    return new Uint8Array(new TextEncoder().encode(U));
  }
  function E(U) {
    return typeof U == "string" && (U = k(U)), (0, r.bytes)(U), U;
  }
  function A(...U) {
    let V = 0;
    for (let C = 0; C < U.length; C++) {
      const R = U[C];
      (0, r.bytes)(R), V += R.length;
    }
    const F = new Uint8Array(V);
    for (let C = 0, R = 0; C < U.length; C++) {
      const M = U[C];
      F.set(M, R), R += M.length;
    }
    return F;
  }
  class S {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = S;
  const _ = {}.toString;
  function I(U, V) {
    if (V !== void 0 && _.call(V) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(U, V);
  }
  function O(U) {
    const V = (C) => U().update(E(C)).digest(), F = U();
    return V.outputLen = F.outputLen, V.blockLen = F.blockLen, V.create = () => U(), V;
  }
  function z(U) {
    const V = (C, R) => U(R).update(E(C)).digest(), F = U({});
    return V.outputLen = F.outputLen, V.blockLen = F.blockLen, V.create = (C) => U(C), V;
  }
  function D(U) {
    const V = (C, R) => U(R).update(E(C)).digest(), F = U({});
    return V.outputLen = F.outputLen, V.blockLen = F.blockLen, V.create = (C) => U(C), V;
  }
  function G(U = 32) {
    if (t.crypto && typeof t.crypto.getRandomValues == "function")
      return t.crypto.getRandomValues(new Uint8Array(U));
    if (t.crypto && typeof t.crypto.randomBytes == "function")
      return t.crypto.randomBytes(U);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(Yu);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.hmac = e.HMAC = void 0;
  const t = $o, r = Yu;
  class n extends r.Hash {
    constructor(i, s) {
      super(), this.finished = !1, this.destroyed = !1, (0, t.hash)(i);
      const u = (0, r.toBytes)(s);
      if (this.iHash = i.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const l = this.blockLen, c = new Uint8Array(l);
      c.set(u.length > l ? i.create().update(u).digest() : u);
      for (let f = 0; f < c.length; f++)
        c[f] ^= 54;
      this.iHash.update(c), this.oHash = i.create();
      for (let f = 0; f < c.length; f++)
        c[f] ^= 106;
      this.oHash.update(c), c.fill(0);
    }
    update(i) {
      return (0, t.exists)(this), this.iHash.update(i), this;
    }
    digestInto(i) {
      (0, t.exists)(this), (0, t.bytes)(i, this.outputLen), this.finished = !0, this.iHash.digestInto(i), this.oHash.update(i), this.oHash.digestInto(i), this.destroy();
    }
    digest() {
      const i = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(i), i;
    }
    _cloneInto(i) {
      i || (i = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: s, iHash: u, finished: l, destroyed: c, blockLen: f, outputLen: h } = this;
      return i = i, i.finished = l, i.destroyed = c, i.blockLen = f, i.outputLen = h, i.oHash = s._cloneInto(i.oHash), i.iHash = u._cloneInto(i.iHash), i;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e.HMAC = n;
  const o = (a, i, s) => new n(a, i).update(s).digest();
  e.hmac = o, e.hmac.create = (a, i) => new n(a, i);
})(nb);
var ki = {}, rs = {};
Object.defineProperty(rs, "__esModule", { value: !0 });
rs.HashMD = rs.Maj = rs.Chi = void 0;
const uw = $o, Gd = Yu;
function G1e(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), a = BigInt(4294967295), i = Number(r >> o & a), s = Number(r & a), u = n ? 4 : 0, l = n ? 0 : 4;
  e.setUint32(t + u, i, n), e.setUint32(t + l, s, n);
}
const Z1e = (e, t, r) => e & t ^ ~e & r;
rs.Chi = Z1e;
const W1e = (e, t, r) => e & t ^ e & r ^ t & r;
rs.Maj = W1e;
class X1e extends Gd.Hash {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = (0, Gd.createView)(this.buffer);
  }
  update(t) {
    (0, uw.exists)(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = (0, Gd.toBytes)(t);
    const a = t.length;
    for (let i = 0; i < a; ) {
      const s = Math.min(o - this.pos, a - i);
      if (s === o) {
        const u = (0, Gd.createView)(t);
        for (; o <= a - i; i += o)
          this.process(u, i);
        continue;
      }
      n.set(t.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    (0, uw.exists)(this), (0, uw.output)(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: o, isLE: a } = this;
    let { pos: i } = this;
    r[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > o - i && (this.process(n, 0), i = 0);
    for (let f = i; f < o; f++)
      r[f] = 0;
    G1e(n, o - 8, BigInt(this.length * 8), a), this.process(n, 0);
    const s = (0, Gd.createView)(t), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, c = this.get();
    if (l > c.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < l; f++)
      s.setUint32(4 * f, c[f], a);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: a, destroyed: i, pos: s } = this;
    return t.length = o, t.pos = s, t.finished = a, t.destroyed = i, o % r && t.buffer.set(n), t;
  }
}
rs.HashMD = X1e;
Object.defineProperty(ki, "__esModule", { value: !0 });
ki.sha224 = ki.sha256 = ki.SHA256 = void 0;
const cw = rs, Do = Yu, Y1e = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), cu = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), lu = /* @__PURE__ */ new Uint32Array(64);
class B4 extends cw.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = cu[0] | 0, this.B = cu[1] | 0, this.C = cu[2] | 0, this.D = cu[3] | 0, this.E = cu[4] | 0, this.F = cu[5] | 0, this.G = cu[6] | 0, this.H = cu[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: a, F: i, G: s, H: u } = this;
    return [t, r, n, o, a, i, s, u];
  }
  // prettier-ignore
  set(t, r, n, o, a, i, s, u) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = a | 0, this.F = i | 0, this.G = s | 0, this.H = u | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      lu[f] = t.getUint32(r, !1);
    for (let f = 16; f < 64; f++) {
      const h = lu[f - 15], p = lu[f - 2], y = (0, Do.rotr)(h, 7) ^ (0, Do.rotr)(h, 18) ^ h >>> 3, m = (0, Do.rotr)(p, 17) ^ (0, Do.rotr)(p, 19) ^ p >>> 10;
      lu[f] = m + lu[f - 7] + y + lu[f - 16] | 0;
    }
    let { A: n, B: o, C: a, D: i, E: s, F: u, G: l, H: c } = this;
    for (let f = 0; f < 64; f++) {
      const h = (0, Do.rotr)(s, 6) ^ (0, Do.rotr)(s, 11) ^ (0, Do.rotr)(s, 25), p = c + h + (0, cw.Chi)(s, u, l) + Y1e[f] + lu[f] | 0, y = ((0, Do.rotr)(n, 2) ^ (0, Do.rotr)(n, 13) ^ (0, Do.rotr)(n, 22)) + (0, cw.Maj)(n, o, a) | 0;
      c = l, l = u, u = s, s = i + p | 0, i = a, a = o, o = n, n = p + y | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, a = a + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, c = c + this.H | 0, this.set(n, o, a, i, s, u, l, c);
  }
  roundClean() {
    lu.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
ki.SHA256 = B4;
class J1e extends B4 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
ki.sha256 = (0, Do.wrapConstructor)(() => new B4());
ki.sha224 = (0, Do.wrapConstructor)(() => new J1e());
var Q1e = $4, ege = nb, QC = ki;
function tge(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(r) {
    if (r !== "default") {
      var n = Object.getOwnPropertyDescriptor(e, r);
      Object.defineProperty(t, r, n.get ? n : {
        enumerable: !0,
        get: function() {
          return e[r];
        }
      });
    }
  }), t.default = e, Object.freeze(t);
}
var Ct = /* @__PURE__ */ tge(Q1e);
const Ju = "Expected Private", Qu = "Expected Point", t0 = "Expected Tweak", rge = "Expected Hash", gm = "Expected Signature", N4 = "Expected Extra Data (32 bytes)", r0 = "Expected Scalar", nge = "Bad Recovery Id";
Ct.utils.hmacSha256Sync = (e, ...t) => ege.hmac(QC.sha256, e, Ct.utils.concatBytes(...t));
Ct.utils.sha256Sync = (...e) => QC.sha256(Ct.utils.concatBytes(...e));
const U4 = Ct.utils._normalizePrivateKey, oge = 32, ige = 32, m8 = new Uint8Array([
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  186,
  174,
  220,
  230,
  175,
  72,
  160,
  59,
  191,
  210,
  94,
  140,
  208,
  54,
  65,
  65
]), age = 32, sge = new Uint8Array(32), uge = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  69,
  81,
  35,
  25,
  80,
  183,
  95,
  196,
  64,
  45,
  161,
  114,
  47,
  201,
  186,
  238
]);
function cge(e) {
  return e instanceof Uint8Array;
}
function sp(e, t) {
  for (let r = 0; r < 32; ++r)
    if (e[r] !== t[r])
      return e[r] < t[r] ? -1 : 1;
  return 0;
}
function j9(e) {
  return sp(e, sge) === 0;
}
function n0(e) {
  return !(!(e instanceof Uint8Array) || e.length !== ige || sp(e, m8) >= 0);
}
function R4(e) {
  return e instanceof Uint8Array && e.length === 64 && sp(e.subarray(0, 32), m8) < 0 && sp(e.subarray(32, 64), m8) < 0;
}
function lge(e) {
  return cge(e) && e.length === 64 && sp(e.subarray(0, 32), uge) < 0;
}
function fge(e) {
  return !(j9(e.subarray(0, 32)) || j9(e.subarray(32, 64)));
}
function md(e) {
  return e instanceof Uint8Array && e.length === oge;
}
function z4(e) {
  return e === void 0 || e instanceof Uint8Array && e.length === age;
}
function eB(e) {
  if (typeof e != "string")
    throw new TypeError("hexToNumber: expected string, got " + typeof e);
  return BigInt(`0x${e}`);
}
function dge(e) {
  return eB(Ct.utils.bytesToHex(e));
}
function j4(e) {
  let t;
  if (typeof e == "bigint")
    t = e;
  else if (typeof e == "number" && Number.isSafeInteger(e) && e >= 0)
    t = BigInt(e);
  else if (typeof e == "string") {
    if (e.length !== 64)
      throw new Error("Expected 32 bytes of private scalar");
    t = eB(e);
  } else if (e instanceof Uint8Array) {
    if (e.length !== 32)
      throw new Error("Expected 32 bytes of private scalar");
    t = dge(e);
  } else
    throw new TypeError("Expected valid private scalar");
  if (t < 0) throw new Error("Expected private scalar >= 0");
  return t;
}
const hge = (e, t) => {
  const r = U4(e), n = j4(t), o = Ct.utils._bigintTo32Bytes(Ct.utils.mod(r + n, Ct.CURVE.n));
  return Ct.utils.isValidPrivateKey(o) ? o : null;
}, pge = (e, t) => {
  const r = U4(e), n = j4(t), o = Ct.utils._bigintTo32Bytes(Ct.utils.mod(r - n, Ct.CURVE.n));
  return Ct.utils.isValidPrivateKey(o) ? o : null;
}, gge = (e) => {
  const t = U4(e), r = Ct.utils._bigintTo32Bytes(Ct.CURVE.n - t);
  return Ct.utils.isValidPrivateKey(r) ? r : null;
}, tB = (e, t, r) => {
  const n = Ct.Point.fromHex(e), o = j4(t), a = Ct.Point.BASE.multiplyAndAddUnsafe(n, o, BigInt(1));
  if (!a) throw new Error("Tweaked point at infinity");
  return a.toRawBytes(r);
}, mge = (e, t, r) => {
  const n = Ct.Point.fromHex(e), o = typeof t == "string" ? t : Ct.utils.bytesToHex(t), a = BigInt(`0x${o}`);
  return n.multiply(a).toRawBytes(r);
};
function yd(e, t) {
  return e === void 0 ? t !== void 0 ? rB(t) : !0 : !!e;
}
function kl(e) {
  try {
    return e();
  } catch {
    return null;
  }
}
function L4(e, t) {
  if (e.length === 32 !== t) return !1;
  try {
    return !!Ct.Point.fromHex(e);
  } catch {
    return !1;
  }
}
function qu(e) {
  return L4(e, !1);
}
function rB(e) {
  return L4(e, !1) && e.length === 33;
}
function ws(e) {
  return Ct.utils.isValidPrivateKey(e);
}
function ib(e) {
  return L4(e, !0);
}
function yge(e, t) {
  if (!ib(e))
    throw new Error(Qu);
  if (!n0(t))
    throw new Error(t0);
  return kl(() => {
    const r = tB(e, t, !0);
    return { parity: r[0] % 2 === 1 ? 1 : 0, xOnlyPubkey: r.slice(1) };
  });
}
function nB(e) {
  if (!qu(e))
    throw new Error(Qu);
  return e.slice(1, 33);
}
function oB(e, t) {
  if (!ws(e))
    throw new Error(Ju);
  return kl(
    () => Ct.getPublicKey(e, yd(t))
  );
}
function bge(e) {
  if (!ws(e))
    throw new Error(Ju);
  return nB(oB(e));
}
function wge(e, t) {
  if (!qu(e))
    throw new Error(Qu);
  return Ct.Point.fromHex(e).toRawBytes(yd(t, e));
}
function vge(e, t, r) {
  if (!qu(e))
    throw new Error(Qu);
  if (!n0(t))
    throw new Error(t0);
  return kl(
    () => mge(e, t, yd(r, e))
  );
}
function Ege(e, t, r) {
  if (!qu(e) || !qu(t))
    throw new Error(Qu);
  return kl(() => {
    const n = Ct.Point.fromHex(e), o = Ct.Point.fromHex(t);
    return n.equals(o.negate()) ? null : n.add(o).toRawBytes(yd(r, e));
  });
}
function kge(e, t, r) {
  if (!qu(e))
    throw new Error(Qu);
  if (!n0(t))
    throw new Error(t0);
  return kl(
    () => tB(e, t, yd(r, e))
  );
}
function xge(e, t) {
  if (ws(e) === !1)
    throw new Error(Ju);
  if (n0(t) === !1)
    throw new Error(t0);
  return kl(() => hge(e, t));
}
function Age(e, t) {
  if (ws(e) === !1)
    throw new Error(Ju);
  if (n0(t) === !1)
    throw new Error(t0);
  return kl(() => pge(e, t));
}
function Sge(e) {
  if (ws(e) === !1)
    throw new Error(Ju);
  return gge(e);
}
function _ge(e, t, r) {
  if (!ws(t))
    throw new Error(Ju);
  if (!md(e))
    throw new Error(r0);
  if (!z4(r))
    throw new Error(N4);
  return Ct.signSync(e, t, { der: !1, extraEntropy: r });
}
function Ige(e, t, r) {
  if (!ws(t))
    throw new Error(Ju);
  if (!md(e))
    throw new Error(r0);
  if (!z4(r))
    throw new Error(N4);
  const [n, o] = Ct.signSync(e, t, { der: !1, extraEntropy: r, recovered: !0 });
  return { signature: n, recoveryId: o };
}
function Tge(e, t, r = Buffer.alloc(32, 0)) {
  if (!ws(t))
    throw new Error(Ju);
  if (!md(e))
    throw new Error(r0);
  if (!z4(r))
    throw new Error(N4);
  return Ct.schnorr.signSync(e, t, r);
}
function Pge(e, t, r, n) {
  if (!md(e))
    throw new Error(rge);
  if (!R4(t) || !fge(t))
    throw new Error(gm);
  if (r & 2 && !lge(t))
    throw new Error(nge);
  if (!ib(t.subarray(0, 32)))
    throw new Error(gm);
  return Ct.recoverPublicKey(e, t, r, yd(n));
}
function Oge(e, t, r, n) {
  if (!qu(t))
    throw new Error(Qu);
  if (!R4(r))
    throw new Error(gm);
  if (!md(e))
    throw new Error(r0);
  return Ct.verify(r, e, t, { strict: n });
}
function $ge(e, t, r) {
  if (!ib(t))
    throw new Error(Qu);
  if (!R4(r))
    throw new Error(gm);
  if (!md(e))
    throw new Error(r0);
  return Ct.schnorr.verifySync(r, e, t);
}
var Cge = br.isPoint = qu, Bge = br.isPointCompressed = rB, Nge = br.isPrivate = ws, Uge = br.isXOnlyPoint = ib, Rge = br.pointAdd = Ege, zge = br.pointAddScalar = kge, jge = br.pointCompress = wge, Lge = br.pointFromScalar = oB, Hge = br.pointMultiply = vge, Fge = br.privateAdd = xge, Dge = br.privateNegate = Sge, Mge = br.privateSub = Age, Kge = br.recover = Pge, qge = br.sign = _ge, Vge = br.signRecoverable = Ige, Gge = br.signSchnorr = Tge, Zge = br.verify = Oge, Wge = br.verifySchnorr = $ge, Xge = br.xOnlyPointAddTweak = yge, Yge = br.xOnlyPointFromPoint = nB, Jge = br.xOnlyPointFromScalar = bge;
const ab = /* @__PURE__ */ $re({
  __proto__: null,
  default: br,
  isPoint: Cge,
  isPointCompressed: Bge,
  isPrivate: Nge,
  isXOnlyPoint: Uge,
  pointAdd: Rge,
  pointAddScalar: zge,
  pointCompress: jge,
  pointFromScalar: Lge,
  pointMultiply: Hge,
  privateAdd: Fge,
  privateNegate: Dge,
  privateSub: Mge,
  recover: Kge,
  sign: qge,
  signRecoverable: Vge,
  signSchnorr: Gge,
  verify: Zge,
  verifySchnorr: Wge,
  xOnlyPointAddTweak: Xge,
  xOnlyPointFromPoint: Yge,
  xOnlyPointFromScalar: Jge
}, [br]), y8 = "BITCOIN_MAINNET", iB = "BITCOIN_TESTNET", aB = "BITCOIN_TESTNET4", sB = "BITCOIN_SIGNET", uB = "FRACTAL_BITCOIN_MAINNET", cB = "FRACTAL_BITCOIN_TESTNET", L9 = "Mainnet", Qge = "Testnet", eme = "Signet", tme = "livenet", rme = "testnet", lB = "livenet", nme = "testnet", ome = "testnet4", ime = "signet", H9 = "Mainnet", ame = "Testnet", F9 = "main", sme = "testnet", ume = "signet", Ut = "mainnet", En = "signet", Cr = "testnet", hn = "testnet4", xl = "fractal mainnet", Xn = "fractal testnet", B1 = (e) => e === Ut ? L9 : e === Cr || e === hn ? Qge : e === En ? eme : L9, fB = (e) => e === Ut ? y8 : e === Cr ? iB : e === hn ? aB : e === En ? sB : e === xl ? uB : e === Xn ? cB : y8, lw = (e) => e === Ut ? H9 : e === Cr || e === hn || e === En ? ame : H9, cme = (e) => e === Ut ? F9 : e === hn || e === Cr ? sme : e === En ? ume : F9, mm = (e) => e === y8 ? Ut : e === iB ? Cr : e === aB ? hn : e === sB ? En : e === uB ? xl : e === cB ? Xn : Ut, lme = (e) => e === tme ? Ut : e === rme ? Cr : Ut, D9 = (e) => e === lB ? Ut : e === nme ? Cr : e === ome ? hn : e === ime ? En : e === Xn ? Cr : Ut;
function dB(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: fme } = Object.prototype, { getPrototypeOf: H4 } = Object, sb = /* @__PURE__ */ ((e) => (t) => {
  const r = fme.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Ri = (e) => (e = e.toLowerCase(), (t) => sb(t) === e), ub = (e) => (t) => typeof t === e, { isArray: bd } = Array, up = ub("undefined");
function dme(e) {
  return e !== null && !up(e) && e.constructor !== null && !up(e.constructor) && Ao(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const hB = Ri("ArrayBuffer");
function hme(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && hB(e.buffer), t;
}
const pme = ub("string"), Ao = ub("function"), pB = ub("number"), cb = (e) => e !== null && typeof e == "object", gme = (e) => e === !0 || e === !1, N1 = (e) => {
  if (sb(e) !== "object")
    return !1;
  const t = H4(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, mme = Ri("Date"), yme = Ri("File"), bme = Ri("Blob"), wme = Ri("FileList"), vme = (e) => cb(e) && Ao(e.pipe), Eme = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Ao(e.append) && ((t = sb(e)) === "formdata" || // detect form-data instance
  t === "object" && Ao(e.toString) && e.toString() === "[object FormData]"));
}, kme = Ri("URLSearchParams"), [xme, Ame, Sme, _me] = ["ReadableStream", "Request", "Response", "Headers"].map(Ri), Ime = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function o0(e, t, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, o;
  if (typeof e != "object" && (e = [e]), bd(e))
    for (n = 0, o = e.length; n < o; n++)
      t.call(null, e[n], n, e);
  else {
    const a = r ? Object.getOwnPropertyNames(e) : Object.keys(e), i = a.length;
    let s;
    for (n = 0; n < i; n++)
      s = a[n], t.call(null, e[s], s, e);
  }
}
function gB(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, o;
  for (; n-- > 0; )
    if (o = r[n], t === o.toLowerCase())
      return o;
  return null;
}
const Tc = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, mB = (e) => !up(e) && e !== Tc;
function b8() {
  const { caseless: e } = mB(this) && this || {}, t = {}, r = (n, o) => {
    const a = e && gB(t, o) || o;
    N1(t[a]) && N1(n) ? t[a] = b8(t[a], n) : N1(n) ? t[a] = b8({}, n) : bd(n) ? t[a] = n.slice() : t[a] = n;
  };
  for (let n = 0, o = arguments.length; n < o; n++)
    arguments[n] && o0(arguments[n], r);
  return t;
}
const Tme = (e, t, r, { allOwnKeys: n } = {}) => (o0(t, (o, a) => {
  r && Ao(o) ? e[a] = dB(o, r) : e[a] = o;
}, { allOwnKeys: n }), e), Pme = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Ome = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
}, $me = (e, t, r, n) => {
  let o, a, i;
  const s = {};
  if (t = t || {}, e == null) return t;
  do {
    for (o = Object.getOwnPropertyNames(e), a = o.length; a-- > 0; )
      i = o[a], (!n || n(i, e, t)) && !s[i] && (t[i] = e[i], s[i] = !0);
    e = r !== !1 && H4(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
}, Cme = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
}, Bme = (e) => {
  if (!e) return null;
  if (bd(e)) return e;
  let t = e.length;
  if (!pB(t)) return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
}, Nme = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && H4(Uint8Array)), Ume = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let n;
  for (; (n = r.next()) && !n.done; ) {
    const o = n.value;
    t.call(e, o[0], o[1]);
  }
}, Rme = (e, t) => {
  let r;
  const n = [];
  for (; (r = e.exec(t)) !== null; )
    n.push(r);
  return n;
}, zme = Ri("HTMLFormElement"), jme = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, r, n) {
    return r.toUpperCase() + n;
  }
), M9 = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), Lme = Ri("RegExp"), yB = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  o0(r, (o, a) => {
    let i;
    (i = t(o, a, e)) !== !1 && (n[a] = i || o);
  }), Object.defineProperties(e, n);
}, Hme = (e) => {
  yB(e, (t, r) => {
    if (Ao(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = e[r];
    if (Ao(n)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, Fme = (e, t) => {
  const r = {}, n = (o) => {
    o.forEach((a) => {
      r[a] = !0;
    });
  };
  return bd(e) ? n(e) : n(String(e).split(t)), r;
}, Dme = () => {
}, Mme = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, fw = "abcdefghijklmnopqrstuvwxyz", K9 = "0123456789", bB = {
  DIGIT: K9,
  ALPHA: fw,
  ALPHA_DIGIT: fw + fw.toUpperCase() + K9
}, Kme = (e = 16, t = bB.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = t;
  for (; e--; )
    r += t[Math.random() * n | 0];
  return r;
};
function qme(e) {
  return !!(e && Ao(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const Vme = (e) => {
  const t = new Array(10), r = (n, o) => {
    if (cb(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        t[o] = n;
        const a = bd(n) ? [] : {};
        return o0(n, (i, s) => {
          const u = r(i, o + 1);
          !up(u) && (a[s] = u);
        }), t[o] = void 0, a;
      }
    }
    return n;
  };
  return r(e, 0);
}, Gme = Ri("AsyncFunction"), Zme = (e) => e && (cb(e) || Ao(e)) && Ao(e.then) && Ao(e.catch), wB = ((e, t) => e ? setImmediate : t ? ((r, n) => (Tc.addEventListener("message", ({ source: o, data: a }) => {
  o === Tc && a === r && n.length && n.shift()();
}, !1), (o) => {
  n.push(o), Tc.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  Ao(Tc.postMessage)
), Wme = typeof queueMicrotask < "u" ? queueMicrotask.bind(Tc) : typeof process < "u" && process.nextTick || wB, te = {
  isArray: bd,
  isArrayBuffer: hB,
  isBuffer: dme,
  isFormData: Eme,
  isArrayBufferView: hme,
  isString: pme,
  isNumber: pB,
  isBoolean: gme,
  isObject: cb,
  isPlainObject: N1,
  isReadableStream: xme,
  isRequest: Ame,
  isResponse: Sme,
  isHeaders: _me,
  isUndefined: up,
  isDate: mme,
  isFile: yme,
  isBlob: bme,
  isRegExp: Lme,
  isFunction: Ao,
  isStream: vme,
  isURLSearchParams: kme,
  isTypedArray: Nme,
  isFileList: wme,
  forEach: o0,
  merge: b8,
  extend: Tme,
  trim: Ime,
  stripBOM: Pme,
  inherits: Ome,
  toFlatObject: $me,
  kindOf: sb,
  kindOfTest: Ri,
  endsWith: Cme,
  toArray: Bme,
  forEachEntry: Ume,
  matchAll: Rme,
  isHTMLForm: zme,
  hasOwnProperty: M9,
  hasOwnProp: M9,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: yB,
  freezeMethods: Hme,
  toObjectSet: Fme,
  toCamelCase: jme,
  noop: Dme,
  toFiniteNumber: Mme,
  findKey: gB,
  global: Tc,
  isContextDefined: mB,
  ALPHABET: bB,
  generateString: Kme,
  isSpecCompliantForm: qme,
  toJSONObject: Vme,
  isAsyncFn: Gme,
  isThenable: Zme,
  setImmediate: wB,
  asap: Wme
};
function at(e, t, r, n, o) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), o && (this.response = o, this.status = o.status ? o.status : null);
}
te.inherits(at, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: te.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const vB = at.prototype, EB = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  EB[e] = { value: e };
});
Object.defineProperties(at, EB);
Object.defineProperty(vB, "isAxiosError", { value: !0 });
at.from = (e, t, r, n, o, a) => {
  const i = Object.create(vB);
  return te.toFlatObject(e, i, function(s) {
    return s !== Error.prototype;
  }, (s) => s !== "isAxiosError"), at.call(i, e.message, t, r, n, o), i.cause = e, i.name = e.name, a && Object.assign(i, a), i;
};
const Xme = null;
function w8(e) {
  return te.isPlainObject(e) || te.isArray(e);
}
function kB(e) {
  return te.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function q9(e, t, r) {
  return e ? e.concat(t).map(function(n, o) {
    return n = kB(n), !r && o ? "[" + n + "]" : n;
  }).join(r ? "." : "") : t;
}
function Yme(e) {
  return te.isArray(e) && !e.some(w8);
}
const Jme = te.toFlatObject(te, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function lb(e, t, r) {
  if (!te.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), r = te.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(p, y) {
    return !te.isUndefined(y[p]);
  });
  const n = r.metaTokens, o = r.visitor || l, a = r.dots, i = r.indexes, s = (r.Blob || typeof Blob < "u" && Blob) && te.isSpecCompliantForm(t);
  if (!te.isFunction(o))
    throw new TypeError("visitor must be a function");
  function u(p) {
    if (p === null) return "";
    if (te.isDate(p))
      return p.toISOString();
    if (!s && te.isBlob(p))
      throw new at("Blob is not supported. Use a Buffer instead.");
    return te.isArrayBuffer(p) || te.isTypedArray(p) ? s && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p;
  }
  function l(p, y, m) {
    let b = p;
    if (p && !m && typeof p == "object") {
      if (te.endsWith(y, "{}"))
        y = n ? y : y.slice(0, -2), p = JSON.stringify(p);
      else if (te.isArray(p) && Yme(p) || (te.isFileList(p) || te.endsWith(y, "[]")) && (b = te.toArray(p)))
        return y = kB(y), b.forEach(function(v, k) {
          !(te.isUndefined(v) || v === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            i === !0 ? q9([y], k, a) : i === null ? y : y + "[]",
            u(v)
          );
        }), !1;
    }
    return w8(p) ? !0 : (t.append(q9(m, y, a), u(p)), !1);
  }
  const c = [], f = Object.assign(Jme, {
    defaultVisitor: l,
    convertValue: u,
    isVisitable: w8
  });
  function h(p, y) {
    if (!te.isUndefined(p)) {
      if (c.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      c.push(p), te.forEach(p, function(m, b) {
        (!(te.isUndefined(m) || m === null) && o.call(
          t,
          m,
          te.isString(b) ? b.trim() : b,
          y,
          f
        )) === !0 && h(m, y ? y.concat(b) : [b]);
      }), c.pop();
    }
  }
  if (!te.isObject(e))
    throw new TypeError("data must be an object");
  return h(e), t;
}
function V9(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function F4(e, t) {
  this._pairs = [], e && lb(e, this, t);
}
const xB = F4.prototype;
xB.append = function(e, t) {
  this._pairs.push([e, t]);
};
xB.toString = function(e) {
  const t = e ? function(r) {
    return e.call(this, r, V9);
  } : V9;
  return this._pairs.map(function(r) {
    return t(r[0]) + "=" + t(r[1]);
  }, "").join("&");
};
function Qme(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function AB(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || Qme, o = r && r.serialize;
  let a;
  if (o ? a = o(t, r) : a = te.isURLSearchParams(t) ? t.toString() : new F4(t, r).toString(n), a) {
    const i = e.indexOf("#");
    i !== -1 && (e = e.slice(0, i)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return e;
}
class G9 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, n) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    te.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const SB = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, eye = typeof URLSearchParams < "u" ? URLSearchParams : F4, tye = typeof FormData < "u" ? FormData : null, rye = typeof Blob < "u" ? Blob : null, nye = {
  isBrowser: !0,
  classes: {
    URLSearchParams: eye,
    FormData: tye,
    Blob: rye
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, D4 = typeof window < "u" && typeof document < "u", v8 = typeof navigator == "object" && navigator || void 0, oye = D4 && (!v8 || ["ReactNative", "NativeScript", "NS"].indexOf(v8.product) < 0), iye = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", aye = D4 && window.location.href || "http://localhost", sye = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: D4,
  hasStandardBrowserEnv: oye,
  hasStandardBrowserWebWorkerEnv: iye,
  navigator: v8,
  origin: aye
}, Symbol.toStringTag, { value: "Module" })), no = {
  ...sye,
  ...nye
};
function uye(e, t) {
  return lb(e, new no.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, o, a) {
      return no.isNode && te.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function cye(e) {
  return te.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function lye(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const o = r.length;
  let a;
  for (n = 0; n < o; n++)
    a = r[n], t[a] = e[a];
  return t;
}
function _B(e) {
  function t(r, n, o, a) {
    let i = r[a++];
    if (i === "__proto__") return !0;
    const s = Number.isFinite(+i), u = a >= r.length;
    return i = !i && te.isArray(o) ? o.length : i, u ? (te.hasOwnProp(o, i) ? o[i] = [o[i], n] : o[i] = n, !s) : ((!o[i] || !te.isObject(o[i])) && (o[i] = []), t(r, n, o[i], a) && te.isArray(o[i]) && (o[i] = lye(o[i])), !s);
  }
  if (te.isFormData(e) && te.isFunction(e.entries)) {
    const r = {};
    return te.forEachEntry(e, (n, o) => {
      t(cye(n), o, r, 0);
    }), r;
  }
  return null;
}
function fye(e, t, r) {
  if (te.isString(e))
    try {
      return (t || JSON.parse)(e), te.trim(e);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (0, JSON.stringify)(e);
}
const i0 = {
  transitional: SB,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const r = t.getContentType() || "", n = r.indexOf("application/json") > -1, o = te.isObject(e);
    if (o && te.isHTMLForm(e) && (e = new FormData(e)), te.isFormData(e))
      return n ? JSON.stringify(_B(e)) : e;
    if (te.isArrayBuffer(e) || te.isBuffer(e) || te.isStream(e) || te.isFile(e) || te.isBlob(e) || te.isReadableStream(e))
      return e;
    if (te.isArrayBufferView(e))
      return e.buffer;
    if (te.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (o) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return uye(e, this.formSerializer).toString();
      if ((a = te.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const i = this.env && this.env.FormData;
        return lb(
          a ? { "files[]": e } : e,
          i && new i(),
          this.formSerializer
        );
      }
    }
    return o || n ? (t.setContentType("application/json", !1), fye(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || i0.transitional, r = t && t.forcedJSONParsing, n = this.responseType === "json";
    if (te.isResponse(e) || te.isReadableStream(e))
      return e;
    if (e && te.isString(e) && (r && !this.responseType || n)) {
      const o = !(t && t.silentJSONParsing) && n;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? at.from(a, at.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: no.classes.FormData,
    Blob: no.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
te.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  i0.headers[e] = {};
});
const dye = te.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), hye = (e) => {
  const t = {};
  let r, n, o;
  return e && e.split(`
`).forEach(function(a) {
    o = a.indexOf(":"), r = a.substring(0, o).trim().toLowerCase(), n = a.substring(o + 1).trim(), !(!r || t[r] && dye[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
}, Z9 = Symbol("internals");
function Zd(e) {
  return e && String(e).trim().toLowerCase();
}
function U1(e) {
  return e === !1 || e == null ? e : te.isArray(e) ? e.map(U1) : String(e);
}
function pye(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(e); )
    t[n[1]] = n[2];
  return t;
}
const gye = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function dw(e, t, r, n, o) {
  if (te.isFunction(n))
    return n.call(this, t, r);
  if (o && (t = r), !!te.isString(t)) {
    if (te.isString(n))
      return t.indexOf(n) !== -1;
    if (te.isRegExp(n))
      return n.test(t);
  }
}
function mye(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function yye(e, t) {
  const r = te.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(o, a, i) {
        return this[n].call(this, t, o, a, i);
      },
      configurable: !0
    });
  });
}
class oo {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, n) {
    const o = this;
    function a(s, u, l) {
      const c = Zd(u);
      if (!c)
        throw new Error("header name must be a non-empty string");
      const f = te.findKey(o, c);
      (!f || o[f] === void 0 || l === !0 || l === void 0 && o[f] !== !1) && (o[f || u] = U1(s));
    }
    const i = (s, u) => te.forEach(s, (l, c) => a(l, c, u));
    if (te.isPlainObject(t) || t instanceof this.constructor)
      i(t, r);
    else if (te.isString(t) && (t = t.trim()) && !gye(t))
      i(hye(t), r);
    else if (te.isHeaders(t))
      for (const [s, u] of t.entries())
        a(u, s, n);
    else
      t != null && a(r, t, n);
    return this;
  }
  get(t, r) {
    if (t = Zd(t), t) {
      const n = te.findKey(this, t);
      if (n) {
        const o = this[n];
        if (!r)
          return o;
        if (r === !0)
          return pye(o);
        if (te.isFunction(r))
          return r.call(this, o, n);
        if (te.isRegExp(r))
          return r.exec(o);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = Zd(t), t) {
      const n = te.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || dw(this, this[n], n, r)));
    }
    return !1;
  }
  delete(t, r) {
    const n = this;
    let o = !1;
    function a(i) {
      if (i = Zd(i), i) {
        const s = te.findKey(n, i);
        s && (!r || dw(n, n[s], s, r)) && (delete n[s], o = !0);
      }
    }
    return te.isArray(t) ? t.forEach(a) : a(t), o;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, o = !1;
    for (; n--; ) {
      const a = r[n];
      (!t || dw(this, this[a], a, t, !0)) && (delete this[a], o = !0);
    }
    return o;
  }
  normalize(t) {
    const r = this, n = {};
    return te.forEach(this, (o, a) => {
      const i = te.findKey(n, a);
      if (i) {
        r[i] = U1(o), delete r[a];
        return;
      }
      const s = t ? mye(a) : String(a).trim();
      s !== a && delete r[a], r[s] = U1(o), n[s] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return te.forEach(this, (n, o) => {
      n != null && n !== !1 && (r[o] = t && te.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const n = new this(t);
    return r.forEach((o) => n.set(o)), n;
  }
  static accessor(t) {
    const r = (this[Z9] = this[Z9] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function o(a) {
      const i = Zd(a);
      r[i] || (yye(n, a), r[i] = !0);
    }
    return te.isArray(t) ? t.forEach(o) : o(t), this;
  }
}
oo.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
te.reduceDescriptors(oo.prototype, ({ value: e }, t) => {
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(n) {
      this[r] = n;
    }
  };
});
te.freezeMethods(oo);
function hw(e, t) {
  const r = this || i0, n = t || r, o = oo.from(n.headers);
  let a = n.data;
  return te.forEach(e, function(i) {
    a = i.call(r, a, o.normalize(), t ? t.status : void 0);
  }), o.normalize(), a;
}
function IB(e) {
  return !!(e && e.__CANCEL__);
}
function wd(e, t, r) {
  at.call(this, e ?? "canceled", at.ERR_CANCELED, t, r), this.name = "CanceledError";
}
te.inherits(wd, at, {
  __CANCEL__: !0
});
function TB(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new at(
    "Request failed with status code " + r.status,
    [at.ERR_BAD_REQUEST, at.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function bye(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function wye(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let o = 0, a = 0, i;
  return t = t !== void 0 ? t : 1e3, function(s) {
    const u = Date.now(), l = n[a];
    i || (i = u), r[o] = s, n[o] = u;
    let c = a, f = 0;
    for (; c !== o; )
      f += r[c++], c = c % e;
    if (o = (o + 1) % e, o === a && (a = (a + 1) % e), u - i < t)
      return;
    const h = l && u - l;
    return h ? Math.round(f * 1e3 / h) : void 0;
  };
}
function vye(e, t) {
  let r = 0, n = 1e3 / t, o, a;
  const i = (s, u = Date.now()) => {
    r = u, o = null, a && (clearTimeout(a), a = null), e.apply(null, s);
  };
  return [(...s) => {
    const u = Date.now(), l = u - r;
    l >= n ? i(s, u) : (o = s, a || (a = setTimeout(() => {
      a = null, i(o);
    }, n - l)));
  }, () => o && i(o)];
}
const ym = (e, t, r = 3) => {
  let n = 0;
  const o = wye(50, 250);
  return vye((a) => {
    const i = a.loaded, s = a.lengthComputable ? a.total : void 0, u = i - n, l = o(u), c = i <= s;
    n = i;
    const f = {
      loaded: i,
      total: s,
      progress: s ? i / s : void 0,
      bytes: u,
      rate: l || void 0,
      estimated: l && s && c ? (s - i) / l : void 0,
      event: a,
      lengthComputable: s != null,
      [t ? "download" : "upload"]: !0
    };
    e(f);
  }, r);
}, W9 = (e, t) => {
  const r = e != null;
  return [(n) => t[0]({
    lengthComputable: r,
    total: e,
    loaded: n
  }), t[1]];
}, X9 = (e) => (...t) => te.asap(() => e(...t)), Eye = no.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const e = no.navigator && /(msie|trident)/i.test(no.navigator.userAgent), t = document.createElement("a");
    let r;
    function n(o) {
      let a = o;
      return e && (t.setAttribute("href", a), a = t.href), t.setAttribute("href", a), {
        href: t.href,
        protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
        host: t.host,
        search: t.search ? t.search.replace(/^\?/, "") : "",
        hash: t.hash ? t.hash.replace(/^#/, "") : "",
        hostname: t.hostname,
        port: t.port,
        pathname: t.pathname.charAt(0) === "/" ? t.pathname : "/" + t.pathname
      };
    }
    return r = n(window.location.href), function(o) {
      const a = te.isString(o) ? n(o) : o;
      return a.protocol === r.protocol && a.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
), kye = no.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, n, o, a) {
      const i = [e + "=" + encodeURIComponent(t)];
      te.isNumber(r) && i.push("expires=" + new Date(r).toGMTString()), te.isString(n) && i.push("path=" + n), te.isString(o) && i.push("domain=" + o), a === !0 && i.push("secure"), document.cookie = i.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function xye(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function Aye(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function PB(e, t) {
  return e && !xye(t) ? Aye(e, t) : t;
}
const Y9 = (e) => e instanceof oo ? { ...e } : e;
function tl(e, t) {
  t = t || {};
  const r = {};
  function n(l, c, f) {
    return te.isPlainObject(l) && te.isPlainObject(c) ? te.merge.call({ caseless: f }, l, c) : te.isPlainObject(c) ? te.merge({}, c) : te.isArray(c) ? c.slice() : c;
  }
  function o(l, c, f) {
    if (te.isUndefined(c)) {
      if (!te.isUndefined(l))
        return n(void 0, l, f);
    } else return n(l, c, f);
  }
  function a(l, c) {
    if (!te.isUndefined(c))
      return n(void 0, c);
  }
  function i(l, c) {
    if (te.isUndefined(c)) {
      if (!te.isUndefined(l))
        return n(void 0, l);
    } else return n(void 0, c);
  }
  function s(l, c, f) {
    if (f in t)
      return n(l, c);
    if (f in e)
      return n(void 0, l);
  }
  const u = {
    url: a,
    method: a,
    data: a,
    baseURL: i,
    transformRequest: i,
    transformResponse: i,
    paramsSerializer: i,
    timeout: i,
    timeoutMessage: i,
    withCredentials: i,
    withXSRFToken: i,
    adapter: i,
    responseType: i,
    xsrfCookieName: i,
    xsrfHeaderName: i,
    onUploadProgress: i,
    onDownloadProgress: i,
    decompress: i,
    maxContentLength: i,
    maxBodyLength: i,
    beforeRedirect: i,
    transport: i,
    httpAgent: i,
    httpsAgent: i,
    cancelToken: i,
    socketPath: i,
    responseEncoding: i,
    validateStatus: s,
    headers: (l, c) => o(Y9(l), Y9(c), !0)
  };
  return te.forEach(Object.keys(Object.assign({}, e, t)), function(l) {
    const c = u[l] || o, f = c(e[l], t[l], l);
    te.isUndefined(f) && c !== s || (r[l] = f);
  }), r;
}
const OB = (e) => {
  const t = tl({}, e);
  let { data: r, withXSRFToken: n, xsrfHeaderName: o, xsrfCookieName: a, headers: i, auth: s } = t;
  t.headers = i = oo.from(i), t.url = AB(PB(t.baseURL, t.url), e.params, e.paramsSerializer), s && i.set(
    "Authorization",
    "Basic " + btoa((s.username || "") + ":" + (s.password ? unescape(encodeURIComponent(s.password)) : ""))
  );
  let u;
  if (te.isFormData(r)) {
    if (no.hasStandardBrowserEnv || no.hasStandardBrowserWebWorkerEnv)
      i.setContentType(void 0);
    else if ((u = i.getContentType()) !== !1) {
      const [l, ...c] = u ? u.split(";").map((f) => f.trim()).filter(Boolean) : [];
      i.setContentType([l || "multipart/form-data", ...c].join("; "));
    }
  }
  if (no.hasStandardBrowserEnv && (n && te.isFunction(n) && (n = n(t)), n || n !== !1 && Eye(t.url))) {
    const l = o && a && kye.read(a);
    l && i.set(o, l);
  }
  return t;
}, Sye = typeof XMLHttpRequest < "u", _ye = Sye && function(e) {
  return new Promise(function(t, r) {
    const n = OB(e);
    let o = n.data;
    const a = oo.from(n.headers).normalize();
    let { responseType: i, onUploadProgress: s, onDownloadProgress: u } = n, l, c, f, h, p;
    function y() {
      h && h(), p && p(), n.cancelToken && n.cancelToken.unsubscribe(l), n.signal && n.signal.removeEventListener("abort", l);
    }
    let m = new XMLHttpRequest();
    m.open(n.method.toUpperCase(), n.url, !0), m.timeout = n.timeout;
    function b() {
      if (!m)
        return;
      const k = oo.from(
        "getAllResponseHeaders" in m && m.getAllResponseHeaders()
      ), E = {
        data: !i || i === "text" || i === "json" ? m.responseText : m.response,
        status: m.status,
        statusText: m.statusText,
        headers: k,
        config: e,
        request: m
      };
      TB(function(A) {
        t(A), y();
      }, function(A) {
        r(A), y();
      }, E), m = null;
    }
    "onloadend" in m ? m.onloadend = b : m.onreadystatechange = function() {
      !m || m.readyState !== 4 || m.status === 0 && !(m.responseURL && m.responseURL.indexOf("file:") === 0) || setTimeout(b);
    }, m.onabort = function() {
      m && (r(new at("Request aborted", at.ECONNABORTED, e, m)), m = null);
    }, m.onerror = function() {
      r(new at("Network Error", at.ERR_NETWORK, e, m)), m = null;
    }, m.ontimeout = function() {
      let k = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
      const E = n.transitional || SB;
      n.timeoutErrorMessage && (k = n.timeoutErrorMessage), r(new at(
        k,
        E.clarifyTimeoutError ? at.ETIMEDOUT : at.ECONNABORTED,
        e,
        m
      )), m = null;
    }, o === void 0 && a.setContentType(null), "setRequestHeader" in m && te.forEach(a.toJSON(), function(k, E) {
      m.setRequestHeader(E, k);
    }), te.isUndefined(n.withCredentials) || (m.withCredentials = !!n.withCredentials), i && i !== "json" && (m.responseType = n.responseType), u && ([f, p] = ym(u, !0), m.addEventListener("progress", f)), s && m.upload && ([c, h] = ym(s), m.upload.addEventListener("progress", c), m.upload.addEventListener("loadend", h)), (n.cancelToken || n.signal) && (l = (k) => {
      m && (r(!k || k.type ? new wd(null, e, m) : k), m.abort(), m = null);
    }, n.cancelToken && n.cancelToken.subscribe(l), n.signal && (n.signal.aborted ? l() : n.signal.addEventListener("abort", l)));
    const v = bye(n.url);
    if (v && no.protocols.indexOf(v) === -1) {
      r(new at("Unsupported protocol " + v + ":", at.ERR_BAD_REQUEST, e));
      return;
    }
    m.send(o || null);
  });
}, Iye = (e, t) => {
  const { length: r } = e = e ? e.filter(Boolean) : [];
  if (t || r) {
    let n = new AbortController(), o;
    const a = function(l) {
      if (!o) {
        o = !0, s();
        const c = l instanceof Error ? l : this.reason;
        n.abort(c instanceof at ? c : new wd(c instanceof Error ? c.message : c));
      }
    };
    let i = t && setTimeout(() => {
      i = null, a(new at(`timeout ${t} of ms exceeded`, at.ETIMEDOUT));
    }, t);
    const s = () => {
      e && (i && clearTimeout(i), i = null, e.forEach((l) => {
        l.unsubscribe ? l.unsubscribe(a) : l.removeEventListener("abort", a);
      }), e = null);
    };
    e.forEach((l) => l.addEventListener("abort", a));
    const { signal: u } = n;
    return u.unsubscribe = () => te.asap(s), u;
  }
}, Tye = function* (e, t) {
  let r = e.byteLength;
  if (r < t) {
    yield e;
    return;
  }
  let n = 0, o;
  for (; n < r; )
    o = n + t, yield e.slice(n, o), n = o;
}, Pye = async function* (e, t) {
  for await (const r of Oye(e))
    yield* Tye(r, t);
}, Oye = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await t.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await t.cancel();
  }
}, J9 = (e, t, r, n) => {
  const o = Pye(e, t);
  let a = 0, i, s = (u) => {
    i || (i = !0, n && n(u));
  };
  return new ReadableStream({
    async pull(u) {
      try {
        const { done: l, value: c } = await o.next();
        if (l) {
          s(), u.close();
          return;
        }
        let f = c.byteLength;
        if (r) {
          let h = a += f;
          r(h);
        }
        u.enqueue(new Uint8Array(c));
      } catch (l) {
        throw s(l), l;
      }
    },
    cancel(u) {
      return s(u), o.return();
    }
  }, {
    highWaterMark: 2
  });
}, fb = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", $B = fb && typeof ReadableStream == "function", $ye = fb && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), CB = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, Cye = $B && CB(() => {
  let e = !1;
  const t = new Request(no.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), Q9 = 64 * 1024, E8 = $B && CB(() => te.isReadableStream(new Response("").body)), bm = {
  stream: E8 && ((e) => e.body)
};
fb && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !bm[t] && (bm[t] = te.isFunction(e[t]) ? (r) => r[t]() : (r, n) => {
      throw new at(`Response type '${t}' is not supported`, at.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const Bye = async (e) => {
  if (e == null)
    return 0;
  if (te.isBlob(e))
    return e.size;
  if (te.isSpecCompliantForm(e))
    return (await new Request(no.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (te.isArrayBufferView(e) || te.isArrayBuffer(e))
    return e.byteLength;
  if (te.isURLSearchParams(e) && (e = e + ""), te.isString(e))
    return (await $ye(e)).byteLength;
}, Nye = async (e, t) => te.toFiniteNumber(e.getContentLength()) ?? Bye(t), Uye = fb && (async (e) => {
  let {
    url: t,
    method: r,
    data: n,
    signal: o,
    cancelToken: a,
    timeout: i,
    onDownloadProgress: s,
    onUploadProgress: u,
    responseType: l,
    headers: c,
    withCredentials: f = "same-origin",
    fetchOptions: h
  } = OB(e);
  l = l ? (l + "").toLowerCase() : "text";
  let p = Iye([o, a && a.toAbortSignal()], i), y;
  const m = p && p.unsubscribe && (() => {
    p.unsubscribe();
  });
  let b;
  try {
    if (u && Cye && r !== "get" && r !== "head" && (b = await Nye(c, n)) !== 0) {
      let S = new Request(t, {
        method: "POST",
        body: n,
        duplex: "half"
      }), _;
      if (te.isFormData(n) && (_ = S.headers.get("content-type")) && c.setContentType(_), S.body) {
        const [I, O] = W9(
          b,
          ym(X9(u))
        );
        n = J9(S.body, Q9, I, O);
      }
    }
    te.isString(f) || (f = f ? "include" : "omit");
    const v = "credentials" in Request.prototype;
    y = new Request(t, {
      ...h,
      signal: p,
      method: r.toUpperCase(),
      headers: c.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: v ? f : void 0
    });
    let k = await fetch(y);
    const E = E8 && (l === "stream" || l === "response");
    if (E8 && (s || E && m)) {
      const S = {};
      ["status", "statusText", "headers"].forEach((z) => {
        S[z] = k[z];
      });
      const _ = te.toFiniteNumber(k.headers.get("content-length")), [I, O] = s && W9(
        _,
        ym(X9(s), !0)
      ) || [];
      k = new Response(
        J9(k.body, Q9, I, () => {
          O && O(), m && m();
        }),
        S
      );
    }
    l = l || "text";
    let A = await bm[te.findKey(bm, l) || "text"](k, e);
    return !E && m && m(), await new Promise((S, _) => {
      TB(S, _, {
        data: A,
        headers: oo.from(k.headers),
        status: k.status,
        statusText: k.statusText,
        config: e,
        request: y
      });
    });
  } catch (v) {
    throw m && m(), v && v.name === "TypeError" && /fetch/i.test(v.message) ? Object.assign(
      new at("Network Error", at.ERR_NETWORK, e, y),
      {
        cause: v.cause || v
      }
    ) : at.from(v, v && v.code, e, y);
  }
}), k8 = {
  http: Xme,
  xhr: _ye,
  fetch: Uye
};
te.forEach(k8, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const ek = (e) => `- ${e}`, Rye = (e) => te.isFunction(e) || e === null || e === !1, BB = {
  getAdapter: (e) => {
    e = te.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    const o = {};
    for (let a = 0; a < t; a++) {
      r = e[a];
      let i;
      if (n = r, !Rye(r) && (n = k8[(i = String(r)).toLowerCase()], n === void 0))
        throw new at(`Unknown adapter '${i}'`);
      if (n)
        break;
      o[i || "#" + a] = n;
    }
    if (!n) {
      const a = Object.entries(o).map(
        ([s, u]) => `adapter ${s} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let i = t ? a.length > 1 ? `since :
` + a.map(ek).join(`
`) : " " + ek(a[0]) : "as no adapter specified";
      throw new at(
        "There is no suitable adapter to dispatch the request " + i,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: k8
};
function pw(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new wd(null, e);
}
function tk(e) {
  return pw(e), e.headers = oo.from(e.headers), e.data = hw.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), BB.getAdapter(e.adapter || i0.adapter)(e).then(function(t) {
    return pw(e), t.data = hw.call(
      e,
      e.transformResponse,
      t
    ), t.headers = oo.from(t.headers), t;
  }, function(t) {
    return IB(t) || (pw(e), t && t.response && (t.response.data = hw.call(
      e,
      e.transformResponse,
      t.response
    ), t.response.headers = oo.from(t.response.headers))), Promise.reject(t);
  });
}
const NB = "1.7.7", M4 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  M4[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const rk = {};
M4.transitional = function(e, t, r) {
  function n(o, a) {
    return "[Axios v" + NB + "] Transitional option '" + o + "'" + a + (r ? ". " + r : "");
  }
  return (o, a, i) => {
    if (e === !1)
      throw new at(
        n(a, " has been removed" + (t ? " in " + t : "")),
        at.ERR_DEPRECATED
      );
    return t && !rk[a] && (rk[a] = !0, console.warn(
      n(
        a,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(o, a, i) : !0;
  };
};
function zye(e, t, r) {
  if (typeof e != "object")
    throw new at("options must be an object", at.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let o = n.length;
  for (; o-- > 0; ) {
    const a = n[o], i = t[a];
    if (i) {
      const s = e[a], u = s === void 0 || i(s, a, e);
      if (u !== !0)
        throw new at("option " + a + " must be " + u, at.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new at("Unknown option " + a, at.ERR_BAD_OPTION);
  }
}
const x8 = {
  assertOptions: zye,
  validators: M4
}, fu = x8.validators;
class Lc {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new G9(),
      response: new G9()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, r) {
    try {
      return await this._request(t, r);
    } catch (n) {
      if (n instanceof Error) {
        let o;
        Error.captureStackTrace ? Error.captureStackTrace(o = {}) : o = new Error();
        const a = o.stack ? o.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? a && !String(n.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + a) : n.stack = a;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = tl(this.defaults, r);
    const { transitional: n, paramsSerializer: o, headers: a } = r;
    n !== void 0 && x8.assertOptions(n, {
      silentJSONParsing: fu.transitional(fu.boolean),
      forcedJSONParsing: fu.transitional(fu.boolean),
      clarifyTimeoutError: fu.transitional(fu.boolean)
    }, !1), o != null && (te.isFunction(o) ? r.paramsSerializer = {
      serialize: o
    } : x8.assertOptions(o, {
      encode: fu.function,
      serialize: fu.function
    }, !0)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let i = a && te.merge(
      a.common,
      a[r.method]
    );
    a && te.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (y) => {
        delete a[y];
      }
    ), r.headers = oo.concat(i, a);
    const s = [];
    let u = !0;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(r) === !1 || (u = u && y.synchronous, s.unshift(y.fulfilled, y.rejected));
    });
    const l = [];
    this.interceptors.response.forEach(function(y) {
      l.push(y.fulfilled, y.rejected);
    });
    let c, f = 0, h;
    if (!u) {
      const y = [tk.bind(this), void 0];
      for (y.unshift.apply(y, s), y.push.apply(y, l), h = y.length, c = Promise.resolve(r); f < h; )
        c = c.then(y[f++], y[f++]);
      return c;
    }
    h = s.length;
    let p = r;
    for (f = 0; f < h; ) {
      const y = s[f++], m = s[f++];
      try {
        p = y(p);
      } catch (b) {
        m.call(this, b);
        break;
      }
    }
    try {
      c = tk.call(this, p);
    } catch (y) {
      return Promise.reject(y);
    }
    for (f = 0, h = l.length; f < h; )
      c = c.then(l[f++], l[f++]);
    return c;
  }
  getUri(t) {
    t = tl(this.defaults, t);
    const r = PB(t.baseURL, t.url);
    return AB(r, t.params, t.paramsSerializer);
  }
}
te.forEach(["delete", "get", "head", "options"], function(e) {
  Lc.prototype[e] = function(t, r) {
    return this.request(tl(r || {}, {
      method: e,
      url: t,
      data: (r || {}).data
    }));
  };
});
te.forEach(["post", "put", "patch"], function(e) {
  function t(r) {
    return function(n, o, a) {
      return this.request(tl(a || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: n,
        data: o
      }));
    };
  }
  Lc.prototype[e] = t(), Lc.prototype[e + "Form"] = t(!0);
});
class K4 {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(o) {
      r = o;
    });
    const n = this;
    this.promise.then((o) => {
      if (!n._listeners) return;
      let a = n._listeners.length;
      for (; a-- > 0; )
        n._listeners[a](o);
      n._listeners = null;
    }), this.promise.then = (o) => {
      let a;
      const i = new Promise((s) => {
        n.subscribe(s), a = s;
      }).then(o);
      return i.cancel = function() {
        n.unsubscribe(a);
      }, i;
    }, t(function(o, a, i) {
      n.reason || (n.reason = new wd(o, a, i), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), r = (n) => {
      t.abort(n);
    };
    return this.subscribe(r), t.signal.unsubscribe = () => this.unsubscribe(r), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new K4(function(r) {
        t = r;
      }),
      cancel: t
    };
  }
}
function jye(e) {
  return function(t) {
    return e.apply(null, t);
  };
}
function Lye(e) {
  return te.isObject(e) && e.isAxiosError === !0;
}
const A8 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(A8).forEach(([e, t]) => {
  A8[t] = e;
});
function UB(e) {
  const t = new Lc(e), r = dB(Lc.prototype.request, t);
  return te.extend(r, Lc.prototype, t, { allOwnKeys: !0 }), te.extend(r, t, null, { allOwnKeys: !0 }), r.create = function(n) {
    return UB(tl(e, n));
  }, r;
}
const nr = UB(i0);
nr.Axios = Lc;
nr.CanceledError = wd;
nr.CancelToken = K4;
nr.isCancel = IB;
nr.VERSION = NB;
nr.toFormData = lb;
nr.AxiosError = at;
nr.Cancel = nr.CanceledError;
nr.all = function(e) {
  return Promise.all(e);
};
nr.spread = jye;
nr.isAxiosError = Lye;
nr.mergeConfig = tl;
nr.AxiosHeaders = oo;
nr.formToJSON = (e) => _B(te.isHTMLForm(e) ? new FormData(e) : e);
nr.getAdapter = BB.getAdapter;
nr.HttpStatusCode = A8;
nr.default = nr;
const Hye = "https://mempool.space", Fye = "https://mempool.space/testnet", Dye = "https://mempool.space/testnet4", Mye = "https://mempool.space/signet", Kye = "https://mempool.fractalbitcoin.io", qye = "https://mempool-testnet.fractalbitcoin.io", db = (e) => e === Cr ? Fye : e === hn ? Dye : e === En ? Mye : e === xl ? Kye : e === Xn ? qye : Hye;
var va = {}, Qr = {}, rt = {};
Object.defineProperty(rt, "__esModule", { value: !0 });
rt.add5L = rt.add5H = rt.add4H = rt.add4L = rt.add3H = rt.add3L = rt.rotlBL = rt.rotlBH = rt.rotlSL = rt.rotlSH = rt.rotr32L = rt.rotr32H = rt.rotrBL = rt.rotrBH = rt.rotrSL = rt.rotrSH = rt.shrSL = rt.shrSH = rt.toBig = void 0;
rt.fromBig = q4;
rt.split = RB;
rt.add = XB;
const n1 = /* @__PURE__ */ BigInt(2 ** 32 - 1), S8 = /* @__PURE__ */ BigInt(32);
function q4(e, t = !1) {
  return t ? { h: Number(e & n1), l: Number(e >> S8 & n1) } : { h: Number(e >> S8 & n1) | 0, l: Number(e & n1) | 0 };
}
function RB(e, t = !1) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: a, l: i } = q4(e[o], t);
    [r[o], n[o]] = [a, i];
  }
  return [r, n];
}
const zB = (e, t) => BigInt(e >>> 0) << S8 | BigInt(t >>> 0);
rt.toBig = zB;
const jB = (e, t, r) => e >>> r;
rt.shrSH = jB;
const LB = (e, t, r) => e << 32 - r | t >>> r;
rt.shrSL = LB;
const HB = (e, t, r) => e >>> r | t << 32 - r;
rt.rotrSH = HB;
const FB = (e, t, r) => e << 32 - r | t >>> r;
rt.rotrSL = FB;
const DB = (e, t, r) => e << 64 - r | t >>> r - 32;
rt.rotrBH = DB;
const MB = (e, t, r) => e >>> r - 32 | t << 64 - r;
rt.rotrBL = MB;
const KB = (e, t) => t;
rt.rotr32H = KB;
const qB = (e, t) => e;
rt.rotr32L = qB;
const VB = (e, t, r) => e << r | t >>> 32 - r;
rt.rotlSH = VB;
const GB = (e, t, r) => t << r | e >>> 32 - r;
rt.rotlSL = GB;
const ZB = (e, t, r) => t << r - 32 | e >>> 64 - r;
rt.rotlBH = ZB;
const WB = (e, t, r) => e << r - 32 | t >>> 64 - r;
rt.rotlBL = WB;
function XB(e, t, r, n) {
  const o = (t >>> 0) + (n >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
const YB = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
rt.add3L = YB;
const JB = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0;
rt.add3H = JB;
const QB = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
rt.add4L = QB;
const eN = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0;
rt.add4H = eN;
const tN = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0);
rt.add5L = tN;
const rN = (e, t, r, n, o, a) => t + r + n + o + a + (e / 2 ** 32 | 0) | 0;
rt.add5H = rN;
const Vye = {
  fromBig: q4,
  split: RB,
  toBig: zB,
  shrSH: jB,
  shrSL: LB,
  rotrSH: HB,
  rotrSL: FB,
  rotrBH: DB,
  rotrBL: MB,
  rotr32H: KB,
  rotr32L: qB,
  rotlSH: VB,
  rotlSL: GB,
  rotlBH: ZB,
  rotlBL: WB,
  add: XB,
  add3L: YB,
  add3H: JB,
  add4L: QB,
  add4H: eN,
  add5H: rN,
  add5L: tN
};
rt.default = Vye;
Object.defineProperty(Qr, "__esModule", { value: !0 });
Qr.sha384 = Qr.sha512_256 = Qr.sha512_224 = Qr.sha512 = Qr.SHA384 = Qr.SHA512_256 = Qr.SHA512_224 = Qr.SHA512 = void 0;
const Gye = rs, vt = rt, hb = Yu, [Zye, Wye] = vt.default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))), du = /* @__PURE__ */ new Uint32Array(80), hu = /* @__PURE__ */ new Uint32Array(80);
class a0 extends Gye.HashMD {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: o, Ch: a, Cl: i, Dh: s, Dl: u, Eh: l, El: c, Fh: f, Fl: h, Gh: p, Gl: y, Hh: m, Hl: b } = this;
    return [t, r, n, o, a, i, s, u, l, c, f, h, p, y, m, b];
  }
  // prettier-ignore
  set(t, r, n, o, a, i, s, u, l, c, f, h, p, y, m, b) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = o | 0, this.Ch = a | 0, this.Cl = i | 0, this.Dh = s | 0, this.Dl = u | 0, this.Eh = l | 0, this.El = c | 0, this.Fh = f | 0, this.Fl = h | 0, this.Gh = p | 0, this.Gl = y | 0, this.Hh = m | 0, this.Hl = b | 0;
  }
  process(t, r) {
    for (let E = 0; E < 16; E++, r += 4)
      du[E] = t.getUint32(r), hu[E] = t.getUint32(r += 4);
    for (let E = 16; E < 80; E++) {
      const A = du[E - 15] | 0, S = hu[E - 15] | 0, _ = vt.default.rotrSH(A, S, 1) ^ vt.default.rotrSH(A, S, 8) ^ vt.default.shrSH(A, S, 7), I = vt.default.rotrSL(A, S, 1) ^ vt.default.rotrSL(A, S, 8) ^ vt.default.shrSL(A, S, 7), O = du[E - 2] | 0, z = hu[E - 2] | 0, D = vt.default.rotrSH(O, z, 19) ^ vt.default.rotrBH(O, z, 61) ^ vt.default.shrSH(O, z, 6), G = vt.default.rotrSL(O, z, 19) ^ vt.default.rotrBL(O, z, 61) ^ vt.default.shrSL(O, z, 6), U = vt.default.add4L(I, G, hu[E - 7], hu[E - 16]), V = vt.default.add4H(U, _, D, du[E - 7], du[E - 16]);
      du[E] = V | 0, hu[E] = U | 0;
    }
    let { Ah: n, Al: o, Bh: a, Bl: i, Ch: s, Cl: u, Dh: l, Dl: c, Eh: f, El: h, Fh: p, Fl: y, Gh: m, Gl: b, Hh: v, Hl: k } = this;
    for (let E = 0; E < 80; E++) {
      const A = vt.default.rotrSH(f, h, 14) ^ vt.default.rotrSH(f, h, 18) ^ vt.default.rotrBH(f, h, 41), S = vt.default.rotrSL(f, h, 14) ^ vt.default.rotrSL(f, h, 18) ^ vt.default.rotrBL(f, h, 41), _ = f & p ^ ~f & m, I = h & y ^ ~h & b, O = vt.default.add5L(k, S, I, Wye[E], hu[E]), z = vt.default.add5H(O, v, A, _, Zye[E], du[E]), D = O | 0, G = vt.default.rotrSH(n, o, 28) ^ vt.default.rotrBH(n, o, 34) ^ vt.default.rotrBH(n, o, 39), U = vt.default.rotrSL(n, o, 28) ^ vt.default.rotrBL(n, o, 34) ^ vt.default.rotrBL(n, o, 39), V = n & a ^ n & s ^ a & s, F = o & i ^ o & u ^ i & u;
      v = m | 0, k = b | 0, m = p | 0, b = y | 0, p = f | 0, y = h | 0, { h: f, l: h } = vt.default.add(l | 0, c | 0, z | 0, D | 0), l = s | 0, c = u | 0, s = a | 0, u = i | 0, a = n | 0, i = o | 0;
      const C = vt.default.add3L(D, U, F);
      n = vt.default.add3H(C, z, G, V), o = C | 0;
    }
    ({ h: n, l: o } = vt.default.add(this.Ah | 0, this.Al | 0, n | 0, o | 0)), { h: a, l: i } = vt.default.add(this.Bh | 0, this.Bl | 0, a | 0, i | 0), { h: s, l: u } = vt.default.add(this.Ch | 0, this.Cl | 0, s | 0, u | 0), { h: l, l: c } = vt.default.add(this.Dh | 0, this.Dl | 0, l | 0, c | 0), { h: f, l: h } = vt.default.add(this.Eh | 0, this.El | 0, f | 0, h | 0), { h: p, l: y } = vt.default.add(this.Fh | 0, this.Fl | 0, p | 0, y | 0), { h: m, l: b } = vt.default.add(this.Gh | 0, this.Gl | 0, m | 0, b | 0), { h: v, l: k } = vt.default.add(this.Hh | 0, this.Hl | 0, v | 0, k | 0), this.set(n, o, a, i, s, u, l, c, f, h, p, y, m, b, v, k);
  }
  roundClean() {
    du.fill(0), hu.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
Qr.SHA512 = a0;
class nN extends a0 {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}
Qr.SHA512_224 = nN;
class oN extends a0 {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
Qr.SHA512_256 = oN;
class iN extends a0 {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
Qr.SHA384 = iN;
Qr.sha512 = (0, hb.wrapConstructor)(() => new a0());
Qr.sha512_224 = (0, hb.wrapConstructor)(() => new nN());
Qr.sha512_256 = (0, hb.wrapConstructor)(() => new oN());
Qr.sha384 = (0, hb.wrapConstructor)(() => new iN());
var pb = {};
Object.defineProperty(pb, "__esModule", { value: !0 });
pb.pbkdf2 = Yye;
pb.pbkdf2Async = Jye;
const o1 = $o, Xye = nb, gf = Yu;
function aN(e, t, r, n) {
  (0, o1.hash)(e);
  const o = (0, gf.checkOpts)({ dkLen: 32, asyncTick: 10 }, n), { c: a, dkLen: i, asyncTick: s } = o;
  if ((0, o1.number)(a), (0, o1.number)(i), (0, o1.number)(s), a < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const u = (0, gf.toBytes)(t), l = (0, gf.toBytes)(r), c = new Uint8Array(i), f = Xye.hmac.create(e, u), h = f._cloneInto().update(l);
  return { c: a, dkLen: i, asyncTick: s, DK: c, PRF: f, PRFSalt: h };
}
function sN(e, t, r, n, o) {
  return e.destroy(), t.destroy(), n && n.destroy(), o.fill(0), r;
}
function Yye(e, t, r, n) {
  const { c: o, dkLen: a, DK: i, PRF: s, PRFSalt: u } = aN(e, t, r, n);
  let l;
  const c = new Uint8Array(4), f = (0, gf.createView)(c), h = new Uint8Array(s.outputLen);
  for (let p = 1, y = 0; y < a; p++, y += s.outputLen) {
    const m = i.subarray(y, y + s.outputLen);
    f.setInt32(0, p, !1), (l = u._cloneInto(l)).update(c).digestInto(h), m.set(h.subarray(0, m.length));
    for (let b = 1; b < o; b++) {
      s._cloneInto(l).update(h).digestInto(h);
      for (let v = 0; v < m.length; v++)
        m[v] ^= h[v];
    }
  }
  return sN(s, u, i, l, h);
}
async function Jye(e, t, r, n) {
  const { c: o, dkLen: a, asyncTick: i, DK: s, PRF: u, PRFSalt: l } = aN(e, t, r, n);
  let c;
  const f = new Uint8Array(4), h = (0, gf.createView)(f), p = new Uint8Array(u.outputLen);
  for (let y = 1, m = 0; m < a; y++, m += u.outputLen) {
    const b = s.subarray(m, m + u.outputLen);
    h.setInt32(0, y, !1), (c = l._cloneInto(c)).update(f).digestInto(p), b.set(p.subarray(0, b.length)), await (0, gf.asyncLoop)(o - 1, i, () => {
      u._cloneInto(c).update(p).digestInto(p);
      for (let v = 0; v < b.length; v++)
        b[v] ^= p[v];
    });
  }
  return sN(u, l, s, c, p);
}
var qn = {};
const Qye = [
  "abdikace",
  "abeceda",
  "adresa",
  "agrese",
  "akce",
  "aktovka",
  "alej",
  "alkohol",
  "amputace",
  "ananas",
  "andulka",
  "anekdota",
  "anketa",
  "antika",
  "anulovat",
  "archa",
  "arogance",
  "asfalt",
  "asistent",
  "aspirace",
  "astma",
  "astronom",
  "atlas",
  "atletika",
  "atol",
  "autobus",
  "azyl",
  "babka",
  "bachor",
  "bacil",
  "baculka",
  "badatel",
  "bageta",
  "bagr",
  "bahno",
  "bakterie",
  "balada",
  "baletka",
  "balkon",
  "balonek",
  "balvan",
  "balza",
  "bambus",
  "bankomat",
  "barbar",
  "baret",
  "barman",
  "baroko",
  "barva",
  "baterka",
  "batoh",
  "bavlna",
  "bazalka",
  "bazilika",
  "bazuka",
  "bedna",
  "beran",
  "beseda",
  "bestie",
  "beton",
  "bezinka",
  "bezmoc",
  "beztak",
  "bicykl",
  "bidlo",
  "biftek",
  "bikiny",
  "bilance",
  "biograf",
  "biolog",
  "bitva",
  "bizon",
  "blahobyt",
  "blatouch",
  "blecha",
  "bledule",
  "blesk",
  "blikat",
  "blizna",
  "blokovat",
  "bloudit",
  "blud",
  "bobek",
  "bobr",
  "bodlina",
  "bodnout",
  "bohatost",
  "bojkot",
  "bojovat",
  "bokorys",
  "bolest",
  "borec",
  "borovice",
  "bota",
  "boubel",
  "bouchat",
  "bouda",
  "boule",
  "bourat",
  "boxer",
  "bradavka",
  "brambora",
  "branka",
  "bratr",
  "brepta",
  "briketa",
  "brko",
  "brloh",
  "bronz",
  "broskev",
  "brunetka",
  "brusinka",
  "brzda",
  "brzy",
  "bublina",
  "bubnovat",
  "buchta",
  "buditel",
  "budka",
  "budova",
  "bufet",
  "bujarost",
  "bukvice",
  "buldok",
  "bulva",
  "bunda",
  "bunkr",
  "burza",
  "butik",
  "buvol",
  "buzola",
  "bydlet",
  "bylina",
  "bytovka",
  "bzukot",
  "capart",
  "carevna",
  "cedr",
  "cedule",
  "cejch",
  "cejn",
  "cela",
  "celer",
  "celkem",
  "celnice",
  "cenina",
  "cennost",
  "cenovka",
  "centrum",
  "cenzor",
  "cestopis",
  "cetka",
  "chalupa",
  "chapadlo",
  "charita",
  "chata",
  "chechtat",
  "chemie",
  "chichot",
  "chirurg",
  "chlad",
  "chleba",
  "chlubit",
  "chmel",
  "chmura",
  "chobot",
  "chochol",
  "chodba",
  "cholera",
  "chomout",
  "chopit",
  "choroba",
  "chov",
  "chrapot",
  "chrlit",
  "chrt",
  "chrup",
  "chtivost",
  "chudina",
  "chutnat",
  "chvat",
  "chvilka",
  "chvost",
  "chyba",
  "chystat",
  "chytit",
  "cibule",
  "cigareta",
  "cihelna",
  "cihla",
  "cinkot",
  "cirkus",
  "cisterna",
  "citace",
  "citrus",
  "cizinec",
  "cizost",
  "clona",
  "cokoliv",
  "couvat",
  "ctitel",
  "ctnost",
  "cudnost",
  "cuketa",
  "cukr",
  "cupot",
  "cvaknout",
  "cval",
  "cvik",
  "cvrkot",
  "cyklista",
  "daleko",
  "dareba",
  "datel",
  "datum",
  "dcera",
  "debata",
  "dechovka",
  "decibel",
  "deficit",
  "deflace",
  "dekl",
  "dekret",
  "demokrat",
  "deprese",
  "derby",
  "deska",
  "detektiv",
  "dikobraz",
  "diktovat",
  "dioda",
  "diplom",
  "disk",
  "displej",
  "divadlo",
  "divoch",
  "dlaha",
  "dlouho",
  "dluhopis",
  "dnes",
  "dobro",
  "dobytek",
  "docent",
  "dochutit",
  "dodnes",
  "dohled",
  "dohoda",
  "dohra",
  "dojem",
  "dojnice",
  "doklad",
  "dokola",
  "doktor",
  "dokument",
  "dolar",
  "doleva",
  "dolina",
  "doma",
  "dominant",
  "domluvit",
  "domov",
  "donutit",
  "dopad",
  "dopis",
  "doplnit",
  "doposud",
  "doprovod",
  "dopustit",
  "dorazit",
  "dorost",
  "dort",
  "dosah",
  "doslov",
  "dostatek",
  "dosud",
  "dosyta",
  "dotaz",
  "dotek",
  "dotknout",
  "doufat",
  "doutnat",
  "dovozce",
  "dozadu",
  "doznat",
  "dozorce",
  "drahota",
  "drak",
  "dramatik",
  "dravec",
  "draze",
  "drdol",
  "drobnost",
  "drogerie",
  "drozd",
  "drsnost",
  "drtit",
  "drzost",
  "duben",
  "duchovno",
  "dudek",
  "duha",
  "duhovka",
  "dusit",
  "dusno",
  "dutost",
  "dvojice",
  "dvorec",
  "dynamit",
  "ekolog",
  "ekonomie",
  "elektron",
  "elipsa",
  "email",
  "emise",
  "emoce",
  "empatie",
  "epizoda",
  "epocha",
  "epopej",
  "epos",
  "esej",
  "esence",
  "eskorta",
  "eskymo",
  "etiketa",
  "euforie",
  "evoluce",
  "exekuce",
  "exkurze",
  "expedice",
  "exploze",
  "export",
  "extrakt",
  "facka",
  "fajfka",
  "fakulta",
  "fanatik",
  "fantazie",
  "farmacie",
  "favorit",
  "fazole",
  "federace",
  "fejeton",
  "fenka",
  "fialka",
  "figurant",
  "filozof",
  "filtr",
  "finance",
  "finta",
  "fixace",
  "fjord",
  "flanel",
  "flirt",
  "flotila",
  "fond",
  "fosfor",
  "fotbal",
  "fotka",
  "foton",
  "frakce",
  "freska",
  "fronta",
  "fukar",
  "funkce",
  "fyzika",
  "galeje",
  "garant",
  "genetika",
  "geolog",
  "gilotina",
  "glazura",
  "glejt",
  "golem",
  "golfista",
  "gotika",
  "graf",
  "gramofon",
  "granule",
  "grep",
  "gril",
  "grog",
  "groteska",
  "guma",
  "hadice",
  "hadr",
  "hala",
  "halenka",
  "hanba",
  "hanopis",
  "harfa",
  "harpuna",
  "havran",
  "hebkost",
  "hejkal",
  "hejno",
  "hejtman",
  "hektar",
  "helma",
  "hematom",
  "herec",
  "herna",
  "heslo",
  "hezky",
  "historik",
  "hladovka",
  "hlasivky",
  "hlava",
  "hledat",
  "hlen",
  "hlodavec",
  "hloh",
  "hloupost",
  "hltat",
  "hlubina",
  "hluchota",
  "hmat",
  "hmota",
  "hmyz",
  "hnis",
  "hnojivo",
  "hnout",
  "hoblina",
  "hoboj",
  "hoch",
  "hodiny",
  "hodlat",
  "hodnota",
  "hodovat",
  "hojnost",
  "hokej",
  "holinka",
  "holka",
  "holub",
  "homole",
  "honitba",
  "honorace",
  "horal",
  "horda",
  "horizont",
  "horko",
  "horlivec",
  "hormon",
  "hornina",
  "horoskop",
  "horstvo",
  "hospoda",
  "hostina",
  "hotovost",
  "houba",
  "houf",
  "houpat",
  "houska",
  "hovor",
  "hradba",
  "hranice",
  "hravost",
  "hrazda",
  "hrbolek",
  "hrdina",
  "hrdlo",
  "hrdost",
  "hrnek",
  "hrobka",
  "hromada",
  "hrot",
  "hrouda",
  "hrozen",
  "hrstka",
  "hrubost",
  "hryzat",
  "hubenost",
  "hubnout",
  "hudba",
  "hukot",
  "humr",
  "husita",
  "hustota",
  "hvozd",
  "hybnost",
  "hydrant",
  "hygiena",
  "hymna",
  "hysterik",
  "idylka",
  "ihned",
  "ikona",
  "iluze",
  "imunita",
  "infekce",
  "inflace",
  "inkaso",
  "inovace",
  "inspekce",
  "internet",
  "invalida",
  "investor",
  "inzerce",
  "ironie",
  "jablko",
  "jachta",
  "jahoda",
  "jakmile",
  "jakost",
  "jalovec",
  "jantar",
  "jarmark",
  "jaro",
  "jasan",
  "jasno",
  "jatka",
  "javor",
  "jazyk",
  "jedinec",
  "jedle",
  "jednatel",
  "jehlan",
  "jekot",
  "jelen",
  "jelito",
  "jemnost",
  "jenom",
  "jepice",
  "jeseter",
  "jevit",
  "jezdec",
  "jezero",
  "jinak",
  "jindy",
  "jinoch",
  "jiskra",
  "jistota",
  "jitrnice",
  "jizva",
  "jmenovat",
  "jogurt",
  "jurta",
  "kabaret",
  "kabel",
  "kabinet",
  "kachna",
  "kadet",
  "kadidlo",
  "kahan",
  "kajak",
  "kajuta",
  "kakao",
  "kaktus",
  "kalamita",
  "kalhoty",
  "kalibr",
  "kalnost",
  "kamera",
  "kamkoliv",
  "kamna",
  "kanibal",
  "kanoe",
  "kantor",
  "kapalina",
  "kapela",
  "kapitola",
  "kapka",
  "kaple",
  "kapota",
  "kapr",
  "kapusta",
  "kapybara",
  "karamel",
  "karotka",
  "karton",
  "kasa",
  "katalog",
  "katedra",
  "kauce",
  "kauza",
  "kavalec",
  "kazajka",
  "kazeta",
  "kazivost",
  "kdekoliv",
  "kdesi",
  "kedluben",
  "kemp",
  "keramika",
  "kino",
  "klacek",
  "kladivo",
  "klam",
  "klapot",
  "klasika",
  "klaun",
  "klec",
  "klenba",
  "klepat",
  "klesnout",
  "klid",
  "klima",
  "klisna",
  "klobouk",
  "klokan",
  "klopa",
  "kloub",
  "klubovna",
  "klusat",
  "kluzkost",
  "kmen",
  "kmitat",
  "kmotr",
  "kniha",
  "knot",
  "koalice",
  "koberec",
  "kobka",
  "kobliha",
  "kobyla",
  "kocour",
  "kohout",
  "kojenec",
  "kokos",
  "koktejl",
  "kolaps",
  "koleda",
  "kolize",
  "kolo",
  "komando",
  "kometa",
  "komik",
  "komnata",
  "komora",
  "kompas",
  "komunita",
  "konat",
  "koncept",
  "kondice",
  "konec",
  "konfese",
  "kongres",
  "konina",
  "konkurs",
  "kontakt",
  "konzerva",
  "kopanec",
  "kopie",
  "kopnout",
  "koprovka",
  "korbel",
  "korektor",
  "kormidlo",
  "koroptev",
  "korpus",
  "koruna",
  "koryto",
  "korzet",
  "kosatec",
  "kostka",
  "kotel",
  "kotleta",
  "kotoul",
  "koukat",
  "koupelna",
  "kousek",
  "kouzlo",
  "kovboj",
  "koza",
  "kozoroh",
  "krabice",
  "krach",
  "krajina",
  "kralovat",
  "krasopis",
  "kravata",
  "kredit",
  "krejcar",
  "kresba",
  "kreveta",
  "kriket",
  "kritik",
  "krize",
  "krkavec",
  "krmelec",
  "krmivo",
  "krocan",
  "krok",
  "kronika",
  "kropit",
  "kroupa",
  "krovka",
  "krtek",
  "kruhadlo",
  "krupice",
  "krutost",
  "krvinka",
  "krychle",
  "krypta",
  "krystal",
  "kryt",
  "kudlanka",
  "kufr",
  "kujnost",
  "kukla",
  "kulajda",
  "kulich",
  "kulka",
  "kulomet",
  "kultura",
  "kuna",
  "kupodivu",
  "kurt",
  "kurzor",
  "kutil",
  "kvalita",
  "kvasinka",
  "kvestor",
  "kynolog",
  "kyselina",
  "kytara",
  "kytice",
  "kytka",
  "kytovec",
  "kyvadlo",
  "labrador",
  "lachtan",
  "ladnost",
  "laik",
  "lakomec",
  "lamela",
  "lampa",
  "lanovka",
  "lasice",
  "laso",
  "lastura",
  "latinka",
  "lavina",
  "lebka",
  "leckdy",
  "leden",
  "lednice",
  "ledovka",
  "ledvina",
  "legenda",
  "legie",
  "legrace",
  "lehce",
  "lehkost",
  "lehnout",
  "lektvar",
  "lenochod",
  "lentilka",
  "lepenka",
  "lepidlo",
  "letadlo",
  "letec",
  "letmo",
  "letokruh",
  "levhart",
  "levitace",
  "levobok",
  "libra",
  "lichotka",
  "lidojed",
  "lidskost",
  "lihovina",
  "lijavec",
  "lilek",
  "limetka",
  "linie",
  "linka",
  "linoleum",
  "listopad",
  "litina",
  "litovat",
  "lobista",
  "lodivod",
  "logika",
  "logoped",
  "lokalita",
  "loket",
  "lomcovat",
  "lopata",
  "lopuch",
  "lord",
  "losos",
  "lotr",
  "loudal",
  "louh",
  "louka",
  "louskat",
  "lovec",
  "lstivost",
  "lucerna",
  "lucifer",
  "lump",
  "lusk",
  "lustrace",
  "lvice",
  "lyra",
  "lyrika",
  "lysina",
  "madam",
  "madlo",
  "magistr",
  "mahagon",
  "majetek",
  "majitel",
  "majorita",
  "makak",
  "makovice",
  "makrela",
  "malba",
  "malina",
  "malovat",
  "malvice",
  "maminka",
  "mandle",
  "manko",
  "marnost",
  "masakr",
  "maskot",
  "masopust",
  "matice",
  "matrika",
  "maturita",
  "mazanec",
  "mazivo",
  "mazlit",
  "mazurka",
  "mdloba",
  "mechanik",
  "meditace",
  "medovina",
  "melasa",
  "meloun",
  "mentolka",
  "metla",
  "metoda",
  "metr",
  "mezera",
  "migrace",
  "mihnout",
  "mihule",
  "mikina",
  "mikrofon",
  "milenec",
  "milimetr",
  "milost",
  "mimika",
  "mincovna",
  "minibar",
  "minomet",
  "minulost",
  "miska",
  "mistr",
  "mixovat",
  "mladost",
  "mlha",
  "mlhovina",
  "mlok",
  "mlsat",
  "mluvit",
  "mnich",
  "mnohem",
  "mobil",
  "mocnost",
  "modelka",
  "modlitba",
  "mohyla",
  "mokro",
  "molekula",
  "momentka",
  "monarcha",
  "monokl",
  "monstrum",
  "montovat",
  "monzun",
  "mosaz",
  "moskyt",
  "most",
  "motivace",
  "motorka",
  "motyka",
  "moucha",
  "moudrost",
  "mozaika",
  "mozek",
  "mozol",
  "mramor",
  "mravenec",
  "mrkev",
  "mrtvola",
  "mrzet",
  "mrzutost",
  "mstitel",
  "mudrc",
  "muflon",
  "mulat",
  "mumie",
  "munice",
  "muset",
  "mutace",
  "muzeum",
  "muzikant",
  "myslivec",
  "mzda",
  "nabourat",
  "nachytat",
  "nadace",
  "nadbytek",
  "nadhoz",
  "nadobro",
  "nadpis",
  "nahlas",
  "nahnat",
  "nahodile",
  "nahradit",
  "naivita",
  "najednou",
  "najisto",
  "najmout",
  "naklonit",
  "nakonec",
  "nakrmit",
  "nalevo",
  "namazat",
  "namluvit",
  "nanometr",
  "naoko",
  "naopak",
  "naostro",
  "napadat",
  "napevno",
  "naplnit",
  "napnout",
  "naposled",
  "naprosto",
  "narodit",
  "naruby",
  "narychlo",
  "nasadit",
  "nasekat",
  "naslepo",
  "nastat",
  "natolik",
  "navenek",
  "navrch",
  "navzdory",
  "nazvat",
  "nebe",
  "nechat",
  "necky",
  "nedaleko",
  "nedbat",
  "neduh",
  "negace",
  "nehet",
  "nehoda",
  "nejen",
  "nejprve",
  "neklid",
  "nelibost",
  "nemilost",
  "nemoc",
  "neochota",
  "neonka",
  "nepokoj",
  "nerost",
  "nerv",
  "nesmysl",
  "nesoulad",
  "netvor",
  "neuron",
  "nevina",
  "nezvykle",
  "nicota",
  "nijak",
  "nikam",
  "nikdy",
  "nikl",
  "nikterak",
  "nitro",
  "nocleh",
  "nohavice",
  "nominace",
  "nora",
  "norek",
  "nositel",
  "nosnost",
  "nouze",
  "noviny",
  "novota",
  "nozdra",
  "nuda",
  "nudle",
  "nuget",
  "nutit",
  "nutnost",
  "nutrie",
  "nymfa",
  "obal",
  "obarvit",
  "obava",
  "obdiv",
  "obec",
  "obehnat",
  "obejmout",
  "obezita",
  "obhajoba",
  "obilnice",
  "objasnit",
  "objekt",
  "obklopit",
  "oblast",
  "oblek",
  "obliba",
  "obloha",
  "obluda",
  "obnos",
  "obohatit",
  "obojek",
  "obout",
  "obrazec",
  "obrna",
  "obruba",
  "obrys",
  "obsah",
  "obsluha",
  "obstarat",
  "obuv",
  "obvaz",
  "obvinit",
  "obvod",
  "obvykle",
  "obyvatel",
  "obzor",
  "ocas",
  "ocel",
  "ocenit",
  "ochladit",
  "ochota",
  "ochrana",
  "ocitnout",
  "odboj",
  "odbyt",
  "odchod",
  "odcizit",
  "odebrat",
  "odeslat",
  "odevzdat",
  "odezva",
  "odhadce",
  "odhodit",
  "odjet",
  "odjinud",
  "odkaz",
  "odkoupit",
  "odliv",
  "odluka",
  "odmlka",
  "odolnost",
  "odpad",
  "odpis",
  "odplout",
  "odpor",
  "odpustit",
  "odpykat",
  "odrazka",
  "odsoudit",
  "odstup",
  "odsun",
  "odtok",
  "odtud",
  "odvaha",
  "odveta",
  "odvolat",
  "odvracet",
  "odznak",
  "ofina",
  "ofsajd",
  "ohlas",
  "ohnisko",
  "ohrada",
  "ohrozit",
  "ohryzek",
  "okap",
  "okenice",
  "oklika",
  "okno",
  "okouzlit",
  "okovy",
  "okrasa",
  "okres",
  "okrsek",
  "okruh",
  "okupant",
  "okurka",
  "okusit",
  "olejnina",
  "olizovat",
  "omak",
  "omeleta",
  "omezit",
  "omladina",
  "omlouvat",
  "omluva",
  "omyl",
  "onehdy",
  "opakovat",
  "opasek",
  "operace",
  "opice",
  "opilost",
  "opisovat",
  "opora",
  "opozice",
  "opravdu",
  "oproti",
  "orbital",
  "orchestr",
  "orgie",
  "orlice",
  "orloj",
  "ortel",
  "osada",
  "oschnout",
  "osika",
  "osivo",
  "oslava",
  "oslepit",
  "oslnit",
  "oslovit",
  "osnova",
  "osoba",
  "osolit",
  "ospalec",
  "osten",
  "ostraha",
  "ostuda",
  "ostych",
  "osvojit",
  "oteplit",
  "otisk",
  "otop",
  "otrhat",
  "otrlost",
  "otrok",
  "otruby",
  "otvor",
  "ovanout",
  "ovar",
  "oves",
  "ovlivnit",
  "ovoce",
  "oxid",
  "ozdoba",
  "pachatel",
  "pacient",
  "padouch",
  "pahorek",
  "pakt",
  "palanda",
  "palec",
  "palivo",
  "paluba",
  "pamflet",
  "pamlsek",
  "panenka",
  "panika",
  "panna",
  "panovat",
  "panstvo",
  "pantofle",
  "paprika",
  "parketa",
  "parodie",
  "parta",
  "paruka",
  "paryba",
  "paseka",
  "pasivita",
  "pastelka",
  "patent",
  "patrona",
  "pavouk",
  "pazneht",
  "pazourek",
  "pecka",
  "pedagog",
  "pejsek",
  "peklo",
  "peloton",
  "penalta",
  "pendrek",
  "penze",
  "periskop",
  "pero",
  "pestrost",
  "petarda",
  "petice",
  "petrolej",
  "pevnina",
  "pexeso",
  "pianista",
  "piha",
  "pijavice",
  "pikle",
  "piknik",
  "pilina",
  "pilnost",
  "pilulka",
  "pinzeta",
  "pipeta",
  "pisatel",
  "pistole",
  "pitevna",
  "pivnice",
  "pivovar",
  "placenta",
  "plakat",
  "plamen",
  "planeta",
  "plastika",
  "platit",
  "plavidlo",
  "plaz",
  "plech",
  "plemeno",
  "plenta",
  "ples",
  "pletivo",
  "plevel",
  "plivat",
  "plnit",
  "plno",
  "plocha",
  "plodina",
  "plomba",
  "plout",
  "pluk",
  "plyn",
  "pobavit",
  "pobyt",
  "pochod",
  "pocit",
  "poctivec",
  "podat",
  "podcenit",
  "podepsat",
  "podhled",
  "podivit",
  "podklad",
  "podmanit",
  "podnik",
  "podoba",
  "podpora",
  "podraz",
  "podstata",
  "podvod",
  "podzim",
  "poezie",
  "pohanka",
  "pohnutka",
  "pohovor",
  "pohroma",
  "pohyb",
  "pointa",
  "pojistka",
  "pojmout",
  "pokazit",
  "pokles",
  "pokoj",
  "pokrok",
  "pokuta",
  "pokyn",
  "poledne",
  "polibek",
  "polknout",
  "poloha",
  "polynom",
  "pomalu",
  "pominout",
  "pomlka",
  "pomoc",
  "pomsta",
  "pomyslet",
  "ponechat",
  "ponorka",
  "ponurost",
  "popadat",
  "popel",
  "popisek",
  "poplach",
  "poprosit",
  "popsat",
  "popud",
  "poradce",
  "porce",
  "porod",
  "porucha",
  "poryv",
  "posadit",
  "posed",
  "posila",
  "poskok",
  "poslanec",
  "posoudit",
  "pospolu",
  "postava",
  "posudek",
  "posyp",
  "potah",
  "potkan",
  "potlesk",
  "potomek",
  "potrava",
  "potupa",
  "potvora",
  "poukaz",
  "pouto",
  "pouzdro",
  "povaha",
  "povidla",
  "povlak",
  "povoz",
  "povrch",
  "povstat",
  "povyk",
  "povzdech",
  "pozdrav",
  "pozemek",
  "poznatek",
  "pozor",
  "pozvat",
  "pracovat",
  "prahory",
  "praktika",
  "prales",
  "praotec",
  "praporek",
  "prase",
  "pravda",
  "princip",
  "prkno",
  "probudit",
  "procento",
  "prodej",
  "profese",
  "prohra",
  "projekt",
  "prolomit",
  "promile",
  "pronikat",
  "propad",
  "prorok",
  "prosba",
  "proton",
  "proutek",
  "provaz",
  "prskavka",
  "prsten",
  "prudkost",
  "prut",
  "prvek",
  "prvohory",
  "psanec",
  "psovod",
  "pstruh",
  "ptactvo",
  "puberta",
  "puch",
  "pudl",
  "pukavec",
  "puklina",
  "pukrle",
  "pult",
  "pumpa",
  "punc",
  "pupen",
  "pusa",
  "pusinka",
  "pustina",
  "putovat",
  "putyka",
  "pyramida",
  "pysk",
  "pytel",
  "racek",
  "rachot",
  "radiace",
  "radnice",
  "radon",
  "raft",
  "ragby",
  "raketa",
  "rakovina",
  "rameno",
  "rampouch",
  "rande",
  "rarach",
  "rarita",
  "rasovna",
  "rastr",
  "ratolest",
  "razance",
  "razidlo",
  "reagovat",
  "reakce",
  "recept",
  "redaktor",
  "referent",
  "reflex",
  "rejnok",
  "reklama",
  "rekord",
  "rekrut",
  "rektor",
  "reputace",
  "revize",
  "revma",
  "revolver",
  "rezerva",
  "riskovat",
  "riziko",
  "robotika",
  "rodokmen",
  "rohovka",
  "rokle",
  "rokoko",
  "romaneto",
  "ropovod",
  "ropucha",
  "rorejs",
  "rosol",
  "rostlina",
  "rotmistr",
  "rotoped",
  "rotunda",
  "roubenka",
  "roucho",
  "roup",
  "roura",
  "rovina",
  "rovnice",
  "rozbor",
  "rozchod",
  "rozdat",
  "rozeznat",
  "rozhodce",
  "rozinka",
  "rozjezd",
  "rozkaz",
  "rozloha",
  "rozmar",
  "rozpad",
  "rozruch",
  "rozsah",
  "roztok",
  "rozum",
  "rozvod",
  "rubrika",
  "ruchadlo",
  "rukavice",
  "rukopis",
  "ryba",
  "rybolov",
  "rychlost",
  "rydlo",
  "rypadlo",
  "rytina",
  "ryzost",
  "sadista",
  "sahat",
  "sako",
  "samec",
  "samizdat",
  "samota",
  "sanitka",
  "sardinka",
  "sasanka",
  "satelit",
  "sazba",
  "sazenice",
  "sbor",
  "schovat",
  "sebranka",
  "secese",
  "sedadlo",
  "sediment",
  "sedlo",
  "sehnat",
  "sejmout",
  "sekera",
  "sekta",
  "sekunda",
  "sekvoje",
  "semeno",
  "seno",
  "servis",
  "sesadit",
  "seshora",
  "seskok",
  "seslat",
  "sestra",
  "sesuv",
  "sesypat",
  "setba",
  "setina",
  "setkat",
  "setnout",
  "setrvat",
  "sever",
  "seznam",
  "shoda",
  "shrnout",
  "sifon",
  "silnice",
  "sirka",
  "sirotek",
  "sirup",
  "situace",
  "skafandr",
  "skalisko",
  "skanzen",
  "skaut",
  "skeptik",
  "skica",
  "skladba",
  "sklenice",
  "sklo",
  "skluz",
  "skoba",
  "skokan",
  "skoro",
  "skripta",
  "skrz",
  "skupina",
  "skvost",
  "skvrna",
  "slabika",
  "sladidlo",
  "slanina",
  "slast",
  "slavnost",
  "sledovat",
  "slepec",
  "sleva",
  "slezina",
  "slib",
  "slina",
  "sliznice",
  "slon",
  "sloupek",
  "slovo",
  "sluch",
  "sluha",
  "slunce",
  "slupka",
  "slza",
  "smaragd",
  "smetana",
  "smilstvo",
  "smlouva",
  "smog",
  "smrad",
  "smrk",
  "smrtka",
  "smutek",
  "smysl",
  "snad",
  "snaha",
  "snob",
  "sobota",
  "socha",
  "sodovka",
  "sokol",
  "sopka",
  "sotva",
  "souboj",
  "soucit",
  "soudce",
  "souhlas",
  "soulad",
  "soumrak",
  "souprava",
  "soused",
  "soutok",
  "souviset",
  "spalovna",
  "spasitel",
  "spis",
  "splav",
  "spodek",
  "spojenec",
  "spolu",
  "sponzor",
  "spornost",
  "spousta",
  "sprcha",
  "spustit",
  "sranda",
  "sraz",
  "srdce",
  "srna",
  "srnec",
  "srovnat",
  "srpen",
  "srst",
  "srub",
  "stanice",
  "starosta",
  "statika",
  "stavba",
  "stehno",
  "stezka",
  "stodola",
  "stolek",
  "stopa",
  "storno",
  "stoupat",
  "strach",
  "stres",
  "strhnout",
  "strom",
  "struna",
  "studna",
  "stupnice",
  "stvol",
  "styk",
  "subjekt",
  "subtropy",
  "suchar",
  "sudost",
  "sukno",
  "sundat",
  "sunout",
  "surikata",
  "surovina",
  "svah",
  "svalstvo",
  "svetr",
  "svatba",
  "svazek",
  "svisle",
  "svitek",
  "svoboda",
  "svodidlo",
  "svorka",
  "svrab",
  "sykavka",
  "sykot",
  "synek",
  "synovec",
  "sypat",
  "sypkost",
  "syrovost",
  "sysel",
  "sytost",
  "tabletka",
  "tabule",
  "tahoun",
  "tajemno",
  "tajfun",
  "tajga",
  "tajit",
  "tajnost",
  "taktika",
  "tamhle",
  "tampon",
  "tancovat",
  "tanec",
  "tanker",
  "tapeta",
  "tavenina",
  "tazatel",
  "technika",
  "tehdy",
  "tekutina",
  "telefon",
  "temnota",
  "tendence",
  "tenista",
  "tenor",
  "teplota",
  "tepna",
  "teprve",
  "terapie",
  "termoska",
  "textil",
  "ticho",
  "tiskopis",
  "titulek",
  "tkadlec",
  "tkanina",
  "tlapka",
  "tleskat",
  "tlukot",
  "tlupa",
  "tmel",
  "toaleta",
  "topinka",
  "topol",
  "torzo",
  "touha",
  "toulec",
  "tradice",
  "traktor",
  "tramp",
  "trasa",
  "traverza",
  "trefit",
  "trest",
  "trezor",
  "trhavina",
  "trhlina",
  "trochu",
  "trojice",
  "troska",
  "trouba",
  "trpce",
  "trpitel",
  "trpkost",
  "trubec",
  "truchlit",
  "truhlice",
  "trus",
  "trvat",
  "tudy",
  "tuhnout",
  "tuhost",
  "tundra",
  "turista",
  "turnaj",
  "tuzemsko",
  "tvaroh",
  "tvorba",
  "tvrdost",
  "tvrz",
  "tygr",
  "tykev",
  "ubohost",
  "uboze",
  "ubrat",
  "ubrousek",
  "ubrus",
  "ubytovna",
  "ucho",
  "uctivost",
  "udivit",
  "uhradit",
  "ujednat",
  "ujistit",
  "ujmout",
  "ukazatel",
  "uklidnit",
  "uklonit",
  "ukotvit",
  "ukrojit",
  "ulice",
  "ulita",
  "ulovit",
  "umyvadlo",
  "unavit",
  "uniforma",
  "uniknout",
  "upadnout",
  "uplatnit",
  "uplynout",
  "upoutat",
  "upravit",
  "uran",
  "urazit",
  "usednout",
  "usilovat",
  "usmrtit",
  "usnadnit",
  "usnout",
  "usoudit",
  "ustlat",
  "ustrnout",
  "utahovat",
  "utkat",
  "utlumit",
  "utonout",
  "utopenec",
  "utrousit",
  "uvalit",
  "uvolnit",
  "uvozovka",
  "uzdravit",
  "uzel",
  "uzenina",
  "uzlina",
  "uznat",
  "vagon",
  "valcha",
  "valoun",
  "vana",
  "vandal",
  "vanilka",
  "varan",
  "varhany",
  "varovat",
  "vcelku",
  "vchod",
  "vdova",
  "vedro",
  "vegetace",
  "vejce",
  "velbloud",
  "veletrh",
  "velitel",
  "velmoc",
  "velryba",
  "venkov",
  "veranda",
  "verze",
  "veselka",
  "veskrze",
  "vesnice",
  "vespodu",
  "vesta",
  "veterina",
  "veverka",
  "vibrace",
  "vichr",
  "videohra",
  "vidina",
  "vidle",
  "vila",
  "vinice",
  "viset",
  "vitalita",
  "vize",
  "vizitka",
  "vjezd",
  "vklad",
  "vkus",
  "vlajka",
  "vlak",
  "vlasec",
  "vlevo",
  "vlhkost",
  "vliv",
  "vlnovka",
  "vloupat",
  "vnucovat",
  "vnuk",
  "voda",
  "vodivost",
  "vodoznak",
  "vodstvo",
  "vojensky",
  "vojna",
  "vojsko",
  "volant",
  "volba",
  "volit",
  "volno",
  "voskovka",
  "vozidlo",
  "vozovna",
  "vpravo",
  "vrabec",
  "vracet",
  "vrah",
  "vrata",
  "vrba",
  "vrcholek",
  "vrhat",
  "vrstva",
  "vrtule",
  "vsadit",
  "vstoupit",
  "vstup",
  "vtip",
  "vybavit",
  "vybrat",
  "vychovat",
  "vydat",
  "vydra",
  "vyfotit",
  "vyhledat",
  "vyhnout",
  "vyhodit",
  "vyhradit",
  "vyhubit",
  "vyjasnit",
  "vyjet",
  "vyjmout",
  "vyklopit",
  "vykonat",
  "vylekat",
  "vymazat",
  "vymezit",
  "vymizet",
  "vymyslet",
  "vynechat",
  "vynikat",
  "vynutit",
  "vypadat",
  "vyplatit",
  "vypravit",
  "vypustit",
  "vyrazit",
  "vyrovnat",
  "vyrvat",
  "vyslovit",
  "vysoko",
  "vystavit",
  "vysunout",
  "vysypat",
  "vytasit",
  "vytesat",
  "vytratit",
  "vyvinout",
  "vyvolat",
  "vyvrhel",
  "vyzdobit",
  "vyznat",
  "vzadu",
  "vzbudit",
  "vzchopit",
  "vzdor",
  "vzduch",
  "vzdychat",
  "vzestup",
  "vzhledem",
  "vzkaz",
  "vzlykat",
  "vznik",
  "vzorek",
  "vzpoura",
  "vztah",
  "vztek",
  "xylofon",
  "zabrat",
  "zabydlet",
  "zachovat",
  "zadarmo",
  "zadusit",
  "zafoukat",
  "zahltit",
  "zahodit",
  "zahrada",
  "zahynout",
  "zajatec",
  "zajet",
  "zajistit",
  "zaklepat",
  "zakoupit",
  "zalepit",
  "zamezit",
  "zamotat",
  "zamyslet",
  "zanechat",
  "zanikat",
  "zaplatit",
  "zapojit",
  "zapsat",
  "zarazit",
  "zastavit",
  "zasunout",
  "zatajit",
  "zatemnit",
  "zatknout",
  "zaujmout",
  "zavalit",
  "zavelet",
  "zavinit",
  "zavolat",
  "zavrtat",
  "zazvonit",
  "zbavit",
  "zbrusu",
  "zbudovat",
  "zbytek",
  "zdaleka",
  "zdarma",
  "zdatnost",
  "zdivo",
  "zdobit",
  "zdroj",
  "zdvih",
  "zdymadlo",
  "zelenina",
  "zeman",
  "zemina",
  "zeptat",
  "zezadu",
  "zezdola",
  "zhatit",
  "zhltnout",
  "zhluboka",
  "zhotovit",
  "zhruba",
  "zima",
  "zimnice",
  "zjemnit",
  "zklamat",
  "zkoumat",
  "zkratka",
  "zkumavka",
  "zlato",
  "zlehka",
  "zloba",
  "zlom",
  "zlost",
  "zlozvyk",
  "zmapovat",
  "zmar",
  "zmatek",
  "zmije",
  "zmizet",
  "zmocnit",
  "zmodrat",
  "zmrzlina",
  "zmutovat",
  "znak",
  "znalost",
  "znamenat",
  "znovu",
  "zobrazit",
  "zotavit",
  "zoubek",
  "zoufale",
  "zplodit",
  "zpomalit",
  "zprava",
  "zprostit",
  "zprudka",
  "zprvu",
  "zrada",
  "zranit",
  "zrcadlo",
  "zrnitost",
  "zrno",
  "zrovna",
  "zrychlit",
  "zrzavost",
  "zticha",
  "ztratit",
  "zubovina",
  "zubr",
  "zvednout",
  "zvenku",
  "zvesela",
  "zvon",
  "zvrat",
  "zvukovod",
  "zvyk"
], ebe = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], tbe = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], rbe = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], nbe = [
  "abaisser",
  "abandon",
  "abdiquer",
  "abeille",
  "abolir",
  "aborder",
  "aboutir",
  "aboyer",
  "abrasif",
  "abreuver",
  "abriter",
  "abroger",
  "abrupt",
  "absence",
  "absolu",
  "absurde",
  "abusif",
  "abyssal",
  "academie",
  "acajou",
  "acarien",
  "accabler",
  "accepter",
  "acclamer",
  "accolade",
  "accroche",
  "accuser",
  "acerbe",
  "achat",
  "acheter",
  "aciduler",
  "acier",
  "acompte",
  "acquerir",
  "acronyme",
  "acteur",
  "actif",
  "actuel",
  "adepte",
  "adequat",
  "adhesif",
  "adjectif",
  "adjuger",
  "admettre",
  "admirer",
  "adopter",
  "adorer",
  "adoucir",
  "adresse",
  "adroit",
  "adulte",
  "adverbe",
  "aerer",
  "aeronef",
  "affaire",
  "affecter",
  "affiche",
  "affreux",
  "affubler",
  "agacer",
  "agencer",
  "agile",
  "agiter",
  "agrafer",
  "agreable",
  "agrume",
  "aider",
  "aiguille",
  "ailier",
  "aimable",
  "aisance",
  "ajouter",
  "ajuster",
  "alarmer",
  "alchimie",
  "alerte",
  "algebre",
  "algue",
  "aliener",
  "aliment",
  "alleger",
  "alliage",
  "allouer",
  "allumer",
  "alourdir",
  "alpaga",
  "altesse",
  "alveole",
  "amateur",
  "ambigu",
  "ambre",
  "amenager",
  "amertume",
  "amidon",
  "amiral",
  "amorcer",
  "amour",
  "amovible",
  "amphibie",
  "ampleur",
  "amusant",
  "analyse",
  "anaphore",
  "anarchie",
  "anatomie",
  "ancien",
  "aneantir",
  "angle",
  "angoisse",
  "anguleux",
  "animal",
  "annexer",
  "annonce",
  "annuel",
  "anodin",
  "anomalie",
  "anonyme",
  "anormal",
  "antenne",
  "antidote",
  "anxieux",
  "apaiser",
  "aperitif",
  "aplanir",
  "apologie",
  "appareil",
  "appeler",
  "apporter",
  "appuyer",
  "aquarium",
  "aqueduc",
  "arbitre",
  "arbuste",
  "ardeur",
  "ardoise",
  "argent",
  "arlequin",
  "armature",
  "armement",
  "armoire",
  "armure",
  "arpenter",
  "arracher",
  "arriver",
  "arroser",
  "arsenic",
  "arteriel",
  "article",
  "aspect",
  "asphalte",
  "aspirer",
  "assaut",
  "asservir",
  "assiette",
  "associer",
  "assurer",
  "asticot",
  "astre",
  "astuce",
  "atelier",
  "atome",
  "atrium",
  "atroce",
  "attaque",
  "attentif",
  "attirer",
  "attraper",
  "aubaine",
  "auberge",
  "audace",
  "audible",
  "augurer",
  "aurore",
  "automne",
  "autruche",
  "avaler",
  "avancer",
  "avarice",
  "avenir",
  "averse",
  "aveugle",
  "aviateur",
  "avide",
  "avion",
  "aviser",
  "avoine",
  "avouer",
  "avril",
  "axial",
  "axiome",
  "badge",
  "bafouer",
  "bagage",
  "baguette",
  "baignade",
  "balancer",
  "balcon",
  "baleine",
  "balisage",
  "bambin",
  "bancaire",
  "bandage",
  "banlieue",
  "banniere",
  "banquier",
  "barbier",
  "baril",
  "baron",
  "barque",
  "barrage",
  "bassin",
  "bastion",
  "bataille",
  "bateau",
  "batterie",
  "baudrier",
  "bavarder",
  "belette",
  "belier",
  "belote",
  "benefice",
  "berceau",
  "berger",
  "berline",
  "bermuda",
  "besace",
  "besogne",
  "betail",
  "beurre",
  "biberon",
  "bicycle",
  "bidule",
  "bijou",
  "bilan",
  "bilingue",
  "billard",
  "binaire",
  "biologie",
  "biopsie",
  "biotype",
  "biscuit",
  "bison",
  "bistouri",
  "bitume",
  "bizarre",
  "blafard",
  "blague",
  "blanchir",
  "blessant",
  "blinder",
  "blond",
  "bloquer",
  "blouson",
  "bobard",
  "bobine",
  "boire",
  "boiser",
  "bolide",
  "bonbon",
  "bondir",
  "bonheur",
  "bonifier",
  "bonus",
  "bordure",
  "borne",
  "botte",
  "boucle",
  "boueux",
  "bougie",
  "boulon",
  "bouquin",
  "bourse",
  "boussole",
  "boutique",
  "boxeur",
  "branche",
  "brasier",
  "brave",
  "brebis",
  "breche",
  "breuvage",
  "bricoler",
  "brigade",
  "brillant",
  "brioche",
  "brique",
  "brochure",
  "broder",
  "bronzer",
  "brousse",
  "broyeur",
  "brume",
  "brusque",
  "brutal",
  "bruyant",
  "buffle",
  "buisson",
  "bulletin",
  "bureau",
  "burin",
  "bustier",
  "butiner",
  "butoir",
  "buvable",
  "buvette",
  "cabanon",
  "cabine",
  "cachette",
  "cadeau",
  "cadre",
  "cafeine",
  "caillou",
  "caisson",
  "calculer",
  "calepin",
  "calibre",
  "calmer",
  "calomnie",
  "calvaire",
  "camarade",
  "camera",
  "camion",
  "campagne",
  "canal",
  "caneton",
  "canon",
  "cantine",
  "canular",
  "capable",
  "caporal",
  "caprice",
  "capsule",
  "capter",
  "capuche",
  "carabine",
  "carbone",
  "caresser",
  "caribou",
  "carnage",
  "carotte",
  "carreau",
  "carton",
  "cascade",
  "casier",
  "casque",
  "cassure",
  "causer",
  "caution",
  "cavalier",
  "caverne",
  "caviar",
  "cedille",
  "ceinture",
  "celeste",
  "cellule",
  "cendrier",
  "censurer",
  "central",
  "cercle",
  "cerebral",
  "cerise",
  "cerner",
  "cerveau",
  "cesser",
  "chagrin",
  "chaise",
  "chaleur",
  "chambre",
  "chance",
  "chapitre",
  "charbon",
  "chasseur",
  "chaton",
  "chausson",
  "chavirer",
  "chemise",
  "chenille",
  "chequier",
  "chercher",
  "cheval",
  "chien",
  "chiffre",
  "chignon",
  "chimere",
  "chiot",
  "chlorure",
  "chocolat",
  "choisir",
  "chose",
  "chouette",
  "chrome",
  "chute",
  "cigare",
  "cigogne",
  "cimenter",
  "cinema",
  "cintrer",
  "circuler",
  "cirer",
  "cirque",
  "citerne",
  "citoyen",
  "citron",
  "civil",
  "clairon",
  "clameur",
  "claquer",
  "classe",
  "clavier",
  "client",
  "cligner",
  "climat",
  "clivage",
  "cloche",
  "clonage",
  "cloporte",
  "cobalt",
  "cobra",
  "cocasse",
  "cocotier",
  "coder",
  "codifier",
  "coffre",
  "cogner",
  "cohesion",
  "coiffer",
  "coincer",
  "colere",
  "colibri",
  "colline",
  "colmater",
  "colonel",
  "combat",
  "comedie",
  "commande",
  "compact",
  "concert",
  "conduire",
  "confier",
  "congeler",
  "connoter",
  "consonne",
  "contact",
  "convexe",
  "copain",
  "copie",
  "corail",
  "corbeau",
  "cordage",
  "corniche",
  "corpus",
  "correct",
  "cortege",
  "cosmique",
  "costume",
  "coton",
  "coude",
  "coupure",
  "courage",
  "couteau",
  "couvrir",
  "coyote",
  "crabe",
  "crainte",
  "cravate",
  "crayon",
  "creature",
  "crediter",
  "cremeux",
  "creuser",
  "crevette",
  "cribler",
  "crier",
  "cristal",
  "critere",
  "croire",
  "croquer",
  "crotale",
  "crucial",
  "cruel",
  "crypter",
  "cubique",
  "cueillir",
  "cuillere",
  "cuisine",
  "cuivre",
  "culminer",
  "cultiver",
  "cumuler",
  "cupide",
  "curatif",
  "curseur",
  "cyanure",
  "cycle",
  "cylindre",
  "cynique",
  "daigner",
  "damier",
  "danger",
  "danseur",
  "dauphin",
  "debattre",
  "debiter",
  "deborder",
  "debrider",
  "debutant",
  "decaler",
  "decembre",
  "dechirer",
  "decider",
  "declarer",
  "decorer",
  "decrire",
  "decupler",
  "dedale",
  "deductif",
  "deesse",
  "defensif",
  "defiler",
  "defrayer",
  "degager",
  "degivrer",
  "deglutir",
  "degrafer",
  "dejeuner",
  "delice",
  "deloger",
  "demander",
  "demeurer",
  "demolir",
  "denicher",
  "denouer",
  "dentelle",
  "denuder",
  "depart",
  "depenser",
  "dephaser",
  "deplacer",
  "deposer",
  "deranger",
  "derober",
  "desastre",
  "descente",
  "desert",
  "designer",
  "desobeir",
  "dessiner",
  "destrier",
  "detacher",
  "detester",
  "detourer",
  "detresse",
  "devancer",
  "devenir",
  "deviner",
  "devoir",
  "diable",
  "dialogue",
  "diamant",
  "dicter",
  "differer",
  "digerer",
  "digital",
  "digne",
  "diluer",
  "dimanche",
  "diminuer",
  "dioxyde",
  "directif",
  "diriger",
  "discuter",
  "disposer",
  "dissiper",
  "distance",
  "divertir",
  "diviser",
  "docile",
  "docteur",
  "dogme",
  "doigt",
  "domaine",
  "domicile",
  "dompter",
  "donateur",
  "donjon",
  "donner",
  "dopamine",
  "dortoir",
  "dorure",
  "dosage",
  "doseur",
  "dossier",
  "dotation",
  "douanier",
  "double",
  "douceur",
  "douter",
  "doyen",
  "dragon",
  "draper",
  "dresser",
  "dribbler",
  "droiture",
  "duperie",
  "duplexe",
  "durable",
  "durcir",
  "dynastie",
  "eblouir",
  "ecarter",
  "echarpe",
  "echelle",
  "eclairer",
  "eclipse",
  "eclore",
  "ecluse",
  "ecole",
  "economie",
  "ecorce",
  "ecouter",
  "ecraser",
  "ecremer",
  "ecrivain",
  "ecrou",
  "ecume",
  "ecureuil",
  "edifier",
  "eduquer",
  "effacer",
  "effectif",
  "effigie",
  "effort",
  "effrayer",
  "effusion",
  "egaliser",
  "egarer",
  "ejecter",
  "elaborer",
  "elargir",
  "electron",
  "elegant",
  "elephant",
  "eleve",
  "eligible",
  "elitisme",
  "eloge",
  "elucider",
  "eluder",
  "emballer",
  "embellir",
  "embryon",
  "emeraude",
  "emission",
  "emmener",
  "emotion",
  "emouvoir",
  "empereur",
  "employer",
  "emporter",
  "emprise",
  "emulsion",
  "encadrer",
  "enchere",
  "enclave",
  "encoche",
  "endiguer",
  "endosser",
  "endroit",
  "enduire",
  "energie",
  "enfance",
  "enfermer",
  "enfouir",
  "engager",
  "engin",
  "englober",
  "enigme",
  "enjamber",
  "enjeu",
  "enlever",
  "ennemi",
  "ennuyeux",
  "enrichir",
  "enrobage",
  "enseigne",
  "entasser",
  "entendre",
  "entier",
  "entourer",
  "entraver",
  "enumerer",
  "envahir",
  "enviable",
  "envoyer",
  "enzyme",
  "eolien",
  "epaissir",
  "epargne",
  "epatant",
  "epaule",
  "epicerie",
  "epidemie",
  "epier",
  "epilogue",
  "epine",
  "episode",
  "epitaphe",
  "epoque",
  "epreuve",
  "eprouver",
  "epuisant",
  "equerre",
  "equipe",
  "eriger",
  "erosion",
  "erreur",
  "eruption",
  "escalier",
  "espadon",
  "espece",
  "espiegle",
  "espoir",
  "esprit",
  "esquiver",
  "essayer",
  "essence",
  "essieu",
  "essorer",
  "estime",
  "estomac",
  "estrade",
  "etagere",
  "etaler",
  "etanche",
  "etatique",
  "eteindre",
  "etendoir",
  "eternel",
  "ethanol",
  "ethique",
  "ethnie",
  "etirer",
  "etoffer",
  "etoile",
  "etonnant",
  "etourdir",
  "etrange",
  "etroit",
  "etude",
  "euphorie",
  "evaluer",
  "evasion",
  "eventail",
  "evidence",
  "eviter",
  "evolutif",
  "evoquer",
  "exact",
  "exagerer",
  "exaucer",
  "exceller",
  "excitant",
  "exclusif",
  "excuse",
  "executer",
  "exemple",
  "exercer",
  "exhaler",
  "exhorter",
  "exigence",
  "exiler",
  "exister",
  "exotique",
  "expedier",
  "explorer",
  "exposer",
  "exprimer",
  "exquis",
  "extensif",
  "extraire",
  "exulter",
  "fable",
  "fabuleux",
  "facette",
  "facile",
  "facture",
  "faiblir",
  "falaise",
  "fameux",
  "famille",
  "farceur",
  "farfelu",
  "farine",
  "farouche",
  "fasciner",
  "fatal",
  "fatigue",
  "faucon",
  "fautif",
  "faveur",
  "favori",
  "febrile",
  "feconder",
  "federer",
  "felin",
  "femme",
  "femur",
  "fendoir",
  "feodal",
  "fermer",
  "feroce",
  "ferveur",
  "festival",
  "feuille",
  "feutre",
  "fevrier",
  "fiasco",
  "ficeler",
  "fictif",
  "fidele",
  "figure",
  "filature",
  "filetage",
  "filiere",
  "filleul",
  "filmer",
  "filou",
  "filtrer",
  "financer",
  "finir",
  "fiole",
  "firme",
  "fissure",
  "fixer",
  "flairer",
  "flamme",
  "flasque",
  "flatteur",
  "fleau",
  "fleche",
  "fleur",
  "flexion",
  "flocon",
  "flore",
  "fluctuer",
  "fluide",
  "fluvial",
  "folie",
  "fonderie",
  "fongible",
  "fontaine",
  "forcer",
  "forgeron",
  "formuler",
  "fortune",
  "fossile",
  "foudre",
  "fougere",
  "fouiller",
  "foulure",
  "fourmi",
  "fragile",
  "fraise",
  "franchir",
  "frapper",
  "frayeur",
  "fregate",
  "freiner",
  "frelon",
  "fremir",
  "frenesie",
  "frere",
  "friable",
  "friction",
  "frisson",
  "frivole",
  "froid",
  "fromage",
  "frontal",
  "frotter",
  "fruit",
  "fugitif",
  "fuite",
  "fureur",
  "furieux",
  "furtif",
  "fusion",
  "futur",
  "gagner",
  "galaxie",
  "galerie",
  "gambader",
  "garantir",
  "gardien",
  "garnir",
  "garrigue",
  "gazelle",
  "gazon",
  "geant",
  "gelatine",
  "gelule",
  "gendarme",
  "general",
  "genie",
  "genou",
  "gentil",
  "geologie",
  "geometre",
  "geranium",
  "germe",
  "gestuel",
  "geyser",
  "gibier",
  "gicler",
  "girafe",
  "givre",
  "glace",
  "glaive",
  "glisser",
  "globe",
  "gloire",
  "glorieux",
  "golfeur",
  "gomme",
  "gonfler",
  "gorge",
  "gorille",
  "goudron",
  "gouffre",
  "goulot",
  "goupille",
  "gourmand",
  "goutte",
  "graduel",
  "graffiti",
  "graine",
  "grand",
  "grappin",
  "gratuit",
  "gravir",
  "grenat",
  "griffure",
  "griller",
  "grimper",
  "grogner",
  "gronder",
  "grotte",
  "groupe",
  "gruger",
  "grutier",
  "gruyere",
  "guepard",
  "guerrier",
  "guide",
  "guimauve",
  "guitare",
  "gustatif",
  "gymnaste",
  "gyrostat",
  "habitude",
  "hachoir",
  "halte",
  "hameau",
  "hangar",
  "hanneton",
  "haricot",
  "harmonie",
  "harpon",
  "hasard",
  "helium",
  "hematome",
  "herbe",
  "herisson",
  "hermine",
  "heron",
  "hesiter",
  "heureux",
  "hiberner",
  "hibou",
  "hilarant",
  "histoire",
  "hiver",
  "homard",
  "hommage",
  "homogene",
  "honneur",
  "honorer",
  "honteux",
  "horde",
  "horizon",
  "horloge",
  "hormone",
  "horrible",
  "houleux",
  "housse",
  "hublot",
  "huileux",
  "humain",
  "humble",
  "humide",
  "humour",
  "hurler",
  "hydromel",
  "hygiene",
  "hymne",
  "hypnose",
  "idylle",
  "ignorer",
  "iguane",
  "illicite",
  "illusion",
  "image",
  "imbiber",
  "imiter",
  "immense",
  "immobile",
  "immuable",
  "impact",
  "imperial",
  "implorer",
  "imposer",
  "imprimer",
  "imputer",
  "incarner",
  "incendie",
  "incident",
  "incliner",
  "incolore",
  "indexer",
  "indice",
  "inductif",
  "inedit",
  "ineptie",
  "inexact",
  "infini",
  "infliger",
  "informer",
  "infusion",
  "ingerer",
  "inhaler",
  "inhiber",
  "injecter",
  "injure",
  "innocent",
  "inoculer",
  "inonder",
  "inscrire",
  "insecte",
  "insigne",
  "insolite",
  "inspirer",
  "instinct",
  "insulter",
  "intact",
  "intense",
  "intime",
  "intrigue",
  "intuitif",
  "inutile",
  "invasion",
  "inventer",
  "inviter",
  "invoquer",
  "ironique",
  "irradier",
  "irreel",
  "irriter",
  "isoler",
  "ivoire",
  "ivresse",
  "jaguar",
  "jaillir",
  "jambe",
  "janvier",
  "jardin",
  "jauger",
  "jaune",
  "javelot",
  "jetable",
  "jeton",
  "jeudi",
  "jeunesse",
  "joindre",
  "joncher",
  "jongler",
  "joueur",
  "jouissif",
  "journal",
  "jovial",
  "joyau",
  "joyeux",
  "jubiler",
  "jugement",
  "junior",
  "jupon",
  "juriste",
  "justice",
  "juteux",
  "juvenile",
  "kayak",
  "kimono",
  "kiosque",
  "label",
  "labial",
  "labourer",
  "lacerer",
  "lactose",
  "lagune",
  "laine",
  "laisser",
  "laitier",
  "lambeau",
  "lamelle",
  "lampe",
  "lanceur",
  "langage",
  "lanterne",
  "lapin",
  "largeur",
  "larme",
  "laurier",
  "lavabo",
  "lavoir",
  "lecture",
  "legal",
  "leger",
  "legume",
  "lessive",
  "lettre",
  "levier",
  "lexique",
  "lezard",
  "liasse",
  "liberer",
  "libre",
  "licence",
  "licorne",
  "liege",
  "lievre",
  "ligature",
  "ligoter",
  "ligue",
  "limer",
  "limite",
  "limonade",
  "limpide",
  "lineaire",
  "lingot",
  "lionceau",
  "liquide",
  "lisiere",
  "lister",
  "lithium",
  "litige",
  "littoral",
  "livreur",
  "logique",
  "lointain",
  "loisir",
  "lombric",
  "loterie",
  "louer",
  "lourd",
  "loutre",
  "louve",
  "loyal",
  "lubie",
  "lucide",
  "lucratif",
  "lueur",
  "lugubre",
  "luisant",
  "lumiere",
  "lunaire",
  "lundi",
  "luron",
  "lutter",
  "luxueux",
  "machine",
  "magasin",
  "magenta",
  "magique",
  "maigre",
  "maillon",
  "maintien",
  "mairie",
  "maison",
  "majorer",
  "malaxer",
  "malefice",
  "malheur",
  "malice",
  "mallette",
  "mammouth",
  "mandater",
  "maniable",
  "manquant",
  "manteau",
  "manuel",
  "marathon",
  "marbre",
  "marchand",
  "mardi",
  "maritime",
  "marqueur",
  "marron",
  "marteler",
  "mascotte",
  "massif",
  "materiel",
  "matiere",
  "matraque",
  "maudire",
  "maussade",
  "mauve",
  "maximal",
  "mechant",
  "meconnu",
  "medaille",
  "medecin",
  "mediter",
  "meduse",
  "meilleur",
  "melange",
  "melodie",
  "membre",
  "memoire",
  "menacer",
  "mener",
  "menhir",
  "mensonge",
  "mentor",
  "mercredi",
  "merite",
  "merle",
  "messager",
  "mesure",
  "metal",
  "meteore",
  "methode",
  "metier",
  "meuble",
  "miauler",
  "microbe",
  "miette",
  "mignon",
  "migrer",
  "milieu",
  "million",
  "mimique",
  "mince",
  "mineral",
  "minimal",
  "minorer",
  "minute",
  "miracle",
  "miroiter",
  "missile",
  "mixte",
  "mobile",
  "moderne",
  "moelleux",
  "mondial",
  "moniteur",
  "monnaie",
  "monotone",
  "monstre",
  "montagne",
  "monument",
  "moqueur",
  "morceau",
  "morsure",
  "mortier",
  "moteur",
  "motif",
  "mouche",
  "moufle",
  "moulin",
  "mousson",
  "mouton",
  "mouvant",
  "multiple",
  "munition",
  "muraille",
  "murene",
  "murmure",
  "muscle",
  "museum",
  "musicien",
  "mutation",
  "muter",
  "mutuel",
  "myriade",
  "myrtille",
  "mystere",
  "mythique",
  "nageur",
  "nappe",
  "narquois",
  "narrer",
  "natation",
  "nation",
  "nature",
  "naufrage",
  "nautique",
  "navire",
  "nebuleux",
  "nectar",
  "nefaste",
  "negation",
  "negliger",
  "negocier",
  "neige",
  "nerveux",
  "nettoyer",
  "neurone",
  "neutron",
  "neveu",
  "niche",
  "nickel",
  "nitrate",
  "niveau",
  "noble",
  "nocif",
  "nocturne",
  "noirceur",
  "noisette",
  "nomade",
  "nombreux",
  "nommer",
  "normatif",
  "notable",
  "notifier",
  "notoire",
  "nourrir",
  "nouveau",
  "novateur",
  "novembre",
  "novice",
  "nuage",
  "nuancer",
  "nuire",
  "nuisible",
  "numero",
  "nuptial",
  "nuque",
  "nutritif",
  "obeir",
  "objectif",
  "obliger",
  "obscur",
  "observer",
  "obstacle",
  "obtenir",
  "obturer",
  "occasion",
  "occuper",
  "ocean",
  "octobre",
  "octroyer",
  "octupler",
  "oculaire",
  "odeur",
  "odorant",
  "offenser",
  "officier",
  "offrir",
  "ogive",
  "oiseau",
  "oisillon",
  "olfactif",
  "olivier",
  "ombrage",
  "omettre",
  "onctueux",
  "onduler",
  "onereux",
  "onirique",
  "opale",
  "opaque",
  "operer",
  "opinion",
  "opportun",
  "opprimer",
  "opter",
  "optique",
  "orageux",
  "orange",
  "orbite",
  "ordonner",
  "oreille",
  "organe",
  "orgueil",
  "orifice",
  "ornement",
  "orque",
  "ortie",
  "osciller",
  "osmose",
  "ossature",
  "otarie",
  "ouragan",
  "ourson",
  "outil",
  "outrager",
  "ouvrage",
  "ovation",
  "oxyde",
  "oxygene",
  "ozone",
  "paisible",
  "palace",
  "palmares",
  "palourde",
  "palper",
  "panache",
  "panda",
  "pangolin",
  "paniquer",
  "panneau",
  "panorama",
  "pantalon",
  "papaye",
  "papier",
  "papoter",
  "papyrus",
  "paradoxe",
  "parcelle",
  "paresse",
  "parfumer",
  "parler",
  "parole",
  "parrain",
  "parsemer",
  "partager",
  "parure",
  "parvenir",
  "passion",
  "pasteque",
  "paternel",
  "patience",
  "patron",
  "pavillon",
  "pavoiser",
  "payer",
  "paysage",
  "peigne",
  "peintre",
  "pelage",
  "pelican",
  "pelle",
  "pelouse",
  "peluche",
  "pendule",
  "penetrer",
  "penible",
  "pensif",
  "penurie",
  "pepite",
  "peplum",
  "perdrix",
  "perforer",
  "periode",
  "permuter",
  "perplexe",
  "persil",
  "perte",
  "peser",
  "petale",
  "petit",
  "petrir",
  "peuple",
  "pharaon",
  "phobie",
  "phoque",
  "photon",
  "phrase",
  "physique",
  "piano",
  "pictural",
  "piece",
  "pierre",
  "pieuvre",
  "pilote",
  "pinceau",
  "pipette",
  "piquer",
  "pirogue",
  "piscine",
  "piston",
  "pivoter",
  "pixel",
  "pizza",
  "placard",
  "plafond",
  "plaisir",
  "planer",
  "plaque",
  "plastron",
  "plateau",
  "pleurer",
  "plexus",
  "pliage",
  "plomb",
  "plonger",
  "pluie",
  "plumage",
  "pochette",
  "poesie",
  "poete",
  "pointe",
  "poirier",
  "poisson",
  "poivre",
  "polaire",
  "policier",
  "pollen",
  "polygone",
  "pommade",
  "pompier",
  "ponctuel",
  "ponderer",
  "poney",
  "portique",
  "position",
  "posseder",
  "posture",
  "potager",
  "poteau",
  "potion",
  "pouce",
  "poulain",
  "poumon",
  "pourpre",
  "poussin",
  "pouvoir",
  "prairie",
  "pratique",
  "precieux",
  "predire",
  "prefixe",
  "prelude",
  "prenom",
  "presence",
  "pretexte",
  "prevoir",
  "primitif",
  "prince",
  "prison",
  "priver",
  "probleme",
  "proceder",
  "prodige",
  "profond",
  "progres",
  "proie",
  "projeter",
  "prologue",
  "promener",
  "propre",
  "prospere",
  "proteger",
  "prouesse",
  "proverbe",
  "prudence",
  "pruneau",
  "psychose",
  "public",
  "puceron",
  "puiser",
  "pulpe",
  "pulsar",
  "punaise",
  "punitif",
  "pupitre",
  "purifier",
  "puzzle",
  "pyramide",
  "quasar",
  "querelle",
  "question",
  "quietude",
  "quitter",
  "quotient",
  "racine",
  "raconter",
  "radieux",
  "ragondin",
  "raideur",
  "raisin",
  "ralentir",
  "rallonge",
  "ramasser",
  "rapide",
  "rasage",
  "ratisser",
  "ravager",
  "ravin",
  "rayonner",
  "reactif",
  "reagir",
  "realiser",
  "reanimer",
  "recevoir",
  "reciter",
  "reclamer",
  "recolter",
  "recruter",
  "reculer",
  "recycler",
  "rediger",
  "redouter",
  "refaire",
  "reflexe",
  "reformer",
  "refrain",
  "refuge",
  "regalien",
  "region",
  "reglage",
  "regulier",
  "reiterer",
  "rejeter",
  "rejouer",
  "relatif",
  "relever",
  "relief",
  "remarque",
  "remede",
  "remise",
  "remonter",
  "remplir",
  "remuer",
  "renard",
  "renfort",
  "renifler",
  "renoncer",
  "rentrer",
  "renvoi",
  "replier",
  "reporter",
  "reprise",
  "reptile",
  "requin",
  "reserve",
  "resineux",
  "resoudre",
  "respect",
  "rester",
  "resultat",
  "retablir",
  "retenir",
  "reticule",
  "retomber",
  "retracer",
  "reunion",
  "reussir",
  "revanche",
  "revivre",
  "revolte",
  "revulsif",
  "richesse",
  "rideau",
  "rieur",
  "rigide",
  "rigoler",
  "rincer",
  "riposter",
  "risible",
  "risque",
  "rituel",
  "rival",
  "riviere",
  "rocheux",
  "romance",
  "rompre",
  "ronce",
  "rondin",
  "roseau",
  "rosier",
  "rotatif",
  "rotor",
  "rotule",
  "rouge",
  "rouille",
  "rouleau",
  "routine",
  "royaume",
  "ruban",
  "rubis",
  "ruche",
  "ruelle",
  "rugueux",
  "ruiner",
  "ruisseau",
  "ruser",
  "rustique",
  "rythme",
  "sabler",
  "saboter",
  "sabre",
  "sacoche",
  "safari",
  "sagesse",
  "saisir",
  "salade",
  "salive",
  "salon",
  "saluer",
  "samedi",
  "sanction",
  "sanglier",
  "sarcasme",
  "sardine",
  "saturer",
  "saugrenu",
  "saumon",
  "sauter",
  "sauvage",
  "savant",
  "savonner",
  "scalpel",
  "scandale",
  "scelerat",
  "scenario",
  "sceptre",
  "schema",
  "science",
  "scinder",
  "score",
  "scrutin",
  "sculpter",
  "seance",
  "secable",
  "secher",
  "secouer",
  "secreter",
  "sedatif",
  "seduire",
  "seigneur",
  "sejour",
  "selectif",
  "semaine",
  "sembler",
  "semence",
  "seminal",
  "senateur",
  "sensible",
  "sentence",
  "separer",
  "sequence",
  "serein",
  "sergent",
  "serieux",
  "serrure",
  "serum",
  "service",
  "sesame",
  "sevir",
  "sevrage",
  "sextuple",
  "sideral",
  "siecle",
  "sieger",
  "siffler",
  "sigle",
  "signal",
  "silence",
  "silicium",
  "simple",
  "sincere",
  "sinistre",
  "siphon",
  "sirop",
  "sismique",
  "situer",
  "skier",
  "social",
  "socle",
  "sodium",
  "soigneux",
  "soldat",
  "soleil",
  "solitude",
  "soluble",
  "sombre",
  "sommeil",
  "somnoler",
  "sonde",
  "songeur",
  "sonnette",
  "sonore",
  "sorcier",
  "sortir",
  "sosie",
  "sottise",
  "soucieux",
  "soudure",
  "souffle",
  "soulever",
  "soupape",
  "source",
  "soutirer",
  "souvenir",
  "spacieux",
  "spatial",
  "special",
  "sphere",
  "spiral",
  "stable",
  "station",
  "sternum",
  "stimulus",
  "stipuler",
  "strict",
  "studieux",
  "stupeur",
  "styliste",
  "sublime",
  "substrat",
  "subtil",
  "subvenir",
  "succes",
  "sucre",
  "suffixe",
  "suggerer",
  "suiveur",
  "sulfate",
  "superbe",
  "supplier",
  "surface",
  "suricate",
  "surmener",
  "surprise",
  "sursaut",
  "survie",
  "suspect",
  "syllabe",
  "symbole",
  "symetrie",
  "synapse",
  "syntaxe",
  "systeme",
  "tabac",
  "tablier",
  "tactile",
  "tailler",
  "talent",
  "talisman",
  "talonner",
  "tambour",
  "tamiser",
  "tangible",
  "tapis",
  "taquiner",
  "tarder",
  "tarif",
  "tartine",
  "tasse",
  "tatami",
  "tatouage",
  "taupe",
  "taureau",
  "taxer",
  "temoin",
  "temporel",
  "tenaille",
  "tendre",
  "teneur",
  "tenir",
  "tension",
  "terminer",
  "terne",
  "terrible",
  "tetine",
  "texte",
  "theme",
  "theorie",
  "therapie",
  "thorax",
  "tibia",
  "tiede",
  "timide",
  "tirelire",
  "tiroir",
  "tissu",
  "titane",
  "titre",
  "tituber",
  "toboggan",
  "tolerant",
  "tomate",
  "tonique",
  "tonneau",
  "toponyme",
  "torche",
  "tordre",
  "tornade",
  "torpille",
  "torrent",
  "torse",
  "tortue",
  "totem",
  "toucher",
  "tournage",
  "tousser",
  "toxine",
  "traction",
  "trafic",
  "tragique",
  "trahir",
  "train",
  "trancher",
  "travail",
  "trefle",
  "tremper",
  "tresor",
  "treuil",
  "triage",
  "tribunal",
  "tricoter",
  "trilogie",
  "triomphe",
  "tripler",
  "triturer",
  "trivial",
  "trombone",
  "tronc",
  "tropical",
  "troupeau",
  "tuile",
  "tulipe",
  "tumulte",
  "tunnel",
  "turbine",
  "tuteur",
  "tutoyer",
  "tuyau",
  "tympan",
  "typhon",
  "typique",
  "tyran",
  "ubuesque",
  "ultime",
  "ultrason",
  "unanime",
  "unifier",
  "union",
  "unique",
  "unitaire",
  "univers",
  "uranium",
  "urbain",
  "urticant",
  "usage",
  "usine",
  "usuel",
  "usure",
  "utile",
  "utopie",
  "vacarme",
  "vaccin",
  "vagabond",
  "vague",
  "vaillant",
  "vaincre",
  "vaisseau",
  "valable",
  "valise",
  "vallon",
  "valve",
  "vampire",
  "vanille",
  "vapeur",
  "varier",
  "vaseux",
  "vassal",
  "vaste",
  "vecteur",
  "vedette",
  "vegetal",
  "vehicule",
  "veinard",
  "veloce",
  "vendredi",
  "venerer",
  "venger",
  "venimeux",
  "ventouse",
  "verdure",
  "verin",
  "vernir",
  "verrou",
  "verser",
  "vertu",
  "veston",
  "veteran",
  "vetuste",
  "vexant",
  "vexer",
  "viaduc",
  "viande",
  "victoire",
  "vidange",
  "video",
  "vignette",
  "vigueur",
  "vilain",
  "village",
  "vinaigre",
  "violon",
  "vipere",
  "virement",
  "virtuose",
  "virus",
  "visage",
  "viseur",
  "vision",
  "visqueux",
  "visuel",
  "vital",
  "vitesse",
  "viticole",
  "vitrine",
  "vivace",
  "vivipare",
  "vocation",
  "voguer",
  "voile",
  "voisin",
  "voiture",
  "volaille",
  "volcan",
  "voltiger",
  "volume",
  "vorace",
  "vortex",
  "voter",
  "vouloir",
  "voyage",
  "voyelle",
  "wagon",
  "xenon",
  "yacht",
  "zebre",
  "zenith",
  "zeste",
  "zoologie"
], obe = [
  "abaco",
  "abbaglio",
  "abbinato",
  "abete",
  "abisso",
  "abolire",
  "abrasivo",
  "abrogato",
  "accadere",
  "accenno",
  "accusato",
  "acetone",
  "achille",
  "acido",
  "acqua",
  "acre",
  "acrilico",
  "acrobata",
  "acuto",
  "adagio",
  "addebito",
  "addome",
  "adeguato",
  "aderire",
  "adipe",
  "adottare",
  "adulare",
  "affabile",
  "affetto",
  "affisso",
  "affranto",
  "aforisma",
  "afoso",
  "africano",
  "agave",
  "agente",
  "agevole",
  "aggancio",
  "agire",
  "agitare",
  "agonismo",
  "agricolo",
  "agrumeto",
  "aguzzo",
  "alabarda",
  "alato",
  "albatro",
  "alberato",
  "albo",
  "albume",
  "alce",
  "alcolico",
  "alettone",
  "alfa",
  "algebra",
  "aliante",
  "alibi",
  "alimento",
  "allagato",
  "allegro",
  "allievo",
  "allodola",
  "allusivo",
  "almeno",
  "alogeno",
  "alpaca",
  "alpestre",
  "altalena",
  "alterno",
  "alticcio",
  "altrove",
  "alunno",
  "alveolo",
  "alzare",
  "amalgama",
  "amanita",
  "amarena",
  "ambito",
  "ambrato",
  "ameba",
  "america",
  "ametista",
  "amico",
  "ammasso",
  "ammenda",
  "ammirare",
  "ammonito",
  "amore",
  "ampio",
  "ampliare",
  "amuleto",
  "anacardo",
  "anagrafe",
  "analista",
  "anarchia",
  "anatra",
  "anca",
  "ancella",
  "ancora",
  "andare",
  "andrea",
  "anello",
  "angelo",
  "angolare",
  "angusto",
  "anima",
  "annegare",
  "annidato",
  "anno",
  "annuncio",
  "anonimo",
  "anticipo",
  "anzi",
  "apatico",
  "apertura",
  "apode",
  "apparire",
  "appetito",
  "appoggio",
  "approdo",
  "appunto",
  "aprile",
  "arabica",
  "arachide",
  "aragosta",
  "araldica",
  "arancio",
  "aratura",
  "arazzo",
  "arbitro",
  "archivio",
  "ardito",
  "arenile",
  "argento",
  "argine",
  "arguto",
  "aria",
  "armonia",
  "arnese",
  "arredato",
  "arringa",
  "arrosto",
  "arsenico",
  "arso",
  "artefice",
  "arzillo",
  "asciutto",
  "ascolto",
  "asepsi",
  "asettico",
  "asfalto",
  "asino",
  "asola",
  "aspirato",
  "aspro",
  "assaggio",
  "asse",
  "assoluto",
  "assurdo",
  "asta",
  "astenuto",
  "astice",
  "astratto",
  "atavico",
  "ateismo",
  "atomico",
  "atono",
  "attesa",
  "attivare",
  "attorno",
  "attrito",
  "attuale",
  "ausilio",
  "austria",
  "autista",
  "autonomo",
  "autunno",
  "avanzato",
  "avere",
  "avvenire",
  "avviso",
  "avvolgere",
  "azione",
  "azoto",
  "azzimo",
  "azzurro",
  "babele",
  "baccano",
  "bacino",
  "baco",
  "badessa",
  "badilata",
  "bagnato",
  "baita",
  "balcone",
  "baldo",
  "balena",
  "ballata",
  "balzano",
  "bambino",
  "bandire",
  "baraonda",
  "barbaro",
  "barca",
  "baritono",
  "barlume",
  "barocco",
  "basilico",
  "basso",
  "batosta",
  "battuto",
  "baule",
  "bava",
  "bavosa",
  "becco",
  "beffa",
  "belgio",
  "belva",
  "benda",
  "benevole",
  "benigno",
  "benzina",
  "bere",
  "berlina",
  "beta",
  "bibita",
  "bici",
  "bidone",
  "bifido",
  "biga",
  "bilancia",
  "bimbo",
  "binocolo",
  "biologo",
  "bipede",
  "bipolare",
  "birbante",
  "birra",
  "biscotto",
  "bisesto",
  "bisnonno",
  "bisonte",
  "bisturi",
  "bizzarro",
  "blando",
  "blatta",
  "bollito",
  "bonifico",
  "bordo",
  "bosco",
  "botanico",
  "bottino",
  "bozzolo",
  "braccio",
  "bradipo",
  "brama",
  "branca",
  "bravura",
  "bretella",
  "brevetto",
  "brezza",
  "briglia",
  "brillante",
  "brindare",
  "broccolo",
  "brodo",
  "bronzina",
  "brullo",
  "bruno",
  "bubbone",
  "buca",
  "budino",
  "buffone",
  "buio",
  "bulbo",
  "buono",
  "burlone",
  "burrasca",
  "bussola",
  "busta",
  "cadetto",
  "caduco",
  "calamaro",
  "calcolo",
  "calesse",
  "calibro",
  "calmo",
  "caloria",
  "cambusa",
  "camerata",
  "camicia",
  "cammino",
  "camola",
  "campale",
  "canapa",
  "candela",
  "cane",
  "canino",
  "canotto",
  "cantina",
  "capace",
  "capello",
  "capitolo",
  "capogiro",
  "cappero",
  "capra",
  "capsula",
  "carapace",
  "carcassa",
  "cardo",
  "carisma",
  "carovana",
  "carretto",
  "cartolina",
  "casaccio",
  "cascata",
  "caserma",
  "caso",
  "cassone",
  "castello",
  "casuale",
  "catasta",
  "catena",
  "catrame",
  "cauto",
  "cavillo",
  "cedibile",
  "cedrata",
  "cefalo",
  "celebre",
  "cellulare",
  "cena",
  "cenone",
  "centesimo",
  "ceramica",
  "cercare",
  "certo",
  "cerume",
  "cervello",
  "cesoia",
  "cespo",
  "ceto",
  "chela",
  "chiaro",
  "chicca",
  "chiedere",
  "chimera",
  "china",
  "chirurgo",
  "chitarra",
  "ciao",
  "ciclismo",
  "cifrare",
  "cigno",
  "cilindro",
  "ciottolo",
  "circa",
  "cirrosi",
  "citrico",
  "cittadino",
  "ciuffo",
  "civetta",
  "civile",
  "classico",
  "clinica",
  "cloro",
  "cocco",
  "codardo",
  "codice",
  "coerente",
  "cognome",
  "collare",
  "colmato",
  "colore",
  "colposo",
  "coltivato",
  "colza",
  "coma",
  "cometa",
  "commando",
  "comodo",
  "computer",
  "comune",
  "conciso",
  "condurre",
  "conferma",
  "congelare",
  "coniuge",
  "connesso",
  "conoscere",
  "consumo",
  "continuo",
  "convegno",
  "coperto",
  "copione",
  "coppia",
  "copricapo",
  "corazza",
  "cordata",
  "coricato",
  "cornice",
  "corolla",
  "corpo",
  "corredo",
  "corsia",
  "cortese",
  "cosmico",
  "costante",
  "cottura",
  "covato",
  "cratere",
  "cravatta",
  "creato",
  "credere",
  "cremoso",
  "crescita",
  "creta",
  "criceto",
  "crinale",
  "crisi",
  "critico",
  "croce",
  "cronaca",
  "crostata",
  "cruciale",
  "crusca",
  "cucire",
  "cuculo",
  "cugino",
  "cullato",
  "cupola",
  "curatore",
  "cursore",
  "curvo",
  "cuscino",
  "custode",
  "dado",
  "daino",
  "dalmata",
  "damerino",
  "daniela",
  "dannoso",
  "danzare",
  "datato",
  "davanti",
  "davvero",
  "debutto",
  "decennio",
  "deciso",
  "declino",
  "decollo",
  "decreto",
  "dedicato",
  "definito",
  "deforme",
  "degno",
  "delegare",
  "delfino",
  "delirio",
  "delta",
  "demenza",
  "denotato",
  "dentro",
  "deposito",
  "derapata",
  "derivare",
  "deroga",
  "descritto",
  "deserto",
  "desiderio",
  "desumere",
  "detersivo",
  "devoto",
  "diametro",
  "dicembre",
  "diedro",
  "difeso",
  "diffuso",
  "digerire",
  "digitale",
  "diluvio",
  "dinamico",
  "dinnanzi",
  "dipinto",
  "diploma",
  "dipolo",
  "diradare",
  "dire",
  "dirotto",
  "dirupo",
  "disagio",
  "discreto",
  "disfare",
  "disgelo",
  "disposto",
  "distanza",
  "disumano",
  "dito",
  "divano",
  "divelto",
  "dividere",
  "divorato",
  "doblone",
  "docente",
  "doganale",
  "dogma",
  "dolce",
  "domato",
  "domenica",
  "dominare",
  "dondolo",
  "dono",
  "dormire",
  "dote",
  "dottore",
  "dovuto",
  "dozzina",
  "drago",
  "druido",
  "dubbio",
  "dubitare",
  "ducale",
  "duna",
  "duomo",
  "duplice",
  "duraturo",
  "ebano",
  "eccesso",
  "ecco",
  "eclissi",
  "economia",
  "edera",
  "edicola",
  "edile",
  "editoria",
  "educare",
  "egemonia",
  "egli",
  "egoismo",
  "egregio",
  "elaborato",
  "elargire",
  "elegante",
  "elencato",
  "eletto",
  "elevare",
  "elfico",
  "elica",
  "elmo",
  "elsa",
  "eluso",
  "emanato",
  "emblema",
  "emesso",
  "emiro",
  "emotivo",
  "emozione",
  "empirico",
  "emulo",
  "endemico",
  "enduro",
  "energia",
  "enfasi",
  "enoteca",
  "entrare",
  "enzima",
  "epatite",
  "epilogo",
  "episodio",
  "epocale",
  "eppure",
  "equatore",
  "erario",
  "erba",
  "erboso",
  "erede",
  "eremita",
  "erigere",
  "ermetico",
  "eroe",
  "erosivo",
  "errante",
  "esagono",
  "esame",
  "esanime",
  "esaudire",
  "esca",
  "esempio",
  "esercito",
  "esibito",
  "esigente",
  "esistere",
  "esito",
  "esofago",
  "esortato",
  "esoso",
  "espanso",
  "espresso",
  "essenza",
  "esso",
  "esteso",
  "estimare",
  "estonia",
  "estroso",
  "esultare",
  "etilico",
  "etnico",
  "etrusco",
  "etto",
  "euclideo",
  "europa",
  "evaso",
  "evidenza",
  "evitato",
  "evoluto",
  "evviva",
  "fabbrica",
  "faccenda",
  "fachiro",
  "falco",
  "famiglia",
  "fanale",
  "fanfara",
  "fango",
  "fantasma",
  "fare",
  "farfalla",
  "farinoso",
  "farmaco",
  "fascia",
  "fastoso",
  "fasullo",
  "faticare",
  "fato",
  "favoloso",
  "febbre",
  "fecola",
  "fede",
  "fegato",
  "felpa",
  "feltro",
  "femmina",
  "fendere",
  "fenomeno",
  "fermento",
  "ferro",
  "fertile",
  "fessura",
  "festivo",
  "fetta",
  "feudo",
  "fiaba",
  "fiducia",
  "fifa",
  "figurato",
  "filo",
  "finanza",
  "finestra",
  "finire",
  "fiore",
  "fiscale",
  "fisico",
  "fiume",
  "flacone",
  "flamenco",
  "flebo",
  "flemma",
  "florido",
  "fluente",
  "fluoro",
  "fobico",
  "focaccia",
  "focoso",
  "foderato",
  "foglio",
  "folata",
  "folclore",
  "folgore",
  "fondente",
  "fonetico",
  "fonia",
  "fontana",
  "forbito",
  "forchetta",
  "foresta",
  "formica",
  "fornaio",
  "foro",
  "fortezza",
  "forzare",
  "fosfato",
  "fosso",
  "fracasso",
  "frana",
  "frassino",
  "fratello",
  "freccetta",
  "frenata",
  "fresco",
  "frigo",
  "frollino",
  "fronde",
  "frugale",
  "frutta",
  "fucilata",
  "fucsia",
  "fuggente",
  "fulmine",
  "fulvo",
  "fumante",
  "fumetto",
  "fumoso",
  "fune",
  "funzione",
  "fuoco",
  "furbo",
  "furgone",
  "furore",
  "fuso",
  "futile",
  "gabbiano",
  "gaffe",
  "galateo",
  "gallina",
  "galoppo",
  "gambero",
  "gamma",
  "garanzia",
  "garbo",
  "garofano",
  "garzone",
  "gasdotto",
  "gasolio",
  "gastrico",
  "gatto",
  "gaudio",
  "gazebo",
  "gazzella",
  "geco",
  "gelatina",
  "gelso",
  "gemello",
  "gemmato",
  "gene",
  "genitore",
  "gennaio",
  "genotipo",
  "gergo",
  "ghepardo",
  "ghiaccio",
  "ghisa",
  "giallo",
  "gilda",
  "ginepro",
  "giocare",
  "gioiello",
  "giorno",
  "giove",
  "girato",
  "girone",
  "gittata",
  "giudizio",
  "giurato",
  "giusto",
  "globulo",
  "glutine",
  "gnomo",
  "gobba",
  "golf",
  "gomito",
  "gommone",
  "gonfio",
  "gonna",
  "governo",
  "gracile",
  "grado",
  "grafico",
  "grammo",
  "grande",
  "grattare",
  "gravoso",
  "grazia",
  "greca",
  "gregge",
  "grifone",
  "grigio",
  "grinza",
  "grotta",
  "gruppo",
  "guadagno",
  "guaio",
  "guanto",
  "guardare",
  "gufo",
  "guidare",
  "ibernato",
  "icona",
  "identico",
  "idillio",
  "idolo",
  "idra",
  "idrico",
  "idrogeno",
  "igiene",
  "ignaro",
  "ignorato",
  "ilare",
  "illeso",
  "illogico",
  "illudere",
  "imballo",
  "imbevuto",
  "imbocco",
  "imbuto",
  "immane",
  "immerso",
  "immolato",
  "impacco",
  "impeto",
  "impiego",
  "importo",
  "impronta",
  "inalare",
  "inarcare",
  "inattivo",
  "incanto",
  "incendio",
  "inchino",
  "incisivo",
  "incluso",
  "incontro",
  "incrocio",
  "incubo",
  "indagine",
  "india",
  "indole",
  "inedito",
  "infatti",
  "infilare",
  "inflitto",
  "ingaggio",
  "ingegno",
  "inglese",
  "ingordo",
  "ingrosso",
  "innesco",
  "inodore",
  "inoltrare",
  "inondato",
  "insano",
  "insetto",
  "insieme",
  "insonnia",
  "insulina",
  "intasato",
  "intero",
  "intonaco",
  "intuito",
  "inumidire",
  "invalido",
  "invece",
  "invito",
  "iperbole",
  "ipnotico",
  "ipotesi",
  "ippica",
  "iride",
  "irlanda",
  "ironico",
  "irrigato",
  "irrorare",
  "isolato",
  "isotopo",
  "isterico",
  "istituto",
  "istrice",
  "italia",
  "iterare",
  "labbro",
  "labirinto",
  "lacca",
  "lacerato",
  "lacrima",
  "lacuna",
  "laddove",
  "lago",
  "lampo",
  "lancetta",
  "lanterna",
  "lardoso",
  "larga",
  "laringe",
  "lastra",
  "latenza",
  "latino",
  "lattuga",
  "lavagna",
  "lavoro",
  "legale",
  "leggero",
  "lembo",
  "lentezza",
  "lenza",
  "leone",
  "lepre",
  "lesivo",
  "lessato",
  "lesto",
  "letterale",
  "leva",
  "levigato",
  "libero",
  "lido",
  "lievito",
  "lilla",
  "limatura",
  "limitare",
  "limpido",
  "lineare",
  "lingua",
  "liquido",
  "lira",
  "lirica",
  "lisca",
  "lite",
  "litigio",
  "livrea",
  "locanda",
  "lode",
  "logica",
  "lombare",
  "londra",
  "longevo",
  "loquace",
  "lorenzo",
  "loto",
  "lotteria",
  "luce",
  "lucidato",
  "lumaca",
  "luminoso",
  "lungo",
  "lupo",
  "luppolo",
  "lusinga",
  "lusso",
  "lutto",
  "macabro",
  "macchina",
  "macero",
  "macinato",
  "madama",
  "magico",
  "maglia",
  "magnete",
  "magro",
  "maiolica",
  "malafede",
  "malgrado",
  "malinteso",
  "malsano",
  "malto",
  "malumore",
  "mana",
  "mancia",
  "mandorla",
  "mangiare",
  "manifesto",
  "mannaro",
  "manovra",
  "mansarda",
  "mantide",
  "manubrio",
  "mappa",
  "maratona",
  "marcire",
  "maretta",
  "marmo",
  "marsupio",
  "maschera",
  "massaia",
  "mastino",
  "materasso",
  "matricola",
  "mattone",
  "maturo",
  "mazurca",
  "meandro",
  "meccanico",
  "mecenate",
  "medesimo",
  "meditare",
  "mega",
  "melassa",
  "melis",
  "melodia",
  "meninge",
  "meno",
  "mensola",
  "mercurio",
  "merenda",
  "merlo",
  "meschino",
  "mese",
  "messere",
  "mestolo",
  "metallo",
  "metodo",
  "mettere",
  "miagolare",
  "mica",
  "micelio",
  "michele",
  "microbo",
  "midollo",
  "miele",
  "migliore",
  "milano",
  "milite",
  "mimosa",
  "minerale",
  "mini",
  "minore",
  "mirino",
  "mirtillo",
  "miscela",
  "missiva",
  "misto",
  "misurare",
  "mitezza",
  "mitigare",
  "mitra",
  "mittente",
  "mnemonico",
  "modello",
  "modifica",
  "modulo",
  "mogano",
  "mogio",
  "mole",
  "molosso",
  "monastero",
  "monco",
  "mondina",
  "monetario",
  "monile",
  "monotono",
  "monsone",
  "montato",
  "monviso",
  "mora",
  "mordere",
  "morsicato",
  "mostro",
  "motivato",
  "motosega",
  "motto",
  "movenza",
  "movimento",
  "mozzo",
  "mucca",
  "mucosa",
  "muffa",
  "mughetto",
  "mugnaio",
  "mulatto",
  "mulinello",
  "multiplo",
  "mummia",
  "munto",
  "muovere",
  "murale",
  "musa",
  "muscolo",
  "musica",
  "mutevole",
  "muto",
  "nababbo",
  "nafta",
  "nanometro",
  "narciso",
  "narice",
  "narrato",
  "nascere",
  "nastrare",
  "naturale",
  "nautica",
  "naviglio",
  "nebulosa",
  "necrosi",
  "negativo",
  "negozio",
  "nemmeno",
  "neofita",
  "neretto",
  "nervo",
  "nessuno",
  "nettuno",
  "neutrale",
  "neve",
  "nevrotico",
  "nicchia",
  "ninfa",
  "nitido",
  "nobile",
  "nocivo",
  "nodo",
  "nome",
  "nomina",
  "nordico",
  "normale",
  "norvegese",
  "nostrano",
  "notare",
  "notizia",
  "notturno",
  "novella",
  "nucleo",
  "nulla",
  "numero",
  "nuovo",
  "nutrire",
  "nuvola",
  "nuziale",
  "oasi",
  "obbedire",
  "obbligo",
  "obelisco",
  "oblio",
  "obolo",
  "obsoleto",
  "occasione",
  "occhio",
  "occidente",
  "occorrere",
  "occultare",
  "ocra",
  "oculato",
  "odierno",
  "odorare",
  "offerta",
  "offrire",
  "offuscato",
  "oggetto",
  "oggi",
  "ognuno",
  "olandese",
  "olfatto",
  "oliato",
  "oliva",
  "ologramma",
  "oltre",
  "omaggio",
  "ombelico",
  "ombra",
  "omega",
  "omissione",
  "ondoso",
  "onere",
  "onice",
  "onnivoro",
  "onorevole",
  "onta",
  "operato",
  "opinione",
  "opposto",
  "oracolo",
  "orafo",
  "ordine",
  "orecchino",
  "orefice",
  "orfano",
  "organico",
  "origine",
  "orizzonte",
  "orma",
  "ormeggio",
  "ornativo",
  "orologio",
  "orrendo",
  "orribile",
  "ortensia",
  "ortica",
  "orzata",
  "orzo",
  "osare",
  "oscurare",
  "osmosi",
  "ospedale",
  "ospite",
  "ossa",
  "ossidare",
  "ostacolo",
  "oste",
  "otite",
  "otre",
  "ottagono",
  "ottimo",
  "ottobre",
  "ovale",
  "ovest",
  "ovino",
  "oviparo",
  "ovocito",
  "ovunque",
  "ovviare",
  "ozio",
  "pacchetto",
  "pace",
  "pacifico",
  "padella",
  "padrone",
  "paese",
  "paga",
  "pagina",
  "palazzina",
  "palesare",
  "pallido",
  "palo",
  "palude",
  "pandoro",
  "pannello",
  "paolo",
  "paonazzo",
  "paprica",
  "parabola",
  "parcella",
  "parere",
  "pargolo",
  "pari",
  "parlato",
  "parola",
  "partire",
  "parvenza",
  "parziale",
  "passivo",
  "pasticca",
  "patacca",
  "patologia",
  "pattume",
  "pavone",
  "peccato",
  "pedalare",
  "pedonale",
  "peggio",
  "peloso",
  "penare",
  "pendice",
  "penisola",
  "pennuto",
  "penombra",
  "pensare",
  "pentola",
  "pepe",
  "pepita",
  "perbene",
  "percorso",
  "perdonato",
  "perforare",
  "pergamena",
  "periodo",
  "permesso",
  "perno",
  "perplesso",
  "persuaso",
  "pertugio",
  "pervaso",
  "pesatore",
  "pesista",
  "peso",
  "pestifero",
  "petalo",
  "pettine",
  "petulante",
  "pezzo",
  "piacere",
  "pianta",
  "piattino",
  "piccino",
  "picozza",
  "piega",
  "pietra",
  "piffero",
  "pigiama",
  "pigolio",
  "pigro",
  "pila",
  "pilifero",
  "pillola",
  "pilota",
  "pimpante",
  "pineta",
  "pinna",
  "pinolo",
  "pioggia",
  "piombo",
  "piramide",
  "piretico",
  "pirite",
  "pirolisi",
  "pitone",
  "pizzico",
  "placebo",
  "planare",
  "plasma",
  "platano",
  "plenario",
  "pochezza",
  "poderoso",
  "podismo",
  "poesia",
  "poggiare",
  "polenta",
  "poligono",
  "pollice",
  "polmonite",
  "polpetta",
  "polso",
  "poltrona",
  "polvere",
  "pomice",
  "pomodoro",
  "ponte",
  "popoloso",
  "porfido",
  "poroso",
  "porpora",
  "porre",
  "portata",
  "posa",
  "positivo",
  "possesso",
  "postulato",
  "potassio",
  "potere",
  "pranzo",
  "prassi",
  "pratica",
  "precluso",
  "predica",
  "prefisso",
  "pregiato",
  "prelievo",
  "premere",
  "prenotare",
  "preparato",
  "presenza",
  "pretesto",
  "prevalso",
  "prima",
  "principe",
  "privato",
  "problema",
  "procura",
  "produrre",
  "profumo",
  "progetto",
  "prolunga",
  "promessa",
  "pronome",
  "proposta",
  "proroga",
  "proteso",
  "prova",
  "prudente",
  "prugna",
  "prurito",
  "psiche",
  "pubblico",
  "pudica",
  "pugilato",
  "pugno",
  "pulce",
  "pulito",
  "pulsante",
  "puntare",
  "pupazzo",
  "pupilla",
  "puro",
  "quadro",
  "qualcosa",
  "quasi",
  "querela",
  "quota",
  "raccolto",
  "raddoppio",
  "radicale",
  "radunato",
  "raffica",
  "ragazzo",
  "ragione",
  "ragno",
  "ramarro",
  "ramingo",
  "ramo",
  "randagio",
  "rantolare",
  "rapato",
  "rapina",
  "rappreso",
  "rasatura",
  "raschiato",
  "rasente",
  "rassegna",
  "rastrello",
  "rata",
  "ravveduto",
  "reale",
  "recepire",
  "recinto",
  "recluta",
  "recondito",
  "recupero",
  "reddito",
  "redimere",
  "regalato",
  "registro",
  "regola",
  "regresso",
  "relazione",
  "remare",
  "remoto",
  "renna",
  "replica",
  "reprimere",
  "reputare",
  "resa",
  "residente",
  "responso",
  "restauro",
  "rete",
  "retina",
  "retorica",
  "rettifica",
  "revocato",
  "riassunto",
  "ribadire",
  "ribelle",
  "ribrezzo",
  "ricarica",
  "ricco",
  "ricevere",
  "riciclato",
  "ricordo",
  "ricreduto",
  "ridicolo",
  "ridurre",
  "rifasare",
  "riflesso",
  "riforma",
  "rifugio",
  "rigare",
  "rigettato",
  "righello",
  "rilassato",
  "rilevato",
  "rimanere",
  "rimbalzo",
  "rimedio",
  "rimorchio",
  "rinascita",
  "rincaro",
  "rinforzo",
  "rinnovo",
  "rinomato",
  "rinsavito",
  "rintocco",
  "rinuncia",
  "rinvenire",
  "riparato",
  "ripetuto",
  "ripieno",
  "riportare",
  "ripresa",
  "ripulire",
  "risata",
  "rischio",
  "riserva",
  "risibile",
  "riso",
  "rispetto",
  "ristoro",
  "risultato",
  "risvolto",
  "ritardo",
  "ritegno",
  "ritmico",
  "ritrovo",
  "riunione",
  "riva",
  "riverso",
  "rivincita",
  "rivolto",
  "rizoma",
  "roba",
  "robotico",
  "robusto",
  "roccia",
  "roco",
  "rodaggio",
  "rodere",
  "roditore",
  "rogito",
  "rollio",
  "romantico",
  "rompere",
  "ronzio",
  "rosolare",
  "rospo",
  "rotante",
  "rotondo",
  "rotula",
  "rovescio",
  "rubizzo",
  "rubrica",
  "ruga",
  "rullino",
  "rumine",
  "rumoroso",
  "ruolo",
  "rupe",
  "russare",
  "rustico",
  "sabato",
  "sabbiare",
  "sabotato",
  "sagoma",
  "salasso",
  "saldatura",
  "salgemma",
  "salivare",
  "salmone",
  "salone",
  "saltare",
  "saluto",
  "salvo",
  "sapere",
  "sapido",
  "saporito",
  "saraceno",
  "sarcasmo",
  "sarto",
  "sassoso",
  "satellite",
  "satira",
  "satollo",
  "saturno",
  "savana",
  "savio",
  "saziato",
  "sbadiglio",
  "sbalzo",
  "sbancato",
  "sbarra",
  "sbattere",
  "sbavare",
  "sbendare",
  "sbirciare",
  "sbloccato",
  "sbocciato",
  "sbrinare",
  "sbruffone",
  "sbuffare",
  "scabroso",
  "scadenza",
  "scala",
  "scambiare",
  "scandalo",
  "scapola",
  "scarso",
  "scatenare",
  "scavato",
  "scelto",
  "scenico",
  "scettro",
  "scheda",
  "schiena",
  "sciarpa",
  "scienza",
  "scindere",
  "scippo",
  "sciroppo",
  "scivolo",
  "sclerare",
  "scodella",
  "scolpito",
  "scomparto",
  "sconforto",
  "scoprire",
  "scorta",
  "scossone",
  "scozzese",
  "scriba",
  "scrollare",
  "scrutinio",
  "scuderia",
  "scultore",
  "scuola",
  "scuro",
  "scusare",
  "sdebitare",
  "sdoganare",
  "seccatura",
  "secondo",
  "sedano",
  "seggiola",
  "segnalato",
  "segregato",
  "seguito",
  "selciato",
  "selettivo",
  "sella",
  "selvaggio",
  "semaforo",
  "sembrare",
  "seme",
  "seminato",
  "sempre",
  "senso",
  "sentire",
  "sepolto",
  "sequenza",
  "serata",
  "serbato",
  "sereno",
  "serio",
  "serpente",
  "serraglio",
  "servire",
  "sestina",
  "setola",
  "settimana",
  "sfacelo",
  "sfaldare",
  "sfamato",
  "sfarzoso",
  "sfaticato",
  "sfera",
  "sfida",
  "sfilato",
  "sfinge",
  "sfocato",
  "sfoderare",
  "sfogo",
  "sfoltire",
  "sforzato",
  "sfratto",
  "sfruttato",
  "sfuggito",
  "sfumare",
  "sfuso",
  "sgabello",
  "sgarbato",
  "sgonfiare",
  "sgorbio",
  "sgrassato",
  "sguardo",
  "sibilo",
  "siccome",
  "sierra",
  "sigla",
  "signore",
  "silenzio",
  "sillaba",
  "simbolo",
  "simpatico",
  "simulato",
  "sinfonia",
  "singolo",
  "sinistro",
  "sino",
  "sintesi",
  "sinusoide",
  "sipario",
  "sisma",
  "sistole",
  "situato",
  "slitta",
  "slogatura",
  "sloveno",
  "smarrito",
  "smemorato",
  "smentito",
  "smeraldo",
  "smilzo",
  "smontare",
  "smottato",
  "smussato",
  "snellire",
  "snervato",
  "snodo",
  "sobbalzo",
  "sobrio",
  "soccorso",
  "sociale",
  "sodale",
  "soffitto",
  "sogno",
  "soldato",
  "solenne",
  "solido",
  "sollazzo",
  "solo",
  "solubile",
  "solvente",
  "somatico",
  "somma",
  "sonda",
  "sonetto",
  "sonnifero",
  "sopire",
  "soppeso",
  "sopra",
  "sorgere",
  "sorpasso",
  "sorriso",
  "sorso",
  "sorteggio",
  "sorvolato",
  "sospiro",
  "sosta",
  "sottile",
  "spada",
  "spalla",
  "spargere",
  "spatola",
  "spavento",
  "spazzola",
  "specie",
  "spedire",
  "spegnere",
  "spelatura",
  "speranza",
  "spessore",
  "spettrale",
  "spezzato",
  "spia",
  "spigoloso",
  "spillato",
  "spinoso",
  "spirale",
  "splendido",
  "sportivo",
  "sposo",
  "spranga",
  "sprecare",
  "spronato",
  "spruzzo",
  "spuntino",
  "squillo",
  "sradicare",
  "srotolato",
  "stabile",
  "stacco",
  "staffa",
  "stagnare",
  "stampato",
  "stantio",
  "starnuto",
  "stasera",
  "statuto",
  "stelo",
  "steppa",
  "sterzo",
  "stiletto",
  "stima",
  "stirpe",
  "stivale",
  "stizzoso",
  "stonato",
  "storico",
  "strappo",
  "stregato",
  "stridulo",
  "strozzare",
  "strutto",
  "stuccare",
  "stufo",
  "stupendo",
  "subentro",
  "succoso",
  "sudore",
  "suggerito",
  "sugo",
  "sultano",
  "suonare",
  "superbo",
  "supporto",
  "surgelato",
  "surrogato",
  "sussurro",
  "sutura",
  "svagare",
  "svedese",
  "sveglio",
  "svelare",
  "svenuto",
  "svezia",
  "sviluppo",
  "svista",
  "svizzera",
  "svolta",
  "svuotare",
  "tabacco",
  "tabulato",
  "tacciare",
  "taciturno",
  "tale",
  "talismano",
  "tampone",
  "tannino",
  "tara",
  "tardivo",
  "targato",
  "tariffa",
  "tarpare",
  "tartaruga",
  "tasto",
  "tattico",
  "taverna",
  "tavolata",
  "tazza",
  "teca",
  "tecnico",
  "telefono",
  "temerario",
  "tempo",
  "temuto",
  "tendone",
  "tenero",
  "tensione",
  "tentacolo",
  "teorema",
  "terme",
  "terrazzo",
  "terzetto",
  "tesi",
  "tesserato",
  "testato",
  "tetro",
  "tettoia",
  "tifare",
  "tigella",
  "timbro",
  "tinto",
  "tipico",
  "tipografo",
  "tiraggio",
  "tiro",
  "titanio",
  "titolo",
  "titubante",
  "tizio",
  "tizzone",
  "toccare",
  "tollerare",
  "tolto",
  "tombola",
  "tomo",
  "tonfo",
  "tonsilla",
  "topazio",
  "topologia",
  "toppa",
  "torba",
  "tornare",
  "torrone",
  "tortora",
  "toscano",
  "tossire",
  "tostatura",
  "totano",
  "trabocco",
  "trachea",
  "trafila",
  "tragedia",
  "tralcio",
  "tramonto",
  "transito",
  "trapano",
  "trarre",
  "trasloco",
  "trattato",
  "trave",
  "treccia",
  "tremolio",
  "trespolo",
  "tributo",
  "tricheco",
  "trifoglio",
  "trillo",
  "trincea",
  "trio",
  "tristezza",
  "triturato",
  "trivella",
  "tromba",
  "trono",
  "troppo",
  "trottola",
  "trovare",
  "truccato",
  "tubatura",
  "tuffato",
  "tulipano",
  "tumulto",
  "tunisia",
  "turbare",
  "turchino",
  "tuta",
  "tutela",
  "ubicato",
  "uccello",
  "uccisore",
  "udire",
  "uditivo",
  "uffa",
  "ufficio",
  "uguale",
  "ulisse",
  "ultimato",
  "umano",
  "umile",
  "umorismo",
  "uncinetto",
  "ungere",
  "ungherese",
  "unicorno",
  "unificato",
  "unisono",
  "unitario",
  "unte",
  "uovo",
  "upupa",
  "uragano",
  "urgenza",
  "urlo",
  "usanza",
  "usato",
  "uscito",
  "usignolo",
  "usuraio",
  "utensile",
  "utilizzo",
  "utopia",
  "vacante",
  "vaccinato",
  "vagabondo",
  "vagliato",
  "valanga",
  "valgo",
  "valico",
  "valletta",
  "valoroso",
  "valutare",
  "valvola",
  "vampata",
  "vangare",
  "vanitoso",
  "vano",
  "vantaggio",
  "vanvera",
  "vapore",
  "varano",
  "varcato",
  "variante",
  "vasca",
  "vedetta",
  "vedova",
  "veduto",
  "vegetale",
  "veicolo",
  "velcro",
  "velina",
  "velluto",
  "veloce",
  "venato",
  "vendemmia",
  "vento",
  "verace",
  "verbale",
  "vergogna",
  "verifica",
  "vero",
  "verruca",
  "verticale",
  "vescica",
  "vessillo",
  "vestale",
  "veterano",
  "vetrina",
  "vetusto",
  "viandante",
  "vibrante",
  "vicenda",
  "vichingo",
  "vicinanza",
  "vidimare",
  "vigilia",
  "vigneto",
  "vigore",
  "vile",
  "villano",
  "vimini",
  "vincitore",
  "viola",
  "vipera",
  "virgola",
  "virologo",
  "virulento",
  "viscoso",
  "visione",
  "vispo",
  "vissuto",
  "visura",
  "vita",
  "vitello",
  "vittima",
  "vivanda",
  "vivido",
  "viziare",
  "voce",
  "voga",
  "volatile",
  "volere",
  "volpe",
  "voragine",
  "vulcano",
  "zampogna",
  "zanna",
  "zappato",
  "zattera",
  "zavorra",
  "zefiro",
  "zelante",
  "zelo",
  "zenzero",
  "zerbino",
  "zibetto",
  "zinco",
  "zircone",
  "zitto",
  "zolla",
  "zotico",
  "zucchero",
  "zufolo",
  "zulu",
  "zuppa"
], ibe = [
  "abaco",
  "abdomen",
  "abeja",
  "abierto",
  "abogado",
  "abono",
  "aborto",
  "abrazo",
  "abrir",
  "abuelo",
  "abuso",
  "acabar",
  "academia",
  "acceso",
  "accion",
  "aceite",
  "acelga",
  "acento",
  "aceptar",
  "acido",
  "aclarar",
  "acne",
  "acoger",
  "acoso",
  "activo",
  "acto",
  "actriz",
  "actuar",
  "acudir",
  "acuerdo",
  "acusar",
  "adicto",
  "admitir",
  "adoptar",
  "adorno",
  "aduana",
  "adulto",
  "aereo",
  "afectar",
  "aficion",
  "afinar",
  "afirmar",
  "agil",
  "agitar",
  "agonia",
  "agosto",
  "agotar",
  "agregar",
  "agrio",
  "agua",
  "agudo",
  "aguila",
  "aguja",
  "ahogo",
  "ahorro",
  "aire",
  "aislar",
  "ajedrez",
  "ajeno",
  "ajuste",
  "alacran",
  "alambre",
  "alarma",
  "alba",
  "album",
  "alcalde",
  "aldea",
  "alegre",
  "alejar",
  "alerta",
  "aleta",
  "alfiler",
  "alga",
  "algodon",
  "aliado",
  "aliento",
  "alivio",
  "alma",
  "almeja",
  "almibar",
  "altar",
  "alteza",
  "altivo",
  "alto",
  "altura",
  "alumno",
  "alzar",
  "amable",
  "amante",
  "amapola",
  "amargo",
  "amasar",
  "ambar",
  "ambito",
  "ameno",
  "amigo",
  "amistad",
  "amor",
  "amparo",
  "amplio",
  "ancho",
  "anciano",
  "ancla",
  "andar",
  "anden",
  "anemia",
  "angulo",
  "anillo",
  "animo",
  "anis",
  "anotar",
  "antena",
  "antiguo",
  "antojo",
  "anual",
  "anular",
  "anuncio",
  "anadir",
  "anejo",
  "ano",
  "apagar",
  "aparato",
  "apetito",
  "apio",
  "aplicar",
  "apodo",
  "aporte",
  "apoyo",
  "aprender",
  "aprobar",
  "apuesta",
  "apuro",
  "arado",
  "arana",
  "arar",
  "arbitro",
  "arbol",
  "arbusto",
  "archivo",
  "arco",
  "arder",
  "ardilla",
  "arduo",
  "area",
  "arido",
  "aries",
  "armonia",
  "arnes",
  "aroma",
  "arpa",
  "arpon",
  "arreglo",
  "arroz",
  "arruga",
  "arte",
  "artista",
  "asa",
  "asado",
  "asalto",
  "ascenso",
  "asegurar",
  "aseo",
  "asesor",
  "asiento",
  "asilo",
  "asistir",
  "asno",
  "asombro",
  "aspero",
  "astilla",
  "astro",
  "astuto",
  "asumir",
  "asunto",
  "atajo",
  "ataque",
  "atar",
  "atento",
  "ateo",
  "atico",
  "atleta",
  "atomo",
  "atraer",
  "atroz",
  "atun",
  "audaz",
  "audio",
  "auge",
  "aula",
  "aumento",
  "ausente",
  "autor",
  "aval",
  "avance",
  "avaro",
  "ave",
  "avellana",
  "avena",
  "avestruz",
  "avion",
  "aviso",
  "ayer",
  "ayuda",
  "ayuno",
  "azafran",
  "azar",
  "azote",
  "azucar",
  "azufre",
  "azul",
  "baba",
  "babor",
  "bache",
  "bahia",
  "baile",
  "bajar",
  "balanza",
  "balcon",
  "balde",
  "bambu",
  "banco",
  "banda",
  "bano",
  "barba",
  "barco",
  "barniz",
  "barro",
  "bascula",
  "baston",
  "basura",
  "batalla",
  "bateria",
  "batir",
  "batuta",
  "baul",
  "bazar",
  "bebe",
  "bebida",
  "bello",
  "besar",
  "beso",
  "bestia",
  "bicho",
  "bien",
  "bingo",
  "blanco",
  "bloque",
  "blusa",
  "boa",
  "bobina",
  "bobo",
  "boca",
  "bocina",
  "boda",
  "bodega",
  "boina",
  "bola",
  "bolero",
  "bolsa",
  "bomba",
  "bondad",
  "bonito",
  "bono",
  "bonsai",
  "borde",
  "borrar",
  "bosque",
  "bote",
  "botin",
  "boveda",
  "bozal",
  "bravo",
  "brazo",
  "brecha",
  "breve",
  "brillo",
  "brinco",
  "brisa",
  "broca",
  "broma",
  "bronce",
  "brote",
  "bruja",
  "brusco",
  "bruto",
  "buceo",
  "bucle",
  "bueno",
  "buey",
  "bufanda",
  "bufon",
  "buho",
  "buitre",
  "bulto",
  "burbuja",
  "burla",
  "burro",
  "buscar",
  "butaca",
  "buzon",
  "caballo",
  "cabeza",
  "cabina",
  "cabra",
  "cacao",
  "cadaver",
  "cadena",
  "caer",
  "cafe",
  "caida",
  "caiman",
  "caja",
  "cajon",
  "cal",
  "calamar",
  "calcio",
  "caldo",
  "calidad",
  "calle",
  "calma",
  "calor",
  "calvo",
  "cama",
  "cambio",
  "camello",
  "camino",
  "campo",
  "cancer",
  "candil",
  "canela",
  "canguro",
  "canica",
  "canto",
  "cana",
  "canon",
  "caoba",
  "caos",
  "capaz",
  "capitan",
  "capote",
  "captar",
  "capucha",
  "cara",
  "carbon",
  "carcel",
  "careta",
  "carga",
  "carino",
  "carne",
  "carpeta",
  "carro",
  "carta",
  "casa",
  "casco",
  "casero",
  "caspa",
  "castor",
  "catorce",
  "catre",
  "caudal",
  "causa",
  "cazo",
  "cebolla",
  "ceder",
  "cedro",
  "celda",
  "celebre",
  "celoso",
  "celula",
  "cemento",
  "ceniza",
  "centro",
  "cerca",
  "cerdo",
  "cereza",
  "cero",
  "cerrar",
  "certeza",
  "cesped",
  "cetro",
  "chacal",
  "chaleco",
  "champu",
  "chancla",
  "chapa",
  "charla",
  "chico",
  "chiste",
  "chivo",
  "choque",
  "choza",
  "chuleta",
  "chupar",
  "ciclon",
  "ciego",
  "cielo",
  "cien",
  "cierto",
  "cifra",
  "cigarro",
  "cima",
  "cinco",
  "cine",
  "cinta",
  "cipres",
  "circo",
  "ciruela",
  "cisne",
  "cita",
  "ciudad",
  "clamor",
  "clan",
  "claro",
  "clase",
  "clave",
  "cliente",
  "clima",
  "clinica",
  "cobre",
  "coccion",
  "cochino",
  "cocina",
  "coco",
  "codigo",
  "codo",
  "cofre",
  "coger",
  "cohete",
  "cojin",
  "cojo",
  "cola",
  "colcha",
  "colegio",
  "colgar",
  "colina",
  "collar",
  "colmo",
  "columna",
  "combate",
  "comer",
  "comida",
  "comodo",
  "compra",
  "conde",
  "conejo",
  "conga",
  "conocer",
  "consejo",
  "contar",
  "copa",
  "copia",
  "corazon",
  "corbata",
  "corcho",
  "cordon",
  "corona",
  "correr",
  "coser",
  "cosmos",
  "costa",
  "craneo",
  "crater",
  "crear",
  "crecer",
  "creido",
  "crema",
  "cria",
  "crimen",
  "cripta",
  "crisis",
  "cromo",
  "cronica",
  "croqueta",
  "crudo",
  "cruz",
  "cuadro",
  "cuarto",
  "cuatro",
  "cubo",
  "cubrir",
  "cuchara",
  "cuello",
  "cuento",
  "cuerda",
  "cuesta",
  "cueva",
  "cuidar",
  "culebra",
  "culpa",
  "culto",
  "cumbre",
  "cumplir",
  "cuna",
  "cuneta",
  "cuota",
  "cupon",
  "cupula",
  "curar",
  "curioso",
  "curso",
  "curva",
  "cutis",
  "dama",
  "danza",
  "dar",
  "dardo",
  "datil",
  "deber",
  "debil",
  "decada",
  "decir",
  "dedo",
  "defensa",
  "definir",
  "dejar",
  "delfin",
  "delgado",
  "delito",
  "demora",
  "denso",
  "dental",
  "deporte",
  "derecho",
  "derrota",
  "desayuno",
  "deseo",
  "desfile",
  "desnudo",
  "destino",
  "desvio",
  "detalle",
  "detener",
  "deuda",
  "dia",
  "diablo",
  "diadema",
  "diamante",
  "diana",
  "diario",
  "dibujo",
  "dictar",
  "diente",
  "dieta",
  "diez",
  "dificil",
  "digno",
  "dilema",
  "diluir",
  "dinero",
  "directo",
  "dirigir",
  "disco",
  "diseno",
  "disfraz",
  "diva",
  "divino",
  "doble",
  "doce",
  "dolor",
  "domingo",
  "don",
  "donar",
  "dorado",
  "dormir",
  "dorso",
  "dos",
  "dosis",
  "dragon",
  "droga",
  "ducha",
  "duda",
  "duelo",
  "dueno",
  "dulce",
  "duo",
  "duque",
  "durar",
  "dureza",
  "duro",
  "ebano",
  "ebrio",
  "echar",
  "eco",
  "ecuador",
  "edad",
  "edicion",
  "edificio",
  "editor",
  "educar",
  "efecto",
  "eficaz",
  "eje",
  "ejemplo",
  "elefante",
  "elegir",
  "elemento",
  "elevar",
  "elipse",
  "elite",
  "elixir",
  "elogio",
  "eludir",
  "embudo",
  "emitir",
  "emocion",
  "empate",
  "empeno",
  "empleo",
  "empresa",
  "enano",
  "encargo",
  "enchufe",
  "encia",
  "enemigo",
  "enero",
  "enfado",
  "enfermo",
  "engano",
  "enigma",
  "enlace",
  "enorme",
  "enredo",
  "ensayo",
  "ensenar",
  "entero",
  "entrar",
  "envase",
  "envio",
  "epoca",
  "equipo",
  "erizo",
  "escala",
  "escena",
  "escolar",
  "escribir",
  "escudo",
  "esencia",
  "esfera",
  "esfuerzo",
  "espada",
  "espejo",
  "espia",
  "esposa",
  "espuma",
  "esqui",
  "estar",
  "este",
  "estilo",
  "estufa",
  "etapa",
  "eterno",
  "etica",
  "etnia",
  "evadir",
  "evaluar",
  "evento",
  "evitar",
  "exacto",
  "examen",
  "exceso",
  "excusa",
  "exento",
  "exigir",
  "exilio",
  "existir",
  "exito",
  "experto",
  "explicar",
  "exponer",
  "extremo",
  "fabrica",
  "fabula",
  "fachada",
  "facil",
  "factor",
  "faena",
  "faja",
  "falda",
  "fallo",
  "falso",
  "faltar",
  "fama",
  "familia",
  "famoso",
  "faraon",
  "farmacia",
  "farol",
  "farsa",
  "fase",
  "fatiga",
  "fauna",
  "favor",
  "fax",
  "febrero",
  "fecha",
  "feliz",
  "feo",
  "feria",
  "feroz",
  "fertil",
  "fervor",
  "festin",
  "fiable",
  "fianza",
  "fiar",
  "fibra",
  "ficcion",
  "ficha",
  "fideo",
  "fiebre",
  "fiel",
  "fiera",
  "fiesta",
  "figura",
  "fijar",
  "fijo",
  "fila",
  "filete",
  "filial",
  "filtro",
  "fin",
  "finca",
  "fingir",
  "finito",
  "firma",
  "flaco",
  "flauta",
  "flecha",
  "flor",
  "flota",
  "fluir",
  "flujo",
  "fluor",
  "fobia",
  "foca",
  "fogata",
  "fogon",
  "folio",
  "folleto",
  "fondo",
  "forma",
  "forro",
  "fortuna",
  "forzar",
  "fosa",
  "foto",
  "fracaso",
  "fragil",
  "franja",
  "frase",
  "fraude",
  "freir",
  "freno",
  "fresa",
  "frio",
  "frito",
  "fruta",
  "fuego",
  "fuente",
  "fuerza",
  "fuga",
  "fumar",
  "funcion",
  "funda",
  "furgon",
  "furia",
  "fusil",
  "futbol",
  "futuro",
  "gacela",
  "gafas",
  "gaita",
  "gajo",
  "gala",
  "galeria",
  "gallo",
  "gamba",
  "ganar",
  "gancho",
  "ganga",
  "ganso",
  "garaje",
  "garza",
  "gasolina",
  "gastar",
  "gato",
  "gavilan",
  "gemelo",
  "gemir",
  "gen",
  "genero",
  "genio",
  "gente",
  "geranio",
  "gerente",
  "germen",
  "gesto",
  "gigante",
  "gimnasio",
  "girar",
  "giro",
  "glaciar",
  "globo",
  "gloria",
  "gol",
  "golfo",
  "goloso",
  "golpe",
  "goma",
  "gordo",
  "gorila",
  "gorra",
  "gota",
  "goteo",
  "gozar",
  "grada",
  "grafico",
  "grano",
  "grasa",
  "gratis",
  "grave",
  "grieta",
  "grillo",
  "gripe",
  "gris",
  "grito",
  "grosor",
  "grua",
  "grueso",
  "grumo",
  "grupo",
  "guante",
  "guapo",
  "guardia",
  "guerra",
  "guia",
  "guino",
  "guion",
  "guiso",
  "guitarra",
  "gusano",
  "gustar",
  "haber",
  "habil",
  "hablar",
  "hacer",
  "hacha",
  "hada",
  "hallar",
  "hamaca",
  "harina",
  "haz",
  "hazana",
  "hebilla",
  "hebra",
  "hecho",
  "helado",
  "helio",
  "hembra",
  "herir",
  "hermano",
  "heroe",
  "hervir",
  "hielo",
  "hierro",
  "higado",
  "higiene",
  "hijo",
  "himno",
  "historia",
  "hocico",
  "hogar",
  "hoguera",
  "hoja",
  "hombre",
  "hongo",
  "honor",
  "honra",
  "hora",
  "hormiga",
  "horno",
  "hostil",
  "hoyo",
  "hueco",
  "huelga",
  "huerta",
  "hueso",
  "huevo",
  "huida",
  "huir",
  "humano",
  "humedo",
  "humilde",
  "humo",
  "hundir",
  "huracan",
  "hurto",
  "icono",
  "ideal",
  "idioma",
  "idolo",
  "iglesia",
  "iglu",
  "igual",
  "ilegal",
  "ilusion",
  "imagen",
  "iman",
  "imitar",
  "impar",
  "imperio",
  "imponer",
  "impulso",
  "incapaz",
  "indice",
  "inerte",
  "infiel",
  "informe",
  "ingenio",
  "inicio",
  "inmenso",
  "inmune",
  "innato",
  "insecto",
  "instante",
  "interes",
  "intimo",
  "intuir",
  "inutil",
  "invierno",
  "ira",
  "iris",
  "ironia",
  "isla",
  "islote",
  "jabali",
  "jabon",
  "jamon",
  "jarabe",
  "jardin",
  "jarra",
  "jaula",
  "jazmin",
  "jefe",
  "jeringa",
  "jinete",
  "jornada",
  "joroba",
  "joven",
  "joya",
  "juerga",
  "jueves",
  "juez",
  "jugador",
  "jugo",
  "juguete",
  "juicio",
  "junco",
  "jungla",
  "junio",
  "juntar",
  "jupiter",
  "jurar",
  "justo",
  "juvenil",
  "juzgar",
  "kilo",
  "koala",
  "labio",
  "lacio",
  "lacra",
  "lado",
  "ladron",
  "lagarto",
  "lagrima",
  "laguna",
  "laico",
  "lamer",
  "lamina",
  "lampara",
  "lana",
  "lancha",
  "langosta",
  "lanza",
  "lapiz",
  "largo",
  "larva",
  "lastima",
  "lata",
  "latex",
  "latir",
  "laurel",
  "lavar",
  "lazo",
  "leal",
  "leccion",
  "leche",
  "lector",
  "leer",
  "legion",
  "legumbre",
  "lejano",
  "lengua",
  "lento",
  "lena",
  "leon",
  "leopardo",
  "lesion",
  "letal",
  "letra",
  "leve",
  "leyenda",
  "libertad",
  "libro",
  "licor",
  "lider",
  "lidiar",
  "lienzo",
  "liga",
  "ligero",
  "lima",
  "limite",
  "limon",
  "limpio",
  "lince",
  "lindo",
  "linea",
  "lingote",
  "lino",
  "linterna",
  "liquido",
  "liso",
  "lista",
  "litera",
  "litio",
  "litro",
  "llaga",
  "llama",
  "llanto",
  "llave",
  "llegar",
  "llenar",
  "llevar",
  "llorar",
  "llover",
  "lluvia",
  "lobo",
  "locion",
  "loco",
  "locura",
  "logica",
  "logro",
  "lombriz",
  "lomo",
  "lonja",
  "lote",
  "lucha",
  "lucir",
  "lugar",
  "lujo",
  "luna",
  "lunes",
  "lupa",
  "lustro",
  "luto",
  "luz",
  "maceta",
  "macho",
  "madera",
  "madre",
  "maduro",
  "maestro",
  "mafia",
  "magia",
  "mago",
  "maiz",
  "maldad",
  "maleta",
  "malla",
  "malo",
  "mama",
  "mambo",
  "mamut",
  "manco",
  "mando",
  "manejar",
  "manga",
  "maniqui",
  "manjar",
  "mano",
  "manso",
  "manta",
  "manana",
  "mapa",
  "maquina",
  "mar",
  "marco",
  "marea",
  "marfil",
  "margen",
  "marido",
  "marmol",
  "marron",
  "martes",
  "marzo",
  "masa",
  "mascara",
  "masivo",
  "matar",
  "materia",
  "matiz",
  "matriz",
  "maximo",
  "mayor",
  "mazorca",
  "mecha",
  "medalla",
  "medio",
  "medula",
  "mejilla",
  "mejor",
  "melena",
  "melon",
  "memoria",
  "menor",
  "mensaje",
  "mente",
  "menu",
  "mercado",
  "merengue",
  "merito",
  "mes",
  "meson",
  "meta",
  "meter",
  "metodo",
  "metro",
  "mezcla",
  "miedo",
  "miel",
  "miembro",
  "miga",
  "mil",
  "milagro",
  "militar",
  "millon",
  "mimo",
  "mina",
  "minero",
  "minimo",
  "minuto",
  "miope",
  "mirar",
  "misa",
  "miseria",
  "misil",
  "mismo",
  "mitad",
  "mito",
  "mochila",
  "mocion",
  "moda",
  "modelo",
  "moho",
  "mojar",
  "molde",
  "moler",
  "molino",
  "momento",
  "momia",
  "monarca",
  "moneda",
  "monja",
  "monto",
  "mono",
  "morada",
  "morder",
  "moreno",
  "morir",
  "morro",
  "morsa",
  "mortal",
  "mosca",
  "mostrar",
  "motivo",
  "mover",
  "movil",
  "mozo",
  "mucho",
  "mudar",
  "mueble",
  "muela",
  "muerte",
  "muestra",
  "mugre",
  "mujer",
  "mula",
  "muleta",
  "multa",
  "mundo",
  "muneca",
  "mural",
  "muro",
  "musculo",
  "museo",
  "musgo",
  "musica",
  "muslo",
  "nacar",
  "nacion",
  "nadar",
  "naipe",
  "naranja",
  "nariz",
  "narrar",
  "nasal",
  "natal",
  "nativo",
  "natural",
  "nausea",
  "naval",
  "nave",
  "navidad",
  "necio",
  "nectar",
  "negar",
  "negocio",
  "negro",
  "neon",
  "nervio",
  "neto",
  "neutro",
  "nevar",
  "nevera",
  "nicho",
  "nido",
  "niebla",
  "nieto",
  "ninez",
  "nino",
  "nitido",
  "nivel",
  "nobleza",
  "noche",
  "nomina",
  "noria",
  "norma",
  "norte",
  "nota",
  "noticia",
  "novato",
  "novela",
  "novio",
  "nube",
  "nuca",
  "nucleo",
  "nudillo",
  "nudo",
  "nuera",
  "nueve",
  "nuez",
  "nulo",
  "numero",
  "nutria",
  "oasis",
  "obeso",
  "obispo",
  "objeto",
  "obra",
  "obrero",
  "observar",
  "obtener",
  "obvio",
  "oca",
  "ocaso",
  "oceano",
  "ochenta",
  "ocho",
  "ocio",
  "ocre",
  "octavo",
  "octubre",
  "oculto",
  "ocupar",
  "ocurrir",
  "odiar",
  "odio",
  "odisea",
  "oeste",
  "ofensa",
  "oferta",
  "oficio",
  "ofrecer",
  "ogro",
  "oido",
  "oir",
  "ojo",
  "ola",
  "oleada",
  "olfato",
  "olivo",
  "olla",
  "olmo",
  "olor",
  "olvido",
  "ombligo",
  "onda",
  "onza",
  "opaco",
  "opcion",
  "opera",
  "opinar",
  "oponer",
  "optar",
  "optica",
  "opuesto",
  "oracion",
  "orador",
  "oral",
  "orbita",
  "orca",
  "orden",
  "oreja",
  "organo",
  "orgia",
  "orgullo",
  "oriente",
  "origen",
  "orilla",
  "oro",
  "orquesta",
  "oruga",
  "osadia",
  "oscuro",
  "osezno",
  "oso",
  "ostra",
  "otono",
  "otro",
  "oveja",
  "ovulo",
  "oxido",
  "oxigeno",
  "oyente",
  "ozono",
  "pacto",
  "padre",
  "paella",
  "pagina",
  "pago",
  "pais",
  "pajaro",
  "palabra",
  "palco",
  "paleta",
  "palido",
  "palma",
  "paloma",
  "palpar",
  "pan",
  "panal",
  "panico",
  "pantera",
  "panuelo",
  "papa",
  "papel",
  "papilla",
  "paquete",
  "parar",
  "parcela",
  "pared",
  "parir",
  "paro",
  "parpado",
  "parque",
  "parrafo",
  "parte",
  "pasar",
  "paseo",
  "pasion",
  "paso",
  "pasta",
  "pata",
  "patio",
  "patria",
  "pausa",
  "pauta",
  "pavo",
  "payaso",
  "peaton",
  "pecado",
  "pecera",
  "pecho",
  "pedal",
  "pedir",
  "pegar",
  "peine",
  "pelar",
  "peldano",
  "pelea",
  "peligro",
  "pellejo",
  "pelo",
  "peluca",
  "pena",
  "pensar",
  "penon",
  "peon",
  "peor",
  "pepino",
  "pequeno",
  "pera",
  "percha",
  "perder",
  "pereza",
  "perfil",
  "perico",
  "perla",
  "permiso",
  "perro",
  "persona",
  "pesa",
  "pesca",
  "pesimo",
  "pestana",
  "petalo",
  "petroleo",
  "pez",
  "pezuna",
  "picar",
  "pichon",
  "pie",
  "piedra",
  "pierna",
  "pieza",
  "pijama",
  "pilar",
  "piloto",
  "pimienta",
  "pino",
  "pintor",
  "pinza",
  "pina",
  "piojo",
  "pipa",
  "pirata",
  "pisar",
  "piscina",
  "piso",
  "pista",
  "piton",
  "pizca",
  "placa",
  "plan",
  "plata",
  "playa",
  "plaza",
  "pleito",
  "pleno",
  "plomo",
  "pluma",
  "plural",
  "pobre",
  "poco",
  "poder",
  "podio",
  "poema",
  "poesia",
  "poeta",
  "polen",
  "policia",
  "pollo",
  "polvo",
  "pomada",
  "pomelo",
  "pomo",
  "pompa",
  "poner",
  "porcion",
  "portal",
  "posada",
  "poseer",
  "posible",
  "poste",
  "potencia",
  "potro",
  "pozo",
  "prado",
  "precoz",
  "pregunta",
  "premio",
  "prensa",
  "preso",
  "previo",
  "primo",
  "principe",
  "prision",
  "privar",
  "proa",
  "probar",
  "proceso",
  "producto",
  "proeza",
  "profesor",
  "programa",
  "prole",
  "promesa",
  "pronto",
  "propio",
  "proximo",
  "prueba",
  "publico",
  "puchero",
  "pudor",
  "pueblo",
  "puerta",
  "puesto",
  "pulga",
  "pulir",
  "pulmon",
  "pulpo",
  "pulso",
  "puma",
  "punto",
  "punal",
  "puno",
  "pupa",
  "pupila",
  "pure",
  "quedar",
  "queja",
  "quemar",
  "querer",
  "queso",
  "quieto",
  "quimica",
  "quince",
  "quitar",
  "rabano",
  "rabia",
  "rabo",
  "racion",
  "radical",
  "raiz",
  "rama",
  "rampa",
  "rancho",
  "rango",
  "rapaz",
  "rapido",
  "rapto",
  "rasgo",
  "raspa",
  "rato",
  "rayo",
  "raza",
  "razon",
  "reaccion",
  "realidad",
  "rebano",
  "rebote",
  "recaer",
  "receta",
  "rechazo",
  "recoger",
  "recreo",
  "recto",
  "recurso",
  "red",
  "redondo",
  "reducir",
  "reflejo",
  "reforma",
  "refran",
  "refugio",
  "regalo",
  "regir",
  "regla",
  "regreso",
  "rehen",
  "reino",
  "reir",
  "reja",
  "relato",
  "relevo",
  "relieve",
  "relleno",
  "reloj",
  "remar",
  "remedio",
  "remo",
  "rencor",
  "rendir",
  "renta",
  "reparto",
  "repetir",
  "reposo",
  "reptil",
  "res",
  "rescate",
  "resina",
  "respeto",
  "resto",
  "resumen",
  "retiro",
  "retorno",
  "retrato",
  "reunir",
  "reves",
  "revista",
  "rey",
  "rezar",
  "rico",
  "riego",
  "rienda",
  "riesgo",
  "rifa",
  "rigido",
  "rigor",
  "rincon",
  "rinon",
  "rio",
  "riqueza",
  "risa",
  "ritmo",
  "rito",
  "rizo",
  "roble",
  "roce",
  "rociar",
  "rodar",
  "rodeo",
  "rodilla",
  "roer",
  "rojizo",
  "rojo",
  "romero",
  "romper",
  "ron",
  "ronco",
  "ronda",
  "ropa",
  "ropero",
  "rosa",
  "rosca",
  "rostro",
  "rotar",
  "rubi",
  "rubor",
  "rudo",
  "rueda",
  "rugir",
  "ruido",
  "ruina",
  "ruleta",
  "rulo",
  "rumbo",
  "rumor",
  "ruptura",
  "ruta",
  "rutina",
  "sabado",
  "saber",
  "sabio",
  "sable",
  "sacar",
  "sagaz",
  "sagrado",
  "sala",
  "saldo",
  "salero",
  "salir",
  "salmon",
  "salon",
  "salsa",
  "salto",
  "salud",
  "salvar",
  "samba",
  "sancion",
  "sandia",
  "sanear",
  "sangre",
  "sanidad",
  "sano",
  "santo",
  "sapo",
  "saque",
  "sardina",
  "sarten",
  "sastre",
  "satan",
  "sauna",
  "saxofon",
  "seccion",
  "seco",
  "secreto",
  "secta",
  "sed",
  "seguir",
  "seis",
  "sello",
  "selva",
  "semana",
  "semilla",
  "senda",
  "sensor",
  "senal",
  "senor",
  "separar",
  "sepia",
  "sequia",
  "ser",
  "serie",
  "sermon",
  "servir",
  "sesenta",
  "sesion",
  "seta",
  "setenta",
  "severo",
  "sexo",
  "sexto",
  "sidra",
  "siesta",
  "siete",
  "siglo",
  "signo",
  "silaba",
  "silbar",
  "silencio",
  "silla",
  "simbolo",
  "simio",
  "sirena",
  "sistema",
  "sitio",
  "situar",
  "sobre",
  "socio",
  "sodio",
  "sol",
  "solapa",
  "soldado",
  "soledad",
  "solido",
  "soltar",
  "solucion",
  "sombra",
  "sondeo",
  "sonido",
  "sonoro",
  "sonrisa",
  "sopa",
  "soplar",
  "soporte",
  "sordo",
  "sorpresa",
  "sorteo",
  "sosten",
  "sotano",
  "suave",
  "subir",
  "suceso",
  "sudor",
  "suegra",
  "suelo",
  "sueno",
  "suerte",
  "sufrir",
  "sujeto",
  "sultan",
  "sumar",
  "superar",
  "suplir",
  "suponer",
  "supremo",
  "sur",
  "surco",
  "sureno",
  "surgir",
  "susto",
  "sutil",
  "tabaco",
  "tabique",
  "tabla",
  "tabu",
  "taco",
  "tacto",
  "tajo",
  "talar",
  "talco",
  "talento",
  "talla",
  "talon",
  "tamano",
  "tambor",
  "tango",
  "tanque",
  "tapa",
  "tapete",
  "tapia",
  "tapon",
  "taquilla",
  "tarde",
  "tarea",
  "tarifa",
  "tarjeta",
  "tarot",
  "tarro",
  "tarta",
  "tatuaje",
  "tauro",
  "taza",
  "tazon",
  "teatro",
  "techo",
  "tecla",
  "tecnica",
  "tejado",
  "tejer",
  "tejido",
  "tela",
  "telefono",
  "tema",
  "temor",
  "templo",
  "tenaz",
  "tender",
  "tener",
  "tenis",
  "tenso",
  "teoria",
  "terapia",
  "terco",
  "termino",
  "ternura",
  "terror",
  "tesis",
  "tesoro",
  "testigo",
  "tetera",
  "texto",
  "tez",
  "tibio",
  "tiburon",
  "tiempo",
  "tienda",
  "tierra",
  "tieso",
  "tigre",
  "tijera",
  "tilde",
  "timbre",
  "timido",
  "timo",
  "tinta",
  "tio",
  "tipico",
  "tipo",
  "tira",
  "tiron",
  "titan",
  "titere",
  "titulo",
  "tiza",
  "toalla",
  "tobillo",
  "tocar",
  "tocino",
  "todo",
  "toga",
  "toldo",
  "tomar",
  "tono",
  "tonto",
  "topar",
  "tope",
  "toque",
  "torax",
  "torero",
  "tormenta",
  "torneo",
  "toro",
  "torpedo",
  "torre",
  "torso",
  "tortuga",
  "tos",
  "tosco",
  "toser",
  "toxico",
  "trabajo",
  "tractor",
  "traer",
  "trafico",
  "trago",
  "traje",
  "tramo",
  "trance",
  "trato",
  "trauma",
  "trazar",
  "trebol",
  "tregua",
  "treinta",
  "tren",
  "trepar",
  "tres",
  "tribu",
  "trigo",
  "tripa",
  "triste",
  "triunfo",
  "trofeo",
  "trompa",
  "tronco",
  "tropa",
  "trote",
  "trozo",
  "truco",
  "trueno",
  "trufa",
  "tuberia",
  "tubo",
  "tuerto",
  "tumba",
  "tumor",
  "tunel",
  "tunica",
  "turbina",
  "turismo",
  "turno",
  "tutor",
  "ubicar",
  "ulcera",
  "umbral",
  "unidad",
  "unir",
  "universo",
  "uno",
  "untar",
  "una",
  "urbano",
  "urbe",
  "urgente",
  "urna",
  "usar",
  "usuario",
  "util",
  "utopia",
  "uva",
  "vaca",
  "vacio",
  "vacuna",
  "vagar",
  "vago",
  "vaina",
  "vajilla",
  "vale",
  "valido",
  "valle",
  "valor",
  "valvula",
  "vampiro",
  "vara",
  "variar",
  "varon",
  "vaso",
  "vecino",
  "vector",
  "vehiculo",
  "veinte",
  "vejez",
  "vela",
  "velero",
  "veloz",
  "vena",
  "vencer",
  "venda",
  "veneno",
  "vengar",
  "venir",
  "venta",
  "venus",
  "ver",
  "verano",
  "verbo",
  "verde",
  "vereda",
  "verja",
  "verso",
  "verter",
  "via",
  "viaje",
  "vibrar",
  "vicio",
  "victima",
  "vida",
  "video",
  "vidrio",
  "viejo",
  "viernes",
  "vigor",
  "vil",
  "villa",
  "vinagre",
  "vino",
  "vinedo",
  "violin",
  "viral",
  "virgo",
  "virtud",
  "visor",
  "vispera",
  "vista",
  "vitamina",
  "viudo",
  "vivaz",
  "vivero",
  "vivir",
  "vivo",
  "volcan",
  "volumen",
  "volver",
  "voraz",
  "votar",
  "voto",
  "voz",
  "vuelo",
  "vulgar",
  "yacer",
  "yate",
  "yegua",
  "yema",
  "yerno",
  "yeso",
  "yodo",
  "yoga",
  "yogur",
  "zafiro",
  "zanja",
  "zapato",
  "zarza",
  "zona",
  "zorro",
  "zumo",
  "zurdo"
], abe = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], sbe = [
  "abacate",
  "abaixo",
  "abalar",
  "abater",
  "abduzir",
  "abelha",
  "aberto",
  "abismo",
  "abotoar",
  "abranger",
  "abreviar",
  "abrigar",
  "abrupto",
  "absinto",
  "absoluto",
  "absurdo",
  "abutre",
  "acabado",
  "acalmar",
  "acampar",
  "acanhar",
  "acaso",
  "aceitar",
  "acelerar",
  "acenar",
  "acervo",
  "acessar",
  "acetona",
  "achatar",
  "acidez",
  "acima",
  "acionado",
  "acirrar",
  "aclamar",
  "aclive",
  "acolhida",
  "acomodar",
  "acoplar",
  "acordar",
  "acumular",
  "acusador",
  "adaptar",
  "adega",
  "adentro",
  "adepto",
  "adequar",
  "aderente",
  "adesivo",
  "adeus",
  "adiante",
  "aditivo",
  "adjetivo",
  "adjunto",
  "admirar",
  "adorar",
  "adquirir",
  "adubo",
  "adverso",
  "advogado",
  "aeronave",
  "afastar",
  "aferir",
  "afetivo",
  "afinador",
  "afivelar",
  "aflito",
  "afluente",
  "afrontar",
  "agachar",
  "agarrar",
  "agasalho",
  "agenciar",
  "agilizar",
  "agiota",
  "agitado",
  "agora",
  "agradar",
  "agreste",
  "agrupar",
  "aguardar",
  "agulha",
  "ajoelhar",
  "ajudar",
  "ajustar",
  "alameda",
  "alarme",
  "alastrar",
  "alavanca",
  "albergue",
  "albino",
  "alcatra",
  "aldeia",
  "alecrim",
  "alegria",
  "alertar",
  "alface",
  "alfinete",
  "algum",
  "alheio",
  "aliar",
  "alicate",
  "alienar",
  "alinhar",
  "aliviar",
  "almofada",
  "alocar",
  "alpiste",
  "alterar",
  "altitude",
  "alucinar",
  "alugar",
  "aluno",
  "alusivo",
  "alvo",
  "amaciar",
  "amador",
  "amarelo",
  "amassar",
  "ambas",
  "ambiente",
  "ameixa",
  "amenizar",
  "amido",
  "amistoso",
  "amizade",
  "amolador",
  "amontoar",
  "amoroso",
  "amostra",
  "amparar",
  "ampliar",
  "ampola",
  "anagrama",
  "analisar",
  "anarquia",
  "anatomia",
  "andaime",
  "anel",
  "anexo",
  "angular",
  "animar",
  "anjo",
  "anomalia",
  "anotado",
  "ansioso",
  "anterior",
  "anuidade",
  "anunciar",
  "anzol",
  "apagador",
  "apalpar",
  "apanhado",
  "apego",
  "apelido",
  "apertada",
  "apesar",
  "apetite",
  "apito",
  "aplauso",
  "aplicada",
  "apoio",
  "apontar",
  "aposta",
  "aprendiz",
  "aprovar",
  "aquecer",
  "arame",
  "aranha",
  "arara",
  "arcada",
  "ardente",
  "areia",
  "arejar",
  "arenito",
  "aresta",
  "argiloso",
  "argola",
  "arma",
  "arquivo",
  "arraial",
  "arrebate",
  "arriscar",
  "arroba",
  "arrumar",
  "arsenal",
  "arterial",
  "artigo",
  "arvoredo",
  "asfaltar",
  "asilado",
  "aspirar",
  "assador",
  "assinar",
  "assoalho",
  "assunto",
  "astral",
  "atacado",
  "atadura",
  "atalho",
  "atarefar",
  "atear",
  "atender",
  "aterro",
  "ateu",
  "atingir",
  "atirador",
  "ativo",
  "atoleiro",
  "atracar",
  "atrevido",
  "atriz",
  "atual",
  "atum",
  "auditor",
  "aumentar",
  "aura",
  "aurora",
  "autismo",
  "autoria",
  "autuar",
  "avaliar",
  "avante",
  "avaria",
  "avental",
  "avesso",
  "aviador",
  "avisar",
  "avulso",
  "axila",
  "azarar",
  "azedo",
  "azeite",
  "azulejo",
  "babar",
  "babosa",
  "bacalhau",
  "bacharel",
  "bacia",
  "bagagem",
  "baiano",
  "bailar",
  "baioneta",
  "bairro",
  "baixista",
  "bajular",
  "baleia",
  "baliza",
  "balsa",
  "banal",
  "bandeira",
  "banho",
  "banir",
  "banquete",
  "barato",
  "barbado",
  "baronesa",
  "barraca",
  "barulho",
  "baseado",
  "bastante",
  "batata",
  "batedor",
  "batida",
  "batom",
  "batucar",
  "baunilha",
  "beber",
  "beijo",
  "beirada",
  "beisebol",
  "beldade",
  "beleza",
  "belga",
  "beliscar",
  "bendito",
  "bengala",
  "benzer",
  "berimbau",
  "berlinda",
  "berro",
  "besouro",
  "bexiga",
  "bezerro",
  "bico",
  "bicudo",
  "bienal",
  "bifocal",
  "bifurcar",
  "bigorna",
  "bilhete",
  "bimestre",
  "bimotor",
  "biologia",
  "biombo",
  "biosfera",
  "bipolar",
  "birrento",
  "biscoito",
  "bisneto",
  "bispo",
  "bissexto",
  "bitola",
  "bizarro",
  "blindado",
  "bloco",
  "bloquear",
  "boato",
  "bobagem",
  "bocado",
  "bocejo",
  "bochecha",
  "boicotar",
  "bolada",
  "boletim",
  "bolha",
  "bolo",
  "bombeiro",
  "bonde",
  "boneco",
  "bonita",
  "borbulha",
  "borda",
  "boreal",
  "borracha",
  "bovino",
  "boxeador",
  "branco",
  "brasa",
  "braveza",
  "breu",
  "briga",
  "brilho",
  "brincar",
  "broa",
  "brochura",
  "bronzear",
  "broto",
  "bruxo",
  "bucha",
  "budismo",
  "bufar",
  "bule",
  "buraco",
  "busca",
  "busto",
  "buzina",
  "cabana",
  "cabelo",
  "cabide",
  "cabo",
  "cabrito",
  "cacau",
  "cacetada",
  "cachorro",
  "cacique",
  "cadastro",
  "cadeado",
  "cafezal",
  "caiaque",
  "caipira",
  "caixote",
  "cajado",
  "caju",
  "calafrio",
  "calcular",
  "caldeira",
  "calibrar",
  "calmante",
  "calota",
  "camada",
  "cambista",
  "camisa",
  "camomila",
  "campanha",
  "camuflar",
  "canavial",
  "cancelar",
  "caneta",
  "canguru",
  "canhoto",
  "canivete",
  "canoa",
  "cansado",
  "cantar",
  "canudo",
  "capacho",
  "capela",
  "capinar",
  "capotar",
  "capricho",
  "captador",
  "capuz",
  "caracol",
  "carbono",
  "cardeal",
  "careca",
  "carimbar",
  "carneiro",
  "carpete",
  "carreira",
  "cartaz",
  "carvalho",
  "casaco",
  "casca",
  "casebre",
  "castelo",
  "casulo",
  "catarata",
  "cativar",
  "caule",
  "causador",
  "cautelar",
  "cavalo",
  "caverna",
  "cebola",
  "cedilha",
  "cegonha",
  "celebrar",
  "celular",
  "cenoura",
  "censo",
  "centeio",
  "cercar",
  "cerrado",
  "certeiro",
  "cerveja",
  "cetim",
  "cevada",
  "chacota",
  "chaleira",
  "chamado",
  "chapada",
  "charme",
  "chatice",
  "chave",
  "chefe",
  "chegada",
  "cheiro",
  "cheque",
  "chicote",
  "chifre",
  "chinelo",
  "chocalho",
  "chover",
  "chumbo",
  "chutar",
  "chuva",
  "cicatriz",
  "ciclone",
  "cidade",
  "cidreira",
  "ciente",
  "cigana",
  "cimento",
  "cinto",
  "cinza",
  "ciranda",
  "circuito",
  "cirurgia",
  "citar",
  "clareza",
  "clero",
  "clicar",
  "clone",
  "clube",
  "coado",
  "coagir",
  "cobaia",
  "cobertor",
  "cobrar",
  "cocada",
  "coelho",
  "coentro",
  "coeso",
  "cogumelo",
  "coibir",
  "coifa",
  "coiote",
  "colar",
  "coleira",
  "colher",
  "colidir",
  "colmeia",
  "colono",
  "coluna",
  "comando",
  "combinar",
  "comentar",
  "comitiva",
  "comover",
  "complexo",
  "comum",
  "concha",
  "condor",
  "conectar",
  "confuso",
  "congelar",
  "conhecer",
  "conjugar",
  "consumir",
  "contrato",
  "convite",
  "cooperar",
  "copeiro",
  "copiador",
  "copo",
  "coquetel",
  "coragem",
  "cordial",
  "corneta",
  "coronha",
  "corporal",
  "correio",
  "cortejo",
  "coruja",
  "corvo",
  "cosseno",
  "costela",
  "cotonete",
  "couro",
  "couve",
  "covil",
  "cozinha",
  "cratera",
  "cravo",
  "creche",
  "credor",
  "creme",
  "crer",
  "crespo",
  "criada",
  "criminal",
  "crioulo",
  "crise",
  "criticar",
  "crosta",
  "crua",
  "cruzeiro",
  "cubano",
  "cueca",
  "cuidado",
  "cujo",
  "culatra",
  "culminar",
  "culpar",
  "cultura",
  "cumprir",
  "cunhado",
  "cupido",
  "curativo",
  "curral",
  "cursar",
  "curto",
  "cuspir",
  "custear",
  "cutelo",
  "damasco",
  "datar",
  "debater",
  "debitar",
  "deboche",
  "debulhar",
  "decalque",
  "decimal",
  "declive",
  "decote",
  "decretar",
  "dedal",
  "dedicado",
  "deduzir",
  "defesa",
  "defumar",
  "degelo",
  "degrau",
  "degustar",
  "deitado",
  "deixar",
  "delator",
  "delegado",
  "delinear",
  "delonga",
  "demanda",
  "demitir",
  "demolido",
  "dentista",
  "depenado",
  "depilar",
  "depois",
  "depressa",
  "depurar",
  "deriva",
  "derramar",
  "desafio",
  "desbotar",
  "descanso",
  "desenho",
  "desfiado",
  "desgaste",
  "desigual",
  "deslize",
  "desmamar",
  "desova",
  "despesa",
  "destaque",
  "desviar",
  "detalhar",
  "detentor",
  "detonar",
  "detrito",
  "deusa",
  "dever",
  "devido",
  "devotado",
  "dezena",
  "diagrama",
  "dialeto",
  "didata",
  "difuso",
  "digitar",
  "dilatado",
  "diluente",
  "diminuir",
  "dinastia",
  "dinheiro",
  "diocese",
  "direto",
  "discreta",
  "disfarce",
  "disparo",
  "disquete",
  "dissipar",
  "distante",
  "ditador",
  "diurno",
  "diverso",
  "divisor",
  "divulgar",
  "dizer",
  "dobrador",
  "dolorido",
  "domador",
  "dominado",
  "donativo",
  "donzela",
  "dormente",
  "dorsal",
  "dosagem",
  "dourado",
  "doutor",
  "drenagem",
  "drible",
  "drogaria",
  "duelar",
  "duende",
  "dueto",
  "duplo",
  "duquesa",
  "durante",
  "duvidoso",
  "eclodir",
  "ecoar",
  "ecologia",
  "edificar",
  "edital",
  "educado",
  "efeito",
  "efetivar",
  "ejetar",
  "elaborar",
  "eleger",
  "eleitor",
  "elenco",
  "elevador",
  "eliminar",
  "elogiar",
  "embargo",
  "embolado",
  "embrulho",
  "embutido",
  "emenda",
  "emergir",
  "emissor",
  "empatia",
  "empenho",
  "empinado",
  "empolgar",
  "emprego",
  "empurrar",
  "emulador",
  "encaixe",
  "encenado",
  "enchente",
  "encontro",
  "endeusar",
  "endossar",
  "enfaixar",
  "enfeite",
  "enfim",
  "engajado",
  "engenho",
  "englobar",
  "engomado",
  "engraxar",
  "enguia",
  "enjoar",
  "enlatar",
  "enquanto",
  "enraizar",
  "enrolado",
  "enrugar",
  "ensaio",
  "enseada",
  "ensino",
  "ensopado",
  "entanto",
  "enteado",
  "entidade",
  "entortar",
  "entrada",
  "entulho",
  "envergar",
  "enviado",
  "envolver",
  "enxame",
  "enxerto",
  "enxofre",
  "enxuto",
  "epiderme",
  "equipar",
  "ereto",
  "erguido",
  "errata",
  "erva",
  "ervilha",
  "esbanjar",
  "esbelto",
  "escama",
  "escola",
  "escrita",
  "escuta",
  "esfinge",
  "esfolar",
  "esfregar",
  "esfumado",
  "esgrima",
  "esmalte",
  "espanto",
  "espelho",
  "espiga",
  "esponja",
  "espreita",
  "espumar",
  "esquerda",
  "estaca",
  "esteira",
  "esticar",
  "estofado",
  "estrela",
  "estudo",
  "esvaziar",
  "etanol",
  "etiqueta",
  "euforia",
  "europeu",
  "evacuar",
  "evaporar",
  "evasivo",
  "eventual",
  "evidente",
  "evoluir",
  "exagero",
  "exalar",
  "examinar",
  "exato",
  "exausto",
  "excesso",
  "excitar",
  "exclamar",
  "executar",
  "exemplo",
  "exibir",
  "exigente",
  "exonerar",
  "expandir",
  "expelir",
  "expirar",
  "explanar",
  "exposto",
  "expresso",
  "expulsar",
  "externo",
  "extinto",
  "extrato",
  "fabricar",
  "fabuloso",
  "faceta",
  "facial",
  "fada",
  "fadiga",
  "faixa",
  "falar",
  "falta",
  "familiar",
  "fandango",
  "fanfarra",
  "fantoche",
  "fardado",
  "farelo",
  "farinha",
  "farofa",
  "farpa",
  "fartura",
  "fatia",
  "fator",
  "favorita",
  "faxina",
  "fazenda",
  "fechado",
  "feijoada",
  "feirante",
  "felino",
  "feminino",
  "fenda",
  "feno",
  "fera",
  "feriado",
  "ferrugem",
  "ferver",
  "festejar",
  "fetal",
  "feudal",
  "fiapo",
  "fibrose",
  "ficar",
  "ficheiro",
  "figurado",
  "fileira",
  "filho",
  "filme",
  "filtrar",
  "firmeza",
  "fisgada",
  "fissura",
  "fita",
  "fivela",
  "fixador",
  "fixo",
  "flacidez",
  "flamingo",
  "flanela",
  "flechada",
  "flora",
  "flutuar",
  "fluxo",
  "focal",
  "focinho",
  "fofocar",
  "fogo",
  "foguete",
  "foice",
  "folgado",
  "folheto",
  "forjar",
  "formiga",
  "forno",
  "forte",
  "fosco",
  "fossa",
  "fragata",
  "fralda",
  "frango",
  "frasco",
  "fraterno",
  "freira",
  "frente",
  "fretar",
  "frieza",
  "friso",
  "fritura",
  "fronha",
  "frustrar",
  "fruteira",
  "fugir",
  "fulano",
  "fuligem",
  "fundar",
  "fungo",
  "funil",
  "furador",
  "furioso",
  "futebol",
  "gabarito",
  "gabinete",
  "gado",
  "gaiato",
  "gaiola",
  "gaivota",
  "galega",
  "galho",
  "galinha",
  "galocha",
  "ganhar",
  "garagem",
  "garfo",
  "gargalo",
  "garimpo",
  "garoupa",
  "garrafa",
  "gasoduto",
  "gasto",
  "gata",
  "gatilho",
  "gaveta",
  "gazela",
  "gelado",
  "geleia",
  "gelo",
  "gemada",
  "gemer",
  "gemido",
  "generoso",
  "gengiva",
  "genial",
  "genoma",
  "genro",
  "geologia",
  "gerador",
  "germinar",
  "gesso",
  "gestor",
  "ginasta",
  "gincana",
  "gingado",
  "girafa",
  "girino",
  "glacial",
  "glicose",
  "global",
  "glorioso",
  "goela",
  "goiaba",
  "golfe",
  "golpear",
  "gordura",
  "gorjeta",
  "gorro",
  "gostoso",
  "goteira",
  "governar",
  "gracejo",
  "gradual",
  "grafite",
  "gralha",
  "grampo",
  "granada",
  "gratuito",
  "graveto",
  "graxa",
  "grego",
  "grelhar",
  "greve",
  "grilo",
  "grisalho",
  "gritaria",
  "grosso",
  "grotesco",
  "grudado",
  "grunhido",
  "gruta",
  "guache",
  "guarani",
  "guaxinim",
  "guerrear",
  "guiar",
  "guincho",
  "guisado",
  "gula",
  "guloso",
  "guru",
  "habitar",
  "harmonia",
  "haste",
  "haver",
  "hectare",
  "herdar",
  "heresia",
  "hesitar",
  "hiato",
  "hibernar",
  "hidratar",
  "hiena",
  "hino",
  "hipismo",
  "hipnose",
  "hipoteca",
  "hoje",
  "holofote",
  "homem",
  "honesto",
  "honrado",
  "hormonal",
  "hospedar",
  "humorado",
  "iate",
  "ideia",
  "idoso",
  "ignorado",
  "igreja",
  "iguana",
  "ileso",
  "ilha",
  "iludido",
  "iluminar",
  "ilustrar",
  "imagem",
  "imediato",
  "imenso",
  "imersivo",
  "iminente",
  "imitador",
  "imortal",
  "impacto",
  "impedir",
  "implante",
  "impor",
  "imprensa",
  "impune",
  "imunizar",
  "inalador",
  "inapto",
  "inativo",
  "incenso",
  "inchar",
  "incidir",
  "incluir",
  "incolor",
  "indeciso",
  "indireto",
  "indutor",
  "ineficaz",
  "inerente",
  "infantil",
  "infestar",
  "infinito",
  "inflamar",
  "informal",
  "infrator",
  "ingerir",
  "inibido",
  "inicial",
  "inimigo",
  "injetar",
  "inocente",
  "inodoro",
  "inovador",
  "inox",
  "inquieto",
  "inscrito",
  "inseto",
  "insistir",
  "inspetor",
  "instalar",
  "insulto",
  "intacto",
  "integral",
  "intimar",
  "intocado",
  "intriga",
  "invasor",
  "inverno",
  "invicto",
  "invocar",
  "iogurte",
  "iraniano",
  "ironizar",
  "irreal",
  "irritado",
  "isca",
  "isento",
  "isolado",
  "isqueiro",
  "italiano",
  "janeiro",
  "jangada",
  "janta",
  "jararaca",
  "jardim",
  "jarro",
  "jasmim",
  "jato",
  "javali",
  "jazida",
  "jejum",
  "joaninha",
  "joelhada",
  "jogador",
  "joia",
  "jornal",
  "jorrar",
  "jovem",
  "juba",
  "judeu",
  "judoca",
  "juiz",
  "julgador",
  "julho",
  "jurado",
  "jurista",
  "juro",
  "justa",
  "labareda",
  "laboral",
  "lacre",
  "lactante",
  "ladrilho",
  "lagarta",
  "lagoa",
  "laje",
  "lamber",
  "lamentar",
  "laminar",
  "lampejo",
  "lanche",
  "lapidar",
  "lapso",
  "laranja",
  "lareira",
  "largura",
  "lasanha",
  "lastro",
  "lateral",
  "latido",
  "lavanda",
  "lavoura",
  "lavrador",
  "laxante",
  "lazer",
  "lealdade",
  "lebre",
  "legado",
  "legendar",
  "legista",
  "leigo",
  "leiloar",
  "leitura",
  "lembrete",
  "leme",
  "lenhador",
  "lentilha",
  "leoa",
  "lesma",
  "leste",
  "letivo",
  "letreiro",
  "levar",
  "leveza",
  "levitar",
  "liberal",
  "libido",
  "liderar",
  "ligar",
  "ligeiro",
  "limitar",
  "limoeiro",
  "limpador",
  "linda",
  "linear",
  "linhagem",
  "liquidez",
  "listagem",
  "lisura",
  "litoral",
  "livro",
  "lixa",
  "lixeira",
  "locador",
  "locutor",
  "lojista",
  "lombo",
  "lona",
  "longe",
  "lontra",
  "lorde",
  "lotado",
  "loteria",
  "loucura",
  "lousa",
  "louvar",
  "luar",
  "lucidez",
  "lucro",
  "luneta",
  "lustre",
  "lutador",
  "luva",
  "macaco",
  "macete",
  "machado",
  "macio",
  "madeira",
  "madrinha",
  "magnata",
  "magreza",
  "maior",
  "mais",
  "malandro",
  "malha",
  "malote",
  "maluco",
  "mamilo",
  "mamoeiro",
  "mamute",
  "manada",
  "mancha",
  "mandato",
  "manequim",
  "manhoso",
  "manivela",
  "manobrar",
  "mansa",
  "manter",
  "manusear",
  "mapeado",
  "maquinar",
  "marcador",
  "maresia",
  "marfim",
  "margem",
  "marinho",
  "marmita",
  "maroto",
  "marquise",
  "marreco",
  "martelo",
  "marujo",
  "mascote",
  "masmorra",
  "massagem",
  "mastigar",
  "matagal",
  "materno",
  "matinal",
  "matutar",
  "maxilar",
  "medalha",
  "medida",
  "medusa",
  "megafone",
  "meiga",
  "melancia",
  "melhor",
  "membro",
  "memorial",
  "menino",
  "menos",
  "mensagem",
  "mental",
  "merecer",
  "mergulho",
  "mesada",
  "mesclar",
  "mesmo",
  "mesquita",
  "mestre",
  "metade",
  "meteoro",
  "metragem",
  "mexer",
  "mexicano",
  "micro",
  "migalha",
  "migrar",
  "milagre",
  "milenar",
  "milhar",
  "mimado",
  "minerar",
  "minhoca",
  "ministro",
  "minoria",
  "miolo",
  "mirante",
  "mirtilo",
  "misturar",
  "mocidade",
  "moderno",
  "modular",
  "moeda",
  "moer",
  "moinho",
  "moita",
  "moldura",
  "moleza",
  "molho",
  "molinete",
  "molusco",
  "montanha",
  "moqueca",
  "morango",
  "morcego",
  "mordomo",
  "morena",
  "mosaico",
  "mosquete",
  "mostarda",
  "motel",
  "motim",
  "moto",
  "motriz",
  "muda",
  "muito",
  "mulata",
  "mulher",
  "multar",
  "mundial",
  "munido",
  "muralha",
  "murcho",
  "muscular",
  "museu",
  "musical",
  "nacional",
  "nadador",
  "naja",
  "namoro",
  "narina",
  "narrado",
  "nascer",
  "nativa",
  "natureza",
  "navalha",
  "navegar",
  "navio",
  "neblina",
  "nebuloso",
  "negativa",
  "negociar",
  "negrito",
  "nervoso",
  "neta",
  "neural",
  "nevasca",
  "nevoeiro",
  "ninar",
  "ninho",
  "nitidez",
  "nivelar",
  "nobreza",
  "noite",
  "noiva",
  "nomear",
  "nominal",
  "nordeste",
  "nortear",
  "notar",
  "noticiar",
  "noturno",
  "novelo",
  "novilho",
  "novo",
  "nublado",
  "nudez",
  "numeral",
  "nupcial",
  "nutrir",
  "nuvem",
  "obcecado",
  "obedecer",
  "objetivo",
  "obrigado",
  "obscuro",
  "obstetra",
  "obter",
  "obturar",
  "ocidente",
  "ocioso",
  "ocorrer",
  "oculista",
  "ocupado",
  "ofegante",
  "ofensiva",
  "oferenda",
  "oficina",
  "ofuscado",
  "ogiva",
  "olaria",
  "oleoso",
  "olhar",
  "oliveira",
  "ombro",
  "omelete",
  "omisso",
  "omitir",
  "ondulado",
  "oneroso",
  "ontem",
  "opcional",
  "operador",
  "oponente",
  "oportuno",
  "oposto",
  "orar",
  "orbitar",
  "ordem",
  "ordinal",
  "orfanato",
  "orgasmo",
  "orgulho",
  "oriental",
  "origem",
  "oriundo",
  "orla",
  "ortodoxo",
  "orvalho",
  "oscilar",
  "ossada",
  "osso",
  "ostentar",
  "otimismo",
  "ousadia",
  "outono",
  "outubro",
  "ouvido",
  "ovelha",
  "ovular",
  "oxidar",
  "oxigenar",
  "pacato",
  "paciente",
  "pacote",
  "pactuar",
  "padaria",
  "padrinho",
  "pagar",
  "pagode",
  "painel",
  "pairar",
  "paisagem",
  "palavra",
  "palestra",
  "palheta",
  "palito",
  "palmada",
  "palpitar",
  "pancada",
  "panela",
  "panfleto",
  "panqueca",
  "pantanal",
  "papagaio",
  "papelada",
  "papiro",
  "parafina",
  "parcial",
  "pardal",
  "parede",
  "partida",
  "pasmo",
  "passado",
  "pastel",
  "patamar",
  "patente",
  "patinar",
  "patrono",
  "paulada",
  "pausar",
  "peculiar",
  "pedalar",
  "pedestre",
  "pediatra",
  "pedra",
  "pegada",
  "peitoral",
  "peixe",
  "pele",
  "pelicano",
  "penca",
  "pendurar",
  "peneira",
  "penhasco",
  "pensador",
  "pente",
  "perceber",
  "perfeito",
  "pergunta",
  "perito",
  "permitir",
  "perna",
  "perplexo",
  "persiana",
  "pertence",
  "peruca",
  "pescado",
  "pesquisa",
  "pessoa",
  "petiscar",
  "piada",
  "picado",
  "piedade",
  "pigmento",
  "pilastra",
  "pilhado",
  "pilotar",
  "pimenta",
  "pincel",
  "pinguim",
  "pinha",
  "pinote",
  "pintar",
  "pioneiro",
  "pipoca",
  "piquete",
  "piranha",
  "pires",
  "pirueta",
  "piscar",
  "pistola",
  "pitanga",
  "pivete",
  "planta",
  "plaqueta",
  "platina",
  "plebeu",
  "plumagem",
  "pluvial",
  "pneu",
  "poda",
  "poeira",
  "poetisa",
  "polegada",
  "policiar",
  "poluente",
  "polvilho",
  "pomar",
  "pomba",
  "ponderar",
  "pontaria",
  "populoso",
  "porta",
  "possuir",
  "postal",
  "pote",
  "poupar",
  "pouso",
  "povoar",
  "praia",
  "prancha",
  "prato",
  "praxe",
  "prece",
  "predador",
  "prefeito",
  "premiar",
  "prensar",
  "preparar",
  "presilha",
  "pretexto",
  "prevenir",
  "prezar",
  "primata",
  "princesa",
  "prisma",
  "privado",
  "processo",
  "produto",
  "profeta",
  "proibido",
  "projeto",
  "prometer",
  "propagar",
  "prosa",
  "protetor",
  "provador",
  "publicar",
  "pudim",
  "pular",
  "pulmonar",
  "pulseira",
  "punhal",
  "punir",
  "pupilo",
  "pureza",
  "puxador",
  "quadra",
  "quantia",
  "quarto",
  "quase",
  "quebrar",
  "queda",
  "queijo",
  "quente",
  "querido",
  "quimono",
  "quina",
  "quiosque",
  "rabanada",
  "rabisco",
  "rachar",
  "racionar",
  "radial",
  "raiar",
  "rainha",
  "raio",
  "raiva",
  "rajada",
  "ralado",
  "ramal",
  "ranger",
  "ranhura",
  "rapadura",
  "rapel",
  "rapidez",
  "raposa",
  "raquete",
  "raridade",
  "rasante",
  "rascunho",
  "rasgar",
  "raspador",
  "rasteira",
  "rasurar",
  "ratazana",
  "ratoeira",
  "realeza",
  "reanimar",
  "reaver",
  "rebaixar",
  "rebelde",
  "rebolar",
  "recado",
  "recente",
  "recheio",
  "recibo",
  "recordar",
  "recrutar",
  "recuar",
  "rede",
  "redimir",
  "redonda",
  "reduzida",
  "reenvio",
  "refinar",
  "refletir",
  "refogar",
  "refresco",
  "refugiar",
  "regalia",
  "regime",
  "regra",
  "reinado",
  "reitor",
  "rejeitar",
  "relativo",
  "remador",
  "remendo",
  "remorso",
  "renovado",
  "reparo",
  "repelir",
  "repleto",
  "repolho",
  "represa",
  "repudiar",
  "requerer",
  "resenha",
  "resfriar",
  "resgatar",
  "residir",
  "resolver",
  "respeito",
  "ressaca",
  "restante",
  "resumir",
  "retalho",
  "reter",
  "retirar",
  "retomada",
  "retratar",
  "revelar",
  "revisor",
  "revolta",
  "riacho",
  "rica",
  "rigidez",
  "rigoroso",
  "rimar",
  "ringue",
  "risada",
  "risco",
  "risonho",
  "robalo",
  "rochedo",
  "rodada",
  "rodeio",
  "rodovia",
  "roedor",
  "roleta",
  "romano",
  "roncar",
  "rosado",
  "roseira",
  "rosto",
  "rota",
  "roteiro",
  "rotina",
  "rotular",
  "rouco",
  "roupa",
  "roxo",
  "rubro",
  "rugido",
  "rugoso",
  "ruivo",
  "rumo",
  "rupestre",
  "russo",
  "sabor",
  "saciar",
  "sacola",
  "sacudir",
  "sadio",
  "safira",
  "saga",
  "sagrada",
  "saibro",
  "salada",
  "saleiro",
  "salgado",
  "saliva",
  "salpicar",
  "salsicha",
  "saltar",
  "salvador",
  "sambar",
  "samurai",
  "sanar",
  "sanfona",
  "sangue",
  "sanidade",
  "sapato",
  "sarda",
  "sargento",
  "sarjeta",
  "saturar",
  "saudade",
  "saxofone",
  "sazonal",
  "secar",
  "secular",
  "seda",
  "sedento",
  "sediado",
  "sedoso",
  "sedutor",
  "segmento",
  "segredo",
  "segundo",
  "seiva",
  "seleto",
  "selvagem",
  "semanal",
  "semente",
  "senador",
  "senhor",
  "sensual",
  "sentado",
  "separado",
  "sereia",
  "seringa",
  "serra",
  "servo",
  "setembro",
  "setor",
  "sigilo",
  "silhueta",
  "silicone",
  "simetria",
  "simpatia",
  "simular",
  "sinal",
  "sincero",
  "singular",
  "sinopse",
  "sintonia",
  "sirene",
  "siri",
  "situado",
  "soberano",
  "sobra",
  "socorro",
  "sogro",
  "soja",
  "solda",
  "soletrar",
  "solteiro",
  "sombrio",
  "sonata",
  "sondar",
  "sonegar",
  "sonhador",
  "sono",
  "soprano",
  "soquete",
  "sorrir",
  "sorteio",
  "sossego",
  "sotaque",
  "soterrar",
  "sovado",
  "sozinho",
  "suavizar",
  "subida",
  "submerso",
  "subsolo",
  "subtrair",
  "sucata",
  "sucesso",
  "suco",
  "sudeste",
  "sufixo",
  "sugador",
  "sugerir",
  "sujeito",
  "sulfato",
  "sumir",
  "suor",
  "superior",
  "suplicar",
  "suposto",
  "suprimir",
  "surdina",
  "surfista",
  "surpresa",
  "surreal",
  "surtir",
  "suspiro",
  "sustento",
  "tabela",
  "tablete",
  "tabuada",
  "tacho",
  "tagarela",
  "talher",
  "talo",
  "talvez",
  "tamanho",
  "tamborim",
  "tampa",
  "tangente",
  "tanto",
  "tapar",
  "tapioca",
  "tardio",
  "tarefa",
  "tarja",
  "tarraxa",
  "tatuagem",
  "taurino",
  "taxativo",
  "taxista",
  "teatral",
  "tecer",
  "tecido",
  "teclado",
  "tedioso",
  "teia",
  "teimar",
  "telefone",
  "telhado",
  "tempero",
  "tenente",
  "tensor",
  "tentar",
  "termal",
  "terno",
  "terreno",
  "tese",
  "tesoura",
  "testado",
  "teto",
  "textura",
  "texugo",
  "tiara",
  "tigela",
  "tijolo",
  "timbrar",
  "timidez",
  "tingido",
  "tinteiro",
  "tiragem",
  "titular",
  "toalha",
  "tocha",
  "tolerar",
  "tolice",
  "tomada",
  "tomilho",
  "tonel",
  "tontura",
  "topete",
  "tora",
  "torcido",
  "torneio",
  "torque",
  "torrada",
  "torto",
  "tostar",
  "touca",
  "toupeira",
  "toxina",
  "trabalho",
  "tracejar",
  "tradutor",
  "trafegar",
  "trajeto",
  "trama",
  "trancar",
  "trapo",
  "traseiro",
  "tratador",
  "travar",
  "treino",
  "tremer",
  "trepidar",
  "trevo",
  "triagem",
  "tribo",
  "triciclo",
  "tridente",
  "trilogia",
  "trindade",
  "triplo",
  "triturar",
  "triunfal",
  "trocar",
  "trombeta",
  "trova",
  "trunfo",
  "truque",
  "tubular",
  "tucano",
  "tudo",
  "tulipa",
  "tupi",
  "turbo",
  "turma",
  "turquesa",
  "tutelar",
  "tutorial",
  "uivar",
  "umbigo",
  "unha",
  "unidade",
  "uniforme",
  "urologia",
  "urso",
  "urtiga",
  "urubu",
  "usado",
  "usina",
  "usufruir",
  "vacina",
  "vadiar",
  "vagaroso",
  "vaidoso",
  "vala",
  "valente",
  "validade",
  "valores",
  "vantagem",
  "vaqueiro",
  "varanda",
  "vareta",
  "varrer",
  "vascular",
  "vasilha",
  "vassoura",
  "vazar",
  "vazio",
  "veado",
  "vedar",
  "vegetar",
  "veicular",
  "veleiro",
  "velhice",
  "veludo",
  "vencedor",
  "vendaval",
  "venerar",
  "ventre",
  "verbal",
  "verdade",
  "vereador",
  "vergonha",
  "vermelho",
  "verniz",
  "versar",
  "vertente",
  "vespa",
  "vestido",
  "vetorial",
  "viaduto",
  "viagem",
  "viajar",
  "viatura",
  "vibrador",
  "videira",
  "vidraria",
  "viela",
  "viga",
  "vigente",
  "vigiar",
  "vigorar",
  "vilarejo",
  "vinco",
  "vinheta",
  "vinil",
  "violeta",
  "virada",
  "virtude",
  "visitar",
  "visto",
  "vitral",
  "viveiro",
  "vizinho",
  "voador",
  "voar",
  "vogal",
  "volante",
  "voleibol",
  "voltagem",
  "volumoso",
  "vontade",
  "vulto",
  "vuvuzela",
  "xadrez",
  "xarope",
  "xeque",
  "xeretar",
  "xerife",
  "xingar",
  "zangado",
  "zarpar",
  "zebu",
  "zelador",
  "zombar",
  "zoologia",
  "zumbido"
], ube = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
Object.defineProperty(qn, "__esModule", { value: !0 });
const _o = {};
qn.wordlists = _o;
let pr;
var Ea = qn._default = pr;
try {
  Ea = qn._default = pr = Qye, _o.czech = pr;
} catch {
}
try {
  Ea = qn._default = pr = ebe, _o.chinese_simplified = pr;
} catch {
}
try {
  Ea = qn._default = pr = tbe, _o.chinese_traditional = pr;
} catch {
}
try {
  Ea = qn._default = pr = rbe, _o.korean = pr;
} catch {
}
try {
  Ea = qn._default = pr = nbe, _o.french = pr;
} catch {
}
try {
  Ea = qn._default = pr = obe, _o.italian = pr;
} catch {
}
try {
  Ea = qn._default = pr = ibe, _o.spanish = pr;
} catch {
}
try {
  Ea = qn._default = pr = abe, _o.japanese = pr, _o.JA = pr;
} catch {
}
try {
  Ea = qn._default = pr = sbe, _o.portuguese = pr;
} catch {
}
try {
  Ea = qn._default = pr = ube, _o.english = pr, _o.EN = pr;
} catch {
}
Object.defineProperty(va, "__esModule", { value: !0 });
const cbe = ki, uN = Qr, cN = pb, lbe = Yu, wm = qn;
let cp = wm._default;
const nk = "Invalid mnemonic", Hc = "Invalid entropy", fbe = "Invalid mnemonic checksum", lN = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
function lp(e) {
  return (e || "").normalize("NFKD");
}
function fN(e, t, r) {
  for (; e.length < r; )
    e = t + e;
  return e;
}
function dN(e) {
  return parseInt(e, 2);
}
function hN(e) {
  return e.map((t) => fN(t.toString(2), "0", 8)).join("");
}
function pN(e) {
  const t = e.length * 8 / 32, r = cbe.sha256(Uint8Array.from(e));
  return hN(Array.from(r)).slice(0, t);
}
function gN(e) {
  return "mnemonic" + (e || "");
}
function dbe(e, t) {
  const r = Uint8Array.from(Buffer.from(lp(e), "utf8")), n = Uint8Array.from(Buffer.from(gN(lp(t)), "utf8")), o = cN.pbkdf2(uN.sha512, r, n, {
    c: 2048,
    dkLen: 64
  });
  return Buffer.from(o);
}
va.mnemonicToSeedSync = dbe;
function hbe(e, t) {
  const r = Uint8Array.from(Buffer.from(lp(e), "utf8")), n = Uint8Array.from(Buffer.from(gN(lp(t)), "utf8"));
  return cN.pbkdf2Async(uN.sha512, r, n, {
    c: 2048,
    dkLen: 64
  }).then((o) => Buffer.from(o));
}
var pbe = va.mnemonicToSeed = hbe;
function mN(e, t) {
  if (t = t || cp, !t)
    throw new Error(lN);
  const r = lp(e).split(" ");
  if (r.length % 3 !== 0)
    throw new Error(nk);
  const n = r.map((l) => {
    const c = t.indexOf(l);
    if (c === -1)
      throw new Error(nk);
    return fN(c.toString(2), "0", 11);
  }).join(""), o = Math.floor(n.length / 33) * 32, a = n.slice(0, o), i = n.slice(o), s = a.match(/(.{1,8})/g).map(dN);
  if (s.length < 16)
    throw new Error(Hc);
  if (s.length > 32)
    throw new Error(Hc);
  if (s.length % 4 !== 0)
    throw new Error(Hc);
  const u = Buffer.from(s);
  if (pN(u) !== i)
    throw new Error(fbe);
  return u.toString("hex");
}
va.mnemonicToEntropy = mN;
function yN(e, t) {
  if (Buffer.isBuffer(e) || (e = Buffer.from(e, "hex")), t = t || cp, !t)
    throw new Error(lN);
  if (e.length < 16)
    throw new TypeError(Hc);
  if (e.length > 32)
    throw new TypeError(Hc);
  if (e.length % 4 !== 0)
    throw new TypeError(Hc);
  const r = hN(Array.from(e)), n = pN(e), o = (r + n).match(/(.{1,11})/g).map((a) => {
    const i = dN(a);
    return t[i];
  });
  return t[0] === "" ? o.join("") : o.join(" ");
}
var gbe = va.entropyToMnemonic = yN;
function mbe(e, t, r) {
  if (e = e || 128, e % 32 !== 0)
    throw new TypeError(Hc);
  return t = t || ((n) => Buffer.from(lbe.randomBytes(n))), yN(t(e / 8), r);
}
va.generateMnemonic = mbe;
function ybe(e, t) {
  try {
    mN(e, t);
  } catch {
    return !1;
  }
  return !0;
}
va.validateMnemonic = ybe;
function bbe(e) {
  const t = wm.wordlists[e];
  if (t)
    cp = t;
  else
    throw new Error('Could not find wordlist for language "' + e + '"');
}
va.setDefaultWordlist = bbe;
function wbe() {
  if (!cp)
    throw new Error("No Default Wordlist set");
  return Object.keys(wm.wordlists).filter((e) => e === "JA" || e === "EN" ? !1 : wm.wordlists[e].every((t, r) => t === cp[r]))[0];
}
va.getDefaultWordlist = wbe;
var vbe = qn;
va.wordlists = vbe.wordlists;
function Ebe(e) {
  return $P(tn(e));
}
function ok(e, t) {
  return D5(rce, e, t);
}
const ft = (e) => Yne(e);
function kbe(e) {
  if (Lr(e.isPoint(ft("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), Lr(!e.isPoint(ft("030000000000000000000000000000000000000000000000000000000000000005"))), Lr(e.isPrivate(ft("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), Lr(e.isPrivate(ft("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), Lr(!e.isPrivate(ft("0000000000000000000000000000000000000000000000000000000000000000"))), Lr(!e.isPrivate(ft("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), Lr(!e.isPrivate(ft("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), Lr(Na(e.pointFromScalar(ft("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), ft("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0), e.xOnlyPointAddTweak) {
    Lr(e.xOnlyPointAddTweak(ft("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), ft("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
    let t = e.xOnlyPointAddTweak(ft("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), ft("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
    Lr(Na(t.xOnlyPubkey, ft("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && t.parity === 1), t = e.xOnlyPointAddTweak(ft("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), ft("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
  }
  Lr(Na(e.pointAddScalar(ft("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), ft("0000000000000000000000000000000000000000000000000000000000000003")), ft("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0), Lr(Na(e.privateAdd(ft("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), ft("0000000000000000000000000000000000000000000000000000000000000002")), ft("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), e.privateNegate && (Lr(Na(e.privateNegate(ft("0000000000000000000000000000000000000000000000000000000000000001")), ft("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), Lr(Na(e.privateNegate(ft("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), ft("0000000000000000000000000000000000000000000000000000000000000003")) === 0), Lr(Na(e.privateNegate(ft("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), ft("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0)), Lr(Na(e.sign(ft("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), ft("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), ft("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0), Lr(e.verify(ft("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), ft("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), ft("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), e.signSchnorr && Lr(Na(e.signSchnorr(ft("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), ft("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), ft("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), ft("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0), e.verifySchnorr && Lr(e.verifySchnorr(ft("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), ft("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), ft("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
}
function Lr(e) {
  if (!e)
    throw new Error("ecc library invalid");
}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function _8(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
// @__NO_SIDE_EFFECTS__
function bN(...e) {
  const t = (a) => a, r = (a, i) => (s) => a(i(s)), n = e.map((a) => a.encode).reduceRight(r, t), o = e.map((a) => a.decode).reduce(r, t);
  return { encode: n, decode: o };
}
// @__NO_SIDE_EFFECTS__
function xbe(e) {
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return t.map((r) => {
        if (r < 0 || r >= e.length)
          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
        return e[r];
      });
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return t.map((r) => {
        if (typeof r != "string")
          throw new Error(`alphabet.decode: not string element=${r}`);
        const n = e.indexOf(r);
        if (n === -1)
          throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
        return n;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function Abe(e = "") {
  if (typeof e != "string")
    throw new Error("join separator should be string");
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let r of t)
        if (typeof r != "string")
          throw new Error(`join.encode: non-string input=${r}`);
      return t.join(e);
    },
    decode: (t) => {
      if (typeof t != "string")
        throw new Error("join.decode input should be string");
      return t.split(e);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function ik(e, t, r) {
  if (t < 2)
    throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
  if (!Array.isArray(e))
    throw new Error("convertRadix: data should be array");
  if (!e.length)
    return [];
  let n = 0;
  const o = [], a = Array.from(e);
  for (a.forEach((i) => {
    if (i < 0 || i >= t)
      throw new Error(`Wrong integer: ${i}`);
  }); ; ) {
    let i = 0, s = !0;
    for (let u = n; u < a.length; u++) {
      const l = a[u], c = t * i + l;
      if (!Number.isSafeInteger(c) || t * i / t !== i || c - l !== t * i)
        throw new Error("convertRadix: carry overflow");
      i = c % r;
      const f = Math.floor(c / r);
      if (a[u] = f, !Number.isSafeInteger(f) || f * r + i !== c)
        throw new Error("convertRadix: carry overflow");
      if (s)
        f ? s = !1 : n = u;
      else continue;
    }
    if (o.push(i), s)
      break;
  }
  for (let i = 0; i < e.length - 1 && e[i] === 0; i++)
    o.push(0);
  return o.reverse();
}
// @__NO_SIDE_EFFECTS__
function Sbe(e) {
  return {
    encode: (t) => {
      if (!_8(t))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ ik(Array.from(t), 2 ** 8, e);
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(/* @__PURE__ */ ik(t, e, 2 ** 8));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function _be(e, t) {
  if (typeof t != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(r) {
      if (!_8(r))
        throw new Error("checksum.encode: input should be Uint8Array");
      const n = t(r).slice(0, e), o = new Uint8Array(r.length + e);
      return o.set(r), o.set(n, r.length), o;
    },
    decode(r) {
      if (!_8(r))
        throw new Error("checksum.decode: input should be Uint8Array");
      const n = r.slice(0, -e), o = t(n).slice(0, e), a = r.slice(-e);
      for (let i = 0; i < e; i++)
        if (o[i] !== a[i])
          throw new Error("Invalid checksum");
      return n;
    }
  };
}
const Ibe = (e) => /* @__PURE__ */ bN(/* @__PURE__ */ Sbe(58), /* @__PURE__ */ xbe(e), /* @__PURE__ */ Abe("")), Tbe = /* @__PURE__ */ Ibe("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), Pbe = (e) => /* @__PURE__ */ bN(/* @__PURE__ */ _be(4, (t) => e(e(t))), Tbe), Obe = Pbe;
function $be(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? void 0,
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? void 0,
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? void 0
  };
}
function Cbe(e, t) {
  var r;
  return (r = void 0) == null ? void 0 : r.get(t);
}
function fp(e) {
  var t, r;
  const n = typeof e;
  return n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n === "object" || n === "function" ? (e && ((r = (t = Object.getPrototypeOf(e)) == null ? void 0 : t.constructor) == null ? void 0 : r.name)) ?? "null" : n;
}
function vs(e, t, r, n, o) {
  const a = o && "input" in o ? o.input : r.value, i = (o == null ? void 0 : o.expected) ?? e.expects ?? null, s = (o == null ? void 0 : o.received) ?? fp(a), u = {
    kind: e.kind,
    type: e.type,
    input: a,
    expected: i,
    received: s,
    message: `Invalid ${t}: ${i ? `Expected ${i} but r` : "R"}eceived ${s}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, l = e.kind === "schema", c = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? Cbe(e.reference, u.lang) ?? (l ? (u.lang, void 0) : null) ?? n.message ?? (u.lang, void 0);
  c && (u.message = typeof c == "function" ? c(u) : c), l && (r.typed = !1), r.issues ? r.issues.push(u) : r.issues = [u];
}
var Bbe = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e) {
    super(e[0].message), xe(this, "issues"), this.name = "ValiError", this.issues = e;
  }
};
function gb(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: gb,
    async: !1,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && vs(this, "integer", t, r), t;
    }
  };
}
function V4(e, t) {
  return {
    kind: "validation",
    type: "length",
    reference: V4,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length !== this.requirement && vs(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function mb(e, t) {
  return {
    kind: "validation",
    type: "max_value",
    reference: mb,
    async: !1,
    expects: `<=${e instanceof Date ? e.toJSON() : fp(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value > this.requirement && vs(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : fp(r.value)
      }), r;
    }
  };
}
function yb(e, t) {
  return {
    kind: "validation",
    type: "min_value",
    reference: yb,
    async: !1,
    expects: `>=${e instanceof Date ? e.toJSON() : fp(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value < this.requirement && vs(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : fp(r.value)
      }), r;
    }
  };
}
function wN(e, t) {
  return {
    kind: "validation",
    type: "regex",
    reference: wN,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.test(r.value) && vs(this, "format", r, n), r;
    }
  };
}
function bb(e, t) {
  return {
    kind: "schema",
    type: "instance",
    reference: bb,
    expects: e.name,
    async: !1,
    class: e,
    message: t,
    _run(r, n) {
      return r.value instanceof this.class ? r.typed = !0 : vs(this, "type", r, n), r;
    }
  };
}
function wb(e) {
  return {
    kind: "schema",
    type: "number",
    reference: wb,
    expects: "number",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : vs(this, "type", t, r), t;
    }
  };
}
function I8(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: I8,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (a && typeof a == "object") {
        r.typed = !0, r.value = {};
        for (const i in this.entries) {
          const s = a[i], u = this.entries[i]._run(
            { typed: !1, value: s },
            n
          );
          if (u.issues) {
            const l = {
              type: "object",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), (u.value !== void 0 || i in a) && (r.value[i] = u.value);
        }
      } else
        vs(this, "type", r, n);
      return r;
    }
  };
}
function vN(e) {
  return {
    kind: "schema",
    type: "string",
    reference: vN,
    expects: "string",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = !0 : vs(this, "type", t, r), t;
    }
  };
}
function za(e, t, r) {
  const n = e._run(
    { typed: !1, value: t },
    $be(r)
  );
  if (n.issues)
    throw new Bbe(n.issues);
  return n.value;
}
function vd(...e) {
  return {
    ...e[0],
    pipe: e,
    _run(t, r) {
      for (const n of e)
        if (n.kind !== "metadata") {
          if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
            t.typed = !1;
            break;
          }
          (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
        }
      return t;
    }
  };
}
const T8 = vd(wb(), gb(), yb(0), mb(4294967295)), Nbe = vd(wb(), gb(), yb(0), mb(2147483647)), Ube = vd(wb(), gb(), yb(0), mb(255)), gw = vd(bb(Uint8Array), V4(32)), Rbe = vd(bb(Uint8Array), V4(33)), zbe = I8({
  wif: Ube,
  bip32: I8({
    public: T8,
    private: T8
  })
}), jbe = vd(vN(), wN(/^(m\/)?(\d+'?\/)*\d+'?$/));
function Lbe(e, t, r) {
  if (t.length !== 32)
    throw new TypeError("Invalid privateKey length");
  var n = new Uint8Array(34), o = new DataView(n.buffer);
  return o.setUint8(0, e), n.set(t, 1), n[33] = 1, n;
}
function Hbe(e) {
  return Cf.encode(Lbe(e.version, e.privateKey));
}
const ak = Obe(tn), sk = {
  encode: (e) => ak.encode(e),
  decode: (e) => ak.decode(e)
};
function Fbe(e) {
  kbe(e);
  const t = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  }, r = 2147483648;
  function n(h) {
    return h.length === 32 ? h : h.slice(1, 33);
  }
  class o {
    constructor(p, y) {
      xe(this, "__D"), xe(this, "__Q"), xe(this, "lowR", !1), this.__D = p, this.__Q = y;
    }
    get publicKey() {
      return this.__Q === void 0 && (this.__Q = e.pointFromScalar(this.__D, !0)), this.__Q;
    }
    get privateKey() {
      return this.__D;
    }
    sign(p, y) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (y === void 0 && (y = this.lowR), y === !1)
        return e.sign(p, this.privateKey);
      {
        let m = e.sign(p, this.privateKey);
        const b = new Uint8Array(32);
        let v = 0;
        for (; m[0] > 127; )
          v++, cc(b, 0, v, "LE"), m = e.sign(p, this.privateKey, b);
        return m;
      }
    }
    signSchnorr(p) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (!e.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return e.signSchnorr(p, this.privateKey);
    }
    verify(p, y) {
      return e.verify(p, this.publicKey, y);
    }
    verifySchnorr(p, y) {
      if (!e.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return e.verifySchnorr(p, this.publicKey.subarray(1, 33), y);
    }
  }
  class a extends o {
    constructor(p, y, m, b, v = 0, k = 0, E = 0) {
      super(p, y), xe(this, "chainCode"), xe(this, "network"), xe(this, "__DEPTH"), xe(this, "__INDEX"), xe(this, "__PARENT_FINGERPRINT"), this.chainCode = m, this.network = b, this.__DEPTH = v, this.__INDEX = k, this.__PARENT_FINGERPRINT = E, za(zbe, b);
    }
    get depth() {
      return this.__DEPTH;
    }
    get index() {
      return this.__INDEX;
    }
    get parentFingerprint() {
      return this.__PARENT_FINGERPRINT;
    }
    get identifier() {
      return Ebe(this.publicKey);
    }
    get fingerprint() {
      return this.identifier.slice(0, 4);
    }
    get compressed() {
      return !0;
    }
    // Private === not neutered
    // Public === neutered
    isNeutered() {
      return this.__D === void 0;
    }
    neutered() {
      return c(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const p = this.network, y = this.isNeutered() ? p.bip32.public : p.bip32.private, m = new Uint8Array(78);
      return cc(m, 0, y, "BE"), R7(m, 4, this.depth), cc(m, 5, this.parentFingerprint, "BE"), cc(m, 9, this.index, "BE"), m.set(this.chainCode, 13), this.isNeutered() ? m.set(this.publicKey, 45) : (R7(m, 45, 0), m.set(this.privateKey, 46)), sk.encode(m);
    }
    toWIF() {
      if (!this.privateKey)
        throw new TypeError("Missing private key");
      return Hbe({
        version: this.network.wif,
        privateKey: this.privateKey,
        compressed: !0
      });
    }
    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    derive(p) {
      za(T8, p);
      const y = p >= r, m = new Uint8Array(37);
      if (y) {
        if (this.isNeutered())
          throw new TypeError("Missing private key for hardened child key");
        m[0] = 0, m.set(this.privateKey, 1), cc(m, 33, p, "BE");
      } else
        m.set(this.publicKey, 0), cc(m, 33, p, "BE");
      const b = ok(this.chainCode, m), v = b.slice(0, 32), k = b.slice(32);
      if (!e.isPrivate(v))
        return this.derive(p + 1);
      let E;
      if (this.isNeutered()) {
        const A = e.pointAddScalar(this.publicKey, v, !0);
        if (A === null)
          return this.derive(p + 1);
        E = c(A, k, this.network, this.depth + 1, p, Kl(this.fingerprint, 0, "BE"));
      } else {
        const A = e.privateAdd(this.privateKey, v);
        if (A == null)
          return this.derive(p + 1);
        E = u(A, k, this.network, this.depth + 1, p, Kl(this.fingerprint, 0, "BE"));
      }
      return E;
    }
    deriveHardened(p) {
      if (typeof za(Nbe, p) == "number")
        return this.derive(p + r);
      throw new TypeError("Expected UInt31, got " + p);
    }
    derivePath(p) {
      za(jbe, p);
      let y = p.split("/");
      if (y[0] === "m") {
        if (this.parentFingerprint)
          throw new TypeError("Expected master, got child");
        y = y.slice(1);
      }
      return y.reduce((m, b) => {
        let v;
        return b.slice(-1) === "'" ? (v = parseInt(b.slice(0, -1), 10), m.deriveHardened(v)) : (v = parseInt(b, 10), m.derive(v));
      }, this);
    }
    tweak(p) {
      return this.privateKey ? this.tweakFromPrivateKey(p) : this.tweakFromPublicKey(p);
    }
    tweakFromPublicKey(p) {
      const y = n(this.publicKey);
      if (!e.xOnlyPointAddTweak)
        throw new Error("xOnlyPointAddTweak not supported by ecc library");
      const m = e.xOnlyPointAddTweak(y, p);
      if (!m || m.xOnlyPubkey === null)
        throw new Error("Cannot tweak public key!");
      const b = Uint8Array.from([
        m.parity === 0 ? 2 : 3
      ]), v = Xne([
        b,
        m.xOnlyPubkey
      ]);
      return new o(void 0, v);
    }
    tweakFromPrivateKey(p) {
      const y = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, m = (() => {
        if (y) {
          if (e.privateNegate)
            return e.privateNegate(this.privateKey);
          throw new Error("privateNegate not supported by ecc library");
        } else return this.privateKey;
      })(), b = e.privateAdd(m, p);
      if (!b)
        throw new Error("Invalid tweaked private key!");
      return new o(b, void 0);
    }
  }
  function i(h, p) {
    const y = sk.decode(h);
    if (y.length !== 78)
      throw new TypeError("Invalid buffer length");
    p = p || t;
    const m = Kl(y, 0, "BE");
    if (m !== p.bip32.private && m !== p.bip32.public)
      throw new TypeError("Invalid network version");
    const b = y[4], v = Kl(y, 5, "BE");
    if (b === 0 && v !== 0)
      throw new TypeError("Invalid parent fingerprint");
    const k = Kl(y, 9, "BE");
    if (b === 0 && k !== 0)
      throw new TypeError("Invalid index");
    const E = y.slice(13, 45);
    let A;
    if (m === p.bip32.private) {
      if (y[45] !== 0)
        throw new TypeError("Invalid private key");
      const S = y.slice(46, 78);
      A = u(S, E, p, b, k, v);
    } else {
      const S = y.slice(45, 78);
      A = c(S, E, p, b, k, v);
    }
    return A;
  }
  function s(h, p, y) {
    return u(h, p, y);
  }
  function u(h, p, y, m, b, v) {
    if (za(gw, h), za(gw, p), y = y || t, !e.isPrivate(h))
      throw new TypeError("Private key not in range [1, n)");
    return new a(h, void 0, p, y, m, b, v);
  }
  function l(h, p, y) {
    return c(h, p, y);
  }
  function c(h, p, y, m, b, v) {
    if (za(Rbe, h), za(gw, p), y = y || t, !e.isPoint(h))
      throw new TypeError("Point is not on the curve");
    return new a(void 0, h, p, y, m, b, v);
  }
  function f(h, p) {
    if (za(bb(Uint8Array), h), h.length < 16)
      throw new TypeError("Seed should be at least 128 bits");
    if (h.length > 64)
      throw new TypeError("Seed should be at most 512 bits");
    p = p || t;
    const y = ok(Wne("Bitcoin seed"), h), m = y.slice(0, 32), b = y.slice(32);
    return s(m, b, p);
  }
  return {
    fromSeed: f,
    fromBase58: i,
    fromPublicKey: l,
    fromPrivateKey: s
  };
}
const Dbe = "text/plain", uk = "btc", ck = "runes", G4 = "bip322", s0 = "ecdsa", vb = "bip322-simple";
async function EN(e, t = Ut) {
  try {
    return await nr.get(`${db(t)}/api/tx/${e}`).then((r) => r.data);
  } catch (r) {
    throw r;
  }
}
const kN = async (e) => await nr.get(`${db(e)}/api/v1/fees/recommended`, {
  headers: {
    "Content-Type": "application/json"
  }
}).then((t) => t.data), Mbe = Fbe(ab);
N5(ab);
async function Kbe(e) {
  const t = crypto.getRandomValues(new Uint8Array(32)), r = gbe(Buffer.from(t)), n = await pbe(r), o = Mbe.fromSeed(n, kr(e));
  return o == null ? void 0 : o.derivePath("m/44'/0'/0'/0/0").privateKey;
}
const xN = (e, t) => {
  try {
    const r = kr(t), n = KP(e);
    if (n.version === r.pubKeyHash) return zre;
    if (n.version === r.scriptHash) {
      const o = dr(n.hash);
      return o && o.length === 2 && o[0] === Lt.OP_0 ? jre : E5;
    }
  } catch {
    try {
      const r = R5(e);
      if (r.version === 0 && r.data.length === 20) return Bv;
      if (r.version === 0 && r.data.length === 32) return Lre;
      if (r.version === 1 && r.data.length === 32) return lf;
    } catch {
      return "unknown";
    }
  }
  return "unknown";
};
function qbe(e, t) {
  const r = kr(t);
  return Gp(e, r);
}
function Z4(e, t) {
  var r;
  const n = Mp({
    pubkey: Buffer.from(e, "hex"),
    network: kr(t)
  }), o = dd({
    redeem: n,
    network: kr(t)
  });
  return (r = o == null ? void 0 : o.redeem) == null ? void 0 : r.output;
}
async function Vbe(e, t) {
  const r = Date.now();
  for (; ; )
    try {
      if (await EN(e, t))
        return console.log("Transaction found in mempool:", e), !0;
      if (Date.now() - r > 6e4)
        return !1;
      await new Promise((n) => setTimeout(n, 5e3));
    } catch {
      if (Date.now() - r > 6e4)
        return !1;
      await new Promise((n) => setTimeout(n, 5e3));
    }
}
async function Gbe(e, t, r) {
  const n = Date.now();
  for (; ; )
    try {
      const o = await EN(e, r);
      if (o && o.vout && o.vout.length > 0)
        return Math.floor(o.vout[t].value);
      if (Date.now() - n > 6e4)
        return null;
      await new Promise((a) => setTimeout(a, 5e3));
    } catch (o) {
      if (console.error("Error fetching transaction output value:", o), Date.now() - n > 6e4)
        return null;
      await new Promise((a) => setTimeout(a, 5e3));
    }
}
N5(ab);
const kr = (e) => e === Cr || e === hn || e === En ? Hre : Ui, W4 = (e) => e.find(
  ({ purpose: t }) => t === "ordinals"
), X4 = (e) => e.find(
  ({ purpose: t }) => t === "payment"
), fs = async (e, t) => {
  try {
    const r = await Eb(
      e,
      t
    );
    return r ? r.reduce((n, o) => n + BigInt(o.value), 0n) : 0n;
  } catch (r) {
    throw console.error("Error fetching BTC balance:", r), new Error("Failed to fetch BTC balance");
  }
};
function AN(e, t, r) {
  const n = e * 57 + t * 41, o = r * 34;
  return 10 + n + o;
}
async function Eb(e, t) {
  if (e.startsWith("t")) {
    if (t === Ut)
      return [];
    if (t === xl)
      return [];
    if (t === Xn)
      return [];
  }
  return await nr.get(`${db(t)}/api/address/${e}/utxo`).then((r) => r.data);
}
async function Y4(e, t, r, n, o, a, i = 7) {
  const s = e === t, u = await Eb(
    t,
    a
  );
  if (!u)
    throw new Error("No UTXOs found");
  const l = u.sort(
    (m, b) => b.value - m.value
  ), c = new Zt({ network: kr(a) }), f = AN(1, 0, 2), h = Math.floor(f * i) + n;
  let p = 0, y = 0;
  for await (let m of l) {
    const { txid: b, vout: v, value: k } = m, E = Gp(
      t,
      kr(a)
    );
    if (c.addInput({
      hash: b,
      index: v,
      witnessUtxo: {
        script: E,
        value: BigInt(k)
      }
    }), !s) {
      const A = Z4(o, a);
      c.updateInput(y, { redeemScript: A });
    }
    if (p += k, p >= h)
      break;
  }
  if (p < h)
    throw new Error("Insufficient funds");
  return c.addOutput({
    address: r,
    value: BigInt(n)
  }), p > h && c.addOutput({
    address: t,
    value: BigInt(p - h)
  }), {
    psbtBase64: c.toBase64(),
    psbtHex: c.toHex()
  };
}
function SN(e) {
  return e == null ? void 0 : e.reduce((t, r) => t + r.value, 0);
}
async function kb(e, t) {
  return (await nr.post(
    `${db(t)}/api/tx`,
    e,
    {
      headers: {
        "Content-Type": "text/plain"
      }
    }
  )).data;
}
const J4 = (e) => e === Cr || e === hn || e === En, Ed = (e) => e === Ut || e === xl || e === Xn;
N5(ab);
const Zbe = async ({
  contentBase64: e,
  mimeType: t,
  quantity: r = 1,
  inscriptions: n,
  ordinalAddress: o,
  paymentAddress: a,
  paymentPublicKey: i,
  signPsbt: s,
  network: u = Ut
}) => {
  try {
    if (!e && !n)
      throw new Error("contentBase64 or inscriptions is required");
    const l = await Kbe(u), c = Buffer.from(l).toString("hex"), f = n || Array(r).fill({
      content: e,
      mimeType: t
    }), h = await Wbe({
      inscriptions: f,
      paymentAddress: a,
      paymentPublicKey: i,
      privKey: c,
      network: u
    });
    if (!h || !(h != null && h.psbtHex))
      throw new Error("couldn't get commit tx");
    const p = String(h == null ? void 0 : h.psbtHex), y = String(h == null ? void 0 : h.psbtBase64), m = await s(
      "",
      p,
      y,
      !0,
      !1,
      u
    );
    if (!m) throw new Error("sign psbt failed");
    const b = Zt.fromHex((m == null ? void 0 : m.signedPsbtHex) || "").extractTransaction(), v = await kb(b.toHex(), u);
    if (!v) throw new Error("commit tx failed");
    return await Xbe({
      inscriptions: f,
      ordinalAddress: o,
      privKey: c,
      commitTxId: v,
      network: u
    });
  } catch (l) {
    throw l;
  }
}, Wbe = async ({
  inscriptions: e,
  paymentAddress: t,
  paymentPublicKey: r,
  privKey: n,
  network: o
}) => {
  try {
    const a = e.length, i = e.reduce(
      (S, _) => S + Buffer.from(_.content).length,
      0
    );
    if (i > 39e4)
      throw new Error("Content size is too large, must be less than 390kb");
    const { fastestFee: s } = await kN(o), u = UO(String(n), !0), l = new Zt({
      network: kr(o)
    }), { inscriberAddress: c } = Ybe(
      u,
      e,
      o
    ), f = 5 * 34 * a, h = Math.floor(f * s * a), p = Math.floor(i * s / 3) + 1e3 + 546 * a, y = Math.floor(h + p), m = (await Eb(
      t,
      o
    )).filter((S) => S.value > 3e3).sort((S, _) => _.value - S.value), b = SN(m);
    if (b === 0)
      throw new Error("insufficient funds");
    if (b < y)
      throw new Error("insufficient funds");
    let v = 0;
    const k = Gp(
      t,
      kr(o)
    );
    let E = 0;
    for await (const S of m) {
      const _ = xN(t, o);
      if (l.addInput({
        hash: S.txid,
        index: S.vout,
        witnessUtxo: { value: BigInt(S.value), script: k }
      }), _ === lf && l.updateInput(E, {
        tapInternalKey: Uc(Buffer.from(r, "hex"))
      }), _ === E5) {
        let I = Z4(r, o);
        l.updateInput(E, { redeemScript: I });
      }
      if (E++, v += S.value, v > y)
        break;
    }
    const A = v - y;
    return l.addOutput({
      value: BigInt(p),
      address: c
    }), A > 546 && l.addOutput({
      value: BigInt(A),
      address: t
    }), {
      psbtHex: l.toHex(),
      psbtBase64: l.toBase64()
    };
  } catch (a) {
    throw a;
  }
}, Xbe = async ({
  inscriptions: e,
  ordinalAddress: t,
  commitTxId: r,
  privKey: n,
  network: o,
  isDry: a
}) => {
  try {
    const i = nce(n), s = UO(n, !0), u = _N(s, e), l = om.encodeScript(u), [c, f] = om.getPubKey(s, { target: l });
    if (!await Vbe(String(r), o))
      throw new Error("ERROR WAITING FOR COMMIT TX");
    const h = await Gbe(
      r,
      0,
      o
    );
    if (h === 0 || !h)
      throw new Error("ERROR GETTING FIRST INPUT VALUE");
    const p = wi.create({
      vin: [
        {
          txid: r,
          vout: 0,
          prevout: {
            value: h,
            scriptPubKey: ["OP_1", c]
          }
        }
      ],
      vout: [
        ...Array(e.length).fill({
          value: 546,
          scriptPubKey: PC.toScriptPubKey(t)
        })
      ]
    }), y = z0e.taproot.sign(i, p, 0, { extension: l });
    return p.vin[0].witness = [y, u, f], a ? wi.util.getTxid(p) : await kb(wi.encode(p).hex, o);
  } catch (i) {
    throw i;
  }
}, _N = (e, t) => {
  const r = new TextEncoder(), n = r.encode("ord"), o = 546, a = (s, u) => {
    let l;
    if (u === Dbe) {
      const f = Buffer.from(s, "base64").toString("utf-8");
      l = Buffer.from(f, "utf-8");
    } else
      l = Buffer.from(s, "base64");
    const c = [];
    for (let f = 0; f < l.length; f += 520)
      c.push(l.slice(f, f + 520));
    return c;
  }, i = [e, "OP_CHECKSIG"];
  return t.forEach((s, u) => {
    const { content: l, mimeType: c } = s, f = a(l, c);
    if (i.push("OP_0", "OP_IF", n, "01", r.encode(c), "OP_0"), u > 0) {
      const h = o * (u + 1), p = Buffer.from([h]);
      i.push(Buffer.from([2])), i.push(p);
    }
    i.push(...f.map((h) => h), "OP_ENDIF");
  }), i;
}, Ybe = (e, t, r = Ut) => {
  const n = _N(e, t), o = om.encodeScript(n), [a] = om.getPubKey(e, { target: o });
  return {
    inscriberAddress: PC.p2tr.fromPubKey(
      a,
      cme(r)
    ),
    tpubkey: a,
    tapleaf: o
  };
};
var Jbe = {}, u0 = {};
Object.defineProperty(u0, "__esModule", { value: !0 });
u0.isRunestone = void 0;
function Qbe(e) {
  return !("flaws" in e);
}
u0.isRunestone = Qbe;
var tr = {}, Co = {}, Q4 = {}, Bo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isNone = e.isSome = e.None = e.Some = e.OptionType = void 0, e.OptionType = {
    Some: Symbol(":some"),
    None: Symbol(":none")
  };
  class t {
    constructor(s) {
      this.val = s;
    }
    get type() {
      return e.OptionType.Some;
    }
    isSome() {
      return !0;
    }
    isNone() {
      return !1;
    }
    match(s) {
      return s.some(this.val);
    }
    map(s) {
      return n(s(this.val));
    }
    inspect(s) {
      return s(this.val), this;
    }
    andThen(s) {
      return s(this.val);
    }
    or(s) {
      return this;
    }
    orElse(s) {
      return this;
    }
    and(s) {
      return s;
    }
    unwrapOr(s) {
      return this.val;
    }
    unwrap() {
      return this.val;
    }
  }
  class r {
    get type() {
      return e.OptionType.None;
    }
    isSome() {
      return !1;
    }
    isNone() {
      return !0;
    }
    match({ none: s }) {
      return typeof s == "function" ? s() : s;
    }
    map(s) {
      return new r();
    }
    inspect(s) {
      return this;
    }
    andThen(s) {
      return new r();
    }
    or(s) {
      return s;
    }
    orElse(s) {
      return s();
    }
    and(s) {
      return new r();
    }
    unwrapOr(s) {
      return s;
    }
    unwrap() {
      throw new ReferenceError("Trying to unwrap None.");
    }
  }
  function n(i) {
    return new t(i);
  }
  e.Some = n, e.None = new r();
  function o(i) {
    return i.isSome();
  }
  e.isSome = o;
  function a(i) {
    return i.isNone();
  }
  e.isNone = a;
})(Bo);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.u8 = e.U8_MAX_BIGINT = void 0;
  const t = Bo;
  e.U8_MAX_BIGINT = 0xffn;
  function r(n) {
    return (typeof n == "bigint" ? n : BigInt(n)) & e.U8_MAX_BIGINT;
  }
  e.u8 = r, function(n) {
    n.MAX = n(e.U8_MAX_BIGINT);
    function o(i, s) {
      const u = i + s;
      return u > n.MAX ? t.None : (0, t.Some)(n(u));
    }
    n.checkedAdd = o;
    function a(i, s) {
      const u = i - s;
      return u < 0n ? t.None : (0, t.Some)(n(u));
    }
    n.checkedSub = a;
  }(r || (e.u8 = r = {}));
})(Q4);
var e6 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.u32 = e.U32_MAX_BIGINT = void 0;
  const t = Bo;
  e.U32_MAX_BIGINT = 0xffffffffn;
  function r(n) {
    return (typeof n == "bigint" ? n : BigInt(n)) & e.U32_MAX_BIGINT;
  }
  e.u32 = r, function(n) {
    n.MAX = n(e.U32_MAX_BIGINT);
    function o(i, s) {
      const u = i + s;
      return u > n.MAX ? t.None : (0, t.Some)(n(u));
    }
    n.checkedAdd = o;
    function a(i, s) {
      const u = i - s;
      return u < 0n ? t.None : (0, t.Some)(n(u));
    }
    n.checkedSub = a;
  }(r || (e.u32 = r = {}));
})(e6);
var t6 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.u64 = e.U64_MAX_BIGINT = void 0;
  const t = Bo;
  e.U64_MAX_BIGINT = 0xffffffffffffffffn;
  function r(n) {
    return (typeof n == "bigint" ? n : BigInt(n)) & e.U64_MAX_BIGINT;
  }
  e.u64 = r, function(n) {
    n.MAX = n(e.U64_MAX_BIGINT);
    function o(i, s) {
      const u = i + s;
      return u > n.MAX ? t.None : (0, t.Some)(n(u));
    }
    n.checkedAdd = o;
    function a(i, s) {
      const u = i - s;
      return u < 0n ? t.None : (0, t.Some)(n(u));
    }
    n.checkedSub = a;
  }(r || (e.u64 = r = {}));
})(t6);
var IN = {}, c0 = {};
Object.defineProperty(c0, "__esModule", { value: !0 });
c0.SeekBuffer = void 0;
class e2e {
  constructor(t) {
    this.buffer = t, this.seekIndex = 0;
  }
  readUInt8() {
    if (!this.isFinished())
      return this.buffer.readUInt8(this.seekIndex++);
  }
  isFinished() {
    return this.seekIndex >= this.buffer.length;
  }
}
c0.SeekBuffer = e2e;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getAllU128 = e.u128 = e.U128_MAX_BIGINT = void 0;
  const t = Bo, r = c0, n = t6, o = e6, a = Q4;
  e.U128_MAX_BIGINT = 0xffffffffffffffffffffffffffffffffn;
  function i(u) {
    return (typeof u == "bigint" ? u : BigInt(u)) & e.U128_MAX_BIGINT;
  }
  e.u128 = i, function(u) {
    u.MAX = u(e.U128_MAX_BIGINT);
    function l(I, O) {
      const z = I + O;
      return z > u.MAX ? t.None : (0, t.Some)(u(z));
    }
    u.checkedAdd = l;
    function c(I, O) {
      const z = u.checkedAdd(I, O);
      if (z.isNone())
        throw new Error("checked add overflow");
      return z.unwrap();
    }
    u.checkedAddThrow = c;
    function f(I, O) {
      const z = I - O;
      return z < 0n ? t.None : (0, t.Some)(u(z));
    }
    u.checkedSub = f;
    function h(I, O) {
      const z = u.checkedSub(I, O);
      if (z.isNone())
        throw new Error("checked sub overflow");
      return z.unwrap();
    }
    u.checkedSubThrow = h;
    function p(I, O) {
      const z = I * O;
      return z > u.MAX ? t.None : (0, t.Some)(u(z));
    }
    u.checkedMultiply = p;
    function y(I, O) {
      const z = I + O;
      return z > u.MAX ? u.MAX : u(z);
    }
    u.saturatingAdd = y;
    function m(I, O) {
      const z = I * O;
      return z > u.MAX ? u.MAX : u(z);
    }
    u.saturatingMultiply = m;
    function b(I, O) {
      return u(I < O ? 0 : I - O);
    }
    u.saturatingSub = b;
    function v(I) {
      try {
        return (0, t.Some)(k(I));
      } catch {
        return t.None;
      }
    }
    u.decodeVarInt = v;
    function k(I) {
      let O = u(0);
      for (let z = 0; z <= 18; z++) {
        const D = I.readUInt8();
        if (D === void 0)
          throw new Error("Unterminated");
        const G = u(D) & 127n;
        if (z === 18 && (G & 124n) !== 0n)
          throw new Error("Overflow");
        if (O = u(O | G << u(7 * z)), !(D & 128))
          return O;
      }
      throw new Error("Overlong");
    }
    u.tryDecodeVarInt = k;
    function E(I) {
      const O = [];
      for (; I >> 7n > 0n; )
        O.push(Number(I & 0xffn) | 128), I = u(I >> 7n);
      return O.push(Number(I & 0xffn)), Buffer.from(O);
    }
    u.encodeVarInt = E;
    function A(I) {
      return I > n.u64.MAX ? t.None : (0, t.Some)((0, n.u64)(I));
    }
    u.tryIntoU64 = A;
    function S(I) {
      return I > o.u32.MAX ? t.None : (0, t.Some)((0, o.u32)(I));
    }
    u.tryIntoU32 = S;
    function _(I) {
      return I > a.u8.MAX ? t.None : (0, t.Some)((0, a.u8)(I));
    }
    u.tryIntoU8 = _;
  }(i || (e.u128 = i = {}));
  function* s(u) {
    const l = new r.SeekBuffer(u);
    for (; !l.isFinished(); ) {
      const c = i.tryDecodeVarInt(l);
      if (c === void 0)
        return;
      yield c;
    }
  }
  e.getAllU128 = s;
})(IN);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.u128 = e.u64 = e.u32 = e.u8 = void 0;
  var t = Q4;
  Object.defineProperty(e, "u8", { enumerable: !0, get: function() {
    return t.u8;
  } });
  var r = e6;
  Object.defineProperty(e, "u32", { enumerable: !0, get: function() {
    return r.u32;
  } });
  var n = t6;
  Object.defineProperty(e, "u64", { enumerable: !0, get: function() {
    return n.u64;
  } });
  var o = IN;
  Object.defineProperty(e, "u128", { enumerable: !0, get: function() {
    return o.u128;
  } });
})(Co);
var Vu = {};
Object.defineProperty(Vu, "__esModule", { value: !0 });
Vu.script = Vu.opcodes = void 0;
var fh;
(function(e) {
  function t(o) {
    return o < Vo.OP_PUSHDATA1 ? 1 : o <= 255 ? 2 : o <= 65535 ? 3 : 5;
  }
  e.encodingLength = t;
  function r(o, a, i) {
    const s = t(a);
    return s === 1 ? o.writeUInt8(a, i) : s === 2 ? (o.writeUInt8(Vo.OP_PUSHDATA1, i), o.writeUInt8(a, i + 1)) : s === 3 ? (o.writeUInt8(Vo.OP_PUSHDATA2, i), o.writeUInt16LE(a, i + 1)) : (o.writeUInt8(Vo.OP_PUSHDATA4, i), o.writeUInt32LE(a, i + 1)), s;
  }
  e.encode = r;
  function n(o, a) {
    const i = o.readUInt8(a);
    let s, u;
    if (i < Vo.OP_PUSHDATA1)
      s = i, u = 1;
    else if (i === Vo.OP_PUSHDATA1) {
      if (a + 2 > o.length)
        return null;
      s = o.readUInt8(a + 1), u = 2;
    } else if (i === Vo.OP_PUSHDATA2) {
      if (a + 3 > o.length)
        return null;
      s = o.readUInt16LE(a + 1), u = 3;
    } else {
      if (a + 5 > o.length)
        return null;
      if (i !== Vo.OP_PUSHDATA4)
        throw new Error("Unexpected opcode");
      s = o.readUInt32LE(a + 1), u = 5;
    }
    return {
      opcode: i,
      number: s,
      size: u
    };
  }
  e.decode = n;
})(fh || (fh = {}));
const Vo = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
Vu.opcodes = Vo;
Vo.OP_RESERVED;
function lk(e) {
  return Buffer.isBuffer(e);
}
var fk;
(function(e) {
  function t(n) {
    const o = n.reduce((s, u) => lk(u) ? s + fh.encodingLength(u.length) + u.length : s + 1, 0), a = Buffer.allocUnsafe(o);
    let i = 0;
    if (n.forEach((s) => {
      lk(s) ? (i += fh.encode(a, s.length, i), s.copy(a, i), i += s.length) : (a.writeUInt8(s, i), i += 1);
    }), i !== a.length)
      throw new Error("Could not decode chunks");
    return a;
  }
  e.compile = t;
  function* r(n) {
    let o = 0;
    for (; o < n.length; ) {
      const a = n[o];
      if (a >= Vo.OP_0 && a <= Vo.OP_PUSHDATA4) {
        const i = fh.decode(n, o);
        if (i === null || (o += i.size, o + i.number > n.length))
          return !1;
        const s = n.slice(o, o + i.number);
        o += i.number, yield s;
      } else
        yield a, o += 1;
    }
    return !0;
  }
  e.decompile = r;
})(fk || (Vu.script = fk = {}));
Object.defineProperty(tr, "__esModule", { value: !0 });
tr.TAPROOT_SCRIPT_PUBKEY_TYPE = tr.COMMIT_CONFIRMATIONS = tr.TAPROOT_ANNEX_PREFIX = tr.MAGIC_NUMBER = tr.OP_RETURN = tr.MAX_SCRIPT_ELEMENT_SIZE = tr.SUBSIDY_HALVING_INTERVAL = tr.RESERVED = tr.MAX_DIVISIBILITY = void 0;
const TN = Co, PN = Vu;
tr.MAX_DIVISIBILITY = (0, TN.u8)(38);
tr.RESERVED = (0, TN.u128)(6402364363415443603228541259936211926n);
tr.SUBSIDY_HALVING_INTERVAL = 21e4;
tr.MAX_SCRIPT_ELEMENT_SIZE = 520;
tr.OP_RETURN = PN.opcodes.OP_RETURN;
tr.MAGIC_NUMBER = PN.opcodes.OP_13;
tr.TAPROOT_ANNEX_PREFIX = 80;
tr.COMMIT_CONFIRMATIONS = 6;
tr.TAPROOT_SCRIPT_PUBKEY_TYPE = "witness_v1_taproot";
var l0 = {};
Object.defineProperty(l0, "__esModule", { value: !0 });
l0.Etching = void 0;
const dk = Bo, Wd = Co;
class t2e {
  constructor(t, r, n, o, a, i, s) {
    this.divisibility = t, this.rune = r, this.spacers = n, this.terms = a, this.premine = i, this.turbo = s, this.symbol = o.andThen((u) => {
      const l = u.codePointAt(0);
      return l !== void 0 ? (0, dk.Some)(String.fromCodePoint(l)) : dk.None;
    });
  }
  get supply() {
    const t = this.premine.unwrapOr((0, Wd.u128)(0)), r = this.terms.andThen((o) => o.cap).unwrapOr((0, Wd.u128)(0)), n = this.terms.andThen((o) => o.amount).unwrapOr((0, Wd.u128)(0));
    return Wd.u128.checkedMultiply(r, n).andThen((o) => Wd.u128.checkedAdd(t, o));
  }
}
l0.Etching = t2e;
var kd = {};
Object.defineProperty(kd, "__esModule", { value: !0 });
kd.Flaw = void 0;
var hk;
(function(e) {
  e[e.EDICT_OUTPUT = 0] = "EDICT_OUTPUT", e[e.EDICT_RUNE_ID = 1] = "EDICT_RUNE_ID", e[e.INVALID_SCRIPT = 2] = "INVALID_SCRIPT", e[e.OPCODE = 3] = "OPCODE", e[e.SUPPLY_OVERFLOW = 4] = "SUPPLY_OVERFLOW", e[e.TRAILING_INTEGERS = 5] = "TRAILING_INTEGERS", e[e.TRUNCATED_FIELD = 6] = "TRUNCATED_FIELD", e[e.UNRECOGNIZED_EVEN_TAG = 7] = "UNRECOGNIZED_EVEN_TAG", e[e.UNRECOGNIZED_FLAG = 8] = "UNRECOGNIZED_FLAG", e[e.VARINT = 9] = "VARINT";
})(hk || (kd.Flaw = hk = {}));
var xd = {};
Object.defineProperty(xd, "__esModule", { value: !0 });
xd.RuneId = void 0;
const pu = Bo, Ji = Co;
class dh {
  constructor(t, r) {
    this.block = t, this.tx = r;
  }
  static new(t, r) {
    const n = new dh(t, r);
    return n.block === 0n && n.tx > 0 ? pu.None : (0, pu.Some)(n);
  }
  static sort(t) {
    return [...t].sort((r, n) => Number(r.block - n.block || r.tx - n.tx));
  }
  delta(t) {
    const r = Ji.u64.checkedSub(t.block, this.block);
    if (r.isNone())
      return pu.None;
    const n = r.unwrap();
    let o;
    if (n === 0n) {
      const a = Ji.u32.checkedSub(t.tx, this.tx);
      if (a.isNone())
        return pu.None;
      o = a.unwrap();
    } else
      o = t.tx;
    return (0, pu.Some)([(0, Ji.u128)(n), (0, Ji.u128)(o)]);
  }
  next(t, r) {
    const n = Ji.u128.tryIntoU64(t), o = Ji.u128.tryIntoU32(r);
    if (n.isNone() || o.isNone())
      return pu.None;
    const a = n.unwrap(), i = o.unwrap(), s = Ji.u64.checkedAdd(this.block, a);
    if (s.isNone())
      return pu.None;
    let u;
    if (a === 0n) {
      const l = Ji.u32.checkedAdd(this.tx, i);
      if (l.isNone())
        return pu.None;
      u = l.unwrap();
    } else
      u = i;
    return dh.new(s.unwrap(), u);
  }
  toString() {
    return `${this.block}:${this.tx}`;
  }
  static fromString(t) {
    const r = t.split(":");
    if (r.length !== 2)
      throw new Error(`invalid rune ID: ${t}`);
    const [n, o] = r;
    if (!/^\d+$/.test(n) || !/^\d+$/.test(o))
      throw new Error(`invalid rune ID: ${t}`);
    return new dh((0, Ji.u64)(BigInt(n)), (0, Ji.u32)(BigInt(o)));
  }
}
xd.RuneId = dh;
var r6 = {}, Ad = {};
Object.defineProperty(Ad, "__esModule", { value: !0 });
Ad.Tag = void 0;
const i1 = Bo, zl = Co;
var vm;
(function(e) {
  e[e.BODY = 0] = "BODY", e[e.FLAGS = 2] = "FLAGS", e[e.RUNE = 4] = "RUNE", e[e.PREMINE = 6] = "PREMINE", e[e.CAP = 8] = "CAP", e[e.AMOUNT = 10] = "AMOUNT", e[e.HEIGHT_START = 12] = "HEIGHT_START", e[e.HEIGHT_END = 14] = "HEIGHT_END", e[e.OFFSET_START = 16] = "OFFSET_START", e[e.OFFSET_END = 18] = "OFFSET_END", e[e.MINT = 20] = "MINT", e[e.POINTER = 22] = "POINTER", e[e.CENOTAPH = 126] = "CENOTAPH", e[e.DIVISIBILITY = 1] = "DIVISIBILITY", e[e.SPACERS = 3] = "SPACERS", e[e.SYMBOL = 5] = "SYMBOL", e[e.NOP = 127] = "NOP";
})(vm || (Ad.Tag = vm = {}));
(function(e) {
  function t(o, a, i, s) {
    const u = a.get((0, zl.u128)(o));
    if (u === void 0)
      return i1.None;
    const l = [];
    for (const f of [...Array(i).keys()]) {
      if (u[f] === void 0)
        return i1.None;
      l[f] = u[f];
    }
    const c = s(l);
    return c.isNone() ? i1.None : (u.splice(0, i), u.length === 0 && a.delete((0, zl.u128)(o)), (0, i1.Some)(c.unwrap()));
  }
  e.take = t;
  function r(o, a) {
    return Buffer.concat(a.map((i) => [zl.u128.encodeVarInt((0, zl.u128)(o)), zl.u128.encodeVarInt(i)]).flat());
  }
  e.encode = r;
  function n(o, a) {
    return a.map((i) => e.encode(o, [(0, zl.u128)(i)])).unwrapOr(Buffer.alloc(0));
  }
  e.encodeOptionInt = n;
})(vm || (Ad.Tag = vm = {}));
var Sd = {}, Al = {};
Object.defineProperty(Al, "__esModule", { value: !0 });
Al.Network = void 0;
const a1 = tr;
var Em;
(function(e) {
  e[e.MAINNET = 0] = "MAINNET", e[e.SIGNET = 1] = "SIGNET", e[e.TESTNET = 2] = "TESTNET", e[e.REGTEST = 3] = "REGTEST";
})(Em || (Al.Network = Em = {}));
(function(e) {
  function t(r) {
    switch (r) {
      case e.MAINNET:
        return a1.SUBSIDY_HALVING_INTERVAL * 4;
      case e.REGTEST:
        return a1.SUBSIDY_HALVING_INTERVAL * 0;
      case e.SIGNET:
        return a1.SUBSIDY_HALVING_INTERVAL * 0;
      case e.TESTNET:
        return a1.SUBSIDY_HALVING_INTERVAL * 12;
    }
  }
  e.getFirstRuneHeight = t;
})(Em || (Al.Network = Em = {}));
Object.defineProperty(Sd, "__esModule", { value: !0 });
Sd.Rune = void 0;
const r2e = Al, s1 = tr, Oe = Co;
class si {
  constructor(t) {
    this.value = t;
  }
  static getMinimumAtHeight(t, r) {
    let n = Oe.u128.saturatingAdd(r, (0, Oe.u128)(1));
    const o = (0, Oe.u128)(s1.SUBSIDY_HALVING_INTERVAL / 12);
    let a = (0, Oe.u128)(r2e.Network.getFirstRuneHeight(t)), i = Oe.u128.saturatingAdd(a, (0, Oe.u128)(s1.SUBSIDY_HALVING_INTERVAL));
    if (n < a)
      return new si(si.STEPS[12]);
    if (n >= i)
      return new si((0, Oe.u128)(0));
    let s = Oe.u128.saturatingSub(n, a), u = Oe.u128.saturatingSub((0, Oe.u128)(12n), (0, Oe.u128)(s / o)), l = Number(u & (0, Oe.u128)(Oe.u32.MAX)), c = si.STEPS[l], f = si.STEPS[l - 1], h = (0, Oe.u128)(s % o);
    return new si((0, Oe.u128)(c - (c - f) * h / o));
  }
  get reserved() {
    return this.value >= s1.RESERVED;
  }
  get commitment() {
    const t = Buffer.alloc(16);
    t.writeBigUInt64LE(0xffffffffffffffffn & this.value, 0), t.writeBigUInt64LE(this.value >> 64n, 8);
    let r = t.length;
    for (; r > 0 && t.at(r - 1) === 0; )
      r--;
    return t.subarray(0, r);
  }
  static getReserved(t, r) {
    return new si(Oe.u128.checkedAdd(s1.RESERVED, (0, Oe.u128)(t << 32n | r)).unwrap());
  }
  toString() {
    let t = this.value;
    if (t === Oe.u128.MAX)
      return "BCGDENLQRQWDSLRUGSNLBTMFIJAV";
    t = (0, Oe.u128)(t + 1n);
    let r = "";
    for (; t > 0; )
      r = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Number((t - 1n) % 26n)] + r, t = (0, Oe.u128)((t - 1n) / 26n);
    return r;
  }
  static fromString(t) {
    let r = (0, Oe.u128)(0);
    for (const n of [...Array(t.length).keys()]) {
      const o = t[n];
      if (n > 0 && (r = (0, Oe.u128)(r + 1n)), r = Oe.u128.checkedMultiply(r, (0, Oe.u128)(26)).unwrap(), "A" <= o && o <= "Z")
        r = Oe.u128.checkedAdd(r, (0, Oe.u128)(o.charCodeAt(0) - 65)).unwrap();
      else
        throw new Error(`invalid character in rune name: ${o}`);
    }
    return new si(r);
  }
}
Sd.Rune = si;
si.STEPS = [
  (0, Oe.u128)(0n),
  (0, Oe.u128)(26n),
  (0, Oe.u128)(702n),
  (0, Oe.u128)(18278n),
  (0, Oe.u128)(475254n),
  (0, Oe.u128)(12356630n),
  (0, Oe.u128)(321272406n),
  (0, Oe.u128)(8353082582n),
  (0, Oe.u128)(217180147158n),
  (0, Oe.u128)(5646683826134n),
  (0, Oe.u128)(146813779479510n),
  (0, Oe.u128)(3817158266467286n),
  (0, Oe.u128)(99246114928149462n),
  (0, Oe.u128)(2580398988131886038n),
  (0, Oe.u128)(67090373691429037014n),
  (0, Oe.u128)(1744349715977154962390n),
  (0, Oe.u128)(45353092615406029022166n),
  (0, Oe.u128)(1179180408000556754576342n),
  (0, Oe.u128)(30658690608014475618984918n),
  (0, Oe.u128)(797125955808376366093607894n),
  (0, Oe.u128)(20725274851017785518433805270n),
  (0, Oe.u128)(538857146126462423479278937046n),
  (0, Oe.u128)(14010285799288023010461252363222n),
  (0, Oe.u128)(364267430781488598271992561443798n),
  (0, Oe.u128)(9470953200318703555071806597538774n),
  (0, Oe.u128)(246244783208286292431866971536008150n),
  (0, Oe.u128)(6402364363415443603228541259936211926n),
  (0, Oe.u128)(166461473448801533683942072758341510102n)
];
var f0 = {};
Object.defineProperty(f0, "__esModule", { value: !0 });
f0.Flag = void 0;
const mw = Co;
var km;
(function(e) {
  e[e.ETCHING = 0] = "ETCHING", e[e.TERMS = 1] = "TERMS", e[e.TURBO = 2] = "TURBO", e[e.CENOTAPH = 127] = "CENOTAPH";
})(km || (f0.Flag = km = {}));
(function(e) {
  function t(o) {
    return (0, mw.u128)(1n << BigInt(o));
  }
  e.mask = t;
  function r(o, a) {
    const i = e.mask(a), s = (o & i) !== 0n;
    return { set: s, flags: s ? (0, mw.u128)(o - i) : o };
  }
  e.take = r;
  function n(o, a) {
    return (0, mw.u128)(o | e.mask(a));
  }
  e.set = n;
})(km || (f0.Flag = km = {}));
var xb = {};
Object.defineProperty(xb, "__esModule", { value: !0 });
xb.Instruction = void 0;
var pk;
(function(e) {
  function t(n) {
    return typeof n == "number";
  }
  e.isNumber = t;
  function r(n) {
    return typeof n != "number";
  }
  e.isBuffer = r;
})(pk || (xb.Instruction = pk = {}));
var Ab = {}, Sb = {};
Object.defineProperty(Sb, "__esModule", { value: !0 });
Sb.Edict = void 0;
const u1 = Bo, n2e = Co;
var gk;
(function(e) {
  function t(r, n, o, a) {
    if (n.block === 0n && n.tx > 0n)
      return u1.None;
    const i = n2e.u128.tryIntoU32(a);
    if (i.isNone())
      return u1.None;
    const s = i.unwrap();
    return s > r ? u1.None : (0, u1.Some)({ id: n, amount: o, output: s });
  }
  e.fromIntegers = t;
})(gk || (Sb.Edict = gk = {}));
Object.defineProperty(Ab, "__esModule", { value: !0 });
Ab.Message = void 0;
const o2e = Sb, c1 = kd, yw = Co, i2e = xd, a2e = Ad;
class n6 {
  constructor(t, r, n) {
    this.flaws = t, this.edicts = r, this.fields = n;
  }
  static fromIntegers(t, r) {
    const n = [], o = /* @__PURE__ */ new Map(), a = [];
    for (const i of [...Array(Math.ceil(r.length / 2)).keys()].map((s) => s * 2)) {
      const s = r[i];
      if ((0, yw.u128)(a2e.Tag.BODY) === s) {
        let c = new i2e.RuneId((0, yw.u64)(0), (0, yw.u32)(0));
        const f = 4, h = r.slice(i + 1);
        for (let p = 0; p < h.length; p += f) {
          const y = h.slice(p, p + f);
          if (y.length !== f) {
            a.push(c1.Flaw.TRAILING_INTEGERS);
            break;
          }
          const m = c.next(y[0], y[1]);
          if (m.isNone()) {
            a.push(c1.Flaw.EDICT_RUNE_ID);
            break;
          }
          const b = m.unwrap(), v = o2e.Edict.fromIntegers(t, b, y[2], y[3]);
          if (v.isNone()) {
            a.push(c1.Flaw.EDICT_OUTPUT);
            break;
          }
          const k = v.unwrap();
          c = b, n.push(k);
        }
        break;
      }
      const u = r[i + 1];
      if (u === void 0) {
        a.push(c1.Flaw.TRUNCATED_FIELD);
        break;
      }
      const l = o.get(s) ?? [];
      l.push(u), o.set(s, l);
    }
    return new n6(a, n, o);
  }
}
Ab.Message = n6;
var _b = {};
Object.defineProperty(_b, "__esModule", { value: !0 });
_b.Cenotaph = void 0;
const mk = Bo;
class s2e {
  constructor(t, r = mk.None, n = mk.None) {
    this.flaws = t, this.etching = r, this.mint = n;
  }
}
_b.Cenotaph = s2e;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Runestone = e.isValidPayload = e.MAX_SPACERS = void 0;
  const t = tr, r = l0, n = c0, o = Ad, a = Co, i = Bo, s = Sd, u = f0, l = xb, c = xd, f = Vu, h = Ab, p = kd, y = _b;
  e.MAX_SPACERS = 134217727;
  function m(v) {
    return Buffer.isBuffer(v);
  }
  e.isValidPayload = m;
  class b {
    constructor(k, E, A, S) {
      this.mint = k, this.pointer = E, this.edicts = A, this.etching = S;
    }
    static decipher(k) {
      const E = b.payload(k);
      if (E.isNone())
        return i.None;
      const A = E.unwrap();
      if (!m(A))
        return (0, i.Some)(new y.Cenotaph([A]));
      const S = b.integers(A);
      if (S.isNone())
        return (0, i.Some)(new y.Cenotaph([p.Flaw.VARINT]));
      const { flaws: _, edicts: I, fields: O } = h.Message.fromIntegers(k.vout.length, S.unwrap());
      let z = o.Tag.take(o.Tag.FLAGS, O, 1, ([C]) => (0, i.Some)(C)).unwrapOr((0, a.u128)(0));
      const D = u.Flag.take(z, u.Flag.ETCHING), G = D.set;
      z = D.flags;
      const U = G ? (() => {
        const C = o.Tag.take(o.Tag.DIVISIBILITY, O, 1, ([Ae]) => a.u128.tryIntoU8(Ae).andThen((ye) => ye <= t.MAX_DIVISIBILITY ? (0, i.Some)(ye) : i.None)), R = o.Tag.take(o.Tag.RUNE, O, 1, ([Ae]) => (0, i.Some)(new s.Rune(Ae))), M = o.Tag.take(o.Tag.SPACERS, O, 1, ([Ae]) => a.u128.tryIntoU32(Ae).andThen((ye) => ye <= e.MAX_SPACERS ? (0, i.Some)(ye) : i.None)), re = o.Tag.take(o.Tag.SYMBOL, O, 1, ([Ae]) => a.u128.tryIntoU32(Ae).andThen((ye) => {
          try {
            return (0, i.Some)(String.fromCodePoint(Number(ye)));
          } catch {
            return i.None;
          }
        })), W = u.Flag.take(z, u.Flag.TERMS), ne = W.set;
        z = W.flags;
        const oe = ne ? (() => {
          const Ae = o.Tag.take(o.Tag.AMOUNT, O, 1, ([be]) => (0, i.Some)(be)), ye = o.Tag.take(o.Tag.CAP, O, 1, ([be]) => (0, i.Some)(be)), Et = [
            o.Tag.take(o.Tag.OFFSET_START, O, 1, ([be]) => a.u128.tryIntoU64(be)),
            o.Tag.take(o.Tag.OFFSET_END, O, 1, ([be]) => a.u128.tryIntoU64(be))
          ], Ge = [
            o.Tag.take(o.Tag.HEIGHT_START, O, 1, ([be]) => a.u128.tryIntoU64(be)),
            o.Tag.take(o.Tag.HEIGHT_END, O, 1, ([be]) => a.u128.tryIntoU64(be))
          ];
          return (0, i.Some)({ amount: Ae, cap: ye, offset: Et, height: Ge });
        })() : i.None, se = o.Tag.take(o.Tag.PREMINE, O, 1, ([Ae]) => (0, i.Some)(Ae)), K = u.Flag.take(z, u.Flag.TURBO), he = D.set;
        return z = K.flags, (0, i.Some)(new r.Etching(C, R, M, re, oe, se, he));
      })() : i.None, V = o.Tag.take(o.Tag.MINT, O, 2, ([C, R]) => {
        const M = a.u128.tryIntoU64(C), re = a.u128.tryIntoU32(R);
        return M.isNone() || re.isNone() ? i.None : c.RuneId.new(M.unwrap(), re.unwrap());
      }), F = o.Tag.take(o.Tag.POINTER, O, 1, ([C]) => a.u128.tryIntoU32(C).andThen((R) => R < k.vout.length ? (0, i.Some)(R) : i.None));
      return U.map((C) => C.supply.isNone()).unwrapOr(!1) && _.push(p.Flaw.SUPPLY_OVERFLOW), z !== 0n && _.push(p.Flaw.UNRECOGNIZED_FLAG), [...O.keys()].find((C) => C % 2n === 0n) !== void 0 && _.push(p.Flaw.UNRECOGNIZED_EVEN_TAG), _.length !== 0 ? (0, i.Some)(new y.Cenotaph(_, U.andThen((C) => C.rune), V)) : (0, i.Some)(new b(V, F, I, U));
    }
    encipher() {
      const k = [];
      if (this.etching.isSome()) {
        const S = this.etching.unwrap();
        let _ = (0, a.u128)(0);
        if (_ = u.Flag.set(_, u.Flag.ETCHING), S.terms.isSome() && (_ = u.Flag.set(_, u.Flag.TERMS)), S.turbo && (_ = u.Flag.set(_, u.Flag.TURBO)), k.push(o.Tag.encode(o.Tag.FLAGS, [_])), k.push(o.Tag.encodeOptionInt(o.Tag.RUNE, S.rune.map((I) => I.value))), k.push(o.Tag.encodeOptionInt(o.Tag.DIVISIBILITY, S.divisibility.map(a.u128))), k.push(o.Tag.encodeOptionInt(o.Tag.SPACERS, S.spacers.map(a.u128))), k.push(o.Tag.encodeOptionInt(o.Tag.SYMBOL, S.symbol.map((I) => (0, a.u128)(I.codePointAt(0))))), k.push(o.Tag.encodeOptionInt(o.Tag.PREMINE, S.premine)), S.terms.isSome()) {
          const I = S.terms.unwrap();
          k.push(o.Tag.encodeOptionInt(o.Tag.AMOUNT, I.amount)), k.push(o.Tag.encodeOptionInt(o.Tag.CAP, I.cap)), k.push(o.Tag.encodeOptionInt(o.Tag.HEIGHT_START, I.height[0])), k.push(o.Tag.encodeOptionInt(o.Tag.HEIGHT_END, I.height[1])), k.push(o.Tag.encodeOptionInt(o.Tag.OFFSET_START, I.offset[0])), k.push(o.Tag.encodeOptionInt(o.Tag.OFFSET_END, I.offset[1]));
        }
      }
      if (this.mint.isSome()) {
        const S = this.mint.unwrap();
        k.push(o.Tag.encode(o.Tag.MINT, [S.block, S.tx].map(a.u128)));
      }
      if (k.push(o.Tag.encodeOptionInt(o.Tag.POINTER, this.pointer.map(a.u128))), this.edicts.length) {
        k.push(a.u128.encodeVarInt((0, a.u128)(o.Tag.BODY)));
        const S = [...this.edicts].sort((I, O) => Number(I.id.block - O.id.block || I.id.tx - O.id.tx));
        let _ = new c.RuneId((0, a.u64)(0), (0, a.u32)(0));
        for (const I of S) {
          const [O, z] = _.delta(I.id).unwrap();
          k.push(a.u128.encodeVarInt(O)), k.push(a.u128.encodeVarInt(z)), k.push(a.u128.encodeVarInt(I.amount)), k.push(a.u128.encodeVarInt((0, a.u128)(I.output))), _ = I.id;
        }
      }
      const E = [];
      E.push(t.OP_RETURN), E.push(t.MAGIC_NUMBER);
      const A = Buffer.concat(k);
      for (let S = 0; S < A.length; S += t.MAX_SCRIPT_ELEMENT_SIZE)
        E.push(A.subarray(S, S + t.MAX_SCRIPT_ELEMENT_SIZE));
      return f.script.compile(E);
    }
    static payload(k) {
      for (const E of k.vout) {
        const A = f.script.decompile(Buffer.from(E.scriptPubKey.hex, "hex"));
        if (A === null)
          throw new Error("unable to decompile");
        let S = A.next();
        if (S.done || S.value !== t.OP_RETURN || (S = A.next(), S.done || l.Instruction.isBuffer(S.value) || S.value !== t.MAGIC_NUMBER))
          continue;
        let _ = [];
        do {
          if (S = A.next(), S.done) {
            if (!S.value)
              return (0, i.Some)(p.Flaw.INVALID_SCRIPT);
            break;
          }
          const I = S.value;
          if (l.Instruction.isBuffer(I))
            _.push(I);
          else
            return (0, i.Some)(p.Flaw.OPCODE);
        } while (!0);
        return (0, i.Some)(Buffer.concat(_));
      }
      return i.None;
    }
    static integers(k) {
      const E = [], A = new n.SeekBuffer(k);
      for (; !A.isFinished(); ) {
        const S = a.u128.decodeVarInt(A);
        if (S.isNone())
          return i.None;
        E.push(S.unwrap());
      }
      return (0, i.Some)(E);
    }
  }
  e.Runestone = b;
})(r6);
var d0 = {};
Object.defineProperty(d0, "__esModule", { value: !0 });
d0.SpacedRune = void 0;
const u2e = Sd;
class o6 {
  constructor(t, r) {
    this.rune = t, this.spacers = r;
  }
  static fromString(t) {
    let r = "", n = 0;
    for (const o of t)
      if ("A" <= o && o <= "Z")
        r += o;
      else if (o === "." || o === "") {
        if (r.length === 0)
          throw new Error("leading spacer");
        const a = 1 << r.length - 1;
        if (n & a)
          throw new Error("double spacer");
        n |= a;
      } else
        throw new Error("invalid character");
    if (n >= 1 << r.length - 1)
      throw new Error("trailing spacer");
    return new o6(u2e.Rune.fromString(r), n);
  }
  toString() {
    const t = this.rune.toString();
    let r = 0, n = "";
    for (const o of t)
      n += o, r < t.length - 1 && this.spacers & 1 << r && (n += ""), r++;
    return n;
  }
}
d0.SpacedRune = o6;
var ON = {}, dp = {}, h0 = {};
Object.defineProperty(h0, "__esModule", { value: !0 });
h0.RuneLocation = void 0;
var yk;
(function(e) {
  function t(r) {
    return `${r.block}:${r.tx}`;
  }
  e.toString = t;
})(yk || (h0.RuneLocation = yk = {}));
Object.defineProperty(dp, "__esModule", { value: !0 });
dp.RuneUpdater = void 0;
const Xd = u0, R1 = tr, dt = Co, mo = Bo, bk = Sd, c2e = r6, l2e = Vu, wk = d0, ja = h0;
function bw(e) {
  return e && Buffer.from(e, "hex")[0] === R1.OP_RETURN;
}
class f2e {
  constructor(t, r, n, o, a) {
    this.reorg = n, this._storage = o, this._rpc = a, this.etchings = [], this.utxoBalances = [], this.spentBalances = [], this._mintCountsByRuneLocation = /* @__PURE__ */ new Map(), this._burnedBalancesByRuneLocation = /* @__PURE__ */ new Map(), this.block = {
      height: r.height,
      hash: r.hash,
      previousblockhash: r.previousblockhash,
      time: r.time
    }, this._minimum = bk.Rune.getMinimumAtHeight(t, (0, dt.u128)(r.height));
  }
  get mintCounts() {
    return [...this._mintCountsByRuneLocation.values()];
  }
  get burnedBalances() {
    return [...this._burnedBalancesByRuneLocation.values()];
  }
  async indexRunes(t, r) {
    const n = c2e.Runestone.decipher(t), o = await this.unallocated(t), a = [...new Array(t.vout.length)].map(() => /* @__PURE__ */ new Map());
    function i(c) {
      const f = ja.RuneLocation.toString(c), h = o.get(f) ?? { runeId: c, amount: 0n };
      return o.set(f, h), h;
    }
    function s(c, f) {
      const h = ja.RuneLocation.toString(f), p = a[c].get(h) ?? { runeId: f, amount: 0n };
      return a[c].set(h, p), p;
    }
    if (n.isSome()) {
      const c = n.unwrap(), f = c.mint;
      if (f.isSome()) {
        const p = f.unwrap(), y = {
          block: Number(p.block),
          tx: Number(p.tx)
        }, m = await this.mint(y, t.txid);
        if (m.isSome()) {
          const b = m.unwrap(), v = i(y);
          v.amount = dt.u128.checkedAddThrow((0, dt.u128)(v.amount), (0, dt.u128)(b));
        }
      }
      const h = await this.etched(r, t, c);
      if ((0, Xd.isRunestone)(c)) {
        const p = c;
        if (h.isSome()) {
          const y = h.unwrap(), m = i(y.runeId);
          m.amount = dt.u128.checkedAddThrow((0, dt.u128)(m.amount), p.etching.unwrap().premine.unwrapOr((0, dt.u128)(0)));
        }
        for (const { id: y, amount: m, output: b } of [...p.edicts]) {
          if (b > t.vout.length)
            throw new Error("Runestone edict output should never exceed transaction output size");
          if (y.block === 0n && y.tx === 0n && h.isNone())
            continue;
          const v = y.block === 0n && y.tx === 0n ? h.unwrap().runeId : { block: Number(y.block), tx: Number(y.tx) }, k = ja.RuneLocation.toString(v), E = o.get(k);
          if (E === void 0)
            continue;
          let A = (S, _) => {
            if (S > 0n) {
              const I = s(_, v);
              E.amount = dt.u128.checkedSubThrow((0, dt.u128)(E.amount), S), I.amount = dt.u128.checkedAddThrow((0, dt.u128)(I.amount), S);
            }
          };
          if (Number(b) === t.vout.length) {
            const S = [...t.vout.entries()].filter(([_, I]) => !bw(I.scriptPubKey.hex)).map(([_]) => _);
            if (S.length !== 0)
              if (m === 0n) {
                const _ = (0, dt.u128)((0, dt.u128)(E.amount) / (0, dt.u128)(S.length)), I = (0, dt.u128)(E.amount) % (0, dt.u128)(S.length);
                for (const [O, z] of S.entries())
                  A(O < I ? dt.u128.checkedAddThrow(_, (0, dt.u128)(1)) : _, z);
              } else
                for (const _ of S)
                  A(m < E.amount ? m : (0, dt.u128)(E.amount), _);
          } else
            A(m !== 0n && m < (0, dt.u128)(E.amount) ? m : (0, dt.u128)(E.amount), Number(b));
        }
      }
      if (h.isSome()) {
        const { runeId: p, rune: y } = h.unwrap();
        this.createEtching(t.txid, c, p, y);
      }
    }
    const u = /* @__PURE__ */ new Map();
    function l(c) {
      const f = ja.RuneLocation.toString(c), h = u.get(f) ?? { runeId: c, amount: 0n };
      return u.set(f, h), h;
    }
    if (n.isSome() && !(0, Xd.isRunestone)(n.unwrap()))
      for (const c of o.values()) {
        const f = l(c.runeId);
        f.amount = dt.u128.checkedAddThrow((0, dt.u128)(f.amount), (0, dt.u128)(c.amount));
      }
    else {
      const c = n.map((f) => {
        if (!(0, Xd.isRunestone)(f))
          throw new Error("unreachable");
        return f.pointer;
      }).unwrapOr(mo.None).map((f) => Number(f)).inspect((f) => {
        if (f < 0 || f >= a.length)
          throw new Error("Pointer is invalid");
      }).orElse(() => {
        const f = [...t.vout.entries()].find(([h, p]) => !bw(p.scriptPubKey.hex));
        return f !== void 0 ? (0, mo.Some)(f[0]) : mo.None;
      });
      if (c.isSome()) {
        const f = c.unwrap();
        for (const h of o.values())
          if (h.amount > 0) {
            const p = s(f, h.runeId);
            p.amount = dt.u128.checkedAddThrow((0, dt.u128)(p.amount), (0, dt.u128)(h.amount));
          }
      } else
        for (const [f, h] of o)
          if (h.amount > 0) {
            const p = l(h.runeId);
            u.set(f, {
              runeId: h.runeId,
              amount: dt.u128.checkedAddThrow((0, dt.u128)(p.amount), (0, dt.u128)(h.amount))
            });
          }
    }
    for (const [c, f] of a.entries()) {
      if (f.size === 0)
        continue;
      const h = t.vout[c];
      if (bw(h.scriptPubKey.hex)) {
        for (const [y, m] of f) {
          const b = l(m.runeId);
          b.amount = dt.u128.checkedAddThrow((0, dt.u128)(b.amount), (0, dt.u128)(m.amount));
        }
        continue;
      }
      const p = new Map(this.etchings.map((y) => [ja.RuneLocation.toString(y.runeId), y]));
      for (const y of f.values()) {
        const m = ja.RuneLocation.toString(y.runeId), b = p.get(m) ?? await this._storage.getEtching(m);
        if (b === null)
          throw new Error("Rune should exist at this point");
        this.utxoBalances.push({
          runeId: y.runeId,
          runeTicker: b.runeTicker,
          amount: y.amount,
          scriptPubKey: Buffer.from(h.scriptPubKey.hex),
          txid: t.txid,
          vout: c,
          address: h.scriptPubKey.address
        });
      }
    }
    for (const [c, f] of u)
      this._burnedBalancesByRuneLocation.set(c, f);
  }
  async etched(t, r, n) {
    let o;
    if ((0, Xd.isRunestone)(n)) {
      const i = n;
      if (i.etching.isNone())
        return mo.None;
      o = i.etching.unwrap().rune;
    } else {
      const i = n;
      if (i.etching.isNone())
        return mo.None;
      o = i.etching;
    }
    let a;
    if (o.isSome()) {
      if (a = o.unwrap(), a.value < this._minimum.value || a.reserved || this.etchings.find((s) => wk.SpacedRune.fromString(s.runeName).rune.toString() === a.toString()))
        return mo.None;
      const i = await this._storage.getRuneLocation(a.toString());
      if (i && i.block < this.block.height || !await this.txCommitsToRune(r, a))
        return mo.None;
    } else
      a = bk.Rune.getReserved((0, dt.u64)(this.block.height), (0, dt.u32)(t));
    return (0, mo.Some)({
      runeId: {
        block: this.block.height,
        tx: t
      },
      rune: a
    });
  }
  async mint(t, r) {
    var n, o, a, i;
    const s = ja.RuneLocation.toString(t), u = new Map(this.etchings.map((E) => [ja.RuneLocation.toString(E.runeId), E])).get(s) ?? await this._storage.getEtching(s);
    if (u === null || !u.valid || !u.terms)
      return mo.None;
    const l = u.terms, c = ((n = l.offset) == null ? void 0 : n.start) !== void 0 ? u.runeId.block + Number(l.offset.start) : null, f = ((o = l.height) == null ? void 0 : o.start) !== void 0 ? Number(l.height.start) : null, h = c !== null || f !== null ? Math.max(c ?? -1 / 0, f ?? -1 / 0) : null;
    if (h !== null && this.block.height < h)
      return mo.None;
    const p = ((a = l.offset) == null ? void 0 : a.end) !== void 0 ? u.runeId.block + Number(l.offset.end) : null, y = ((i = l.height) == null ? void 0 : i.end) !== void 0 ? Number(l.height.end) : null, m = p !== null || y !== null ? Math.max(p ?? -1 / 0, y ?? -1 / 0) : null;
    if (m !== null && this.block.height >= m)
      return mo.None;
    const b = l.cap ?? 0n, v = this._mintCountsByRuneLocation.get(s) ?? {
      mint: t,
      count: 0
    };
    if (this._mintCountsByRuneLocation.set(s, v), v.count + await this._storage.getValidMintCount(s, this.block.height - 1) >= b)
      return mo.None;
    const k = l.amount ?? 0n;
    return v.count++, (0, mo.Some)(k);
  }
  async unallocated(t) {
    const r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    for (const o of this.utxoBalances) {
      const a = `${o.txid}:${o.vout}`, i = n.get(a) ?? [];
      i.push(o), n.set(a, i);
    }
    for (const o of t.vin) {
      if ("coinbase" in o)
        continue;
      const a = n.get(`${o.txid}:${o.vout}`) ?? await this._storage.getUtxoBalance(o.txid, o.vout);
      for (const i of a) {
        const s = i.runeId, u = ja.RuneLocation.toString(s), l = r.get(u) ?? { runeId: s, amount: 0n };
        r.set(u, l), l.amount = dt.u128.checkedAddThrow((0, dt.u128)(l.amount), (0, dt.u128)(i.amount)), this.spentBalances.push({
          txid: o.txid,
          vout: o.vout,
          address: i.address,
          scriptPubKey: i.scriptPubKey,
          runeId: i.runeId,
          runeTicker: i.runeTicker,
          amount: i.amount,
          spentTxid: t.txid
        });
      }
    }
    return r;
  }
  async txCommitsToRune(t, r) {
    const n = r.commitment;
    for (const o of t.vin) {
      if ("coinbase" in o)
        continue;
      const a = o.txinwitness.map((c) => Buffer.from(c, "hex")), i = a[a.length - 1], s = a.length >= 2 && i[0] === R1.TAPROOT_ANNEX_PREFIX ? 3 : 2;
      if (s > a.length)
        continue;
      const u = a[a.length - s];
      if (u === void 0)
        continue;
      const l = l2e.script.decompile(u);
      for (const c of l) {
        if (!Buffer.isBuffer(c) || Buffer.compare(c, n) !== 0)
          continue;
        const f = await this._rpc.getrawtransaction({
          txid: o.txid,
          verbose: !0
        });
        if (f.error !== null)
          throw f.error;
        const h = f.result;
        if (h.vout[o.vout].scriptPubKey.type !== R1.TAPROOT_SCRIPT_PUBKEY_TYPE)
          continue;
        const p = await this._rpc.getblock({ blockhash: h.blockhash });
        if (p.error !== null)
          throw p.error;
        const y = p.result.height;
        if (dt.u128.checkedSubThrow((0, dt.u128)(this.block.height), (0, dt.u128)(y)) + 1n >= R1.COMMIT_CONFIRMATIONS)
          return !0;
      }
    }
    return !1;
  }
  createEtching(t, r, n, o) {
    if ((0, Xd.isRunestone)(r)) {
      const { divisibility: a, terms: i, premine: s, spacers: u, symbol: l } = r.etching.unwrap();
      this.etchings.push({
        valid: !0,
        runeTicker: o.toString(),
        runeName: new wk.SpacedRune(o, Number(u.map(Number).unwrapOr(0))).toString(),
        runeId: n,
        txid: t,
        ...a.isSome() ? { divisibility: a.map(Number).unwrap() } : {},
        ...s.isSome() ? { premine: s.unwrap() } : {},
        ...l.isSome() ? { symbol: l.unwrap() } : {},
        ...i.isSome() ? {
          terms: (() => {
            const c = i.unwrap();
            return {
              ...c.amount.isSome() ? { amount: c.amount.unwrap() } : {},
              ...c.cap.isSome() ? { cap: c.cap.unwrap() } : {},
              ...c.height.filter((f) => f.isSome()).length ? {
                height: {
                  ...c.height[0].isSome() ? { start: c.height[0].unwrap() } : {},
                  ...c.height[1].isSome() ? { end: c.height[1].unwrap() } : {}
                }
              } : {},
              ...c.offset.filter((f) => f.isSome()).length ? {
                offset: {
                  ...c.offset[0].isSome() ? { start: c.offset[0].unwrap() } : {},
                  ...c.offset[1].isSome() ? { end: c.offset[1].unwrap() } : {}
                }
              } : {}
            };
          })()
        } : {}
      });
    } else
      this.etchings.push({
        valid: !1,
        runeId: n,
        txid: t,
        runeTicker: o.toString(),
        runeName: o.toString()
      });
  }
}
dp.RuneUpdater = f2e;
(function(e) {
  var t = Ke && Ke.__createBinding || (Object.create ? function(u, l, c, f) {
    f === void 0 && (f = c);
    var h = Object.getOwnPropertyDescriptor(l, c);
    (!h || ("get" in h ? !l.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return l[c];
    } }), Object.defineProperty(u, f, h);
  } : function(u, l, c, f) {
    f === void 0 && (f = c), u[f] = l[c];
  }), r = Ke && Ke.__exportStar || function(u, l) {
    for (var c in u) c !== "default" && !Object.prototype.hasOwnProperty.call(l, c) && t(l, u, c);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.RunestoneIndexer = e.RuneUpdater = void 0;
  const n = Al, o = dp, a = Co;
  r(h0, e);
  var i = dp;
  Object.defineProperty(e, "RuneUpdater", { enumerable: !0, get: function() {
    return i.RuneUpdater;
  } });
  class s {
    constructor(l) {
      this._started = !1, this._updateInProgress = !1, this._rpc = l.bitcoinRpcClient, this._storage = l.storage, this._network = l.network;
    }
    async start() {
      this._started || (await this._storage.connect(), this._started = !0, this._network === n.Network.MAINNET && this._storage.seedEtchings([
        {
          runeTicker: "UNCOMMONGOODS",
          runeName: "UNCOMMONGOODS",
          runeId: { block: 1, tx: 0 },
          txid: "0000000000000000000000000000000000000000000000000000000000000000",
          valid: !0,
          symbol: "",
          terms: { amount: 1n, cap: a.u128.MAX, height: { start: 840000n, end: 1050000n } }
        }
      ]));
    }
    async stop() {
      this._started && (await this._storage.disconnect(), this._started = !1);
    }
    async updateRuneUtxoBalances() {
      if (!this._started)
        throw new Error("Runestone indexer is not started");
      if (!this._updateInProgress) {
        this._updateInProgress = !0;
        try {
          await this.updateRuneUtxoBalancesImpl();
        } finally {
          this._updateInProgress = !1;
        }
      }
    }
    async updateRuneUtxoBalancesImpl() {
      const l = await this._storage.getCurrentBlock();
      if (l) {
        const h = [];
        let p = l.height, y = (await this._rpc.getblockhash({ height: p })).result, m = l.hash;
        for (; m !== y; )
          y && h.push(y), p--, y = (await this._rpc.getblockhash({ height: p })).result, m = await this._storage.getBlockhash(p);
        h.reverse();
        for (const b of h) {
          const v = await this._rpc.getblock({ blockhash: b, verbosity: 2 });
          if (v.error !== null)
            throw v.error;
          const k = v.result, E = new o.RuneUpdater(this._network, k, !0, this._storage, this._rpc);
          for (const [A, S] of k.tx.entries())
            await E.indexRunes(S, A);
          await this._storage.saveBlockIndex(E);
        }
      }
      let c = Math.max(n.Network.getFirstRuneHeight(this._network), l ? l.height + 1 : 0), f = (await this._rpc.getblockhash({ height: c })).result;
      for (; f !== null; ) {
        const h = await this._rpc.getblock({ blockhash: f, verbosity: 2 });
        if (h.error !== null)
          throw h.error;
        const p = h.result, y = new o.RuneUpdater(this._network, p, !1, this._storage, this._rpc);
        for (const [m, b] of p.tx.entries())
          await y.indexRunes(b, m);
        await this._storage.saveBlockIndex(y), c++, f = (await this._rpc.getblockhash({ height: c })).result;
      }
    }
  }
  e.RunestoneIndexer = s;
})(ON);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.tryDecodeRunestone = e.isRunestone = e.encodeRunestone = e.Network = e.RunestoneIndexer = e.RuneUpdater = e.RuneLocation = void 0;
  const t = u0, r = tr, n = l0, o = kd, a = Co, i = Bo, s = xd, u = r6, l = d0;
  var c = ON;
  Object.defineProperty(e, "RuneLocation", { enumerable: !0, get: function() {
    return c.RuneLocation;
  } }), Object.defineProperty(e, "RuneUpdater", { enumerable: !0, get: function() {
    return c.RuneUpdater;
  } }), Object.defineProperty(e, "RunestoneIndexer", { enumerable: !0, get: function() {
    return c.RunestoneIndexer;
  } });
  var f = Al;
  Object.defineProperty(e, "Network", { enumerable: !0, get: function() {
    return f.Network;
  } });
  function h(A) {
    switch (A) {
      case o.Flaw.EDICT_OUTPUT:
        return "edict_output";
      case o.Flaw.EDICT_RUNE_ID:
        return "edict_rune_id";
      case o.Flaw.INVALID_SCRIPT:
        return "invalid_script";
      case o.Flaw.OPCODE:
        return "opcode";
      case o.Flaw.SUPPLY_OVERFLOW:
        return "supply_overflow";
      case o.Flaw.TRAILING_INTEGERS:
        return "trailing_integers";
      case o.Flaw.TRUNCATED_FIELD:
        return "truncated_field";
      case o.Flaw.UNRECOGNIZED_EVEN_TAG:
        return "unrecognized_even_tag";
      case o.Flaw.UNRECOGNIZED_FLAG:
        return "unrecognized_flag";
      case o.Flaw.VARINT:
        return "varint";
    }
  }
  const p = (A) => {
    const S = BigInt(A);
    if (S < 0n || S > a.u8.MAX)
      throw Error("u8 overflow");
    return (0, a.u8)(S);
  }, y = (A) => {
    const S = BigInt(A);
    if (S < 0n || S > a.u32.MAX)
      throw Error("u32 overflow");
    return (0, a.u32)(S);
  }, m = (A) => {
    const S = BigInt(A);
    if (S < 0n || S > a.u64.MAX)
      throw Error("u64 overflow");
    return (0, a.u64)(S);
  }, b = (A) => {
    const S = BigInt(A);
    if (S < 0n || S > a.u128.MAX)
      throw Error("u128 overflow");
    return (0, a.u128)(S);
  };
  function v(A) {
    const S = A.mint ? (0, i.Some)(new s.RuneId(m(A.mint.block), y(A.mint.tx))) : i.None, _ = A.pointer !== void 0 ? (0, i.Some)(A.pointer).map(y) : i.None, I = (A.edicts ?? []).map((D) => ({
      id: new s.RuneId(m(D.id.block), y(D.id.tx)),
      amount: b(D.amount),
      output: y(D.output)
    }));
    let O = i.None, z;
    if (A.etching) {
      const D = A.etching, G = D.runeName ? l.SpacedRune.fromString(D.runeName) : void 0, U = (G == null ? void 0 : G.rune) !== void 0 ? (0, i.Some)(G.rune) : i.None;
      if (D.symbol && !(D.symbol.length === 1 || D.symbol.length === 2 && D.symbol.codePointAt(0) >= 65536))
        throw Error("Symbol must be one code point");
      const V = D.divisibility !== void 0 ? (0, i.Some)(D.divisibility).map(p) : i.None, F = D.premine !== void 0 ? (0, i.Some)(D.premine).map(b) : i.None, C = (G == null ? void 0 : G.spacers) !== void 0 && G.spacers !== 0 ? (0, i.Some)(y(G.spacers)) : i.None, R = D.symbol ? (0, i.Some)(D.symbol) : i.None;
      if (V.isSome() && V.unwrap() > r.MAX_DIVISIBILITY)
        throw Error(`Divisibility is greater than protocol max ${r.MAX_DIVISIBILITY}`);
      let M = i.None;
      if (D.terms) {
        const W = D.terms, ne = W.amount !== void 0 ? (0, i.Some)(W.amount).map(b) : i.None, oe = W.cap !== void 0 ? (0, i.Some)(W.cap).map(b) : i.None, se = W.height ? [
          W.height.start !== void 0 ? (0, i.Some)(W.height.start).map(m) : i.None,
          W.height.end !== void 0 ? (0, i.Some)(W.height.end).map(m) : i.None
        ] : [i.None, i.None], K = W.offset ? [
          W.offset.start !== void 0 ? (0, i.Some)(W.offset.start).map(m) : i.None,
          W.offset.end !== void 0 ? (0, i.Some)(W.offset.end).map(m) : i.None
        ] : [i.None, i.None];
        if (ne.isSome() && oe.isSome() && ne.unwrap() * oe.unwrap() > a.u128.MAX)
          throw Error("Terms overflow with amount times cap");
        M = (0, i.Some)({ amount: ne, cap: oe, height: se, offset: K });
      }
      const re = D.turbo ?? !1;
      O = (0, i.Some)(new n.Etching(V, U, C, R, M, F, re)), z = U.isSome() ? U.unwrap().commitment : void 0;
    }
    return {
      encodedRunestone: new u.Runestone(S, _, I, O).encipher(),
      etchingCommitment: z
    };
  }
  e.encodeRunestone = v;
  function k(A) {
    return !("flaws" in A);
  }
  e.isRunestone = k;
  function E(A) {
    const S = u.Runestone.decipher(A);
    if (S.isNone())
      return null;
    const _ = S.unwrap();
    if ((0, t.isRunestone)(_)) {
      const I = _, O = () => I.etching.unwrap(), z = () => O().terms.unwrap();
      return {
        ...I.etching.isSome() ? {
          etching: {
            ...O().divisibility.isSome() ? { divisibility: O().divisibility.map(Number).unwrap() } : {},
            ...O().premine.isSome() ? { premine: O().premine.unwrap() } : {},
            ...O().rune.isSome() ? {
              runeName: new l.SpacedRune(O().rune.unwrap(), O().spacers.map(Number).unwrapOr(0)).toString()
            } : {},
            ...O().symbol.isSome() ? { symbol: O().symbol.unwrap() } : {},
            ...O().terms.isSome() ? {
              terms: {
                ...z().amount.isSome() ? { amount: z().amount.unwrap() } : {},
                ...z().cap.isSome() ? { cap: z().cap.unwrap() } : {},
                ...z().height.find((D) => D.isSome()) ? {
                  height: {
                    ...z().height[0].isSome() ? { start: z().height[0].unwrap() } : {},
                    ...z().height[1].isSome() ? { end: z().height[1].unwrap() } : {}
                  }
                } : {},
                ...z().offset.find((D) => D.isSome()) ? {
                  offset: {
                    ...z().offset[0].isSome() ? { start: z().offset[0].unwrap() } : {},
                    ...z().offset[1].isSome() ? { end: z().offset[1].unwrap() } : {}
                  }
                } : {}
              }
            } : {},
            turbo: O().turbo
          }
        } : {},
        ...I.mint.isSome() ? {
          mint: {
            block: I.mint.unwrap().block,
            tx: Number(I.mint.unwrap().tx)
          }
        } : {},
        ...I.pointer.isSome() ? { pointer: Number(I.pointer.unwrap()) } : {},
        ...I.edicts.length ? {
          edicts: I.edicts.map((D) => ({
            id: {
              block: D.id.block,
              tx: Number(D.id.tx)
            },
            amount: D.amount,
            output: Number(D.output)
          }))
        } : {}
      };
    } else {
      const I = _;
      return {
        flaws: I.flaws.map(h),
        ...I.etching.isSome() ? { etching: I.etching.unwrap().toString() } : {},
        ...I.mint.isSome() ? { mint: { block: I.mint.unwrap().block, tx: Number(I.mint.unwrap().tx) } } : {}
      };
    }
  }
  e.tryDecodeRunestone = E;
})(Jbe);
const d2e = (e) => /^(?:[A-Za-z0-9+\/]{4})*?(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(e), h2e = (e) => /^[a-fA-F0-9]+$/.test(e), sc = (e) => {
  const t = [];
  let r = e;
  do {
    let n = r & BigInt(127);
    r >>= BigInt(7), r !== BigInt(0) && (n |= BigInt(128)), t.push(Number(n));
  } while (r !== BigInt(0));
  return { varint: Buffer.from(t) };
}, p2e = ({
  runeId: e,
  amount: t,
  divisibility: r = 0,
  sendOutputIndex: n = 1,
  pointer: o = 0
}) => {
  r === 0 && (t = Math.floor(t));
  const a = sc(BigInt(22)).varint, i = sc(BigInt(o)).varint, s = sc(BigInt(0)).varint, u = sc(BigInt(t * 10 ** r)).varint, l = sc(BigInt(n)).varint, c = e.split(":"), f = Number(c[0]), h = Number(c[1]), p = sc(BigInt(f)).varint, y = sc(BigInt(h)).varint, m = Buffer.concat([
    a,
    i,
    s,
    p,
    y,
    u,
    l
  ]);
  let b = m.byteLength.toString(16);
  return b.length % 2 !== 0 && (b = "0" + m.byteLength.toString(16)), Buffer.concat([
    Buffer.from("6a", "hex"),
    Buffer.from("5d", "hex"),
    Buffer.from(b, "hex"),
    m
  ]);
}, g2e = "https://mainnet.sandshrew.io/v1/lasereyes", Ib = async (e, t) => {
  const r = JSON.stringify({
    jsonrpc: "2.0",
    id: e,
    method: e,
    params: t
  });
  return await nr.post(g2e, r, {
    headers: {
      "content-type": "application/json"
    }
  }).then((n) => n.data).catch((n) => {
    throw n;
  });
}, $N = async (e) => {
  try {
    return (await Ib("ord_address", [
      e
    ])).result;
  } catch (t) {
    throw t;
  }
}, CN = async (e) => {
  try {
    return (await Ib("ord_rune", [e])).result;
  } catch (t) {
    throw t;
  }
}, m2e = async (e) => {
  try {
    return await Ib("ord_rune", [e]);
  } catch (t) {
    throw t;
  }
}, y2e = async ({
  outpoints: e,
  rune_name: t
}) => {
  const r = [];
  for (let n = 0; n < e.length; n += 1e3) {
    const o = e.slice(n, n + 1e3), a = o.map((u) => ["ord_output", [u]]), { result: i } = await Ib("sandshrew_multicall", a);
    for (let u = 0; u < i.length; u++)
      i[u].result.output = o[u];
    const s = i.filter(
      (u) => Object.keys(u.result.runes).includes(t)
    );
    r.push(...s);
  }
  return r;
}, b2e = async (e) => {
  try {
    const t = (await $N(e)).runes_balances;
    if (!t)
      throw new Error("No runes data found");
    return t.map((r) => ({
      name: r[0],
      balance: r[1],
      symbol: r[2]
    }));
  } catch (t) {
    console.error("Error fetching ord address:", t);
  }
}, w2e = async ({
  ordOutputs: e
}) => {
  var t;
  try {
    const r = [];
    for (let n = 0; n < e.length; n++) {
      const o = e[n], { result: a } = o;
      if (!((t = a.output) != null && t.split(":")))
        throw new Error("No output found");
      const { output: i, address: s, runes: u } = a, l = {
        output: i,
        wallet_addr: s,
        script: "",
        balances: [],
        decimals: [],
        rune_ids: [],
        value: a.value
      }, [c, f] = i.split(":");
      if (console.log(c, f, i), l.script = Buffer.from(
        qbe(s, Ut)
      ).toString("hex"), typeof u == "object" && !Array.isArray(u))
        for (const h in u)
          l.balances.push(u[h].amount), l.decimals.push(u[h].divisibility), l.rune_ids.push((await m2e(h)).id);
      r.push(l);
    }
    return r;
  } catch (r) {
    throw r;
  }
}, v2e = async ({
  address: e,
  runeId: t
}) => {
  const r = await $N(e), { entry: n } = await CN(t), o = n.spaced_rune, a = await y2e({
    outpoints: r.outputs,
    rune_name: o
  });
  return await w2e({
    ordOutputs: a
  });
}, E2e = async ({
  runeId: e,
  amount: t,
  ordinalAddress: r,
  ordinalPublicKey: n,
  paymentAddress: o,
  paymentPublicKey: a,
  toAddress: i,
  signPsbt: s,
  network: u = Ut
}) => {
  try {
    const l = await k2e({
      fromAddress: r,
      fromAddressPublicKey: n,
      fromPaymentAddress: o,
      fromPaymentPublicKey: a,
      toAddress: i,
      runeId: e,
      amount: t,
      network: u
    });
    if (!l || !(l != null && l.psbtHex))
      throw new Error("couldn't get commit tx");
    const c = String(l == null ? void 0 : l.psbtHex), f = String(l == null ? void 0 : l.psbtBase64), h = await s(
      "",
      c,
      f,
      !0,
      !1,
      u
    );
    if (!h) throw new Error("sign psbt failed");
    const p = Zt.fromHex((h == null ? void 0 : h.signedPsbtHex) || "").extractTransaction();
    return await kb(p.toHex(), u);
  } catch (l) {
    throw l;
  }
}, k2e = async ({
  fromAddress: e,
  fromAddressPublicKey: t,
  fromPaymentAddress: r,
  fromPaymentPublicKey: n,
  toAddress: o,
  runeId: a,
  amount: i,
  network: s
}) => {
  try {
    const { fastestFee: u } = await kN(s);
    let l = (await Eb(r, s)).sort((_, I) => I.value - _.value).filter((_) => _.value > 3e3);
    if (l.length === 0)
      throw new Error("No utxos found");
    let c = new Zt({ network: kr(s) }), f = 0;
    const h = await CN(a), p = await v2e({ runeId: a, address: e }), y = SN(l), m = AN(p.length, 2, 4);
    let b = m * u < 250 ? 250 : m * u, v = 0;
    for await (const _ of p) {
      const { output: I, value: O, script: z } = _, D = I.split(":"), G = D[0], U = D[1];
      c.addInput({
        hash: G,
        index: parseInt(U),
        witnessUtxo: {
          value: BigInt(O),
          script: Buffer.from(z, "hex")
        },
        tapInternalKey: Uc(Buffer.from(t, "hex"))
      }), v++, f += O;
    }
    const k = xN(r, s);
    for (let _ = 0; _ < l.length; _++) {
      const I = Gp(
        r,
        kr(Ut)
      ), O = l[_];
      if (k === lf && c.addInput({
        hash: O.txid,
        index: O.vout,
        witnessUtxo: {
          value: BigInt(O.value),
          script: I
        },
        tapInternalKey: Uc(Buffer.from(n, "hex"))
      }), k === E5) {
        let z = Z4(n, s);
        c.addInput({
          hash: O.txid,
          index: O.vout,
          witnessUtxo: {
            value: BigInt(O.value),
            script: I
          },
          redeemScript: z
        });
      }
      k === "p2wpkh" && c.addInput({
        hash: O.txid,
        index: O.vout,
        witnessUtxo: {
          value: BigInt(O.value),
          script: I
        }
      });
    }
    const E = { script: p2e({
      runeId: h.id,
      amount: i,
      divisibility: h.entry.divisibility,
      sendOutputIndex: 2,
      pointer: 1
    }), value: BigInt(0) };
    c.addOutput(E);
    const A = 546, S = y - (b + A * 2);
    return c.addOutput({
      value: BigInt(A),
      address: e
    }), c.addOutput({
      value: BigInt(A),
      address: o
    }), c.addOutput({
      address: e,
      value: BigInt(S)
    }), { psbtBase64: c.toBase64(), psbtHex: c.toHex() };
  } catch (u) {
    throw u;
  }
}, P8 = new Error(
  "The connected wallet doesn't support this method..."
), x2e = new Error("Wallet is not installed");
class zi {
  constructor(t, r, n) {
    xe(this, "$store"), xe(this, "$network"), this.parent = r, this.config = n, this.$store = t.$store, this.$network = t.$network, this.initialize();
  }
  disconnect() {
  }
  async requestAccounts() {
    return [this.$store.get().address, this.$store.get().paymentAddress];
  }
  async switchNetwork(t) {
    throw this.parent.disconnect(), P8;
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [Cr, hn, En, Xn].includes(this.$network.get()) ? this.$network.get() : Ut;
  }
  async getPublicKey() {
    return this.$store.get().publicKey;
  }
  async getBalance() {
    const { paymentAddress: t } = this.$store.get();
    return await fs(t, this.$network.get());
  }
  async getMetaBalances(t) {
    switch (t) {
      case uk:
        return await this.getBalance();
      case ck:
        if (this.$network.get() !== Ut)
          throw new Error("Unsupported network");
        return await b2e(this.$store.get().address);
      default:
        throw new Error("Unsupported protocol");
    }
  }
  async getInscriptions(t, r) {
    throw console.log("getInscriptions not implemented", t, r), P8;
  }
  async pushPsbt(t) {
    let r = t;
    return r.startsWith("02") || (r = Zt.fromHex(r).extractTransaction().toHex()), await kb(r, this.$network.get());
  }
  async inscribe(t, r) {
    return await Zbe({
      contentBase64: t,
      mimeType: r,
      ordinalAddress: this.$store.get().address,
      paymentAddress: this.$store.get().paymentAddress,
      paymentPublicKey: this.$store.get().paymentPublicKey,
      signPsbt: this.signPsbt.bind(this),
      network: this.$network.get()
    });
  }
  async send(t, r) {
    switch (t) {
      case uk:
        return await this.sendBTC(r.toAddress, r.amount);
      case ck:
        const n = this.$network.get();
        if (n !== Ut)
          throw new Error("Unsupported network");
        const o = r;
        if (!o.runeId || !o.amount || !o.toAddress)
          throw new Error("Missing required parameters");
        return await E2e({
          runeId: o.runeId,
          amount: o.amount,
          ordinalAddress: this.$store.get().address,
          ordinalPublicKey: this.$store.get().publicKey,
          paymentAddress: this.$store.get().paymentAddress,
          paymentPublicKey: this.$store.get().paymentPublicKey,
          toAddress: o.toAddress,
          signPsbt: this.signPsbt.bind(this),
          network: n
        });
      default:
        throw new Error("Unsupported protocol");
    }
  }
}
class A2e extends zi {
  constructor() {
    super(...arguments), xe(this, "observer");
  }
  get library() {
    return window.unisat;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [kc]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Jo(this.$store, ["provider"], (t) => {
      if (t.provider !== kc) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener(
      "accountsChanged",
      this.handleAccountsChanged.bind(this)
    ), (r = this.library) == null || r.removeListener(
      "networkChanged",
      this.handleNetworkChanged.bind(this)
    ));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(kc) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = mm(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(kc);
  }
  async connect(t) {
    if (!this.library) throw new Error("Unisat isn't installed");
    const r = await this.library.requestAccounts();
    if (!r) throw new Error("No accounts found");
    await this.getNetwork().then((o) => {
      this.network !== o && this.switchNetwork(this.network);
    });
    const n = await this.library.getPublicKey();
    if (!n) throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n);
  }
  async getNetwork() {
    var t;
    const r = await ((t = this.library) == null ? void 0 : t.getChain());
    return r ? mm(r.enum) : this.network;
  }
  async sendBTC(t, r) {
    var n;
    const o = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
    if (!o) throw new Error("Transaction failed");
    return o;
  }
  async signMessage(t, r) {
    var n;
    const o = (r == null ? void 0 : r.protocol) === G4 ? vb : r == null ? void 0 : r.protocol;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t, o));
  }
  async signPsbt(t, r, n, o, a) {
    var i;
    const s = await ((i = this.library) == null ? void 0 : i.signPsbt(r, {
      autoFinalized: o
    })), u = Zt.fromHex(s);
    if (o && a) {
      const l = await this.pushPsbt(s);
      return {
        signedPsbtHex: u.toHex(),
        signedPsbtBase64: u.toBase64(),
        txId: l
      };
    }
    return {
      signedPsbtHex: u.toHex(),
      signedPsbtBase64: u.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var r;
    const n = fB(t);
    await ((r = this.library) == null ? void 0 : r.switchChain(n)), this.$network.set(t);
  }
}
function S2e(e) {
  typeof window < "u" && typeof localStorage < "u" && setTimeout(() => {
    const t = document.createTextNode(" ");
    document.body.appendChild(t), t.remove(), Promise.resolve().then(e);
  }, 1500);
}
function BN() {
  return {
    $store: aP({
      provider: void 0,
      address: "",
      paymentAddress: "",
      publicKey: "",
      paymentPublicKey: "",
      connected: !1,
      isConnecting: !1,
      isInitializing: !0,
      accounts: [],
      balance: void 0,
      hasProvider: {
        [uf]: !1,
        [kc]: !1,
        [qa]: !1,
        [cf]: !1,
        [Iu]: !1,
        [_u]: !1,
        [sf]: !1,
        [Ac]: !0,
        [Su]: !1,
        [xc]: !1,
        [Au]: !1
      }
    }),
    $network: Cv(Ut),
    $library: Cv(void 0)
  };
}
function _2e({ network: e }) {
  return {
    network: e
  };
}
const ec = [
  "address",
  "paymentAddress",
  "publicKey",
  "paymentPublicKey",
  "balance"
];
function Sl(e, t, r, n) {
  var o, a, i;
  t.provider === e && (r ? r === "balance" ? n.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : ec.includes(r) && n.setKey(
    r,
    ((a = t[r]) == null ? void 0 : a.toString()) ?? ""
  ) : n.set({
    address: t.address,
    paymentAddress: t.paymentAddress,
    paymentPublicKey: t.paymentPublicKey,
    publicKey: t.publicKey,
    balance: ((i = t.balance) == null ? void 0 : i.toString()) ?? ""
  }));
}
const I2e = (e) => {
  const t = e.match(/.{1,2}/g);
  if (!t)
    throw new Error("Invalid hex string");
  return Uint8Array.from(t.map((r) => parseInt(r, 16)));
};
function T2e(e, t) {
  var r;
  return (r = void 0) == null ? void 0 : r.get(t);
}
function Tb(e) {
  var t, r;
  let n = typeof e;
  return n === "object" && (n = (e && ((r = (t = Object.getPrototypeOf(e)) == null ? void 0 : t.constructor) == null ? void 0 : r.name)) ?? "null"), n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n;
}
function so(e, t, r, n, o) {
  const a = o && "input" in o ? o.input : r.value, i = (o == null ? void 0 : o.expected) ?? e.expects ?? null, s = (o == null ? void 0 : o.received) ?? Tb(a), u = {
    kind: e.kind,
    type: e.type,
    input: a,
    expected: i,
    received: s,
    message: `Invalid ${t}: ${i ? `Expected ${i} but r` : "R"}eceived ${s}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, l = e.kind === "schema", c = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? T2e(e.reference, u.lang) ?? (l ? (u.lang, void 0) : null) ?? n.message ?? (u.lang, void 0);
  c && (u.message = typeof c == "function" ? c(u) : c), l && (r.typed = !1), r.issues ? r.issues.push(u) : r.issues = [u];
}
function P2e(e, t) {
  return Object.hasOwn(e, t) && t !== "__proto__" && t !== "prototype" && t !== "constructor";
}
function NN(e, t, r) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, r)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function vk(e, t) {
  return !e._run({ typed: !1, value: t }, { abortEarly: !0 }).issues;
}
function Pi(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: Pi,
    expects: "Array",
    async: !1,
    item: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (Array.isArray(a)) {
        r.typed = !0, r.value = [];
        for (let i = 0; i < a.length; i++) {
          const s = a[i], u = this.item._run({ typed: !1, value: s }, n);
          if (u.issues) {
            const l = {
              type: "array",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), r.value.push(u.value);
        }
      } else
        so(this, "type", r, n);
      return r;
    }
  };
}
function UN(e) {
  return {
    kind: "schema",
    type: "boolean",
    reference: UN,
    expects: "boolean",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "boolean" ? t.typed = !0 : so(this, "type", t, r), t;
    }
  };
}
function rl(e, t) {
  const r = Object.entries(e).filter(([n]) => isNaN(+n)).map(([, n]) => n);
  return {
    kind: "schema",
    type: "enum",
    reference: rl,
    expects: r.map(Tb).join(" | ") || "never",
    async: !1,
    enum: e,
    options: r,
    message: t,
    _run(n, o) {
      return this.options.includes(n.value) ? n.typed = !0 : so(this, "type", n, o), n;
    }
  };
}
function vr(e, t) {
  return {
    kind: "schema",
    type: "literal",
    reference: vr,
    expects: Tb(e),
    async: !1,
    literal: e,
    message: t,
    _run(r, n) {
      return r.value === this.literal ? r.typed = !0 : so(this, "type", r, n), r;
    }
  };
}
function RN(e, t) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: RN,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (a && typeof a == "object") {
        r.typed = !0, r.value = {};
        for (const i in this.entries) {
          const s = a[i], u = this.entries[i]._run(
            { typed: !1, value: s },
            n
          );
          if (u.issues) {
            const l = {
              type: "object",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), (u.value !== void 0 || i in a) && (r.value[i] = u.value);
        }
        if (!r.issues || !n.abortEarly)
          for (const i in a)
            P2e(a, i) && !(i in this.entries) && (r.value[i] = a[i]);
      } else
        so(this, "type", r, n);
      return r;
    }
  };
}
function i6(e, t) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: i6,
    expects: "!undefined",
    async: !1,
    wrapped: e,
    message: t,
    _run(r, n) {
      return r.value === void 0 ? (so(this, "type", r, n), r) : this.wrapped._run(r, n);
    }
  };
}
function _l(e) {
  return {
    kind: "schema",
    type: "null",
    reference: _l,
    expects: "null",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value === null ? t.typed = !0 : so(this, "type", t, r), t;
    }
  };
}
function Il(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullish",
    reference: Il,
    expects: `${e.expects} | null | undefined`,
    async: !1,
    wrapped: e,
    _run(n, o) {
      return (n.value === null || n.value === void 0) && ("default" in this && (n.value = NN(
        this,
        n,
        o
      )), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function sa(e) {
  return {
    kind: "schema",
    type: "number",
    reference: sa,
    expects: "number",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : so(this, "type", t, r), t;
    }
  };
}
function Ce(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: Ce,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const a = r.value;
      if (a && typeof a == "object") {
        r.typed = !0, r.value = {};
        for (const i in this.entries) {
          const s = a[i], u = this.entries[i]._run(
            { typed: !1, value: s },
            n
          );
          if (u.issues) {
            const l = {
              type: "object",
              origin: "value",
              input: a,
              key: i,
              value: s
            };
            for (const c of u.issues)
              c.path ? c.path.unshift(l) : c.path = [l], (o = r.issues) == null || o.push(c);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), (u.value !== void 0 || i in a) && (r.value[i] = u.value);
        }
      } else
        so(this, "type", r, n);
      return r;
    }
  };
}
function Oi(e, ...t) {
  const r = {
    kind: "schema",
    type: "optional",
    reference: Oi,
    expects: `${e.expects} | undefined`,
    async: !1,
    wrapped: e,
    _run(n, o) {
      return n.value === void 0 && ("default" in this && (n.value = NN(
        this,
        n,
        o
      )), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function zN(e, t) {
  return {
    kind: "schema",
    type: "picklist",
    reference: zN,
    expects: e.map(Tb).join(" | ") || "never",
    async: !1,
    options: e,
    message: t,
    _run(r, n) {
      return this.options.includes(r.value) ? r.typed = !0 : so(this, "type", r, n), r;
    }
  };
}
function He(e) {
  return {
    kind: "schema",
    type: "string",
    reference: He,
    expects: "string",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = !0 : so(this, "type", t, r), t;
    }
  };
}
function a6(e) {
  return {
    kind: "schema",
    type: "undefined",
    reference: a6,
    expects: "undefined",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value === void 0 ? t.typed = !0 : so(this, "type", t, r), t;
    }
  };
}
function Ek(e) {
  let t;
  if (e)
    for (const r of e)
      t ? t.push(...r.issues) : t = r.issues;
  return t;
}
function Pb(e, t) {
  return {
    kind: "schema",
    type: "union",
    reference: Pb,
    expects: [...new Set(e.map((r) => r.expects))].join(" | ") || "never",
    async: !1,
    options: e,
    message: t,
    _run(r, n) {
      let o, a, i;
      for (const s of this.options) {
        const u = s._run(
          { typed: !1, value: r.value },
          n
        );
        if (u.typed)
          if (u.issues)
            a ? a.push(u) : a = [u];
          else {
            o = u;
            break;
          }
        else
          i ? i.push(u) : i = [u];
      }
      if (o)
        return o;
      if (a) {
        if (a.length === 1)
          return a[0];
        so(this, "type", r, n, {
          issues: Ek(a)
        }), r.typed = !0;
      } else {
        if ((i == null ? void 0 : i.length) === 1)
          return i[0];
        so(this, "type", r, n, {
          issues: Ek(i)
        });
      }
      return r;
    }
  };
}
function Ob() {
  return {
    kind: "schema",
    type: "unknown",
    reference: Ob,
    expects: "unknown",
    async: !1,
    _run(e) {
      return e.typed = !0, e;
    }
  };
}
var No = {}, qf = {}, Cn = {}, _d = {};
_d.byteLength = C2e;
_d.toByteArray = N2e;
_d.fromByteArray = z2e;
var ua = [], Ko = [], O2e = typeof Uint8Array < "u" ? Uint8Array : Array, ww = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var jl = 0, $2e = ww.length; jl < $2e; ++jl)
  ua[jl] = ww[jl], Ko[ww.charCodeAt(jl)] = jl;
Ko[45] = 62;
Ko[95] = 63;
function jN(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function C2e(e) {
  var t = jN(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function B2e(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function N2e(e) {
  var t, r = jN(e), n = r[0], o = r[1], a = new O2e(B2e(e, n, o)), i = 0, s = o > 0 ? n - 4 : n, u;
  for (u = 0; u < s; u += 4)
    t = Ko[e.charCodeAt(u)] << 18 | Ko[e.charCodeAt(u + 1)] << 12 | Ko[e.charCodeAt(u + 2)] << 6 | Ko[e.charCodeAt(u + 3)], a[i++] = t >> 16 & 255, a[i++] = t >> 8 & 255, a[i++] = t & 255;
  return o === 2 && (t = Ko[e.charCodeAt(u)] << 2 | Ko[e.charCodeAt(u + 1)] >> 4, a[i++] = t & 255), o === 1 && (t = Ko[e.charCodeAt(u)] << 10 | Ko[e.charCodeAt(u + 1)] << 4 | Ko[e.charCodeAt(u + 2)] >> 2, a[i++] = t >> 8 & 255, a[i++] = t & 255), a;
}
function U2e(e) {
  return ua[e >> 18 & 63] + ua[e >> 12 & 63] + ua[e >> 6 & 63] + ua[e & 63];
}
function R2e(e, t, r) {
  for (var n, o = [], a = t; a < r; a += 3)
    n = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (e[a + 2] & 255), o.push(U2e(n));
  return o.join("");
}
function z2e(e) {
  for (var t, r = e.length, n = r % 3, o = [], a = 16383, i = 0, s = r - n; i < s; i += a)
    o.push(R2e(e, i, i + a > s ? s : i + a));
  return n === 1 ? (t = e[r - 1], o.push(
    ua[t >> 2] + ua[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], o.push(
    ua[t >> 10] + ua[t >> 4 & 63] + ua[t << 2 & 63] + "="
  )), o.join("");
}
Object.defineProperty(Cn, "__esModule", { value: !0 });
Cn.decode = Cn.encode = Cn.unescape = Cn.escape = Cn.pad = void 0;
const LN = _d;
function s6(e) {
  return `${e}${"=".repeat(4 - (e.length % 4 || 4))}`;
}
Cn.pad = s6;
function HN(e) {
  return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
Cn.escape = HN;
function FN(e) {
  return s6(e).replace(/-/g, "+").replace(/_/g, "/");
}
Cn.unescape = FN;
function j2e(e) {
  return HN((0, LN.fromByteArray)(new TextEncoder().encode(e)));
}
Cn.encode = j2e;
function L2e(e) {
  return new TextDecoder().decode((0, LN.toByteArray)(s6(FN(e))));
}
Cn.decode = L2e;
var $b = {}, Cb = {}, Vf = {};
Object.defineProperty(Vf, "__esModule", { value: !0 });
Vf.joseToDer = Vf.derToJose = void 0;
const DN = _d, MN = Cn;
function vw(e) {
  return (e / 8 | 0) + (e % 8 === 0 ? 0 : 1);
}
const H2e = {
  ES256: vw(256),
  ES384: vw(384),
  ES512: vw(521)
};
function KN(e) {
  const t = H2e[e];
  if (t)
    return t;
  throw new Error(`Unknown algorithm "${e}"`);
}
const xm = 128, qN = 0, F2e = 32, D2e = 16, M2e = 2, VN = D2e | F2e | qN << 6, Am = M2e | qN << 6;
function GN(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return (0, DN.toByteArray)((0, MN.pad)(e));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function K2e(e, t) {
  const r = GN(e), n = KN(t), o = n + 1, a = r.length;
  let i = 0;
  if (r[i++] !== VN)
    throw new Error('Could not find expected "seq"');
  let s = r[i++];
  if (s === (xm | 1) && (s = r[i++]), a - i < s)
    throw new Error(`"seq" specified length of "${s}", only "${a - i}" remaining`);
  if (r[i++] !== Am)
    throw new Error('Could not find expected "int" for "r"');
  const u = r[i++];
  if (a - i - 2 < u)
    throw new Error(`"r" specified length of "${u}", only "${a - i - 2}" available`);
  if (o < u)
    throw new Error(`"r" specified length of "${u}", max of "${o}" is acceptable`);
  const l = i;
  if (i += u, r[i++] !== Am)
    throw new Error('Could not find expected "int" for "s"');
  const c = r[i++];
  if (a - i !== c)
    throw new Error(`"s" specified length of "${c}", expected "${a - i}"`);
  if (o < c)
    throw new Error(`"s" specified length of "${c}", max of "${o}" is acceptable`);
  const f = i;
  if (i += c, i !== a)
    throw new Error(`Expected to consume entire array, but "${a - i}" bytes remain`);
  const h = n - u, p = n - c, y = new Uint8Array(h + u + p + c);
  for (i = 0; i < h; ++i)
    y[i] = 0;
  y.set(r.subarray(l + Math.max(-h, 0), l + u), i), i = n;
  for (const m = i; i < m + p; ++i)
    y[i] = 0;
  return y.set(r.subarray(f + Math.max(-p, 0), f + c), i), (0, MN.escape)((0, DN.fromByteArray)(y));
}
Vf.derToJose = K2e;
function kk(e, t, r) {
  let n = 0;
  for (; t + n < r && e[t + n] === 0; )
    ++n;
  return e[t + n] >= xm && --n, n;
}
function q2e(e, t) {
  e = GN(e);
  const r = KN(t), n = e.length;
  if (n !== r * 2)
    throw new TypeError(`"${t}" signatures must be "${r * 2}" bytes, saw "${n}"`);
  const o = kk(e, 0, r), a = kk(e, r, e.length), i = r - o, s = r - a, u = 2 + i + 1 + 1 + s, l = u < xm, c = new Uint8Array((l ? 2 : 3) + u);
  let f = 0;
  return c[f++] = VN, l ? c[f++] = u : (c[f++] = xm | 1, c[f++] = u & 255), c[f++] = Am, c[f++] = i, o < 0 ? (c[f++] = 0, c.set(e.subarray(0, r), f), f += r) : (c.set(e.subarray(o, r), f), f += r - o), c[f++] = Am, c[f++] = s, a < 0 ? (c[f++] = 0, c.set(e.subarray(r), f)) : c.set(e.subarray(r + a), f), c;
}
Vf.joseToDer = q2e;
var ds = {};
Object.defineProperty(ds, "__esModule", { value: !0 });
ds.InvalidTokenError = ds.MissingParametersError = void 0;
class V2e extends Error {
  constructor(t) {
    super(), this.name = "MissingParametersError", this.message = t || "";
  }
}
ds.MissingParametersError = V2e;
class G2e extends Error {
  constructor(t) {
    super(), this.name = "InvalidTokenError", this.message = t || "";
  }
}
ds.InvalidTokenError = G2e;
Object.defineProperty(Cb, "__esModule", { value: !0 });
Cb.SECP256K1Client = void 0;
const Z2e = nb, W2e = ki, z1 = $4, xk = Vf, Ak = ds, Sk = Yu;
z1.utils.hmacSha256Sync = (e, ...t) => {
  const r = Z2e.hmac.create(W2e.sha256, e);
  return t.forEach((n) => r.update(n)), r.digest();
};
class ZN {
  static derivePublicKey(t, r = !0) {
    return t.length === 66 && (t = t.slice(0, 64)), t.length < 64 && (t = t.padStart(64, "0")), (0, Sk.bytesToHex)(z1.getPublicKey(t, r));
  }
  static signHash(t, r, n = "jose") {
    if (!t || !r)
      throw new Ak.MissingParametersError("a signing input hash and private key are all required");
    const o = z1.signSync(t, r.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (n === "der")
      return (0, Sk.bytesToHex)(o);
    if (n === "jose")
      return (0, xk.derToJose)(o, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(t) {
    return (0, xk.joseToDer)(t, "ES256");
  }
  static verifyHash(t, r, n) {
    if (!t || !r || !n)
      throw new Ak.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return z1.verify(r, t, n, { strict: !1 });
  }
}
Cb.SECP256K1Client = ZN;
ZN.algorithmName = "ES256K";
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.cryptoClients = e.SECP256K1Client = void 0;
  const t = Cb;
  Object.defineProperty(e, "SECP256K1Client", { enumerable: !0, get: function() {
    return t.SECP256K1Client;
  } });
  const r = {
    ES256K: t.SECP256K1Client
  };
  e.cryptoClients = r;
})($b);
var nl = {}, X2e = Ke && Ke.__awaiter || function(e, t, r, n) {
  function o(a) {
    return a instanceof r ? a : new r(function(i) {
      i(a);
    });
  }
  return new (r || (r = Promise))(function(a, i) {
    function s(c) {
      try {
        l(n.next(c));
      } catch (f) {
        i(f);
      }
    }
    function u(c) {
      try {
        l(n.throw(c));
      } catch (f) {
        i(f);
      }
    }
    function l(c) {
      c.done ? a(c.value) : o(c.value).then(s, u);
    }
    l((n = n.apply(e, t || [])).next());
  });
};
Object.defineProperty(nl, "__esModule", { value: !0 });
nl.hashSha256Async = nl.hashSha256 = void 0;
const Y2e = ki;
function WN(e) {
  return (0, Y2e.sha256)(e);
}
nl.hashSha256 = WN;
function J2e(e) {
  return X2e(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const t = typeof e == "string" ? new TextEncoder().encode(e) : e, r = yield crypto.subtle.digest("SHA-256", t);
        return new Uint8Array(r);
      } else {
        const t = GC;
        if (!t.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(t.createHash("sha256").update(e).digest());
      }
    } catch (t) {
      return console.log(t), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(WN(e));
    }
  });
}
nl.hashSha256Async = J2e;
var Q2e = Ke && Ke.__awaiter || function(e, t, r, n) {
  function o(a) {
    return a instanceof r ? a : new r(function(i) {
      i(a);
    });
  }
  return new (r || (r = Promise))(function(a, i) {
    function s(c) {
      try {
        l(n.next(c));
      } catch (f) {
        i(f);
      }
    }
    function u(c) {
      try {
        l(n.throw(c));
      } catch (f) {
        i(f);
      }
    }
    function l(c) {
      c.done ? a(c.value) : o(c.value).then(s, u);
    }
    l((n = n.apply(e, t || [])).next());
  });
};
Object.defineProperty(qf, "__esModule", { value: !0 });
qf.TokenSigner = qf.createUnsecuredToken = void 0;
const O8 = Cn, _k = $b, ewe = ds, Ik = nl;
function $8(e, t) {
  const r = [], n = O8.encode(JSON.stringify(t));
  r.push(n);
  const o = O8.encode(JSON.stringify(e));
  return r.push(o), r.join(".");
}
function twe(e) {
  return $8(e, { typ: "JWT", alg: "none" }) + ".";
}
qf.createUnsecuredToken = twe;
class rwe {
  constructor(t, r) {
    if (!(t && r))
      throw new ewe.MissingParametersError("a signing algorithm and private key are required");
    if (typeof t != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (t = t.toUpperCase(), !_k.cryptoClients.hasOwnProperty(t))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = _k.cryptoClients[t], this.rawPrivateKey = r;
  }
  header(t = {}) {
    const r = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, r, t);
  }
  sign(t, r = !1, n = {}) {
    const o = this.header(n), a = $8(t, o), i = (0, Ik.hashSha256)(a);
    return this.createWithSignedHash(t, r, o, a, i);
  }
  signAsync(t, r = !1, n = {}) {
    return Q2e(this, void 0, void 0, function* () {
      const o = this.header(n), a = $8(t, o), i = yield (0, Ik.hashSha256Async)(a);
      return this.createWithSignedHash(t, r, o, a, i);
    });
  }
  createWithSignedHash(t, r, n, o, a) {
    const i = this.cryptoClient.signHash(a, this.rawPrivateKey);
    return r ? {
      header: [O8.encode(JSON.stringify(n))],
      payload: JSON.stringify(t),
      signature: [i]
    } : [o, i].join(".");
  }
}
qf.TokenSigner = rwe;
var Bb = {};
Object.defineProperty(Bb, "__esModule", { value: !0 });
Bb.TokenVerifier = void 0;
const nwe = Cn, Tk = $b, owe = ds, l1 = nl;
class iwe {
  constructor(t, r) {
    if (!(t && r))
      throw new owe.MissingParametersError("a signing algorithm and public key are required");
    if (typeof t != "string")
      throw "signing algorithm parameter must be a string";
    if (t = t.toUpperCase(), !Tk.cryptoClients.hasOwnProperty(t))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = Tk.cryptoClients[t], this.rawPublicKey = r;
  }
  verify(t) {
    return typeof t == "string" ? this.verifyCompact(t, !1) : typeof t == "object" ? this.verifyExpanded(t, !1) : !1;
  }
  verifyAsync(t) {
    return typeof t == "string" ? this.verifyCompact(t, !0) : typeof t == "object" ? this.verifyExpanded(t, !0) : Promise.resolve(!1);
  }
  verifyCompact(t, r) {
    const n = t.split("."), o = n[0] + "." + n[1], a = (i) => {
      const s = this.cryptoClient.loadSignature(n[2]);
      return this.cryptoClient.verifyHash(i, s, this.rawPublicKey);
    };
    if (r)
      return (0, l1.hashSha256Async)(o).then((i) => a(i));
    {
      const i = (0, l1.hashSha256)(o);
      return a(i);
    }
  }
  verifyExpanded(t, r) {
    const n = [t.header.join("."), nwe.encode(t.payload)].join(".");
    let o = !0;
    const a = (i) => (t.signature.map((s) => {
      const u = this.cryptoClient.loadSignature(s);
      this.cryptoClient.verifyHash(i, u, this.rawPublicKey) || (o = !1);
    }), o);
    if (r)
      return (0, l1.hashSha256Async)(n).then((i) => a(i));
    {
      const i = (0, l1.hashSha256)(n);
      return a(i);
    }
  }
}
Bb.TokenVerifier = iwe;
var Nb = {};
Object.defineProperty(Nb, "__esModule", { value: !0 });
Nb.decodeToken = void 0;
const f1 = Cn;
function awe(e) {
  if (typeof e == "string") {
    const t = e.split("."), r = JSON.parse(f1.decode(t[0])), n = JSON.parse(f1.decode(t[1])), o = t[2];
    return {
      header: r,
      payload: n,
      signature: o
    };
  } else if (typeof e == "object") {
    if (typeof e.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let t = e.payload;
    e.payload[0] !== "{" && (t = f1.decode(t));
    const r = [];
    return e.header.map((n) => {
      const o = JSON.parse(f1.decode(n));
      r.push(o);
    }), {
      header: r,
      payload: JSON.parse(t),
      signature: e.signature
    };
  }
}
Nb.decodeToken = awe;
(function(e) {
  var t = Ke && Ke.__createBinding || (Object.create ? function(n, o, a, i) {
    i === void 0 && (i = a);
    var s = Object.getOwnPropertyDescriptor(o, a);
    (!s || ("get" in s ? !o.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return o[a];
    } }), Object.defineProperty(n, i, s);
  } : function(n, o, a, i) {
    i === void 0 && (i = a), n[i] = o[a];
  }), r = Ke && Ke.__exportStar || function(n, o) {
    for (var a in n) a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && t(o, n, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(qf, e), r(Bb, e), r(Nb, e), r(ds, e), r($b, e);
})(No);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Pk = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const e = Array(256).fill(-1);
  for (let t = 0; t < Pk.length; ++t) e[Pk.charCodeAt(t)] = t;
})();
var Ok, Ew, d1, u6 = (Ok = function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.bech32m = t.bech32 = void 0;
  const r = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", n = {};
  for (let f = 0; f < 32; f++) {
    const h = r.charAt(f);
    n[h] = f;
  }
  function o(f) {
    const h = f >> 25;
    return (33554431 & f) << 5 ^ 996825010 & -(h >> 0 & 1) ^ 642813549 & -(h >> 1 & 1) ^ 513874426 & -(h >> 2 & 1) ^ 1027748829 & -(h >> 3 & 1) ^ 705979059 & -(h >> 4 & 1);
  }
  function a(f) {
    let h = 1;
    for (let p = 0; p < f.length; ++p) {
      const y = f.charCodeAt(p);
      if (y < 33 || y > 126) return "Invalid prefix (" + f + ")";
      h = o(h) ^ y >> 5;
    }
    h = o(h);
    for (let p = 0; p < f.length; ++p) {
      const y = f.charCodeAt(p);
      h = o(h) ^ 31 & y;
    }
    return h;
  }
  function i(f, h, p, y) {
    let m = 0, b = 0;
    const v = (1 << p) - 1, k = [];
    for (let E = 0; E < f.length; ++E) for (m = m << h | f[E], b += h; b >= p; ) b -= p, k.push(m >> b & v);
    if (y) b > 0 && k.push(m << p - b & v);
    else {
      if (b >= h) return "Excess padding";
      if (m << p - b & v) return "Non-zero padding";
    }
    return k;
  }
  function s(f) {
    return i(f, 8, 5, !0);
  }
  function u(f) {
    const h = i(f, 5, 8, !1);
    if (Array.isArray(h)) return h;
  }
  function l(f) {
    const h = i(f, 5, 8, !1);
    if (Array.isArray(h)) return h;
    throw new Error(h);
  }
  function c(f) {
    let h;
    function p(y, m) {
      if (m = m || 90, y.length < 8) return y + " too short";
      if (y.length > m) return "Exceeds length limit";
      const b = y.toLowerCase(), v = y.toUpperCase();
      if (y !== b && y !== v) return "Mixed-case string " + y;
      const k = (y = b).lastIndexOf("1");
      if (k === -1) return "No separator character for " + y;
      if (k === 0) return "Missing prefix for " + y;
      const E = y.slice(0, k), A = y.slice(k + 1);
      if (A.length < 6) return "Data too short";
      let S = a(E);
      if (typeof S == "string") return S;
      const _ = [];
      for (let I = 0; I < A.length; ++I) {
        const O = A.charAt(I), z = n[O];
        if (z === void 0) return "Unknown character " + O;
        S = o(S) ^ z, I + 6 >= A.length || _.push(z);
      }
      return S !== h ? "Invalid checksum for " + y : { prefix: E, words: _ };
    }
    return h = f === "bech32" ? 1 : 734539939, { decodeUnsafe: function(y, m) {
      const b = p(y, m);
      if (typeof b == "object") return b;
    }, decode: function(y, m) {
      const b = p(y, m);
      if (typeof b == "object") return b;
      throw new Error(b);
    }, encode: function(y, m, b) {
      if (b = b || 90, y.length + 7 + m.length > b) throw new TypeError("Exceeds length limit");
      let v = a(y = y.toLowerCase());
      if (typeof v == "string") throw new Error(v);
      let k = y + "1";
      for (let E = 0; E < m.length; ++E) {
        const A = m[E];
        if (A >> 5) throw new Error("Non 5-bit word");
        v = o(v) ^ A, k += r.charAt(A);
      }
      for (let E = 0; E < 6; ++E) v = o(v);
      v ^= h;
      for (let E = 0; E < 6; ++E) k += r.charAt(v >> 5 * (5 - E) & 31);
      return k;
    }, toWords: s, fromWordsUnsafe: u, fromWords: l };
  }
  t.bech32 = c("bech32"), t.bech32m = c("bech32m");
}, Ok(Ew = { exports: {} }, Ew.exports), Ew.exports);
(d1 = u6) && d1.__esModule && Object.prototype.hasOwnProperty.call(d1, "default") && d1.default;
u6.bech32m;
u6.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var Ql, ef;
(function(e) {
  e.mainnet = "mainnet", e.testnet = "testnet", e.regtest = "regtest";
})(Ql || (Ql = {})), function(e) {
  e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr";
}(ef || (ef = {}));
ef.p2pkh, Ql.mainnet, ef.p2pkh, Ql.testnet, ef.p2sh, Ql.mainnet, ef.p2sh, Ql.testnet;
var swe = {}, c6 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
c6.read = function(e, t, r, n, o) {
  var a, i, s = o * 8 - n - 1, u = (1 << s) - 1, l = u >> 1, c = -7, f = r ? o - 1 : 0, h = r ? -1 : 1, p = e[t + f];
  for (f += h, a = p & (1 << -c) - 1, p >>= -c, c += s; c > 0; a = a * 256 + e[t + f], f += h, c -= 8)
    ;
  for (i = a & (1 << -c) - 1, a >>= -c, c += n; c > 0; i = i * 256 + e[t + f], f += h, c -= 8)
    ;
  if (a === 0)
    a = 1 - l;
  else {
    if (a === u)
      return i ? NaN : (p ? -1 : 1) * (1 / 0);
    i = i + Math.pow(2, n), a = a - l;
  }
  return (p ? -1 : 1) * i * Math.pow(2, a - n);
};
c6.write = function(e, t, r, n, o, a) {
  var i, s, u, l = a * 8 - o - 1, c = (1 << l) - 1, f = c >> 1, h = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : a - 1, y = n ? 1 : -1, m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, i = c) : (i = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -i)) < 1 && (i--, u *= 2), i + f >= 1 ? t += h / u : t += h * Math.pow(2, 1 - f), t * u >= 2 && (i++, u /= 2), i + f >= c ? (s = 0, i = c) : i + f >= 1 ? (s = (t * u - 1) * Math.pow(2, o), i = i + f) : (s = t * Math.pow(2, f - 1) * Math.pow(2, o), i = 0)); o >= 8; e[r + p] = s & 255, p += y, s /= 256, o -= 8)
    ;
  for (i = i << o | s, l += o; l > 0; e[r + p] = i & 255, p += y, i /= 256, l -= 8)
    ;
  e[r + p - y] |= m * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = _d, r = c6, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = s, e.SlowBuffer = k, e.INSPECT_MAX_BYTES = 50;
  const o = 2147483647;
  e.kMaxLength = o, s.TYPED_ARRAY_SUPPORT = a(), !s.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a() {
    try {
      const d = new Uint8Array(1), g = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(g, Uint8Array.prototype), Object.setPrototypeOf(d, g), d.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(s.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(s.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.byteOffset;
    }
  });
  function i(d) {
    if (d > o)
      throw new RangeError('The value "' + d + '" is invalid for option "size"');
    const g = new Uint8Array(d);
    return Object.setPrototypeOf(g, s.prototype), g;
  }
  function s(d, g, w) {
    if (typeof d == "number") {
      if (typeof g == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return f(d);
    }
    return u(d, g, w);
  }
  s.poolSize = 8192;
  function u(d, g, w) {
    if (typeof d == "string")
      return h(d, g);
    if (ArrayBuffer.isView(d))
      return y(d);
    if (d == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof d
      );
    if (Xt(d, ArrayBuffer) || d && Xt(d.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Xt(d, SharedArrayBuffer) || d && Xt(d.buffer, SharedArrayBuffer)))
      return m(d, g, w);
    if (typeof d == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const $ = d.valueOf && d.valueOf();
    if ($ != null && $ !== d)
      return s.from($, g, w);
    const N = b(d);
    if (N) return N;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof d[Symbol.toPrimitive] == "function")
      return s.from(d[Symbol.toPrimitive]("string"), g, w);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof d
    );
  }
  s.from = function(d, g, w) {
    return u(d, g, w);
  }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array);
  function l(d) {
    if (typeof d != "number")
      throw new TypeError('"size" argument must be of type number');
    if (d < 0)
      throw new RangeError('The value "' + d + '" is invalid for option "size"');
  }
  function c(d, g, w) {
    return l(d), d <= 0 ? i(d) : g !== void 0 ? typeof w == "string" ? i(d).fill(g, w) : i(d).fill(g) : i(d);
  }
  s.alloc = function(d, g, w) {
    return c(d, g, w);
  };
  function f(d) {
    return l(d), i(d < 0 ? 0 : v(d) | 0);
  }
  s.allocUnsafe = function(d) {
    return f(d);
  }, s.allocUnsafeSlow = function(d) {
    return f(d);
  };
  function h(d, g) {
    if ((typeof g != "string" || g === "") && (g = "utf8"), !s.isEncoding(g))
      throw new TypeError("Unknown encoding: " + g);
    const w = E(d, g) | 0;
    let $ = i(w);
    const N = $.write(d, g);
    return N !== w && ($ = $.slice(0, N)), $;
  }
  function p(d) {
    const g = d.length < 0 ? 0 : v(d.length) | 0, w = i(g);
    for (let $ = 0; $ < g; $ += 1)
      w[$] = d[$] & 255;
    return w;
  }
  function y(d) {
    if (Xt(d, Uint8Array)) {
      const g = new Uint8Array(d);
      return m(g.buffer, g.byteOffset, g.byteLength);
    }
    return p(d);
  }
  function m(d, g, w) {
    if (g < 0 || d.byteLength < g)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (d.byteLength < g + (w || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let $;
    return g === void 0 && w === void 0 ? $ = new Uint8Array(d) : w === void 0 ? $ = new Uint8Array(d, g) : $ = new Uint8Array(d, g, w), Object.setPrototypeOf($, s.prototype), $;
  }
  function b(d) {
    if (s.isBuffer(d)) {
      const g = v(d.length) | 0, w = i(g);
      return w.length === 0 || d.copy(w, 0, 0, g), w;
    }
    if (d.length !== void 0)
      return typeof d.length != "number" || lo(d.length) ? i(0) : p(d);
    if (d.type === "Buffer" && Array.isArray(d.data))
      return p(d.data);
  }
  function v(d) {
    if (d >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return d | 0;
  }
  function k(d) {
    return +d != d && (d = 0), s.alloc(+d);
  }
  s.isBuffer = function(d) {
    return d != null && d._isBuffer === !0 && d !== s.prototype;
  }, s.compare = function(d, g) {
    if (Xt(d, Uint8Array) && (d = s.from(d, d.offset, d.byteLength)), Xt(g, Uint8Array) && (g = s.from(g, g.offset, g.byteLength)), !s.isBuffer(d) || !s.isBuffer(g))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (d === g) return 0;
    let w = d.length, $ = g.length;
    for (let N = 0, H = Math.min(w, $); N < H; ++N)
      if (d[N] !== g[N]) {
        w = d[N], $ = g[N];
        break;
      }
    return w < $ ? -1 : $ < w ? 1 : 0;
  }, s.isEncoding = function(d) {
    switch (String(d).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, s.concat = function(d, g) {
    if (!Array.isArray(d))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (d.length === 0)
      return s.alloc(0);
    let w;
    if (g === void 0)
      for (g = 0, w = 0; w < d.length; ++w)
        g += d[w].length;
    const $ = s.allocUnsafe(g);
    let N = 0;
    for (w = 0; w < d.length; ++w) {
      let H = d[w];
      if (Xt(H, Uint8Array))
        N + H.length > $.length ? (s.isBuffer(H) || (H = s.from(H)), H.copy($, N)) : Uint8Array.prototype.set.call(
          $,
          H,
          N
        );
      else if (s.isBuffer(H))
        H.copy($, N);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      N += H.length;
    }
    return $;
  };
  function E(d, g) {
    if (s.isBuffer(d))
      return d.length;
    if (ArrayBuffer.isView(d) || Xt(d, ArrayBuffer))
      return d.byteLength;
    if (typeof d != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof d
      );
    const w = d.length, $ = arguments.length > 2 && arguments[2] === !0;
    if (!$ && w === 0) return 0;
    let N = !1;
    for (; ; )
      switch (g) {
        case "ascii":
        case "latin1":
        case "binary":
          return w;
        case "utf8":
        case "utf-8":
          return Sn(d).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return w * 2;
        case "hex":
          return w >>> 1;
        case "base64":
          return xa(d).length;
        default:
          if (N)
            return $ ? -1 : Sn(d).length;
          g = ("" + g).toLowerCase(), N = !0;
      }
  }
  s.byteLength = E;
  function A(d, g, w) {
    let $ = !1;
    if ((g === void 0 || g < 0) && (g = 0), g > this.length || ((w === void 0 || w > this.length) && (w = this.length), w <= 0) || (w >>>= 0, g >>>= 0, w <= g))
      return "";
    for (d || (d = "utf8"); ; )
      switch (d) {
        case "hex":
          return W(this, g, w);
        case "utf8":
        case "utf-8":
          return F(this, g, w);
        case "ascii":
          return M(this, g, w);
        case "latin1":
        case "binary":
          return re(this, g, w);
        case "base64":
          return V(this, g, w);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ne(this, g, w);
        default:
          if ($) throw new TypeError("Unknown encoding: " + d);
          d = (d + "").toLowerCase(), $ = !0;
      }
  }
  s.prototype._isBuffer = !0;
  function S(d, g, w) {
    const $ = d[g];
    d[g] = d[w], d[w] = $;
  }
  s.prototype.swap16 = function() {
    const d = this.length;
    if (d % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let g = 0; g < d; g += 2)
      S(this, g, g + 1);
    return this;
  }, s.prototype.swap32 = function() {
    const d = this.length;
    if (d % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let g = 0; g < d; g += 4)
      S(this, g, g + 3), S(this, g + 1, g + 2);
    return this;
  }, s.prototype.swap64 = function() {
    const d = this.length;
    if (d % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let g = 0; g < d; g += 8)
      S(this, g, g + 7), S(this, g + 1, g + 6), S(this, g + 2, g + 5), S(this, g + 3, g + 4);
    return this;
  }, s.prototype.toString = function() {
    const d = this.length;
    return d === 0 ? "" : arguments.length === 0 ? F(this, 0, d) : A.apply(this, arguments);
  }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(d) {
    if (!s.isBuffer(d)) throw new TypeError("Argument must be a Buffer");
    return this === d ? !0 : s.compare(this, d) === 0;
  }, s.prototype.inspect = function() {
    let d = "";
    const g = e.INSPECT_MAX_BYTES;
    return d = this.toString("hex", 0, g).replace(/(.{2})/g, "$1 ").trim(), this.length > g && (d += " ... "), "<Buffer " + d + ">";
  }, n && (s.prototype[n] = s.prototype.inspect), s.prototype.compare = function(d, g, w, $, N) {
    if (Xt(d, Uint8Array) && (d = s.from(d, d.offset, d.byteLength)), !s.isBuffer(d))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof d
      );
    if (g === void 0 && (g = 0), w === void 0 && (w = d ? d.length : 0), $ === void 0 && ($ = 0), N === void 0 && (N = this.length), g < 0 || w > d.length || $ < 0 || N > this.length)
      throw new RangeError("out of range index");
    if ($ >= N && g >= w)
      return 0;
    if ($ >= N)
      return -1;
    if (g >= w)
      return 1;
    if (g >>>= 0, w >>>= 0, $ >>>= 0, N >>>= 0, this === d) return 0;
    let H = N - $, Z = w - g;
    const Te = Math.min(H, Z), ut = this.slice($, N), Be = d.slice(g, w);
    for (let Ie = 0; Ie < Te; ++Ie)
      if (ut[Ie] !== Be[Ie]) {
        H = ut[Ie], Z = Be[Ie];
        break;
      }
    return H < Z ? -1 : Z < H ? 1 : 0;
  };
  function _(d, g, w, $, N) {
    if (d.length === 0) return -1;
    if (typeof w == "string" ? ($ = w, w = 0) : w > 2147483647 ? w = 2147483647 : w < -2147483648 && (w = -2147483648), w = +w, lo(w) && (w = N ? 0 : d.length - 1), w < 0 && (w = d.length + w), w >= d.length) {
      if (N) return -1;
      w = d.length - 1;
    } else if (w < 0)
      if (N) w = 0;
      else return -1;
    if (typeof g == "string" && (g = s.from(g, $)), s.isBuffer(g))
      return g.length === 0 ? -1 : I(d, g, w, $, N);
    if (typeof g == "number")
      return g = g & 255, typeof Uint8Array.prototype.indexOf == "function" ? N ? Uint8Array.prototype.indexOf.call(d, g, w) : Uint8Array.prototype.lastIndexOf.call(d, g, w) : I(d, [g], w, $, N);
    throw new TypeError("val must be string, number or Buffer");
  }
  function I(d, g, w, $, N) {
    let H = 1, Z = d.length, Te = g.length;
    if ($ !== void 0 && ($ = String($).toLowerCase(), $ === "ucs2" || $ === "ucs-2" || $ === "utf16le" || $ === "utf-16le")) {
      if (d.length < 2 || g.length < 2)
        return -1;
      H = 2, Z /= 2, Te /= 2, w /= 2;
    }
    function ut(Ie, Xe) {
      return H === 1 ? Ie[Xe] : Ie.readUInt16BE(Xe * H);
    }
    let Be;
    if (N) {
      let Ie = -1;
      for (Be = w; Be < Z; Be++)
        if (ut(d, Be) === ut(g, Ie === -1 ? 0 : Be - Ie)) {
          if (Ie === -1 && (Ie = Be), Be - Ie + 1 === Te) return Ie * H;
        } else
          Ie !== -1 && (Be -= Be - Ie), Ie = -1;
    } else
      for (w + Te > Z && (w = Z - Te), Be = w; Be >= 0; Be--) {
        let Ie = !0;
        for (let Xe = 0; Xe < Te; Xe++)
          if (ut(d, Be + Xe) !== ut(g, Xe)) {
            Ie = !1;
            break;
          }
        if (Ie) return Be;
      }
    return -1;
  }
  s.prototype.includes = function(d, g, w) {
    return this.indexOf(d, g, w) !== -1;
  }, s.prototype.indexOf = function(d, g, w) {
    return _(this, d, g, w, !0);
  }, s.prototype.lastIndexOf = function(d, g, w) {
    return _(this, d, g, w, !1);
  };
  function O(d, g, w, $) {
    w = Number(w) || 0;
    const N = d.length - w;
    $ ? ($ = Number($), $ > N && ($ = N)) : $ = N;
    const H = g.length;
    $ > H / 2 && ($ = H / 2);
    let Z;
    for (Z = 0; Z < $; ++Z) {
      const Te = parseInt(g.substr(Z * 2, 2), 16);
      if (lo(Te)) return Z;
      d[w + Z] = Te;
    }
    return Z;
  }
  function z(d, g, w, $) {
    return _n(Sn(g, d.length - w), d, w, $);
  }
  function D(d, g, w, $) {
    return _n(ka(g), d, w, $);
  }
  function G(d, g, w, $) {
    return _n(xa(g), d, w, $);
  }
  function U(d, g, w, $) {
    return _n(tc(g, d.length - w), d, w, $);
  }
  s.prototype.write = function(d, g, w, $) {
    if (g === void 0)
      $ = "utf8", w = this.length, g = 0;
    else if (w === void 0 && typeof g == "string")
      $ = g, w = this.length, g = 0;
    else if (isFinite(g))
      g = g >>> 0, isFinite(w) ? (w = w >>> 0, $ === void 0 && ($ = "utf8")) : ($ = w, w = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const N = this.length - g;
    if ((w === void 0 || w > N) && (w = N), d.length > 0 && (w < 0 || g < 0) || g > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    $ || ($ = "utf8");
    let H = !1;
    for (; ; )
      switch ($) {
        case "hex":
          return O(this, d, g, w);
        case "utf8":
        case "utf-8":
          return z(this, d, g, w);
        case "ascii":
        case "latin1":
        case "binary":
          return D(this, d, g, w);
        case "base64":
          return G(this, d, g, w);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return U(this, d, g, w);
        default:
          if (H) throw new TypeError("Unknown encoding: " + $);
          $ = ("" + $).toLowerCase(), H = !0;
      }
  }, s.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function V(d, g, w) {
    return g === 0 && w === d.length ? t.fromByteArray(d) : t.fromByteArray(d.slice(g, w));
  }
  function F(d, g, w) {
    w = Math.min(d.length, w);
    const $ = [];
    let N = g;
    for (; N < w; ) {
      const H = d[N];
      let Z = null, Te = H > 239 ? 4 : H > 223 ? 3 : H > 191 ? 2 : 1;
      if (N + Te <= w) {
        let ut, Be, Ie, Xe;
        switch (Te) {
          case 1:
            H < 128 && (Z = H);
            break;
          case 2:
            ut = d[N + 1], (ut & 192) === 128 && (Xe = (H & 31) << 6 | ut & 63, Xe > 127 && (Z = Xe));
            break;
          case 3:
            ut = d[N + 1], Be = d[N + 2], (ut & 192) === 128 && (Be & 192) === 128 && (Xe = (H & 15) << 12 | (ut & 63) << 6 | Be & 63, Xe > 2047 && (Xe < 55296 || Xe > 57343) && (Z = Xe));
            break;
          case 4:
            ut = d[N + 1], Be = d[N + 2], Ie = d[N + 3], (ut & 192) === 128 && (Be & 192) === 128 && (Ie & 192) === 128 && (Xe = (H & 15) << 18 | (ut & 63) << 12 | (Be & 63) << 6 | Ie & 63, Xe > 65535 && Xe < 1114112 && (Z = Xe));
        }
      }
      Z === null ? (Z = 65533, Te = 1) : Z > 65535 && (Z -= 65536, $.push(Z >>> 10 & 1023 | 55296), Z = 56320 | Z & 1023), $.push(Z), N += Te;
    }
    return R($);
  }
  const C = 4096;
  function R(d) {
    const g = d.length;
    if (g <= C)
      return String.fromCharCode.apply(String, d);
    let w = "", $ = 0;
    for (; $ < g; )
      w += String.fromCharCode.apply(
        String,
        d.slice($, $ += C)
      );
    return w;
  }
  function M(d, g, w) {
    let $ = "";
    w = Math.min(d.length, w);
    for (let N = g; N < w; ++N)
      $ += String.fromCharCode(d[N] & 127);
    return $;
  }
  function re(d, g, w) {
    let $ = "";
    w = Math.min(d.length, w);
    for (let N = g; N < w; ++N)
      $ += String.fromCharCode(d[N]);
    return $;
  }
  function W(d, g, w) {
    const $ = d.length;
    (!g || g < 0) && (g = 0), (!w || w < 0 || w > $) && (w = $);
    let N = "";
    for (let H = g; H < w; ++H)
      N += rc[d[H]];
    return N;
  }
  function ne(d, g, w) {
    const $ = d.slice(g, w);
    let N = "";
    for (let H = 0; H < $.length - 1; H += 2)
      N += String.fromCharCode($[H] + $[H + 1] * 256);
    return N;
  }
  s.prototype.slice = function(d, g) {
    const w = this.length;
    d = ~~d, g = g === void 0 ? w : ~~g, d < 0 ? (d += w, d < 0 && (d = 0)) : d > w && (d = w), g < 0 ? (g += w, g < 0 && (g = 0)) : g > w && (g = w), g < d && (g = d);
    const $ = this.subarray(d, g);
    return Object.setPrototypeOf($, s.prototype), $;
  };
  function oe(d, g, w) {
    if (d % 1 !== 0 || d < 0) throw new RangeError("offset is not uint");
    if (d + g > w) throw new RangeError("Trying to access beyond buffer length");
  }
  s.prototype.readUintLE = s.prototype.readUIntLE = function(d, g, w) {
    d = d >>> 0, g = g >>> 0, w || oe(d, g, this.length);
    let $ = this[d], N = 1, H = 0;
    for (; ++H < g && (N *= 256); )
      $ += this[d + H] * N;
    return $;
  }, s.prototype.readUintBE = s.prototype.readUIntBE = function(d, g, w) {
    d = d >>> 0, g = g >>> 0, w || oe(d, g, this.length);
    let $ = this[d + --g], N = 1;
    for (; g > 0 && (N *= 256); )
      $ += this[d + --g] * N;
    return $;
  }, s.prototype.readUint8 = s.prototype.readUInt8 = function(d, g) {
    return d = d >>> 0, g || oe(d, 1, this.length), this[d];
  }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(d, g) {
    return d = d >>> 0, g || oe(d, 2, this.length), this[d] | this[d + 1] << 8;
  }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(d, g) {
    return d = d >>> 0, g || oe(d, 2, this.length), this[d] << 8 | this[d + 1];
  }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(d, g) {
    return d = d >>> 0, g || oe(d, 4, this.length), (this[d] | this[d + 1] << 8 | this[d + 2] << 16) + this[d + 3] * 16777216;
  }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(d, g) {
    return d = d >>> 0, g || oe(d, 4, this.length), this[d] * 16777216 + (this[d + 1] << 16 | this[d + 2] << 8 | this[d + 3]);
  }, s.prototype.readBigUInt64LE = or(function(d) {
    d = d >>> 0, Re(d, "offset");
    const g = this[d], w = this[d + 7];
    (g === void 0 || w === void 0) && Tt(d, this.length - 8);
    const $ = g + this[++d] * 2 ** 8 + this[++d] * 2 ** 16 + this[++d] * 2 ** 24, N = this[++d] + this[++d] * 2 ** 8 + this[++d] * 2 ** 16 + w * 2 ** 24;
    return BigInt($) + (BigInt(N) << BigInt(32));
  }), s.prototype.readBigUInt64BE = or(function(d) {
    d = d >>> 0, Re(d, "offset");
    const g = this[d], w = this[d + 7];
    (g === void 0 || w === void 0) && Tt(d, this.length - 8);
    const $ = g * 2 ** 24 + this[++d] * 2 ** 16 + this[++d] * 2 ** 8 + this[++d], N = this[++d] * 2 ** 24 + this[++d] * 2 ** 16 + this[++d] * 2 ** 8 + w;
    return (BigInt($) << BigInt(32)) + BigInt(N);
  }), s.prototype.readIntLE = function(d, g, w) {
    d = d >>> 0, g = g >>> 0, w || oe(d, g, this.length);
    let $ = this[d], N = 1, H = 0;
    for (; ++H < g && (N *= 256); )
      $ += this[d + H] * N;
    return N *= 128, $ >= N && ($ -= Math.pow(2, 8 * g)), $;
  }, s.prototype.readIntBE = function(d, g, w) {
    d = d >>> 0, g = g >>> 0, w || oe(d, g, this.length);
    let $ = g, N = 1, H = this[d + --$];
    for (; $ > 0 && (N *= 256); )
      H += this[d + --$] * N;
    return N *= 128, H >= N && (H -= Math.pow(2, 8 * g)), H;
  }, s.prototype.readInt8 = function(d, g) {
    return d = d >>> 0, g || oe(d, 1, this.length), this[d] & 128 ? (255 - this[d] + 1) * -1 : this[d];
  }, s.prototype.readInt16LE = function(d, g) {
    d = d >>> 0, g || oe(d, 2, this.length);
    const w = this[d] | this[d + 1] << 8;
    return w & 32768 ? w | 4294901760 : w;
  }, s.prototype.readInt16BE = function(d, g) {
    d = d >>> 0, g || oe(d, 2, this.length);
    const w = this[d + 1] | this[d] << 8;
    return w & 32768 ? w | 4294901760 : w;
  }, s.prototype.readInt32LE = function(d, g) {
    return d = d >>> 0, g || oe(d, 4, this.length), this[d] | this[d + 1] << 8 | this[d + 2] << 16 | this[d + 3] << 24;
  }, s.prototype.readInt32BE = function(d, g) {
    return d = d >>> 0, g || oe(d, 4, this.length), this[d] << 24 | this[d + 1] << 16 | this[d + 2] << 8 | this[d + 3];
  }, s.prototype.readBigInt64LE = or(function(d) {
    d = d >>> 0, Re(d, "offset");
    const g = this[d], w = this[d + 7];
    (g === void 0 || w === void 0) && Tt(d, this.length - 8);
    const $ = this[d + 4] + this[d + 5] * 2 ** 8 + this[d + 6] * 2 ** 16 + (w << 24);
    return (BigInt($) << BigInt(32)) + BigInt(g + this[++d] * 2 ** 8 + this[++d] * 2 ** 16 + this[++d] * 2 ** 24);
  }), s.prototype.readBigInt64BE = or(function(d) {
    d = d >>> 0, Re(d, "offset");
    const g = this[d], w = this[d + 7];
    (g === void 0 || w === void 0) && Tt(d, this.length - 8);
    const $ = (g << 24) + // Overflow
    this[++d] * 2 ** 16 + this[++d] * 2 ** 8 + this[++d];
    return (BigInt($) << BigInt(32)) + BigInt(this[++d] * 2 ** 24 + this[++d] * 2 ** 16 + this[++d] * 2 ** 8 + w);
  }), s.prototype.readFloatLE = function(d, g) {
    return d = d >>> 0, g || oe(d, 4, this.length), r.read(this, d, !0, 23, 4);
  }, s.prototype.readFloatBE = function(d, g) {
    return d = d >>> 0, g || oe(d, 4, this.length), r.read(this, d, !1, 23, 4);
  }, s.prototype.readDoubleLE = function(d, g) {
    return d = d >>> 0, g || oe(d, 8, this.length), r.read(this, d, !0, 52, 8);
  }, s.prototype.readDoubleBE = function(d, g) {
    return d = d >>> 0, g || oe(d, 8, this.length), r.read(this, d, !1, 52, 8);
  };
  function se(d, g, w, $, N, H) {
    if (!s.isBuffer(d)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (g > N || g < H) throw new RangeError('"value" argument is out of bounds');
    if (w + $ > d.length) throw new RangeError("Index out of range");
  }
  s.prototype.writeUintLE = s.prototype.writeUIntLE = function(d, g, w, $) {
    if (d = +d, g = g >>> 0, w = w >>> 0, !$) {
      const Z = Math.pow(2, 8 * w) - 1;
      se(this, d, g, w, Z, 0);
    }
    let N = 1, H = 0;
    for (this[g] = d & 255; ++H < w && (N *= 256); )
      this[g + H] = d / N & 255;
    return g + w;
  }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(d, g, w, $) {
    if (d = +d, g = g >>> 0, w = w >>> 0, !$) {
      const Z = Math.pow(2, 8 * w) - 1;
      se(this, d, g, w, Z, 0);
    }
    let N = w - 1, H = 1;
    for (this[g + N] = d & 255; --N >= 0 && (H *= 256); )
      this[g + N] = d / H & 255;
    return g + w;
  }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 1, 255, 0), this[g] = d & 255, g + 1;
  }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 2, 65535, 0), this[g] = d & 255, this[g + 1] = d >>> 8, g + 2;
  }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 2, 65535, 0), this[g] = d >>> 8, this[g + 1] = d & 255, g + 2;
  }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 4, 4294967295, 0), this[g + 3] = d >>> 24, this[g + 2] = d >>> 16, this[g + 1] = d >>> 8, this[g] = d & 255, g + 4;
  }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 4, 4294967295, 0), this[g] = d >>> 24, this[g + 1] = d >>> 16, this[g + 2] = d >>> 8, this[g + 3] = d & 255, g + 4;
  };
  function K(d, g, w, $, N) {
    We(g, $, N, d, w, 7);
    let H = Number(g & BigInt(4294967295));
    d[w++] = H, H = H >> 8, d[w++] = H, H = H >> 8, d[w++] = H, H = H >> 8, d[w++] = H;
    let Z = Number(g >> BigInt(32) & BigInt(4294967295));
    return d[w++] = Z, Z = Z >> 8, d[w++] = Z, Z = Z >> 8, d[w++] = Z, Z = Z >> 8, d[w++] = Z, w;
  }
  function he(d, g, w, $, N) {
    We(g, $, N, d, w, 7);
    let H = Number(g & BigInt(4294967295));
    d[w + 7] = H, H = H >> 8, d[w + 6] = H, H = H >> 8, d[w + 5] = H, H = H >> 8, d[w + 4] = H;
    let Z = Number(g >> BigInt(32) & BigInt(4294967295));
    return d[w + 3] = Z, Z = Z >> 8, d[w + 2] = Z, Z = Z >> 8, d[w + 1] = Z, Z = Z >> 8, d[w] = Z, w + 8;
  }
  s.prototype.writeBigUInt64LE = or(function(d, g = 0) {
    return K(this, d, g, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeBigUInt64BE = or(function(d, g = 0) {
    return he(this, d, g, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeIntLE = function(d, g, w, $) {
    if (d = +d, g = g >>> 0, !$) {
      const Te = Math.pow(2, 8 * w - 1);
      se(this, d, g, w, Te - 1, -Te);
    }
    let N = 0, H = 1, Z = 0;
    for (this[g] = d & 255; ++N < w && (H *= 256); )
      d < 0 && Z === 0 && this[g + N - 1] !== 0 && (Z = 1), this[g + N] = (d / H >> 0) - Z & 255;
    return g + w;
  }, s.prototype.writeIntBE = function(d, g, w, $) {
    if (d = +d, g = g >>> 0, !$) {
      const Te = Math.pow(2, 8 * w - 1);
      se(this, d, g, w, Te - 1, -Te);
    }
    let N = w - 1, H = 1, Z = 0;
    for (this[g + N] = d & 255; --N >= 0 && (H *= 256); )
      d < 0 && Z === 0 && this[g + N + 1] !== 0 && (Z = 1), this[g + N] = (d / H >> 0) - Z & 255;
    return g + w;
  }, s.prototype.writeInt8 = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 1, 127, -128), d < 0 && (d = 255 + d + 1), this[g] = d & 255, g + 1;
  }, s.prototype.writeInt16LE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 2, 32767, -32768), this[g] = d & 255, this[g + 1] = d >>> 8, g + 2;
  }, s.prototype.writeInt16BE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 2, 32767, -32768), this[g] = d >>> 8, this[g + 1] = d & 255, g + 2;
  }, s.prototype.writeInt32LE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 4, 2147483647, -2147483648), this[g] = d & 255, this[g + 1] = d >>> 8, this[g + 2] = d >>> 16, this[g + 3] = d >>> 24, g + 4;
  }, s.prototype.writeInt32BE = function(d, g, w) {
    return d = +d, g = g >>> 0, w || se(this, d, g, 4, 2147483647, -2147483648), d < 0 && (d = 4294967295 + d + 1), this[g] = d >>> 24, this[g + 1] = d >>> 16, this[g + 2] = d >>> 8, this[g + 3] = d & 255, g + 4;
  }, s.prototype.writeBigInt64LE = or(function(d, g = 0) {
    return K(this, d, g, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), s.prototype.writeBigInt64BE = or(function(d, g = 0) {
    return he(this, d, g, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Ae(d, g, w, $, N, H) {
    if (w + $ > d.length) throw new RangeError("Index out of range");
    if (w < 0) throw new RangeError("Index out of range");
  }
  function ye(d, g, w, $, N) {
    return g = +g, w = w >>> 0, N || Ae(d, g, w, 4), r.write(d, g, w, $, 23, 4), w + 4;
  }
  s.prototype.writeFloatLE = function(d, g, w) {
    return ye(this, d, g, !0, w);
  }, s.prototype.writeFloatBE = function(d, g, w) {
    return ye(this, d, g, !1, w);
  };
  function Et(d, g, w, $, N) {
    return g = +g, w = w >>> 0, N || Ae(d, g, w, 8), r.write(d, g, w, $, 52, 8), w + 8;
  }
  s.prototype.writeDoubleLE = function(d, g, w) {
    return Et(this, d, g, !0, w);
  }, s.prototype.writeDoubleBE = function(d, g, w) {
    return Et(this, d, g, !1, w);
  }, s.prototype.copy = function(d, g, w, $) {
    if (!s.isBuffer(d)) throw new TypeError("argument should be a Buffer");
    if (w || (w = 0), !$ && $ !== 0 && ($ = this.length), g >= d.length && (g = d.length), g || (g = 0), $ > 0 && $ < w && ($ = w), $ === w || d.length === 0 || this.length === 0) return 0;
    if (g < 0)
      throw new RangeError("targetStart out of bounds");
    if (w < 0 || w >= this.length) throw new RangeError("Index out of range");
    if ($ < 0) throw new RangeError("sourceEnd out of bounds");
    $ > this.length && ($ = this.length), d.length - g < $ - w && ($ = d.length - g + w);
    const N = $ - w;
    return this === d && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(g, w, $) : Uint8Array.prototype.set.call(
      d,
      this.subarray(w, $),
      g
    ), N;
  }, s.prototype.fill = function(d, g, w, $) {
    if (typeof d == "string") {
      if (typeof g == "string" ? ($ = g, g = 0, w = this.length) : typeof w == "string" && ($ = w, w = this.length), $ !== void 0 && typeof $ != "string")
        throw new TypeError("encoding must be a string");
      if (typeof $ == "string" && !s.isEncoding($))
        throw new TypeError("Unknown encoding: " + $);
      if (d.length === 1) {
        const H = d.charCodeAt(0);
        ($ === "utf8" && H < 128 || $ === "latin1") && (d = H);
      }
    } else typeof d == "number" ? d = d & 255 : typeof d == "boolean" && (d = Number(d));
    if (g < 0 || this.length < g || this.length < w)
      throw new RangeError("Out of range index");
    if (w <= g)
      return this;
    g = g >>> 0, w = w === void 0 ? this.length : w >>> 0, d || (d = 0);
    let N;
    if (typeof d == "number")
      for (N = g; N < w; ++N)
        this[N] = d;
    else {
      const H = s.isBuffer(d) ? d : s.from(d, $), Z = H.length;
      if (Z === 0)
        throw new TypeError('The value "' + d + '" is invalid for argument "value"');
      for (N = 0; N < w - g; ++N)
        this[N + g] = H[N % Z];
    }
    return this;
  };
  const Ge = {};
  function be(d, g, w) {
    Ge[d] = class extends w {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: g.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${d}]`, this.stack, delete this.name;
      }
      get code() {
        return d;
      }
      set code($) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: $,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${d}]: ${this.message}`;
      }
    };
  }
  be(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(d) {
      return d ? `${d} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), be(
    "ERR_INVALID_ARG_TYPE",
    function(d, g) {
      return `The "${d}" argument must be of type number. Received type ${typeof g}`;
    },
    TypeError
  ), be(
    "ERR_OUT_OF_RANGE",
    function(d, g, w) {
      let $ = `The value of "${d}" is out of range.`, N = w;
      return Number.isInteger(w) && Math.abs(w) > 2 ** 32 ? N = st(String(w)) : typeof w == "bigint" && (N = String(w), (w > BigInt(2) ** BigInt(32) || w < -(BigInt(2) ** BigInt(32))) && (N = st(N)), N += "n"), $ += ` It must be ${g}. Received ${N}`, $;
    },
    RangeError
  );
  function st(d) {
    let g = "", w = d.length;
    const $ = d[0] === "-" ? 1 : 0;
    for (; w >= $ + 4; w -= 3)
      g = `_${d.slice(w - 3, w)}${g}`;
    return `${d.slice(0, w)}${g}`;
  }
  function Ze(d, g, w) {
    Re(g, "offset"), (d[g] === void 0 || d[g + w] === void 0) && Tt(g, d.length - (w + 1));
  }
  function We(d, g, w, $, N, H) {
    if (d > w || d < g) {
      const Z = typeof g == "bigint" ? "n" : "";
      let Te;
      throw g === 0 || g === BigInt(0) ? Te = `>= 0${Z} and < 2${Z} ** ${(H + 1) * 8}${Z}` : Te = `>= -(2${Z} ** ${(H + 1) * 8 - 1}${Z}) and < 2 ** ${(H + 1) * 8 - 1}${Z}`, new Ge.ERR_OUT_OF_RANGE("value", Te, d);
    }
    Ze($, N, H);
  }
  function Re(d, g) {
    if (typeof d != "number")
      throw new Ge.ERR_INVALID_ARG_TYPE(g, "number", d);
  }
  function Tt(d, g, w) {
    throw Math.floor(d) !== d ? (Re(d, w), new Ge.ERR_OUT_OF_RANGE("offset", "an integer", d)) : g < 0 ? new Ge.ERR_BUFFER_OUT_OF_BOUNDS() : new Ge.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${g}`,
      d
    );
  }
  const xr = /[^+/0-9A-Za-z-_]/g;
  function Wt(d) {
    if (d = d.split("=")[0], d = d.trim().replace(xr, ""), d.length < 2) return "";
    for (; d.length % 4 !== 0; )
      d = d + "=";
    return d;
  }
  function Sn(d, g) {
    g = g || 1 / 0;
    let w;
    const $ = d.length;
    let N = null;
    const H = [];
    for (let Z = 0; Z < $; ++Z) {
      if (w = d.charCodeAt(Z), w > 55295 && w < 57344) {
        if (!N) {
          if (w > 56319) {
            (g -= 3) > -1 && H.push(239, 191, 189);
            continue;
          } else if (Z + 1 === $) {
            (g -= 3) > -1 && H.push(239, 191, 189);
            continue;
          }
          N = w;
          continue;
        }
        if (w < 56320) {
          (g -= 3) > -1 && H.push(239, 191, 189), N = w;
          continue;
        }
        w = (N - 55296 << 10 | w - 56320) + 65536;
      } else N && (g -= 3) > -1 && H.push(239, 191, 189);
      if (N = null, w < 128) {
        if ((g -= 1) < 0) break;
        H.push(w);
      } else if (w < 2048) {
        if ((g -= 2) < 0) break;
        H.push(
          w >> 6 | 192,
          w & 63 | 128
        );
      } else if (w < 65536) {
        if ((g -= 3) < 0) break;
        H.push(
          w >> 12 | 224,
          w >> 6 & 63 | 128,
          w & 63 | 128
        );
      } else if (w < 1114112) {
        if ((g -= 4) < 0) break;
        H.push(
          w >> 18 | 240,
          w >> 12 & 63 | 128,
          w >> 6 & 63 | 128,
          w & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return H;
  }
  function ka(d) {
    const g = [];
    for (let w = 0; w < d.length; ++w)
      g.push(d.charCodeAt(w) & 255);
    return g;
  }
  function tc(d, g) {
    let w, $, N;
    const H = [];
    for (let Z = 0; Z < d.length && !((g -= 2) < 0); ++Z)
      w = d.charCodeAt(Z), $ = w >> 8, N = w % 256, H.push(N), H.push($);
    return H;
  }
  function xa(d) {
    return t.toByteArray(Wt(d));
  }
  function _n(d, g, w, $) {
    let N;
    for (N = 0; N < $ && !(N + w >= g.length || N >= d.length); ++N)
      g[N + w] = d[N];
    return N;
  }
  function Xt(d, g) {
    return d instanceof g || d != null && d.constructor != null && d.constructor.name != null && d.constructor.name === g.name;
  }
  function lo(d) {
    return d !== d;
  }
  const rc = function() {
    const d = "0123456789abcdef", g = new Array(256);
    for (let w = 0; w < 16; ++w) {
      const $ = w * 16;
      for (let N = 0; N < 16; ++N)
        g[$ + N] = d[w] + d[N];
    }
    return g;
  }();
  function or(d) {
    return typeof BigInt > "u" ? Aa : d;
  }
  function Aa() {
    throw new Error("BigInt not supported");
  }
})(swe);
var uwe = "accountChange";
Ce({
  type: vr(uwe)
});
var cwe = "networkChange";
Ce({
  type: vr(cwe)
});
var lwe = "disconnect";
Ce({
  type: vr(lwe)
});
async function Ub(e) {
  var t;
  const r = await (e == null ? void 0 : e()) || ((t = window.XverseProviders) == null ? void 0 : t.BitcoinProvider) || window.BitcoinProvider;
  if (!r)
    throw new Error("No Bitcoin wallet installed");
  return r;
}
var XN = /* @__PURE__ */ ((e) => (e.Mainnet = "Mainnet", e.Testnet = "Testnet", e.Signet = "Signet", e))(XN || {}), l6 = Oi(Pb([He(), sa(), _l()])), co = Ce({
  jsonrpc: vr("2.0"),
  method: He(),
  params: Oi(
    Pb([
      Pi(Ob()),
      RN({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      _l()
    ])
  ),
  id: l6
}), hh = /* @__PURE__ */ ((e) => (e[e.PARSE_ERROR = -32700] = "PARSE_ERROR", e[e.INVALID_REQUEST = -32600] = "INVALID_REQUEST", e[e.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", e[e.INVALID_PARAMS = -32602] = "INVALID_PARAMS", e[e.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", e[e.USER_REJECTION = -32e3] = "USER_REJECTION", e[e.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED", e[e.ACCESS_DENIED = -32002] = "ACCESS_DENIED", e))(hh || {}), YN = Ce({
  jsonrpc: vr("2.0"),
  result: i6(Ob()),
  id: l6
}), JN = Ce({
  jsonrpc: vr("2.0"),
  error: i6(Ob()),
  id: l6
});
Pb([
  YN,
  JN
]);
var Rb = /* @__PURE__ */ ((e) => (e.Ordinals = "ordinals", e.Payment = "payment", e.Stacks = "stacks", e))(Rb || {}), QN = /* @__PURE__ */ ((e) => (e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr", e.stacks = "stacks", e))(QN || {}), fwe = Ce({
  address: He(),
  publicKey: He(),
  purpose: rl(Rb),
  addressType: rl(QN)
}), eU = async (e) => {
  var t, r;
  const n = await Ub(e.getProvider), { purposes: o } = e.payload;
  if (!o)
    throw new Error("Address purposes are required");
  try {
    const a = No.createUnsecuredToken(e.payload), i = await n.connect(a);
    (t = e.onFinish) == null || t.call(e, i);
  } catch (a) {
    console.error("[Connect] Error during address request", a), (r = e.onCancel) == null || r.call(e);
  }
}, dwe = "stx_getAddresses", hwe = Il(
  Ce({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: Oi(He())
  })
);
Ce({
  ...co.entries,
  ...Ce({
    method: vr(dwe),
    params: hwe,
    id: He()
  }).entries
});
var pwe = "stx_signTransaction", gwe = Ce({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: He(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: Oi(He()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: Oi(UN())
});
Ce({
  ...co.entries,
  ...Ce({
    method: vr(pwe),
    params: gwe,
    id: He()
  }).entries
});
var mwe = ["software", "ledger"], ywe = zN(mwe), bwe = "getInfo", wwe = Il(_l());
Ce({
  /**
   * Version of the wallet.
   */
  version: He(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: Oi(Pi(He())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: Pi(He())
});
Ce({
  ...co.entries,
  ...Ce({
    method: vr(bwe),
    params: wwe,
    id: He()
  }).entries
});
var vwe = "getAddresses", Ewe = Ce({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: Pi(rl(Rb)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: Oi(He())
});
Ce({
  ...co.entries,
  ...Ce({
    method: vr(vwe),
    params: Ewe,
    id: He()
  }).entries
});
var kwe = "signMessage", ol = /* @__PURE__ */ ((e) => (e.ECDSA = "ECDSA", e.BIP322 = "BIP322", e))(ol || {}), xwe = Ce({
  /**
   * The address used for signing.
   **/
  address: He(),
  /**
   * The message to sign.
   **/
  message: He(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: Oi(rl(ol))
});
Ce({
  /**
   * The signature of the message.
   */
  signature: He(),
  /**
   * hash of the message.
   */
  messageHash: He(),
  /**
   * The address used for signing.
   */
  address: He(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: rl(ol)
});
Ce({
  ...co.entries,
  ...Ce({
    method: vr(kwe),
    params: xwe,
    id: He()
  }).entries
});
var Awe = "getAccounts", Swe = Ce({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: Pi(rl(Rb)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: Oi(He())
});
Pi(
  Ce({
    ...fwe.entries,
    ...Ce({
      walletType: ywe
    }).entries
  })
);
Ce({
  ...co.entries,
  ...Ce({
    method: vr(Awe),
    params: Swe,
    id: He()
  }).entries
});
var _we = "getBalance";
Il(_l());
Ce({
  ...co.entries,
  ...Ce({
    method: vr(_we),
    id: He()
  }).entries
});
var Iwe = "wallet_requestPermissions", Twe = a6();
vr(!0);
Ce({
  ...co.entries,
  ...Ce({
    method: vr(Iwe),
    params: Twe,
    id: He()
  }).entries
});
var Pwe = "wallet_renouncePermissions", Owe = a6();
vr(!0);
Ce({
  ...co.entries,
  ...Ce({
    method: vr(Pwe),
    params: Owe,
    id: He()
  }).entries
});
var $we = "wallet_getWalletType";
Il(_l());
Ce({
  ...co.entries,
  ...Ce({
    method: vr($we),
    id: He()
  }).entries
});
var Cwe = "runes_getBalance", Bwe = Il(_l());
Ce({
  balances: Pi(
    Ce({
      runeName: He(),
      amount: He(),
      divisibility: sa(),
      symbol: He(),
      inscriptionId: Il(He())
    })
  )
});
Ce({
  ...co.entries,
  ...Ce({
    method: vr(Cwe),
    params: Bwe,
    id: He()
  }).entries
});
var Nwe = "runes_transfer", Uwe = Ce({
  recipients: Pi(
    Ce({
      runeName: He(),
      amount: He(),
      address: He()
    })
  )
});
Ce({
  ...co.entries,
  ...Ce({
    method: vr(Nwe),
    params: Uwe,
    id: He()
  }).entries
});
var Rwe = "ord_getInscriptions", zwe = Ce({
  offset: sa(),
  limit: sa()
});
Ce({
  total: sa(),
  limit: sa(),
  offset: sa(),
  inscriptions: Pi(
    Ce({
      inscriptionId: He(),
      inscriptionNumber: He(),
      address: He(),
      collectionName: Oi(He()),
      postage: He(),
      contentLength: He(),
      contentType: He(),
      timestamp: sa(),
      offset: sa(),
      genesisTransaction: He(),
      output: He()
    })
  )
});
Ce({
  ...co.entries,
  ...Ce({
    method: vr(Rwe),
    params: zwe,
    id: He()
  }).entries
});
var jwe = "ord_sendInscriptions", Lwe = Ce({
  transfers: Pi(
    Ce({
      address: He(),
      inscriptionId: He()
    })
  )
});
Ce({
  ...co.entries,
  ...Ce({
    method: vr(jwe),
    params: Lwe,
    id: He()
  }).entries
});
var h1 = async (e, t, r) => {
  var n;
  let o = ((n = window.XverseProviders) == null ? void 0 : n.BitcoinProvider) || window.BitcoinProvider;
  if (!o)
    throw new Error("no wallet provider was found");
  if (!e)
    throw new Error("A wallet method is required");
  const a = await o.request(e, t);
  return vk(JN, a) ? {
    status: "error",
    error: a.error
  } : vk(YN, a) ? {
    status: "success",
    result: a.result
  } : {
    status: "error",
    error: {
      code: -32603,
      message: "Received unknown response from provider.",
      data: a
    }
  };
}, Hwe = async (e) => {
  var t, r;
  const n = await Ub(e.getProvider), { address: o, message: a } = e.payload;
  if (!o)
    throw new Error("An address is required to sign a message");
  if (!a)
    throw new Error("A message to be signed is required");
  try {
    const i = No.createUnsecuredToken(e.payload), s = await n.signMessage(i);
    (t = e.onFinish) == null || t.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during sign message request", i), (r = e.onCancel) == null || r.call(e);
  }
}, Fwe = (e) => e.map((t) => {
  const { address: r, amountSats: n } = t;
  return {
    address: r,
    amountSats: n.toString()
  };
}), Dwe = async (e) => {
  var t, r;
  const n = await Ub(e.getProvider), { recipients: o, senderAddress: a, network: i, message: s } = e.payload;
  if (!o || o.length === 0)
    throw new Error("At least one recipient is required");
  if (o.some(
    (u) => typeof u.address != "string" || typeof u.amountSats != "bigint"
  ))
    throw new Error("Incorrect recipient format");
  if (!a)
    throw new Error("The sender address is required");
  try {
    const u = Fwe(o), l = {
      network: i,
      senderAddress: a,
      message: s,
      recipients: u
    }, c = No.createUnsecuredToken(l), f = await n.sendBtcTransaction(c);
    (t = e.onFinish) == null || t.call(e, f);
  } catch (u) {
    console.error("[Connect] Error during send BTC transaction request", u), (r = e.onCancel) == null || r.call(e);
  }
}, Mwe = async (e) => {
  var t, r;
  const n = await Ub(e.getProvider), { psbtBase64: o, inputsToSign: a } = e.payload;
  if (!o)
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!a)
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const i = No.createUnsecuredToken(e.payload), s = await n.signTransaction(i);
    (t = e.onFinish) == null || t.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during sign transaction request", i), (r = e.onCancel) == null || r.call(e);
  }
};
let $k = (e) => e, eh = {}, wu = { addEventListener() {
}, removeEventListener() {
} };
function Kwe() {
  try {
    return typeof localStorage < "u";
  } catch {
    return !1;
  }
}
Kwe() && (eh = localStorage);
let qwe = {
  addEventListener(e, t, r) {
    window.addEventListener("storage", t), window.addEventListener("pageshow", r);
  },
  removeEventListener(e, t, r) {
    window.removeEventListener("storage", t), window.removeEventListener("pageshow", r);
  }
};
typeof window < "u" && (wu = qwe);
function Tl(e, t = {}, r = {}) {
  let n = r.encode || $k, o = r.decode || $k, a = aP(), i = a.setKey, s = (f, h) => {
    typeof h > "u" ? (r.listen !== !1 && wu.perKey && wu.removeEventListener(e + f, l, c), delete eh[e + f]) : (r.listen !== !1 && wu.perKey && !(f in a.value) && wu.addEventListener(e + f, l, c), eh[e + f] = n(h));
  };
  a.setKey = (f, h) => {
    s(f, h), i(f, h);
  };
  let u = a.set;
  a.set = function(f) {
    for (let h in f)
      s(h, f[h]);
    for (let h in a.value)
      h in f || s(h, void 0);
    u(f);
  };
  function l(f) {
    f.key ? f.key.startsWith(e) && (f.newValue === null ? i(f.key.slice(e.length), void 0) : i(f.key.slice(e.length), o(f.newValue))) : u({});
  }
  function c() {
    let f = { ...t };
    for (let h in eh)
      h.startsWith(e) && (f[h.slice(e.length)] = o(eh[h]));
    for (let h in f)
      a.setKey(h, f[h]);
  }
  return Ure(a, () => {
    if (c(), r.listen !== !1)
      return wu.addEventListener(e, l, c), () => {
        wu.removeEventListener(e, l, c);
        for (let f in a.value)
          wu.removeEventListener(e + f, l, c);
      };
  }), a;
}
const Vwe = "XVERSE_CONNECTED_WALLET_STATE";
class Gwe extends zi {
  constructor() {
    super(...arguments), xe(this, "observer"), xe(this, "$valueStore", Tl(
      Vwe,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), xe(this, "removeSubscriber");
  }
  get library() {
    return window == null ? void 0 : window.BitcoinProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of ec)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    Sl(Au, t, n, this.$valueStore);
  }
  initialize() {
    Jo(this.$store, ["provider"], (t) => {
      t.provider !== Au ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    }), typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t, r;
      (t = window == null ? void 0 : window.XverseProviders) != null && t.BitcoinProvider && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Au]: !0
      }), (r = this.observer) == null || r.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 }));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r)
        if (r.startsWith("tb1") && Ed(this.network))
          this.disconnect();
        else {
          this.restorePersistedValues(), fs(n, this.network).then((a) => {
            this.$store.setKey("balance", a);
          });
          return;
        }
      let o = B1(this.network || Ut);
      await eU({
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Connecting with lasereyes",
          network: {
            type: o
          }
        },
        onFinish: (a) => {
          const i = W4(a.addresses), s = X4(a.addresses);
          if (!i || !s)
            throw new Error("Could not find the addresses");
          i && s && (this.$store.setKey("address", i.address), this.$store.setKey("paymentAddress", s.address), this.$store.setKey("accounts", [
            i.address,
            s.address
          ])), this.$store.setKey(
            "publicKey",
            String(a.addresses[0].publicKey)
          ), this.$store.setKey(
            "paymentPublicKey",
            String(a.addresses[1].publicKey)
          );
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${Au} wallet`);
        },
        onError: (a) => {
          throw new Error(`Can't lasereyes to ${Au} wallet`);
        }
      });
    } catch (o) {
      throw o;
    }
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [Cr, hn, En, Xn].includes(this.network) ? this.network : Ut;
  }
  async sendBTC(t, r) {
    const n = await h1("sendTransfer", {
      recipients: [
        {
          address: t,
          amount: r
        }
      ]
    });
    if (n.status === "success")
      return n.result.txid;
    throw n.error.code === hh.USER_REJECTION ? new Error("User rejected the request") : new Error("Error sending BTC: " + n.error.message);
  }
  async signMessage(t, { toSignAddress: r, protocol: n }) {
    const o = r || this.$store.get().paymentAddress, a = await h1("signMessage", {
      address: o,
      message: t,
      protocol: n === s0 ? ol.ECDSA : ol.BIP322
    });
    if (a.status === "success")
      return a.result.signature;
    throw a.error.code === hh.USER_REJECTION ? new Error("User rejected the request") : new Error("Error signing message: " + a.error.message);
  }
  async signPsbt(t, r, n, o, a) {
    try {
      const i = Zt.fromBase64(String(n), {
        network: kr(this.network)
      }), s = this.$store.get().address, u = this.$store.get().paymentAddress, l = i.data.inputs;
      let c = {};
      const f = {
        [s]: []
      }, h = {
        [u]: []
      };
      let p = 0;
      for await (let E of l) {
        if (E.witnessUtxo === void 0)
          h[u].push(Number(p));
        else {
          const { script: A } = E.witnessUtxo, S = Vp(
            A,
            kr(this.network)
          );
          S === u ? h[u].push(Number(p)) : S === s && f[s].push(Number(p));
        }
        p++;
      }
      f[s].length > 0 && (c = { ...c, ...f }), h[u].length > 0 && (c = { ...c, ...h });
      let y, m, b, v;
      const k = await h1("signPsbt", {
        psbt: n,
        broadcast: !!a,
        signInputs: c
      });
      if (k.status === "success")
        v = Zt.fromBase64(k.result.psbt, {
          network: kr(this.network)
        }), y = k.result.txid;
      else
        throw k.error.code === hh.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
      if (!v)
        throw new Error("Error signing psbt");
      return o && !y ? (v.finalizeAllInputs(), m = v.toHex(), b = v.toBase64()) : (m = v.toHex(), b = v.toBase64()), {
        signedPsbtHex: m,
        signedPsbtBase64: b,
        txId: y
      };
    } catch (i) {
      throw console.error(i), i;
    }
  }
  async getInscriptions(t, r) {
    const n = await h1("ord_getInscriptions", {
      offset: t || 0,
      limit: r || 10
    });
    if (n.status === "success")
      return console.log(n.result), n.result.inscriptions;
    throw console.error(n.error), new Error("Error getting inscriptions");
  }
}
class Zwe extends zi {
  constructor() {
    super(...arguments), xe(this, "observer");
  }
  get library() {
    return window.wizz;
  }
  get network() {
    return this.$network.get();
  }
  handleNetworkChanged(t) {
    this.parent.connect(xc);
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && this.$store.setKey("accounts", t);
  }
  initialize() {
    Jo(this.$store, ["provider"], (t) => {
      t.provider === xc ? this.addLibraryListeners() : this.removeLibraryListeners();
    }), typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [xc]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 }));
  }
  removeLibraryListeners() {
    var t, r;
    (t = this.library) == null || t.removeListener(
      "networkChanged",
      this.handleNetworkChanged.bind(this)
    ), (r = this.library) == null || r.removeListener(
      "accountsChanged",
      this.handleAccountsChanged.bind(this)
    );
  }
  addLibraryListeners() {
    var t, r;
    (t = this.library) == null || t.on("networkChanged", this.handleNetworkChanged.bind(this)), (r = this.library) == null || r.on("accountsChanged", this.handleAccountsChanged.bind(this));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeLibraryListeners();
  }
  async connect() {
    if (!this.library) throw x2e;
    const t = await this.library.requestAccounts();
    if (!t) throw new Error("No accounts found");
    const r = await this.library.getPublicKey();
    if (!r) throw new Error("No public key found");
    this.$store.setKey("accounts", t), this.$store.setKey("address", t[0]), this.$store.setKey("paymentAddress", t[0]), this.$store.setKey("publicKey", r), this.$store.setKey("paymentPublicKey", r), this.$store.setKey("provider", xc), await this.getNetwork().then((n) => {
      var o;
      n && ((o = this.config) == null ? void 0 : o.network) !== n && this.parent.switchNetwork(n);
    }), this.$store.setKey("connected", !0);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async getNetwork() {
    var t;
    const r = await ((t = this.library) == null ? void 0 : t.getNetwork());
    return r ? D9(r) : void 0;
  }
  async switchNetwork(t) {
    var r;
    if (t === Xn || t === xl)
      return await this.library.switchNetwork(lB);
    const n = D9(t);
    await ((r = this.library) == null ? void 0 : r.switchNetwork(n)), this.$network.set(t), await this.parent.getBalance();
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async sendBTC(t, r) {
    var n;
    const o = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
    if (o)
      return o;
    throw new Error("Error sending BTC");
  }
  async signMessage(t, r) {
    var n;
    const o = (r == null ? void 0 : r.protocol) === G4 ? vb : r == null ? void 0 : r.protocol;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t, o));
  }
  async signPsbt(t, r, n, o, a) {
    var i;
    const s = await ((i = this.library) == null ? void 0 : i.signPsbt(r, {
      autoFinalized: o,
      broadcast: !1
    })), u = Zt.fromHex(s);
    let l;
    return o && a && (l = await this.pushPsbt(s)), {
      signedPsbtHex: u.toHex(),
      signedPsbtBase64: u.toBase64(),
      txId: l
    };
  }
}
const Wwe = "OYL_CONNECTED_WALLET_STATE";
class Xwe extends zi {
  constructor() {
    super(...arguments), xe(this, "observer"), xe(this, "$valueStore", Tl(
      Wwe,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), xe(this, "removeSubscriber");
  }
  get library() {
    return window.oyl;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of ec)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    Sl(sf, t, n, this.$valueStore);
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      window != null && window.oyl && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [sf]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Jo(this.$store, ["provider"], (t) => {
      t.provider !== sf ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    if (r)
      if (r.startsWith("tb1") && Ed(this.network))
        this.disconnect();
      else {
        this.restorePersistedValues(), fs(n, this.network).then((i) => {
          this.$store.setKey("balance", i);
        });
        return;
      }
    if (!this.library) throw new Error("Oyl isn't installed");
    if (J4(this.network))
      throw new Error(`${this.network} is not supported by Oyl`);
    const { nativeSegwit: o, taproot: a } = await this.library.getAddresses();
    if (!o || !a) throw new Error("No accounts found");
    this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", a.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey);
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    const { psbtHex: n } = await Y4(
      this.$store.get().address,
      this.$store.get().paymentAddress,
      t,
      r,
      this.$store.get().paymentPublicKey,
      this.network,
      7
    ), o = await this.signPsbt("", n, "", !0, !0);
    if (!o) throw new Error("Error sending BTC");
    return o.txId;
  }
  async signMessage(t, r) {
    const n = (r == null ? void 0 : r.toSignAddress) || this.$store.get().paymentAddress;
    return (await this.library.signMessage({
      address: n,
      message: t,
      protocol: r == null ? void 0 : r.protocol
    })).signature;
  }
  async signPsbt(t, r, n, o, a) {
    const { psbt: i, txid: s } = await this.library.signPsbt({
      psbt: r,
      finalize: o,
      broadcast: a
    }), u = Zt.fromHex(i);
    return {
      signedPsbtHex: u.toHex(),
      signedPsbtBase64: u.toBase64(),
      txId: s
    };
  }
  async pushPsbt(t) {
    return (await this.library.pushPsbt({ psbt: t })).txid;
  }
  async getPublicKey() {
    const { nativeSegwit: t, taproot: r } = await this.library.getAddresses();
    if (!t || !r) throw new Error("No accounts found");
    return this.$store.setKey("publicKey", r.publicKey), this.$store.setKey("paymentPublicKey", t.publicKey), r.publicKey;
  }
  async getBalance() {
    const { total: t } = await this.library.getBalance();
    return this.$store.setKey("balance", t), t;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async requestAccounts() {
    return [this.$store.get().address, this.$store.get().paymentAddress];
  }
  async switchNetwork() {
    throw P8;
  }
}
const Ywe = "LEATHER_CONNECTED_WALLET_STATE";
class Jwe extends zi {
  constructor() {
    super(...arguments), xe(this, "observer"), xe(this, "$valueStore", Tl(
      Ywe,
      {
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }
    )), xe(this, "removeSubscriber");
  }
  get library() {
    return window.LeatherProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of ec)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    Sl(
      uf,
      t,
      n,
      this.$valueStore
    );
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      window != null && window.LeatherProvider && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [uf]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Jo(this.$store, ["provider"], (t) => {
      t.provider !== uf ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    var r;
    const { address: n, paymentAddress: o } = this.$valueStore.get();
    if (n)
      if (n.startsWith("tb1") && Ed(this.network))
        this.disconnect();
      else {
        this.restorePersistedValues(), fs(o, this.network).then((c) => {
          this.$store.setKey("balance", c);
        });
        return;
      }
    if (!this.library) throw new Error("Leather isn't installed");
    const a = await this.library.request("getAddresses");
    if (!a) throw new Error("No accounts found");
    const i = a.result.addresses, s = i.map(
      (c) => c.address
    ), u = i.find(
      (c) => c.type === lf
    ), l = i.find(
      (c) => c.type === Bv
    );
    if (!(u != null && u.publicKey) || !(l != null && l.publicKey))
      throw new Error("No accounts found");
    if ((r = String(u == null ? void 0 : u.address)) != null && r.startsWith("tb") && this.network !== Cr && this.network !== hn && this.network !== En)
      throw new Error(
        `Please switch networks to ${this.network} in the wallet settings.`
      );
    this.$store.setKey("accounts", s), this.$store.setKey("address", u.address), this.$store.setKey("paymentAddress", l.address), this.$store.setKey("publicKey", u.publicKey), this.$store.setKey("paymentPublicKey", l.publicKey);
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    var n, o;
    const a = await ((n = this.library) == null ? void 0 : n.request("sendTransfer", {
      recipients: [
        {
          address: t,
          amount: r
        }
      ]
    }));
    if ((o = a == null ? void 0 : a.result) != null && o.txid)
      return a.result.txid;
    throw a.error.code === hh.USER_REJECTION ? new Error("User rejected the request") : new Error("Error sending BTC: " + a.error.message);
  }
  async signMessage(t, r) {
    var n;
    const o = r == null ? void 0 : r.toSignAddress;
    if ((r == null ? void 0 : r.protocol) === s0)
      throw new Error("Leather doesn't support ECDSA message signing");
    const a = o === this.$store.get().address ? lf : Bv;
    if (o !== this.$store.get().address && o !== this.$store.get().paymentAddress)
      throw new Error("Invalid address to sign message");
    const i = await this.library.request("signMessage", {
      message: t,
      paymentType: a
    });
    return (n = i == null ? void 0 : i.result) == null ? void 0 : n.signature;
  }
  async signPsbt(t, r, n, o, a) {
    const i = {
      hex: r,
      broadcast: !1,
      network: this.network
    }, s = (await this.library.request(
      "signPsbt",
      i
    )).result.hex, u = Zt.fromHex(String(s));
    if (o && a) {
      const l = u.finalizeAllInputs(), c = await this.pushPsbt(l.toHex());
      return {
        signedPsbtHex: u.toHex(),
        signedPsbtBase64: u.toBase64(),
        txId: c
      };
    } else if (o) {
      const l = u.finalizeAllInputs();
      return {
        signedPsbtHex: l.toHex(),
        signedPsbtBase64: l.toBase64(),
        txId: void 0
      };
    } else
      return {
        signedPsbtHex: u.toHex(),
        signedPsbtBase64: u.toBase64(),
        txId: void 0
      };
  }
  async getPublicKey() {
    const { result: t } = await this.library.request(
      "getAddresses"
    ), r = t.addresses.find(
      (n) => n.type === lf
    );
    if (!(r != null && r.publicKey))
      throw new Error("No accounts found");
    return r.publicKey;
  }
  async getBalance() {
    const t = await fs(
      this.$store.get().paymentAddress,
      this.network
    );
    return this.$store.setKey("balance", t), t.toString();
  }
  async requestAccounts() {
    const { result: t } = await this.library.request(
      "getAddresses"
    ), r = t.addresses.map((n) => n.address);
    return this.$store.setKey("accounts", r), r;
  }
}
var ph = {}, tU = {}, ji = {}, rU = {};
Object.defineProperty(rU, "__esModule", { value: !0 });
(function(e) {
  var t = Ke && Ke.__createBinding || (Object.create ? function(i, s, u, l) {
    l === void 0 && (l = u);
    var c = Object.getOwnPropertyDescriptor(s, u);
    (!c || ("get" in c ? !s.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return s[u];
    } }), Object.defineProperty(i, l, c);
  } : function(i, s, u, l) {
    l === void 0 && (l = u), i[l] = s[u];
  }), r = Ke && Ke.__exportStar || function(i, s) {
    for (var u in i) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && t(s, i, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getProviderById = e.getProviders = e.getProviderOrThrow = void 0;
  async function n(i) {
    var s, u;
    if (i) {
      const c = await i();
      if (c)
        return c;
    }
    const l = window.OrangeBitcoinProvider || ((s = window.OrangecryptoProviders) == null ? void 0 : s.BitcoinProvider) || ((u = window.OrangeWalletProviders) == null ? void 0 : u.OrangeBitcoinProvider);
    if (!l)
      throw new Error("No Orange Bitcoin wallet installed");
    return l;
  }
  e.getProviderOrThrow = n;
  function o() {
    return window.btc_providers || (window.btc_providers = []), window.btc_providers;
  }
  e.getProviders = o;
  function a(i) {
    var s;
    if (Array.isArray(window.btc_providers)) {
      const u = window.btc_providers.find((l) => l.id === i);
      return (s = u == null ? void 0 : u.id) == null ? void 0 : s.split(".").reduce((l, c) => l == null ? void 0 : l[c], window);
    } else {
      console.log("window.btc_providers is not defined or not an array");
      return;
    }
  }
  e.getProviderById = a, r(rU, e);
})(ji);
var nU = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.AddressType = e.AddressPurpose = void 0, function(t) {
    t.Ordinals = "ordinals", t.Payment = "payment", t.Stacks = "stacks";
  }(e.AddressPurpose || (e.AddressPurpose = {})), function(t) {
    t.p2pkh = "p2pkh", t.p2sh = "p2sh", t.p2wpkh = "p2wpkh", t.p2wsh = "p2wsh", t.p2tr = "p2tr", t.stacks = "stacks";
  }(e.AddressType || (e.AddressType = {}));
})(nU);
(function(e) {
  var t = Ke && Ke.__createBinding || (Object.create ? function(i, s, u, l) {
    l === void 0 && (l = u);
    var c = Object.getOwnPropertyDescriptor(s, u);
    (!c || ("get" in c ? !s.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return s[u];
    } }), Object.defineProperty(i, l, c);
  } : function(i, s, u, l) {
    l === void 0 && (l = u), i[l] = s[u];
  }), r = Ke && Ke.__exportStar || function(i, s) {
    for (var u in i) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && t(s, i, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getAddress = void 0;
  const n = No, o = ji, a = async (i) => {
    var s, u;
    const l = await (0, o.getProviderOrThrow)(i.getProvider), { purposes: c } = i.payload;
    if (!c)
      throw new Error("Address purposes are required");
    try {
      const f = (0, n.createUnsecuredToken)(i.payload), h = await l.connect(f);
      (s = i.onFinish) == null || s.call(i, h);
    } catch (f) {
      console.error("[Connect] Error during address request", f), (u = i.onCancel) == null || u.call(i);
    }
  };
  e.getAddress = a, r(nU, e);
})(tU);
var oU = {}, iU = {}, aU = {};
Object.defineProperty(aU, "__esModule", { value: !0 });
var sU = {};
Object.defineProperty(sU, "__esModule", { value: !0 });
(function(e) {
  var t = Ke && Ke.__createBinding || (Object.create ? function(n, o, a, i) {
    i === void 0 && (i = a);
    var s = Object.getOwnPropertyDescriptor(o, a);
    (!s || ("get" in s ? !o.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return o[a];
    } }), Object.defineProperty(n, i, s);
  } : function(n, o, a, i) {
    i === void 0 && (i = a), n[i] = o[a];
  }), r = Ke && Ke.__exportStar || function(n, o) {
    for (var a in n) a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && t(o, n, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(aU, e), r(sU, e);
})(iU);
(function(e) {
  var t = Ke && Ke.__createBinding || (Object.create ? function(i, s, u, l) {
    l === void 0 && (l = u);
    var c = Object.getOwnPropertyDescriptor(s, u);
    (!c || ("get" in c ? !s.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return s[u];
    } }), Object.defineProperty(i, l, c);
  } : function(i, s, u, l) {
    l === void 0 && (l = u), i[l] = s[u];
  }), r = Ke && Ke.__exportStar || function(i, s) {
    for (var u in i) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && t(s, i, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.request = void 0;
  const n = ji, o = async (i, s, u) => {
    var l;
    let c = ((l = window.OrangecryptoProviders) == null ? void 0 : l.BitcoinProvider) || window.OrangeBitcoinProvider;
    if (u && (c = await (0, n.getProviderById)(u)), !c)
      throw new Error("no wallet provider was found");
    if (!i)
      throw new Error("A wallet method is required");
    const f = await c.request(i, s);
    return a(f) ? {
      status: "success",
      result: f.result
    } : {
      status: "error",
      error: f.error
    };
  };
  e.request = o;
  const a = (i) => Object.hasOwn(i, "result") && !!i.result;
  r(iU, e);
})(oU);
var uU = {}, cU = {};
Object.defineProperty(cU, "__esModule", { value: !0 });
(function(e) {
  var t = Ke && Ke.__createBinding || (Object.create ? function(s, u, l, c) {
    c === void 0 && (c = l);
    var f = Object.getOwnPropertyDescriptor(u, l);
    (!f || ("get" in f ? !u.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return u[l];
    } }), Object.defineProperty(s, c, f);
  } : function(s, u, l, c) {
    c === void 0 && (c = l), s[c] = u[l];
  }), r = Ke && Ke.__exportStar || function(s, u) {
    for (var l in s) l !== "default" && !Object.prototype.hasOwnProperty.call(u, l) && t(u, s, l);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getCapabilities = void 0;
  const n = No, o = ji, a = (s, u) => {
    const l = (f) => !(!s[f] || u && !u.has(f)), c = {
      request: l("request"),
      connect: l("connect"),
      signMessage: l("signMessage"),
      signTransaction: l("signTransaction"),
      sendBtcTransaction: l("sendBtcTransaction"),
      createInscription: l("createInscription"),
      createRepeatInscriptions: l("createRepeatInscriptions"),
      signMultipleTransactions: l("signMultipleTransactions")
    };
    return Object.entries(c).reduce((f, [h, p]) => p ? [...f, h] : f, []);
  }, i = async (s) => {
    var u, l, c;
    const f = await (0, o.getProviderOrThrow)(s.getProvider), h = (0, n.createUnsecuredToken)(s.payload);
    if (f.getCapabilities)
      try {
        const p = await f.getCapabilities(h);
        (u = s.onFinish) == null || u.call(s, a(f, new Set(p)));
      } catch (p) {
        console.error("[Connect] Error during capabilities request", p);
      }
    try {
      const p = a(f);
      (l = s.onFinish) == null || l.call(s, p);
    } catch (p) {
      console.error("[Connect] Error during capabilities request", p), (c = s.onCancel) == null || c.call(s);
    }
  };
  e.getCapabilities = i, r(cU, e);
})(uU);
var lU = {}, zb = {}, p0 = {};
Object.defineProperty(p0, "__esModule", { value: !0 });
p0.validateInscriptionPayload = void 0;
const Qwe = 4e5, eve = 6e4, tve = (e) => {
  const { contentType: t, content: r, payloadType: n, network: o, appFeeAddress: a, appFee: i } = e;
  if (!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(t))
    throw new Error("Invalid content type detected");
  if (!r || r.length === 0)
    throw new Error("Empty content not allowed");
  if (!n || n !== "BASE_64" && n !== "PLAIN_TEXT")
    throw new Error("Empty invalid payloadType specified");
  if (r.length > (o.type === "Mainnet" ? Qwe : eve))
    throw new Error("Content too large");
  if (((a == null ? void 0 : a.length) ?? 0) > 0 && (i ?? 0) <= 0)
    throw new Error("Invalid combination of app fee address and fee provided");
};
p0.validateInscriptionPayload = tve;
Object.defineProperty(zb, "__esModule", { value: !0 });
zb.createInscription = void 0;
const rve = No, nve = ji, ove = p0, ive = async (e) => {
  var t, r;
  const { getProvider: n } = e, o = await (0, nve.getProviderOrThrow)(n);
  (0, ove.validateInscriptionPayload)(e.payload);
  try {
    const a = (0, rve.createUnsecuredToken)(e.payload), i = await o.createInscription(a);
    (t = e.onFinish) == null || t.call(e, i);
  } catch (a) {
    console.error("[Connect] Error during create inscription", a), (r = e.onCancel) == null || r.call(e);
  }
};
zb.createInscription = ive;
var jb = {};
Object.defineProperty(jb, "__esModule", { value: !0 });
jb.createRepeatInscriptions = void 0;
const ave = ji, sve = No, uve = p0, cve = async (e) => {
  var t, r;
  const { getProvider: n } = e, o = await (0, ave.getProviderOrThrow)(n);
  (0, uve.validateInscriptionPayload)(e.payload);
  try {
    const a = (0, sve.createUnsecuredToken)(e.payload), i = await o.createRepeatInscriptions(a);
    (t = e.onFinish) == null || t.call(e, i);
  } catch (a) {
    console.error("[Connect] Error during create repeat inscriptions", a), (r = e.onCancel) == null || r.call(e);
  }
};
jb.createRepeatInscriptions = cve;
var fU = {};
Object.defineProperty(fU, "__esModule", { value: !0 });
(function(e) {
  var t = Ke && Ke.__createBinding || (Object.create ? function(n, o, a, i) {
    i === void 0 && (i = a);
    var s = Object.getOwnPropertyDescriptor(o, a);
    (!s || ("get" in s ? !o.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return o[a];
    } }), Object.defineProperty(n, i, s);
  } : function(n, o, a, i) {
    i === void 0 && (i = a), n[i] = o[a];
  }), r = Ke && Ke.__exportStar || function(n, o) {
    for (var a in n) a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && t(o, n, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(zb, e), r(jb, e), r(fU, e);
})(lU);
var dU = {}, hU = {};
Object.defineProperty(hU, "__esModule", { value: !0 });
(function(e) {
  var t = Ke && Ke.__createBinding || (Object.create ? function(i, s, u, l) {
    l === void 0 && (l = u);
    var c = Object.getOwnPropertyDescriptor(s, u);
    (!c || ("get" in c ? !s.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
      return s[u];
    } }), Object.defineProperty(i, l, c);
  } : function(i, s, u, l) {
    l === void 0 && (l = u), i[l] = s[u];
  }), r = Ke && Ke.__exportStar || function(i, s) {
    for (var u in i) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && t(s, i, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.signMessage = void 0;
  const n = No, o = ji, a = async (i) => {
    var s, u;
    const l = await (0, o.getProviderOrThrow)(i.getProvider), { address: c, message: f } = i.payload;
    if (!c)
      throw new Error("An address is required to sign a message");
    if (!f)
      throw new Error("A message to be signed is required");
    try {
      const h = (0, n.createUnsecuredToken)(i.payload), p = await l.signMessage(h);
      (s = i.onFinish) == null || s.call(i, p);
    } catch (h) {
      console.error("[Connect] Error during sign message request", h), (u = i.onCancel) == null || u.call(i);
    }
  };
  e.signMessage = a, r(hU, e);
})(dU);
var pU = {}, Lb = {};
Object.defineProperty(Lb, "__esModule", { value: !0 });
Lb.sendBtcTransaction = void 0;
const lve = No, fve = ji, dve = (e) => e.map((t) => {
  const { address: r, amountSats: n } = t;
  return {
    address: r,
    amountSats: n.toString()
  };
}), hve = async (e) => {
  var t, r;
  const n = await (0, fve.getProviderOrThrow)(e.getProvider), { recipients: o, senderAddress: a, network: i, message: s } = e.payload;
  if (!o || o.length === 0)
    throw new Error("At least one recipient is required");
  if (o.some((u) => typeof u.address != "string" || typeof u.amountSats != "bigint"))
    throw new Error("Incorrect recipient format");
  if (!a)
    throw new Error("The sender address is required");
  try {
    const u = dve(o), l = {
      network: i,
      senderAddress: a,
      message: s,
      recipients: u
    }, c = (0, lve.createUnsecuredToken)(l), f = await n.sendBtcTransaction(c);
    (t = e.onFinish) == null || t.call(e, f);
  } catch (u) {
    console.error("[Connect] Error during send BTC transaction request", u), (r = e.onCancel) == null || r.call(e);
  }
};
Lb.sendBtcTransaction = hve;
var Hb = {};
Object.defineProperty(Hb, "__esModule", { value: !0 });
Hb.signTransaction = void 0;
const pve = No, gve = ji, mve = async (e) => {
  var t, r;
  const n = await (0, gve.getProviderOrThrow)(e.getProvider), { psbtBase64: o, inputsToSign: a } = e.payload;
  if (!o)
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!a)
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const i = (0, pve.createUnsecuredToken)(e.payload), s = await n.signTransaction(i);
    (t = e.onFinish) == null || t.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during sign transaction request", i), (r = e.onCancel) == null || r.call(e);
  }
};
Hb.signTransaction = mve;
var Fb = {};
Object.defineProperty(Fb, "__esModule", { value: !0 });
Fb.signMultipleTransactions = void 0;
const yve = No, bve = ji, wve = async (e) => {
  var t, r;
  const n = await (0, bve.getProviderOrThrow)(e.getProvider), { psbts: o } = e.payload;
  if (!o || !o.length)
    throw new Error("psbts array is required");
  if (o.length > 100)
    throw new Error("psbts array must contain less than 100 psbts");
  try {
    const a = (0, yve.createUnsecuredToken)(e.payload), i = await n.signMultipleTransactions(a);
    (t = e.onFinish) == null || t.call(e, i);
  } catch (a) {
    console.error("[Connect] Error during sign Multiple transactions request", a), (r = e.onCancel) == null || r.call(e);
  }
};
Fb.signMultipleTransactions = wve;
var gU = {};
Object.defineProperty(gU, "__esModule", { value: !0 });
(function(e) {
  var t = Ke && Ke.__createBinding || (Object.create ? function(n, o, a, i) {
    i === void 0 && (i = a);
    var s = Object.getOwnPropertyDescriptor(o, a);
    (!s || ("get" in s ? !o.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return o[a];
    } }), Object.defineProperty(n, i, s);
  } : function(n, o, a, i) {
    i === void 0 && (i = a), n[i] = o[a];
  }), r = Ke && Ke.__exportStar || function(n, o) {
    for (var a in n) a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && t(o, n, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Lb, e), r(Hb, e), r(Fb, e), r(gU, e);
})(pU);
var mU = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.RpcErrorCode = e.BitcoinNetworkType = void 0, function(t) {
    t.Mainnet = "Mainnet", t.Testnet = "Testnet";
  }(e.BitcoinNetworkType || (e.BitcoinNetworkType = {})), function(t) {
    t[t.PARSE_ERROR = -32700] = "PARSE_ERROR", t[t.INVALID_REQUEST = -32600] = "INVALID_REQUEST", t[t.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", t[t.INVALID_PARAMS = -32602] = "INVALID_PARAMS", t[t.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", t[t.USER_REJECTION = -32e3] = "USER_REJECTION", t[t.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED";
  }(e.RpcErrorCode || (e.RpcErrorCode = {}));
})(mU);
(function(e) {
  var t = Ke && Ke.__createBinding || (Object.create ? function(n, o, a, i) {
    i === void 0 && (i = a);
    var s = Object.getOwnPropertyDescriptor(o, a);
    (!s || ("get" in s ? !o.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return o[a];
    } }), Object.defineProperty(n, i, s);
  } : function(n, o, a, i) {
    i === void 0 && (i = a), n[i] = o[a];
  }), r = Ke && Ke.__exportStar || function(n, o) {
    for (var a in n) a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && t(o, n, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(tU, e), r(oU, e), r(uU, e), r(lU, e), r(dU, e), r(ji, e), r(pU, e), r(mU, e);
})(ph);
const vve = /* @__PURE__ */ Fne(ph), { signMessage: Eve, sendBtcTransaction: kve } = vve, xve = "ORANGE_CONNECTED_WALLET_STATE";
class Ave extends zi {
  constructor() {
    super(...arguments), xe(this, "observer"), xe(this, "$valueStore", Tl(
      xve,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), xe(this, "removeSubscriber");
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.OrangeWalletProviders) == null ? void 0 : t.OrangeBitcoinProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of ec)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    Sl(_u, t, n, this.$valueStore);
  }
  initialize() {
    var t;
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r;
      window != null && window.OrangeBitcoinProvider && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [_u]: !0
      }), (r = this.observer) == null || r.disconnect());
    }), (t = this.observer) == null || t.observe(document, { childList: !0, subtree: !0 })), Jo(this.$store, ["provider"], (r) => {
      r.provider !== _u ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r) {
        this.restorePersistedValues(), fs(n, this.network).then((i) => {
          this.$store.setKey("balance", i);
        });
        return;
      }
      let o = lw(this.network || Ut);
      const a = {
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Address for receiving Ordinals and payments",
          network: {
            type: o
          }
        },
        onFinish: (i) => {
          const s = W4(i.addresses), u = X4(i.addresses);
          if (!s || !(u != null && u.address))
            throw new Error("Could not find addresses");
          s && u && (this.$store.setKey("provider", _u), this.$store.setKey("address", s.address), this.$store.setKey("paymentAddress", u.address)), this.$store.setKey("publicKey", String(s.publicKey)), this.$store.setKey(
            "paymentPublicKey",
            String(u.publicKey)
          );
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${_u} wallet`);
        }
      };
      await ph.getAddress(a), this.$store.setKey("connected", !0);
    } catch (o) {
      throw o;
    }
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [Cr, hn, En, Xn].includes(this.network) ? this.network : Ut;
  }
  async sendBTC(t, r) {
    let n = "";
    const o = {
      payload: {
        network: {
          type: lw(this.network)
        },
        recipients: [
          {
            address: t,
            amountSats: BigInt(r)
          }
        ],
        senderAddress: this.$store.get().paymentAddress
      },
      onFinish: (a) => {
        n = a;
      },
      onCancel: () => {
        throw new Error("User canceled the request");
      }
    };
    return await kve(o), n;
  }
  async signMessage(t, r) {
    let n = "";
    const o = (r == null ? void 0 : r.toSignAddress) || this.$store.get().paymentAddress, a = {
      payload: {
        network: {
          type: lw(this.network)
        },
        address: o,
        message: t
      },
      onFinish: (i) => {
        n = i;
      },
      onCancel: () => {
        throw new Error("User canceled the request");
      }
    };
    return await Eve(a), n;
  }
  async signPsbt(t, r, n, o, a) {
    try {
      const i = Zt.fromBase64(String(n), {
        network: kr(this.network)
      }), s = this.$store.get().address, u = this.$store.get().paymentAddress, l = i.data.inputs;
      let c = {};
      const f = {
        [s]: []
      }, h = {
        [u]: []
      };
      let p = 0;
      for await (let E of l) {
        if (E.witnessUtxo === void 0)
          h[u].push(Number(p));
        else {
          const { script: A } = E.witnessUtxo, S = Vp(
            A,
            kr(this.network)
          );
          S === u ? h[u].push(Number(p)) : S === s && f[s].push(Number(p));
        }
        p++;
      }
      f[s].length > 0 && (c = { ...c, ...f }), h[u].length > 0 && (c = { ...c, ...h });
      let y, m, b, v;
      const k = await ph.request("signPsbt", {
        psbt: n,
        broadcast: !!a,
        signInputs: c
      });
      if (k.status === "success")
        v = Zt.fromBase64(k.result.psbt, {
          network: kr(this.network)
        }), y = k.result.txid;
      else
        throw k.error.code === ph.RpcErrorCode.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
      if (!v)
        throw new Error("Error signing psbt");
      return o && !y ? (v.finalizeAllInputs(), m = v.toHex(), b = v.toBase64()) : (m = v.toHex(), b = v.toBase64()), {
        signedPsbtHex: m,
        signedPsbtBase64: b,
        txId: y
      };
    } catch (i) {
      throw console.error(i), i;
    }
  }
}
const Sve = "OKX_CONNECTED_WALLET_STATE";
class _ve extends zi {
  constructor() {
    super(...arguments), xe(this, "observer"), xe(this, "$valueStore", Tl(
      Sve,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), xe(this, "removeSubscriber");
  }
  get library() {
    var t, r;
    let n;
    return this.network === Cr || this.network === hn || this.network === En || this.network === Xn ? n = (t = window == null ? void 0 : window.okxwallet) == null ? void 0 : t.bitcoinTestnet : (this.network === Ut || this.network === xl) && (n = (r = window == null ? void 0 : window.okxwallet) == null ? void 0 : r.bitcoin), n;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of ec)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    Sl(cf, t, n, this.$valueStore);
  }
  initialize() {
    var t;
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [cf]: !0
      }), (r = this.observer) == null || r.disconnect());
    }), (t = this.observer) == null || t.observe(document, { childList: !0, subtree: !0 })), Jo(this.$store, ["provider"], (r) => {
      r.provider !== cf ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    if (r)
      if (r.startsWith("tb1") && Ed(this.network))
        this.disconnect();
      else {
        this.restorePersistedValues(), fs(n, this.network).then((o) => {
          this.$store.setKey("balance", o);
        });
        return;
      }
    try {
      const o = await this.library.connect();
      if (!o) throw new Error("No accounts found");
      this.$store.setKey("address", o.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", o.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey), this.$store.setKey("accounts", [o]);
    } catch (o) {
      throw o;
    }
  }
  async requestAccounts() {
    const t = this.library, r = this.network;
    return r === Cr || r === hn || r === Xn ? await t.connect() : await t.requestAccounts();
  }
  async getNetwork() {
    const { address: t } = this.$store.get(), r = this.network;
    if (t.slice(0, 1) === "t")
      return r === Cr ? Cr : r === hn ? hn : r === En ? En : r === Xn ? Xn : Cr;
    const n = await this.library.getNetwork();
    return lme(n);
  }
  async getPublicKey() {
    const t = this.library;
    return await (t == null ? void 0 : t.getPublicKey());
  }
  async getInscriptions(t, r) {
    return await this.library.getInscriptions(t, r);
  }
  async sendBTC(t, r) {
    const n = await this.library.sendBitcoin(t, r);
    if (!n) throw new Error("Transaction failed");
    return n;
  }
  async signMessage(t, r) {
    const n = this.library, o = (r == null ? void 0 : r.protocol) === s0 ? vb : r == null ? void 0 : r.protocol;
    return await (n == null ? void 0 : n.signMessage(t, o));
  }
  async signPsbt(t, r, n, o, a) {
    const i = await this.library.signPsbt(r, {
      autoFinalized: o
    }), s = Zt.fromHex(i);
    if (o && a) {
      const u = await this.pushPsbt(i);
      return {
        signedPsbtHex: s.toHex(),
        signedPsbtBase64: s.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: s.toHex(),
      signedPsbtBase64: s.toBase64(),
      txId: void 0
    };
  }
}
const Ive = "MAGIC_EDEN_CONNECTED_WALLET_STATE";
class Tve extends zi {
  constructor() {
    super(...arguments), xe(this, "observer"), xe(this, "$valueStore", Tl(
      Ive,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), xe(this, "removeSubscriber");
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.magicEden) == null ? void 0 : t.bitcoin;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of ec) {
      if (r === "balance") {
        this.$store.setKey(r, BigInt(t[r]));
        continue;
      }
      this.$store.setKey(r, t[r]);
    }
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    Sl(
      qa,
      t,
      n,
      this.$valueStore
    );
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t, r;
      (t = window == null ? void 0 : window.magicEden) != null && t.bitcoin && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [qa]: !0
      }), (r = this.observer) == null || r.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Jo(this.$store, ["provider"], (t) => {
      t.provider !== qa ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r)
        if (r.startsWith("tb1") && Ed(this.network))
          this.disconnect();
        else {
          fs(n, this.network).then((a) => {
            this.$store.setKey("balance", a);
          }), this.restorePersistedValues();
          return;
        }
      if (J4(this.network))
        throw new Error(`${this.network} is not supported by ${qa}`);
      let o = B1(this.network || Ut);
      await eU({
        getProvider: async () => this.library,
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Connecting with lasereyes",
          network: {
            type: o
          }
        },
        onFinish: (a) => {
          const i = W4(a.addresses), s = X4(a.addresses);
          if (!i || !s)
            throw new Error("No address found");
          i && s && (this.$store.setKey("address", i.address), this.$store.setKey("paymentAddress", s.address), this.$store.setKey("accounts", [
            i.address,
            s.address
          ])), this.$store.setKey(
            "publicKey",
            String(a.addresses[0].publicKey)
          ), this.$store.setKey(
            "paymentPublicKey",
            String(a.addresses[1].publicKey)
          );
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${qa} wallet`);
        },
        onError: (a) => {
          throw new Error(`Can't lasereyes to ${qa} wallet`);
        }
      });
    } catch (o) {
      throw o;
    }
  }
  async sendBTC(t, r) {
    let n;
    if (await Dwe({
      getProvider: async () => this.library,
      payload: {
        network: {
          type: B1(this.network)
        },
        recipients: [
          {
            address: t,
            amountSats: BigInt(r)
          }
        ],
        senderAddress: this.$store.get().paymentAddress
      },
      onFinish: (o) => {
        n = o;
      },
      onCancel: () => {
        throw console.error("Request canceled"), new Error("User canceled the request");
      }
    }), !n) throw new Error("Error sending BTC");
    return n.txid;
  }
  async signMessage(t, r) {
    try {
      const n = (r == null ? void 0 : r.toSignAddress) || this.$store.get().paymentAddress;
      let o = "";
      return await Hwe({
        getProvider: async () => this.library,
        payload: {
          network: {
            type: XN.Mainnet
          },
          address: n,
          message: t,
          protocol: (r == null ? void 0 : r.protocol) === s0 ? ol.ECDSA : ol.BIP322
        },
        onFinish: (a) => {
          o = a;
        },
        onCancel: () => {
          throw console.error("Request canceled"), new Error("User canceled the request");
        }
      }), o;
    } catch (n) {
      throw n;
    }
  }
  async signPsbt(t, r, n, o, a) {
    console.log("signPsbt", n, o, a);
    const { address: i, paymentAddress: s } = this.$store.get(), u = Zt.fromBase64(String(n), {
      network: kr(this.network)
    }), l = u.data.inputs, c = [], f = {
      address: i,
      signingIndexes: []
    }, h = {
      address: s,
      signingIndexes: []
    };
    let p = 0;
    for await (let A of l) {
      const { script: S } = A.witnessUtxo, _ = Vp(
        S,
        kr(this.network)
      );
      _ === s ? (h.signingIndexes.push(Number(p)), A.sighashType && (console.log("Updating sigHash for paymentsAddressData"), h.sigHash = A.sighashType)) : _ === i && (f.signingIndexes.push(Number(p)), A.sighashType && (console.log("Updating sigHash for ordinalAddressData"), f.sigHash = A.sighashType)), p++;
    }
    f.signingIndexes.length > 0 && c.push(f), h.signingIndexes.length > 0 && c.push(h);
    let y, m, b, v;
    const k = B1(this.network), E = {
      getProvider: async () => this.library,
      payload: {
        network: {
          type: k
        },
        message: "Sign Transaction",
        psbtBase64: u.toBase64(),
        broadcast: a,
        inputsToSign: c
      },
      onFinish: async (A) => {
        A.psbtBase64 && (v = Zt.fromBase64(String(A.psbtBase64), {
          network: kr(this.network)
        }), m = v.toHex(), b = v.toBase64());
      },
      onCancel: () => {
        throw console.log("Canceled"), new Error("User canceled the request");
      },
      onError: (A) => {
        throw console.log("error", A), A;
      }
    };
    if (await Mwe(E), !v)
      throw new Error("signature failed");
    return o || a ? (v.finalizeAllInputs(), {
      signedPsbtHex: v.toHex(),
      signedPsbtBase64: b,
      txId: y
    }) : {
      signedPsbtHex: m,
      signedPsbtBase64: b,
      txId: y
    };
  }
}
class Pve extends zi {
  constructor() {
    super(...arguments), xe(this, "observer");
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.phantom) == null ? void 0 : t.bitcoin;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Su]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Jo(this.$store, ["provider"], (t) => {
      t.provider === Su && this.library.requestAccounts().then((r) => {
        this.handleAccountsChanged(r);
      });
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(Su) : this.parent.disconnect());
  }
  async connect(t) {
    if (!this.library) throw new Error("Phantom isn't installed");
    if (J4(this.network))
      throw new Error(`${this.network} is not supported by ${Su}`);
    const r = await this.library.requestAccounts();
    if (!r) throw new Error("No accounts found");
    this.$store.setKey("accounts", r);
    const n = r.find(
      (a) => a.purpose === "ordinals"
    ), o = r.find(
      (a) => a.purpose === "payment"
    );
    this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey), this.$store.setKey("provider", Su), this.$store.setKey("connected", !0);
  }
  async getNetwork() {
    return this.$store.get().address.slice(0, 1) === "t" ? Cr : Ut;
  }
  async sendBTC(t, r) {
    const { psbtHex: n } = await Y4(
      this.$store.get().address,
      this.$store.get().paymentAddress,
      t,
      r,
      this.$store.get().paymentPublicKey,
      this.network,
      7
    ), o = await this.signPsbt("", n, "", !0, !0);
    if (!o) throw new Error("Error sending BTC");
    return o.txId;
  }
  async signMessage(t, r) {
    var n;
    if ((r == null ? void 0 : r.protocol) === s0)
      throw new Error("ECDSA signing is not supported by Phantom");
    const o = new TextEncoder().encode(t), a = new Uint8Array(o), i = (r == null ? void 0 : r.toSignAddress) || this.$store.get().paymentAddress, s = await ((n = this.library) == null ? void 0 : n.signMessage(i, a)), u = String.fromCharCode(...s.signature);
    return btoa(u);
  }
  async signPsbt(t, r, n, o, a) {
    const { address: i, paymentAddress: s } = this.$store.get(), u = Zt.fromHex(String(r), {
      network: kr(this.network)
    }).data.inputs, l = [], c = {
      address: i,
      signingIndexes: []
    }, f = {
      address: s,
      signingIndexes: []
    };
    let h = 0;
    for await (let m of u) {
      const { script: b } = m.witnessUtxo, v = Vp(
        b,
        kr(this.network)
      );
      v === s ? f.signingIndexes.push(Number(h)) : v === i && c.signingIndexes.push(Number(h)), h++;
    }
    c.signingIndexes.length > 0 && l.push(c), f.signingIndexes.length > 0 && l.push(f);
    const p = await this.library.signPSBT(
      I2e(r),
      {
        inputsToSign: l
      }
    ), y = Zt.fromBuffer(p);
    if (o && l.forEach((m) => {
      m.signingIndexes.forEach((b) => {
        y.finalizeInput(b);
      });
    }), a) {
      const m = await this.pushPsbt(y.toHex());
      return {
        signedPsbtHex: y.toHex(),
        signedPsbtBase64: y.toBase64(),
        txId: m
      };
    }
    return {
      signedPsbtHex: y.toHex(),
      signedPsbtBase64: y.toBase64(),
      txId: void 0
    };
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
}
class Ove extends zi {
  constructor() {
    super(...arguments), xe(this, "observer");
  }
  get library() {
    return window == null ? void 0 : window.opnet;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Iu]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Jo(this.$store, ["provider"], (t) => {
      if (t.provider !== Iu) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener(
      "accountsChanged",
      this.handleAccountsChanged.bind(this)
    ), (r = this.library) == null || r.removeListener(
      "networkChanged",
      this.handleNetworkChanged.bind(this)
    ));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(Iu) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = mm(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(Iu);
  }
  async connect(t) {
    if (!this.library) throw new Error("OP_NET isn't installed");
    const r = await this.library.requestAccounts();
    if (!r) throw new Error("No accounts found");
    const n = await this.library.getPublicKey();
    if (!n) throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), this.$store.setKey("provider", Iu), await this.getNetwork().then((o) => {
      var a;
      ((a = this.config) == null ? void 0 : a.network) !== o && this.switchNetwork(o);
    }), this.$store.setKey("connected", !0);
  }
  async getNetwork() {
    var t;
    const r = await ((t = this.library) == null ? void 0 : t.getChain());
    return r ? mm(r.enum) : this.network;
  }
  async sendBTC(t, r) {
    var n;
    const o = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
    if (!o) throw new Error("Transaction failed");
    return o;
  }
  async signMessage(t, r) {
    var n;
    const o = (r == null ? void 0 : r.protocol) === G4 ? vb : r == null ? void 0 : r.protocol;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t, o));
  }
  async signPsbt(t, r, n, o, a) {
    var i;
    const s = await ((i = this.library) == null ? void 0 : i.signPsbt(r, {
      autoFinalized: o
    })), u = Zt.fromHex(s);
    if (o && a) {
      const l = await this.pushPsbt(s);
      return {
        signedPsbtHex: u.toHex(),
        signedPsbtBase64: u.toBase64(),
        txId: l
      };
    }
    return {
      signedPsbtHex: u.toHex(),
      signedPsbtBase64: u.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    return await this.library.getInscriptions(t, r);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var r;
    const n = fB(t);
    await ((r = this.library) == null ? void 0 : r.switchChain(n)), this.$network.set(t);
  }
}
const p1 = {};
function Yd(e) {
  if (p1[e])
    return console.warn(`Multiple requests for "${e}" detected`), p1[e];
  const t = new Promise((r) => {
    const n = console.log;
    console.log = (...o) => {
      o.length > 0 && typeof o[0] == "string" && (console.log = n, p1[e] = void 0, r(o[0]));
    }, n(
      `Please log a value for "${e}" using 
 console.log('<your-value>') 
 to continue.`
    );
  });
  return p1[e] = t, t;
}
class $ve {
  async requestAccounts() {
    const t = await Yd("address");
    if (!t) throw new Error("No address provided");
    const r = await Yd("paymentAddress");
    if (!r) throw new Error("No payment address provided");
    return [t, r];
  }
  async signMessage(t) {
    return console.log("sign this message in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await Yd("message to sign");
  }
  async signPsbt(t) {
    return console.log("sign this in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await Yd("signed psbt hex");
  }
  async getPublicKey() {
    const t = await Yd("publicKey");
    if (!t) throw new Error("No public key provided");
    return t;
  }
  // TODO: Implement network switching between mainnet and testnet
  async getNetwork() {
    return "mainnet";
  }
  async switchNetwork(t) {
  }
}
const Cve = "SPARROW_CONNECTED_WALLET_STATE";
class Bve extends zi {
  constructor() {
    super(...arguments), xe(this, "observer"), xe(this, "$valueStore", Tl(
      Cve,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), xe(this, "removeSubscriber");
  }
  get library() {
    return window == null ? void 0 : window.SparrowWalletProvider;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library || (window.SparrowWalletProvider = new $ve()), this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Ac]: !0
      }), (t = this.observer) == null || t.disconnect();
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), Jo(this.$store, ["provider"], (t) => {
      t.provider !== Ac ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  watchStateChange(t, r, n) {
    Sl(
      Ac,
      t,
      n,
      this.$valueStore
    );
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of ec)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    try {
      const { address: r, paymentAddress: n } = this.$valueStore.get();
      if (r && n)
        if (r.startsWith("tb1") && Ed(this.network))
          this.disconnect();
        else {
          this.restorePersistedValues();
          return;
        }
      if (!this.library) throw new Error("Sparrow wallet isn't supported");
      const o = await this.library.requestAccounts();
      if (!o) throw new Error("No accounts found");
      await this.getNetwork().then((i) => {
        this.network !== i && this.switchNetwork(this.network);
      });
      const a = await this.library.getPublicKey();
      if (!a) throw new Error("No public key found");
      this.$store.setKey("accounts", o), this.$store.setKey("address", o[0]), this.$store.setKey("paymentAddress", o[1]), this.$store.setKey("publicKey", a), this.$store.setKey("paymentPublicKey", a);
    } catch (r) {
      throw console.error("Error during sparrow connect:", r), r;
    }
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    const { psbtBase64: n } = await Y4(
      this.$store.get().address,
      this.$store.get().paymentAddress,
      t,
      r,
      this.$store.get().paymentPublicKey,
      this.network,
      7
    ), o = await this.library.signPsbt(n);
    if (!o) throw new Error("No signed PSBT provided");
    const a = await this.pushPsbt(o);
    if (!a) throw new Error("send failed, no txid returned");
    return a;
  }
  async signMessage(t) {
    return await this.library.signMessage(t);
  }
  async signPsbt(t, r, n, o, a) {
    const i = Zt.fromBase64(n), s = await this.library.signPsbt(n);
    if (o && a) {
      const u = await this.pushPsbt(s);
      return {
        signedPsbtHex: s,
        signedPsbtBase64: i.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: s,
      signedPsbtBase64: i.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    const t = await this.library.getPublicKey();
    return this.$store.setKey("publicKey", t), t;
  }
  async getBalance() {
    const t = await fs(
      this.$store.get().paymentAddress,
      this.network
    );
    return this.$store.setKey("balance", t), t.toString();
  }
  async requestAccounts() {
    return await this.connect(Ac), this.$store.get().accounts;
  }
}
class Nve {
  constructor(t, r) {
    xe(this, "$store"), xe(this, "$network"), xe(this, "$providerMap"), xe(this, "disposed", !1), this.config = r, this.$store = t.$store, this.$network = t.$network, Rre(this.$store), this.$providerMap = {
      [uf]: new Jwe(t, this, r),
      [qa]: new Tve(t, this, r),
      [cf]: new _ve(t, this, r),
      [Iu]: new Ove(t, this, r),
      [_u]: new Ave(t, this, r),
      [sf]: new Xwe(t, this, r),
      [Su]: new Pve(t, this, r),
      [Ac]: new Bve(t, this, r),
      [kc]: new A2e(t, this, r),
      [Au]: new Gwe(t, this, r),
      [xc]: new Zwe(t, this, r)
    };
  }
  dispose() {
    this.disposed = !0, Object.values(this.$providerMap).forEach((t) => t == null ? void 0 : t.dispose());
  }
  initialize() {
    this.$network.listen(this.watchNetworkChange.bind(this)), Jo(this.$store, ["isInitializing"], (t, r) => {
      if (!this.disposed && t.isInitializing !== r.isInitializing)
        return this.handleIsInitializingChanged(t.isInitializing);
    }), this.config && this.config.network && (this.$network.set(this.config.network), this.getNetwork().then((t) => {
      try {
        this.config.network !== t && this.switchNetwork(this.config.network);
      } catch {
        this.disconnect();
      }
    })), S2e(() => this.$store.setKey("isInitializing", !1));
  }
  handleIsInitializingChanged(t) {
    if (typeof window < "u" && typeof localStorage < "u" && !t) {
      const r = localStorage == null ? void 0 : localStorage.getItem(
        C2
      );
      r && this.connect(r);
    }
  }
  async connect(t) {
    if (this.disposed) {
      console.warn("Client disposed, cannot connect");
      return;
    }
    this.$store.setKey("isConnecting", !0);
    try {
      if (localStorage == null || localStorage.setItem(C2, t), !this.$providerMap[t])
        throw new Error("Unsupported wallet provider");
      const r = this.$providerMap[t];
      await (r == null ? void 0 : r.connect(t)), this.$store.setKey("connected", !0), this.$store.setKey("provider", t);
    } catch (r) {
      throw console.error("Error during connect:", r), this.$store.setKey("isConnecting", !1), this.disconnect(), r;
    } finally {
      this.$store.setKey("isConnecting", !1);
    }
  }
  async requestAccounts() {
    var t;
    if (!this.$store.get().provider)
      throw new Error("No wallet provider connected");
    try {
      return await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.requestAccounts());
    } catch (r) {
      throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : r;
    }
  }
  disconnect() {
    this.$store.set({
      provider: void 0,
      address: "",
      paymentAddress: "",
      publicKey: "",
      paymentPublicKey: "",
      balance: void 0,
      accounts: [],
      connected: !1,
      isConnecting: !1,
      isInitializing: !1,
      hasProvider: this.$store.get().hasProvider
    }), localStorage == null || localStorage.removeItem(C2);
  }
  async switchNetwork(t) {
    var r;
    try {
      this.$store.get().provider && await ((r = this.$providerMap[this.$store.get().provider]) == null ? void 0 : r.switchNetwork(
        t
      ));
    } catch (n) {
      throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? (this.disconnect(), new Error(
        "The connected wallet doesn't support programmatic network changes.."
      )) : n;
    }
  }
  watchNetworkChange() {
    this.$store.setKey("balance", void 0);
  }
  async getNetwork() {
    var t;
    return this.$store.get().provider && this.$providerMap[this.$store.get().provider] ? await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.getNetwork()) : this.$network.get();
  }
  async sendBTC(t, r) {
    var n;
    if (r <= 0) throw new Error("Amount must be greater than 0");
    if (!Number.isInteger(r)) throw new Error("Amount must be an integer");
    if (!this.$store.get().provider) throw new Error("No wallet connected");
    if (this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.sendBTC(
          t,
          r
        ));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support sending BTC..."
        ) : o;
      }
  }
  async signMessage(t, r) {
    var n;
    let o = {};
    if (typeof r == "string" ? o = { toSignAddress: r } : r && (o = r), !!this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.signMessage(t, o));
      } catch (a) {
        throw a instanceof Error && a.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support message signing..."
        ) : a;
      }
  }
  async signPsbt(t, r = !1, n = !1) {
    var o;
    let a, i;
    if (!t) throw new Error("No PSBT provided");
    if (h2e(t))
      i = Zt.fromHex(t).toBase64(), a = t;
    else if (d2e(t))
      i = t, a = Zt.fromBase64(t).toHex();
    else
      throw new Error("Invalid PSBT format");
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((o = this.$providerMap[this.$store.get().provider]) == null ? void 0 : o.signPsbt(t, a, i, r, n));
      } catch (s) {
        throw s instanceof Error && s.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support PSBT signing..."
        ) : s;
      }
    else
      throw new Error("No wallet provider connected");
  }
  async pushPsbt(t) {
    var r;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((r = this.$providerMap[this.$store.get().provider]) == null ? void 0 : r.pushPsbt(
          t
        ));
      } catch (n) {
        throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support PSBT signing..."
        ) : n;
      }
  }
  async inscribe(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.inscribe(
          t,
          r
        ));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support inscribing..."
        ) : o;
      }
  }
  async send(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.send(
          t,
          r
        ));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support sending stuff..."
        ) : o;
      }
  }
  async getPublicKey() {
    var t;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.getPublicKey());
      } catch (r) {
        throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getPublicKey") : r;
      }
  }
  async getBalance() {
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        const t = await this.$providerMap[this.$store.get().provider].getBalance();
        return this.$store.setKey("balance", BigInt(t)), t;
      } catch (t) {
        throw t instanceof Error && t.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : t;
      }
  }
  async getMetaBalances(t) {
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        if (!t)
          throw new Error("No protocol provided");
        return await this.$providerMap[this.$store.get().provider].getMetaBalances(
          t
        );
      } catch (r) {
        throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : r;
      }
  }
  async getInscriptions(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.getInscriptions(t, r));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : o;
      }
  }
}
const { $store: Uve, $network: Rve } = BN(), Gn = {
  connect: async () => {
  },
  disconnect: () => {
  },
  getBalance: async () => "",
  getMetaBalances: async () => [],
  getInscriptions: async () => [],
  getNetwork: async () => "",
  getPublicKey: async () => "",
  pushPsbt: async () => "",
  signMessage: async () => "",
  requestAccounts: async () => [],
  sendBTC: async () => "",
  signPsbt: async () => ({
    signedPsbtBase64: "",
    signedPsbtHex: ""
  }),
  switchNetwork: async () => {
  },
  inscribe: async () => "",
  send: async () => ""
}, yU = vU({
  $store: Uve,
  $network: Rve,
  client: null,
  methods: Gn
});
let C8 = Symbol("clean"), ri = [], gu = 0;
const g1 = 4;
let j1 = 0, zve = (e) => {
  let t = [], r = {
    get() {
      return r.lc || r.listen(() => {
      })(), r.value;
    },
    lc: 0,
    listen(n) {
      return r.lc = t.push(n), () => {
        for (let a = gu + g1; a < ri.length; )
          ri[a] === n ? ri.splice(a, g1) : a += g1;
        let o = t.indexOf(n);
        ~o && (t.splice(o, 1), --r.lc || r.off());
      };
    },
    notify(n, o) {
      j1++;
      let a = !ri.length;
      for (let i of t)
        ri.push(
          i,
          r.value,
          n,
          o
        );
      if (a) {
        for (gu = 0; gu < ri.length; gu += g1)
          ri[gu](
            ri[gu + 1],
            ri[gu + 2],
            ri[gu + 3]
          );
        ri.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(n) {
      let o = r.value;
      o !== n && (r.value = n, r.notify(o));
    },
    subscribe(n) {
      let o = r.listen(n);
      return n(r.value), o;
    },
    value: e
  };
  return process.env.NODE_ENV !== "production" && (r[C8] = () => {
    t = [], r.lc = 0, r.off();
  }), r;
};
const jve = 3, Lve = 5, Ll = 6, m1 = 10;
let bU = (e, t, r, n) => (e.events = e.events || {}, e.events[r + m1] || (e.events[r + m1] = n((o) => {
  e.events[r].reduceRight((a, i) => (i(a), a), {
    shared: {},
    ...o
  });
})), e.events[r] = e.events[r] || [], e.events[r].push(t), () => {
  let o = e.events[r], a = o.indexOf(t);
  o.splice(a, 1), o.length || (delete e.events[r], e.events[r + m1](), delete e.events[r + m1]);
}), Hve = (e, t) => bU(e, t, jve, (r) => {
  let n = e.notify;
  return e.notify = (o, a) => {
    let i;
    if (r({ abort: () => {
      i = !0;
    }, changed: a, oldValue: o }), !i) return n(o, a);
  }, () => {
    e.notify = n;
  };
}), Fve = 1e3, Dve = (e, t) => bU(e, (r) => {
  let n = t(r);
  n && e.events[Ll].push(n);
}, Lve, (r) => {
  let n = e.listen;
  e.listen = (...a) => (!e.lc && !e.active && (e.active = !0, r()), n(...a));
  let o = e.off;
  if (e.events[Ll] = [], e.off = () => {
    o(), setTimeout(() => {
      if (e.active && !e.lc) {
        e.active = !1;
        for (let a of e.events[Ll]) a();
        e.events[Ll] = [];
      }
    }, Fve);
  }, process.env.NODE_ENV !== "production") {
    let a = e[C8];
    e[C8] = () => {
      for (let i of e.events[Ll]) i();
      e.events[Ll] = [], e.active = !1, a();
    };
  }
  return () => {
    e.listen = n, e.off = o;
  };
}), Mve = (e, t, r) => {
  Array.isArray(e) || (e = [e]);
  let n, o, a = () => {
    if (o === j1) return;
    o = j1;
    let c = e.map((f) => f.get());
    if (!n || c.some((f, h) => f !== n[h])) {
      n = c;
      let f = t(...c);
      f && f.then && f.t ? f.then((h) => {
        n === c && i.set(h);
      }) : (i.set(f), o = j1);
    }
  }, i = zve(void 0), s = i.get;
  i.get = () => (a(), s());
  let u, l = () => {
    clearTimeout(u), u = setTimeout(a);
  };
  return Dve(i, () => {
    let c = e.map((f) => f.listen(l));
    return a(), () => {
      for (let f of c) f();
    };
  }), i;
}, Kve = (e, t) => Mve(e, t), qve = (e) => {
  e.listen(() => {
  });
};
function Vve(e, t, r) {
  let n = /* @__PURE__ */ new Set([...t, void 0]);
  return e.listen((o, a, i) => {
    n.has(i) && r(o, a, i);
  });
}
function Gve(e, t = {}) {
  let r = yn(
    (o) => t.keys ? Vve(e, t.keys, o) : e.listen(o),
    [t.keys, e]
  ), n = e.get.bind(e);
  return AU(r, n, n);
}
function Ck(e, t) {
  return Object.keys(e).every(function(r) {
    return Object.prototype.hasOwnProperty.call(t, r) && (t[r] === e[r] || typeof e[r] == "number" && typeof t[r] == "number" && isNaN(t[r]) && isNaN(e[r]));
  });
}
function Zve(e, t) {
  return typeof e == "object" && typeof t == "object" ? Ck(e, t) && Ck(t, e) : e === t;
}
function L5e(e) {
  const { $network: t, $store: r, methods: n } = EU(yU), o = y1(() => {
    const a = Kve([r, t], (i, s) => {
      const u = {
        paymentAddress: i.paymentAddress,
        address: i.address,
        publicKey: i.publicKey,
        paymentPublicKey: i.paymentPublicKey,
        library: {},
        network: s,
        accounts: i.accounts,
        balance: Number(i.balance),
        connected: i.connected,
        isConnecting: i.isConnecting,
        isInitializing: i.isInitializing,
        provider: i.provider,
        hasLeather: i.hasProvider.leather ?? !1,
        hasMagicEden: i.hasProvider["magic-eden"] ?? !1,
        hasOkx: i.hasProvider.okx ?? !1,
        hasOyl: i.hasProvider.oyl ?? !1,
        hasOrange: i.hasProvider.orange ?? !1,
        hasOpNet: i.hasProvider.op_net ?? !1,
        hasPhantom: i.hasProvider.phantom ?? !1,
        hasUnisat: i.hasProvider.unisat ?? !1,
        hasSparrow: i.hasProvider.sparrow ?? !1,
        hasWizz: i.hasProvider.wizz ?? !1,
        hasXverse: i.hasProvider.xverse ?? !1,
        ...n
      };
      return typeof e == "function" ? e(u) : u;
    });
    return qve(a), Hve(a, ({ oldValue: i, abort: s }) => {
      Zve(i, a.value) && s();
    }), a;
  }, [t, r, e, n]);
  return Gve(o);
}
function H5e({
  config: e,
  children: t
}) {
  const r = y1(() => BN(), []), n = y1(
    () => _2e(e ?? { network: Ut }),
    [e]
  ), [o, a] = kU(null);
  xU(() => {
    const _ = new Nve(r, n);
    return a(() => _), _.initialize(), () => _.dispose();
  }, [n, r]);
  const i = yn(
    async (_) => await (o == null ? void 0 : o.connect(_)),
    [o]
  ), s = yn(() => o == null ? void 0 : o.disconnect(), [o]), u = yn(
    async () => {
      var _;
      return ((_ = await ((o == null ? void 0 : o.getBalance()) ?? Gn.getBalance())) == null ? void 0 : _.toString()) ?? "";
    },
    [o]
  ), l = yn(
    async (_) => await (o == null ? void 0 : o.getMetaBalances(_)) ?? Gn.getMetaBalances(),
    [o]
  ), c = yn(
    async (_, I) => await (o == null ? void 0 : o.getInscriptions(_, I)) ?? Gn.getInscriptions(),
    [o]
  ), f = yn(
    () => (o == null ? void 0 : o.getNetwork()) ?? Gn.getNetwork(),
    [o]
  ), h = yn(
    async () => await (o == null ? void 0 : o.getPublicKey()) ?? Gn.getPublicKey(),
    [o]
  ), p = yn(
    (_) => (o == null ? void 0 : o.pushPsbt(_)) ?? Gn.pushPsbt(),
    [o]
  ), y = yn(
    async (_, I) => {
      let O = {};
      return typeof I == "string" ? O = { toSignAddress: I } : I && (O = I), await (o == null ? void 0 : o.signMessage(_, O)) ?? Gn.signMessage();
    },
    [o]
  ), m = yn(
    async () => await (o == null ? void 0 : o.requestAccounts()) ?? Gn.requestAccounts(),
    [o]
  ), b = yn(
    async (_, I) => await (o == null ? void 0 : o.sendBTC.call(o, _, I)) ?? Gn.sendBTC(),
    [o]
  ), v = yn(
    async (_, I, O) => await (o == null ? void 0 : o.signPsbt.call(o, _, I, O)) ?? Gn.signPsbt(),
    [o]
  ), k = yn(
    async (_) => await (o == null ? void 0 : o.switchNetwork.call(o, _)),
    [o]
  ), E = yn(
    async (_, I) => await (o == null ? void 0 : o.inscribe.call(o, _, I)) ?? Gn.inscribe(),
    [o]
  ), A = yn(
    async (_, I) => await (o == null ? void 0 : o.send.call(o, _, I)) ?? Gn.send(),
    [o]
  ), S = y1(() => o ? {
    connect: i,
    disconnect: s,
    getBalance: u,
    getMetaBalances: l,
    getInscriptions: c,
    getNetwork: f,
    getPublicKey: h,
    pushPsbt: p,
    signMessage: y,
    requestAccounts: m,
    sendBTC: b,
    signPsbt: v,
    switchNetwork: k,
    inscribe: E,
    send: A
  } : Gn, [
    o,
    i,
    s,
    u,
    c,
    l,
    f,
    h,
    E,
    p,
    m,
    A,
    b,
    y,
    v,
    k
  ]);
  return /* @__PURE__ */ L(
    yU.Provider,
    {
      value: {
        $store: r.$store,
        $network: r.$network,
        client: o,
        methods: S
      },
      children: t
    }
  );
}
const Wve = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => t === "first" ? /* @__PURE__ */ Pt(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      /* @__PURE__ */ L(
        "rect",
        {
          width: "42",
          height: "42",
          rx: "10",
          fill: "#090A0C",
          style: { fill: "#090A0C", fillOpacity: 1 }
        }
      ),
      /* @__PURE__ */ L(
        "path",
        {
          d: "M21 14C29.222 14 38 15.9676 38 20.9054C38 25.8622 29.222 28 21 28C12.778 28 4 26.0324 4 21.0946C4 16.1378 12.778 14 21 14ZM21.0397 25.3135C24.6939 25.3135 30.1752 24.3297 30.1752 21C30.1752 17.6703 24.6939 16.6865 21.0397 16.6865H20.9603C17.3061 16.6865 11.8248 17.6703 11.8248 21C11.8248 24.3297 17.3061 25.3135 20.9603 25.3135H21.0397Z",
          fill: "white",
          style: { fill: "white", fillOpacity: 1 }
        }
      )
    ]
  }
) : /* @__PURE__ */ Pt(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      /* @__PURE__ */ L(
        "rect",
        {
          width: "42",
          height: "42",
          rx: "10",
          fill: "white",
          style: { fill: "white", fillOpacity: 1 }
        }
      ),
      /* @__PURE__ */ L(
        "path",
        {
          d: "M21 14C29.222 14 38 15.9676 38 20.9054C38 25.8622 29.222 28 21 28C12.778 28 4 26.0324 4 21.0946C4 16.1378 12.778 14 21 14ZM21.0397 25.3135C24.6939 25.3135 30.1752 24.3297 30.1752 21C30.1752 17.6703 24.6939 16.6865 21.0397 16.6865H20.9603C17.3061 16.6865 11.8248 17.6703 11.8248 21C11.8248 24.3297 17.3061 25.3135 20.9603 25.3135H21.0397Z",
          fill: "#090A0C",
          style: { fill: "#090A0C", fillOpacity: 1 }
        }
      )
    ]
  }
), Bk = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => t === "first" ? /* @__PURE__ */ Pt(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 128 128",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      /* @__PURE__ */ L("rect", { width: "128", height: "128", rx: "26.8387", fill: "#12100F" }),
      /* @__PURE__ */ L(
        "path",
        {
          d: "M74.9171 52.7114C82.4766 51.5408 93.4087 43.5804 93.4087 37.3761C93.4087 35.5031 91.8968 34.2154 89.6871 34.2154C85.5004 34.2154 78.4061 40.5368 74.9171 52.7114ZM39.911 83.4991C30.0256 83.4991 29.2115 93.3324 39.0969 93.3324C43.5163 93.3324 48.8661 91.5764 51.6573 88.4157C47.5868 84.9038 44.2141 83.4991 39.911 83.4991ZM102.829 79.2848C103.41 95.7907 95.0369 105.039 80.8484 105.039C72.4748 105.039 68.2881 101.878 59.333 96.0249C54.681 101.176 45.8423 105.039 38.5154 105.039C13.2785 105.039 14.3252 72.8463 40.0273 72.8463C45.3771 72.8463 49.9128 74.2511 55.7277 77.88L59.5656 64.4177C43.7489 60.0864 35.8405 47.9118 43.6326 30.4693H56.1929C49.215 42.0586 53.9832 51.6578 62.822 52.7114C67.5903 35.7372 77.8246 22.509 91.4316 22.509C99.1074 22.509 105.155 27.5428 105.155 36.6737C105.155 51.3066 86.0819 63.2471 71.6607 64.4177L65.7295 85.3721C72.4748 93.2153 91.199 100.824 91.199 79.2848H102.829Z",
          fill: "#F5F1ED"
        }
      )
    ]
  }
) : /* @__PURE__ */ Pt(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 128 128",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      /* @__PURE__ */ L("rect", { width: "128", height: "128", rx: "26.8387", fill: "#F5F1ED" }),
      /* @__PURE__ */ L(
        "path",
        {
          d: "M74.9171 52.7115C82.4766 51.5409 93.4087 43.5806 93.4087 37.3762C93.4087 35.5032 91.8968 34.2155 89.6871 34.2155C85.5004 34.2155 78.4061 40.5369 74.9171 52.7115ZM39.911 83.4992C30.0256 83.4992 29.2115 93.3325 39.0969 93.3325C43.5163 93.3325 48.8661 91.5766 51.6573 88.4159C47.5868 84.904 44.2141 83.4992 39.911 83.4992ZM102.829 79.2849C103.41 95.7908 95.0369 105.039 80.8484 105.039C72.4748 105.039 68.2881 101.878 59.333 96.025C54.681 101.176 45.8423 105.039 38.5154 105.039C13.2785 105.039 14.3252 72.8464 40.0273 72.8464C45.3771 72.8464 49.9128 74.2512 55.7277 77.8801L59.5656 64.4179C43.7489 60.0865 35.8405 47.9119 43.6326 30.4695H56.1929C49.215 42.0587 53.9832 51.6579 62.822 52.7115C67.5903 35.7373 77.8246 22.5092 91.4316 22.5092C99.1074 22.5092 105.155 27.5429 105.155 36.6738C105.155 51.3068 86.0819 63.2472 71.6607 64.4179L65.7295 85.3722C72.4748 93.2155 91.199 100.825 91.199 79.2849H102.829Z",
          fill: "#12100F"
        }
      )
    ]
  }
), Xve = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => t === "first" ? /* @__PURE__ */ Pt(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      /* @__PURE__ */ Pt("g", { clipPath: "url(#a)", children: [
        /* @__PURE__ */ L(
          "path",
          {
            fill: "#AB9FF2",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        /* @__PURE__ */ L(
          "path",
          {
            fill: "#FFFDF8",
            fillRule: "evenodd",
            d: "M17.686 27.567c-1.676 2.569-4.484 5.819-8.22 5.819-1.767 0-3.466-.728-3.466-3.887C6 21.454 16.984 9 27.176 9c5.798 0 8.108 4.023 8.108 8.59 0 5.864-3.805 12.568-7.587 12.568-1.2 0-1.79-.659-1.79-1.704 0-.273.046-.568.137-.887-1.291 2.205-3.783 4.25-6.116 4.25-1.698 0-2.559-1.068-2.559-2.568 0-.545.114-1.113.317-1.681Zm8.78-10.135c0 1.331-.786 1.997-1.664 1.997-.892 0-1.664-.666-1.664-1.997s.772-1.996 1.664-1.996c.878 0 1.663.665 1.663 1.996Zm4.99 0c0 1.331-.785 1.997-1.663 1.997-.892 0-1.664-.666-1.664-1.997 0-1.33.772-1.996 1.664-1.996.878 0 1.664.665 1.664 1.996Z",
            clipRule: "evenodd"
          }
        )
      ] }),
      /* @__PURE__ */ L("defs", { children: /* @__PURE__ */ L("clipPath", { id: "a", children: /* @__PURE__ */ L("path", { fill: "#fff", d: "M0 0h42v42H0z" }) }) })
    ]
  }
) : /* @__PURE__ */ Pt(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      /* @__PURE__ */ Pt("g", { clipPath: "url(#a)", children: [
        /* @__PURE__ */ L(
          "path",
          {
            fill: "#FFFDF8",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        /* @__PURE__ */ L(
          "path",
          {
            fill: "#AB9FF2",
            fillRule: "evenodd",
            d: "M17.686 27.567c-1.676 2.569-4.484 5.819-8.22 5.819-1.767 0-3.466-.728-3.466-3.887C6 21.454 16.984 9 27.176 9c5.798 0 8.108 4.023 8.108 8.59 0 5.864-3.805 12.568-7.587 12.568-1.2 0-1.79-.659-1.79-1.704 0-.273.046-.568.137-.887-1.291 2.205-3.783 4.25-6.116 4.25-1.698 0-2.559-1.068-2.559-2.568 0-.545.114-1.113.317-1.681Zm8.78-10.135c0 1.331-.786 1.997-1.664 1.997-.892 0-1.664-.666-1.664-1.997s.772-1.996 1.664-1.996c.878 0 1.663.665 1.663 1.996Zm4.99 0c0 1.331-.785 1.997-1.663 1.997-.892 0-1.664-.666-1.664-1.997 0-1.33.772-1.996 1.664-1.996.878 0 1.664.665 1.664 1.996Z",
            clipRule: "evenodd"
          }
        )
      ] }),
      /* @__PURE__ */ L("defs", { children: /* @__PURE__ */ L("clipPath", { id: "a", children: /* @__PURE__ */ L("path", { fill: "#fff", d: "M0 0h42v42H0z" }) }) })
    ]
  }
), Yve = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Pt(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      /* @__PURE__ */ Pt("g", { clipPath: "url(#clip0_3_53)", children: [
        /* @__PURE__ */ L(
          "path",
          {
            d: "M32 0H10C4.47715 0 0 4.47715 0 10V32C0 37.5228 4.47715 42 10 42H32C37.5228 42 42 37.5228 42 32V10C42 4.47715 37.5228 0 32 0Z",
            fill: "#181818"
          }
        ),
        /* @__PURE__ */ L(
          "path",
          {
            d: "M32 31.6745V27.6829C32 27.5233 31.9203 27.3636 31.8406 27.2438L14.8225 10.1597C14.7029 10.0399 14.5435 10 14.3841 10H10.3986C10.1993 10 10.0399 10.1597 10.0399 10.3592V14.0715C10.0399 14.2311 10.1196 14.3908 10.1993 14.5105L16.2971 20.6177C16.4565 20.7774 16.4565 20.977 16.2971 21.1366L10.1196 27.3237C10.0399 27.4035 10 27.4834 10 27.5632V31.6346C10 31.8342 10.1594 31.9939 10.3587 31.9939H17.0544C17.2536 31.9939 17.413 31.8342 17.413 31.6346V29.2396C17.413 29.1598 17.4529 29.0401 17.5326 29.0002L20.8406 25.6871C21 25.5275 21.1993 25.5275 21.3587 25.6871L27.4964 31.8342C27.6159 31.954 27.7753 31.9939 27.9348 31.9939H31.6413C31.8406 32.0337 32 31.8741 32 31.6745Z",
            fill: "white"
          }
        ),
        /* @__PURE__ */ L(
          "path",
          {
            d: "M23.3406 15.0793H26.5592C26.7507 15.0793 26.9039 15.2333 26.9039 15.4257V18.658C26.9039 18.9658 27.2871 19.1197 27.4788 18.8888L31.8851 14.4637C31.9617 14.3867 32 14.3097 32 14.2328V10.3463C32 10.1539 31.8468 10 31.6552 10H27.7469C27.6703 10 27.5554 10.0385 27.5171 10.1154L23.1107 14.5021C22.8808 14.6945 23.0341 15.0793 23.3406 15.0793Z",
            fill: "#EE7A30"
          }
        )
      ] }),
      /* @__PURE__ */ L("defs", { children: /* @__PURE__ */ L("clipPath", { id: "clip0_3_53", children: /* @__PURE__ */ L("rect", { width: "42", height: "42", fill: "white" }) }) })
    ]
  }
), Jve = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Pt(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      /* @__PURE__ */ Pt("g", { clipPath: "url(#a)", children: [
        /* @__PURE__ */ L(
          "path",
          {
            fill: "#000",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        /* @__PURE__ */ L(
          "path",
          {
            fill: "url(#b)",
            d: "m25.517 9.483 5.759 5.611c.49.477.731.959.724 1.445-.008.486-.219.929-.631 1.33-.431.421-.897.634-1.395.644-.497.007-.992-.228-1.482-.705l-5.89-5.738c-.669-.652-1.315-1.114-1.936-1.385a2.873 2.873 0 0 0-1.96-.127c-.685.185-1.42.662-2.21 1.428-1.086 1.06-1.605 2.054-1.552 2.983.053.929.593 1.893 1.617 2.89l5.938 5.786c.496.482.74.964.732 1.443-.008.48-.22.923-.64 1.332-.419.408-.88.62-1.382.638-.502.016-1.001-.217-1.495-.7l-5.76-5.61c-.936-.912-1.613-1.776-2.029-2.59-.416-.815-.572-1.737-.464-2.765.097-.88.384-1.732.863-2.558.477-.827 1.161-1.671 2.048-2.537C15.43 9.268 16.438 8.48 17.4 7.93c.96-.55 1.889-.854 2.786-.917.899-.064 1.784.112 2.66.527.876.415 1.765 1.061 2.67 1.943h.002Z"
          }
        ),
        /* @__PURE__ */ L(
          "path",
          {
            fill: "url(#c)",
            d: "m16.482 32.123-5.758-5.611c-.49-.479-.731-.959-.724-1.445.008-.486.219-.929.631-1.33.431-.421.897-.634 1.395-.644.498-.007.992.227 1.482.705l5.888 5.738c.671.652 1.315 1.114 1.936 1.385.622.27 1.276.312 1.962.127.685-.185 1.42-.662 2.21-1.43 1.086-1.06 1.605-2.054 1.552-2.983-.053-.929-.593-1.893-1.617-2.891l-3.164-3.056c-.496-.482-.74-.964-.732-1.443.008-.48.22-.923.64-1.332.419-.408.88-.62 1.382-.638.502-.016 1.002.217 1.496.7l2.983 2.88c.936.912 1.613 1.775 2.03 2.59.415.815.571 1.736.463 2.764a6.477 6.477 0 0 1-.863 2.559c-.477.826-1.16 1.67-2.048 2.536-1.057 1.03-2.066 1.819-3.027 2.368-.962.55-1.89.856-2.79.92-.898.063-1.784-.113-2.66-.527-.876-.415-1.765-1.062-2.67-1.944l.003.002Z"
          }
        ),
        /* @__PURE__ */ L(
          "path",
          {
            fill: "url(#d)",
            d: "M20.073 17.645c1.168 0 2.115-.93 2.115-2.08 0-1.149-.947-2.08-2.115-2.08-1.168 0-2.115.931-2.115 2.08 0 1.15.947 2.08 2.115 2.08Z"
          }
        )
      ] }),
      /* @__PURE__ */ Pt("defs", { children: [
        /* @__PURE__ */ Pt(
          "linearGradient",
          {
            id: "b",
            x1: 30.329,
            x2: 12.579,
            y1: 12.752,
            y2: 20.772,
            gradientUnits: "userSpaceOnUse",
            children: [
              /* @__PURE__ */ L("stop", { stopColor: "#201C1B" }),
              /* @__PURE__ */ L("stop", { offset: 0.36, stopColor: "#77390D" }),
              /* @__PURE__ */ L("stop", { offset: 0.67, stopColor: "#EA8101" }),
              /* @__PURE__ */ L("stop", { offset: 1, stopColor: "#F4B852" })
            ]
          }
        ),
        /* @__PURE__ */ Pt(
          "linearGradient",
          {
            id: "c",
            x1: 12.163,
            x2: 32.789,
            y1: 29.085,
            y2: 22.844,
            gradientUnits: "userSpaceOnUse",
            children: [
              /* @__PURE__ */ L("stop", { stopColor: "#1F1D1C" }),
              /* @__PURE__ */ L("stop", { offset: 0.37, stopColor: "#77390D" }),
              /* @__PURE__ */ L("stop", { offset: 0.67, stopColor: "#EA8101" }),
              /* @__PURE__ */ L("stop", { offset: 1, stopColor: "#F4FB52" })
            ]
          }
        ),
        /* @__PURE__ */ Pt(
          "radialGradient",
          {
            id: "d",
            cx: 0,
            cy: 0,
            r: 1,
            gradientTransform: "matrix(2.11484 0 0 2.08019 20.073 15.567)",
            gradientUnits: "userSpaceOnUse",
            children: [
              /* @__PURE__ */ L("stop", { stopColor: "#F4B852" }),
              /* @__PURE__ */ L("stop", { offset: 0.33, stopColor: "#EA8101" }),
              /* @__PURE__ */ L("stop", { offset: 0.64, stopColor: "#77390D" }),
              /* @__PURE__ */ L("stop", { offset: 1, stopColor: "#211C1D" })
            ]
          }
        ),
        /* @__PURE__ */ L("clipPath", { id: "a", children: /* @__PURE__ */ L("path", { fill: "#fff", d: "M0 0h42v42H0z" }) })
      ] })
    ]
  }
), Qve = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Pt(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      /* @__PURE__ */ Pt("g", { clipPath: "url(#a)", children: [
        /* @__PURE__ */ L(
          "path",
          {
            fill: "#000",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        /* @__PURE__ */ Pt("g", { fillRule: "evenodd", clipPath: "url(#b)", clipRule: "evenodd", children: [
          /* @__PURE__ */ L(
            "path",
            {
              fill: "#FFD815",
              d: "m26.507 17.74-1.623-1.623-1.624 1.623 1.623 1.623 1.624 1.624 1.623-1.624-1.623-1.623Z"
            }
          ),
          /* @__PURE__ */ L(
            "path",
            {
              fill: "#FF9813",
              d: "m26.507 8-1.624 1.623 1.624 1.624 1.623-1.624L26.507 8ZM33 14.493l-1.623-1.623-1.624 1.623 1.624 1.623L33 14.493ZM23.26 27.48l1.623 1.623 1.624-1.623-1.623-1.624-1.624 1.624ZM11.897 16.117l1.623 1.623 1.623-1.623-1.623-1.624-1.623 1.624ZM20.014 8 18.39 9.623l1.624 1.624 1.623-1.624L20.014 8ZM13.52 11.247l1.624 1.623 1.623-1.623-1.623-1.624-1.624 1.624ZM31.377 19.363l-1.624 1.623 1.624 1.624L33 20.987l-1.623-1.624ZM28.13 25.856l1.623 1.624 1.624-1.624-1.624-1.623-1.623 1.623Z"
            }
          ),
          /* @__PURE__ */ L(
            "path",
            {
              fill: "#5B5B72",
              d: "m26.507 20.986-1.624-1.623-1.623 1.623-1.623-1.623-1.623-1.623 1.623-1.624-1.623-1.623-1.624-1.623-1.623 1.623 1.623 1.623-1.623 1.624 1.623 1.623-1.623 1.623-.812-.811-1.623 1.623 1.623 1.623-1.623 1.624-1.543 1.542-1.542 1.543-1.624 1.623L8 31.377 9.623 33l1.624-1.623 1.623-1.624 1.543-1.542.08-.08 1.462-1.463.08-.08 1.544-1.543 1.623 1.623 1.623-1.623-.811-.812 1.623-1.623 1.623 1.623 1.623-1.623 1.624 1.623 1.623-1.623-1.623-1.624Z"
            }
          ),
          /* @__PURE__ */ L(
            "path",
            {
              fill: "#FF9813",
              d: "m26.507 14.493-1.624-1.623-1.623 1.623-1.623-1.623-1.623 1.623 1.623 1.623-1.623 1.624 1.623 1.623 1.623 1.623 1.623-1.623-1.623-1.623 1.623-1.623 1.624 1.623 1.623-1.623-1.623-1.624Z"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ Pt("defs", { children: [
        /* @__PURE__ */ L("clipPath", { id: "a", children: /* @__PURE__ */ L("path", { fill: "#fff", d: "M0 0h42v42H0z" }) }),
        /* @__PURE__ */ L("clipPath", { id: "b", children: /* @__PURE__ */ L("path", { fill: "#fff", d: "M8 8h25v25H8z" }) })
      ] })
    ]
  }
), e8e = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Pt(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      /* @__PURE__ */ Pt("g", { clipPath: "url(#a)", children: [
        /* @__PURE__ */ L(
          "path",
          {
            fill: "#000",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        /* @__PURE__ */ L("g", { fill: "#fff", clipPath: "url(#b)", children: /* @__PURE__ */ L("path", { d: "M24.578 17.052h-6.787a.523.523 0 0 0-.52.52v6.788c0 .286.235.52.52.52h6.787c.286 0 .521-.234.521-.52v-6.787a.523.523 0 0 0-.52-.521ZM16.733 9.223H9.946a.523.523 0 0 0-.521.521v6.787c0 .286.235.521.52.521h6.788c.285 0 .52-.235.52-.52V9.743a.523.523 0 0 0-.52-.52ZM32.424 9.223h-6.787a.523.523 0 0 0-.521.521v6.787c0 .286.235.521.52.521h6.788c.286 0 .52-.235.52-.52V9.743a.523.523 0 0 0-.52-.52ZM16.733 24.898H9.946a.523.523 0 0 0-.521.52v6.788c0 .285.235.52.52.52h6.788c.285 0 .52-.235.52-.52v-6.788a.523.523 0 0 0-.52-.52ZM32.424 24.898h-6.787a.523.523 0 0 0-.521.52v6.788c0 .285.235.52.52.52h6.788c.286 0 .52-.235.52-.52v-6.788a.523.523 0 0 0-.52-.52Z" }) })
      ] }),
      /* @__PURE__ */ Pt("defs", { children: [
        /* @__PURE__ */ L("clipPath", { id: "a", children: /* @__PURE__ */ L("path", { fill: "#fff", d: "M0 0h42v42H0z" }) }),
        /* @__PURE__ */ L("clipPath", { id: "b", children: /* @__PURE__ */ L("path", { fill: "#fff", d: "M0 0h42v42H0z" }) })
      ] })
    ]
  }
), t8e = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Pt(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    className: r,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      /* @__PURE__ */ Pt("g", { clipPath: "url(#clip0_17_93)", children: [
        /* @__PURE__ */ L(
          "path",
          {
            fill: "#070C34",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        /* @__PURE__ */ L(
          "path",
          {
            fill: "url(#paint0_linear_17_93)",
            d: "m27.666 16.837 1.874 2.177c.215.245.404.446.483.562.56.55.874 1.293.874 2.07-.053.915-.657 1.54-1.213 2.205l-1.311 1.521-.685.79a.184.184 0 0 0 .046.281c.033.02.07.028.107.026h6.835c1.045 0 2.36.868 2.283 2.184 0 .597-.247 1.171-.68 1.595a2.36 2.36 0 0 1-1.637.664H23.936c-.704 0-2.598.076-3.128-1.521a1.841 1.841 0 0 1-.043-1.035 4.5 4.5 0 0 1 .72-1.404 65.543 65.543 0 0 1 1.695-2.343c.741-1.002 1.503-1.971 2.251-2.992a.19.19 0 0 0 .04-.116.19.19 0 0 0-.04-.116l-2.72-3.156a.192.192 0 0 0-.153-.073.192.192 0 0 0-.152.073c-.728.96-3.917 5.203-4.598 6.063-.68.86-2.355.907-3.283 0l-4.255-4.161a.197.197 0 0 0-.1-.053.195.195 0 0 0-.2.082.192.192 0 0 0-.032.106v8a2.678 2.678 0 0 1-.494 1.594c-.33.466-.804.823-1.352 1.014a2.375 2.375 0 0 1-2.111-.293 2.271 2.271 0 0 1-.72-.805A2.22 2.22 0 0 1 5 28.736V14.349a2.416 2.416 0 0 1 .548-1.422c.33-.406.785-.7 1.298-.841a2.632 2.632 0 0 1 2.502.664l6.54 6.381c.019.02.043.034.07.043a.197.197 0 0 0 .161-.013.188.188 0 0 0 .061-.054l4.646-6.27c.215-.254.485-.46.79-.601.304-.142.636-.217.976-.221H34.68c.33 0 .657.07.959.204a2.31 2.31 0 0 1 1.263 1.409c.096.309.122.633.079.952a2.288 2.288 0 0 1-.813 1.42c-.439.364-.996.56-1.572.551h-6.768a.188.188 0 0 0-.163.099.187.187 0 0 0-.022.095c0 .032.013.065.032.093h-.008Z"
          }
        )
      ] }),
      /* @__PURE__ */ Pt("defs", { children: [
        /* @__PURE__ */ Pt(
          "linearGradient",
          {
            id: "paint0_linear_17_93",
            x1: "-0.315",
            x2: "35.366",
            y1: "9.343",
            y2: "30.176",
            gradientUnits: "userSpaceOnUse",
            children: [
              /* @__PURE__ */ L("stop", { offset: "0.23", stopColor: "#FF0074" }),
              /* @__PURE__ */ L("stop", { offset: "0.26", stopColor: "#FF0068" }),
              /* @__PURE__ */ L("stop", { offset: "0.32", stopColor: "#FF0048" }),
              /* @__PURE__ */ L("stop", { offset: "0.39", stopColor: "#FF0015" }),
              /* @__PURE__ */ L("stop", { offset: "0.41", stopColor: "#FF0009" }),
              /* @__PURE__ */ L("stop", { offset: "0.43", stopColor: "#FF0908" }),
              /* @__PURE__ */ L("stop", { offset: "0.54", stopColor: "#FF4003" }),
              /* @__PURE__ */ L("stop", { offset: "0.62", stopColor: "#FF6201" }),
              /* @__PURE__ */ L("stop", { offset: "0.66", stopColor: "#FF6F00" }),
              /* @__PURE__ */ L("stop", { offset: "0.72", stopColor: "#FF8700" }),
              /* @__PURE__ */ L("stop", { offset: "0.83", stopColor: "#FFAB00" }),
              /* @__PURE__ */ L("stop", { offset: "0.92", stopColor: "#FFC100" }),
              /* @__PURE__ */ L("stop", { offset: "0.98", stopColor: "#FFCA00" })
            ]
          }
        ),
        /* @__PURE__ */ L("clipPath", { id: "clip0_17_93", children: /* @__PURE__ */ L("path", { fill: "#fff", d: "M0 0h42v42H0z" }) })
      ] })
    ]
  }
), r8e = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Pt(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    ...n,
    children: [
      /* @__PURE__ */ Pt("defs", { children: [
        /* @__PURE__ */ L("clipPath", { id: "clip1", children: /* @__PURE__ */ L("path", { d: "M 9.433594 0 L 32.566406 0 C 37.777344 0 42 4.222656 42 9.433594 L 42 32.566406 C 42 37.777344 37.777344 42 32.566406 42 L 9.433594 42 C 4.222656 42 0 37.777344 0 32.566406 L 0 9.433594 C 0 4.222656 4.222656 0 9.433594 0 Z M 9.433594 0 " }) }),
        /* @__PURE__ */ Pt(
          "radialGradient",
          {
            id: "radial0",
            gradientUnits: "userSpaceOnUse",
            cx: 0,
            cy: 0,
            fx: 0,
            fy: 0,
            r: 1,
            gradientTransform: "matrix(0.000000000000001938,31.643555,-31.643555,0.000000000000001938,21,5.578125)",
            children: [
              /* @__PURE__ */ L(
                "stop",
                {
                  offset: 0,
                  style: {
                    stopColor: "rgb(5.098039%,5.490196%,7.058824%)",
                    stopOpacity: 1
                  }
                }
              ),
              /* @__PURE__ */ L(
                "stop",
                {
                  offset: 1,
                  style: {
                    stopColor: "rgb(0%,0%,0%)",
                    stopOpacity: 1
                  }
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ L(
          "image",
          {
            id: "image91",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAIOUlEQVRYhe2YW4jcVx3HP+fyv8785z+XveUm040xaWraitaHFmkfpKCI6LMgLWq9IUUpiA9CwRdfiqBPtbbWy5MKhRbxnuZFRUSMxhBr2nR6Sdrd2ezOzs7szP9yzvFhdus2TEzWJD7l+zQw53/Oh+/vcjg/uKmbuqmbuqlrkbhB+8o2+CFUUoj6EEWgAQ/Ah2IMpQcbS5C9CkMg/3+Cyjb4GpIE4gLSCsROkyKJLCilAEHpWwbS0M8LNvrQG0KvAxngbiTo2wBzaISahpGknqTxxGE1RLoPSCkWcIwN7p9hYX/54Asc0YKLOuPNElYL6P0J+jcCVLQhKCFOoQo0Ak3NSGaUZPbJI2qolXvECXHnlG83TemeeOxf9jcvlXh+zvk+LC9B9wJsXk9Qrw2VBsQWGnriYAvJ7FOH6ChfPSIE91/pDGF57tNnzO8Cy8tRxusZLGdw8Y8wulZQeRgqGioGalWol4pZJ5n77iKnKon6jIVPAuHVbmgL99jDZ+252PCyzni1AW8uwvBRGL916G4A2xC+E1oRtBTsjTW3FB6HF2PUj2+TrShRz1p4aDeQANITn/pWmxdKzXwY0ahCDISnwd9eo69iH9HeysPKVh4qTVNK5oxg9odH1UUh3TecELfvBu4S1YUv3++UHStHWvjUKj7ZiQHl821k0sJcCVQuQpJCRUBqoYnPjJPMf+8Q5zxfPegE94O45u4h4BCWV0pN4kHse4RH6+TeALHBf3fU2w+JDzULc2I7D2/hVCVRH7aObztBcK2Ab4EKAqEIlCASkghDMLJ4PeBjUFwO1HsHVJtQk7BgfPYeDBl//aDcJ6X4poW5631VGMuKAO05VAAq9FAzErWi4LfruKmg+0HLSagXrE/7+0c47/nqMeCu64s3kXMUFPaMZ2kriUsDpK/xuhnBLGSHUsTUqs8gDaFlFXuevJVz2lc/uFGQAM7y+6+8xj2BoKhpjK9xkUMuhojcw39hk2AqaAoVH1KjWQi0+pqAW24UJM69bo15JpYM6ophYskrAtP0EP0YX1nkYnwZR0tIjKLxs8P8A8FHbhikdWeKsf3OV1/mfVXJeiLpJyGjhocFSD1EWIdzGj01R32olpJ6oeSt8up67a7kHD1n3XOPv277ZzPuqCuWZwQrDUV/XrM5F5LrEreaIRohbHqoqRAStIVQKnHg+hKSO2uP58Yd//JL3BspaGi6s4qlpsdaXdGvK8ZNR+4iysEIt33FTQV1IAVojSvK69OHnLXur6a0z37hJe6OFXc1PN6oC1Ybkm7dY63hc3HWsZEKRmODnSsxmcD1AJddpj0BTkgsjrPXymmte8VYnvn8WXssktzRUlxINOtVyWoq6DV91usevaZjY49g5DvyekzZHeH2B+QXMhziMo7mYHxLMSrsSc9T6wjSXRM61p11P3/8Nds/NeJgy+N8LOinirUU1hKf/oxgPQgYzVoGM5KRceR7fcbnR7h9AdmFDOfJSWFN9esgvNdTvKsQvPund8hEC/GlXQDmztrj49I9//A57qsq1iqKfl2ylkCv7rOeKjbSkEHdMYgtxYJi2DeYGUeWCdzMDsh2SNEdgpp2VgqpllSlJPzbqjv/waasIK/YSx2WvxSlefJzL3LgxDozDc1KU9KdlSzNKJZnQ7rzMavzgn7VMJqHYaoZeZBXLIWRGOnIhxa7GJMXGbZbQCZwU0FjiJRDe4JwxdL+eOCekr6QUoojTEsX614sS55+6KxNjq9TTxUXm5qVumKppVieDViZ16w0fQZzJcMFGLY8htKjqOdkQzCxIyvAlAo7YykubAFmY+xRTT419A1IF2DOwn5f0baKtpXs/dERfq2Q9wopDipBaKy9WFpx5osv2veEgmGsGMSCjZpmvQ69xKdfE6zXAsbzgmFLMKpCtiGxiaUsS8y+kHFnDEphZg1FF7ACl4+wx0KKHtDpXCZH2xCOoNaA+QjmpWKfUewVihaCVAgCZVFK4gJJEQpGFcFmRdBvSjZqIesVwaAZMW5YhrGjmFcMNkpsVVEGhtJITGgphhLbsuTbgGYTl4wpjMD1etADhmCnVn0HsvugfxrkASi1wcSKgRDMCEcqJaH2UNpCJCgriix1jFKPfkMxjAKyBclAG0wDxqEm146iBWbksB7kpcO1KmR2CF2gGGG3AZfWcUvgMnAJuHugvGyXdCCOQLU+eb/Uqh71miIpJUkoCYXDqypcoBBVQdHyGDcjxg1N5hlMXTD2FIUwmKqlGEnsnE/+5iVh3gm40ns74F1QdoBT4K7UzsV9UGmDthE1rYlSjR8pvMwQxwEqFbhEYGcEpe9jW4rCCRyWMjGUmcDtD8gul4cHxhSdHnTBbYDdBjwBbOyYmlzVvfMohBF4pkqofIKaRYceXsUhIx9RGHTFh5ai9H3IczBbDo7HMJTYd0Tk3eFkyFSMsEcj8k4POr1JDvpgpwGubv2+6gvyNPjLILsQHAKxXMXfHyHXSvy4jhAjRBhOkj9k8iBXCgMwrZpPdiZrV8Fsu/jcFMBdOfoW7G348RD59w6eraOCEM8ZVJvJW7pSgXMZej6gXMrQSUkJb3dxu910JyBmZx5eCrlnt6HfqZ/chj88jXygDb/o4++xyDvr8Ac1GRYoO9lTOoQVk4N29sSTnUmoE3C3Q3GC/4R6p4vbkJ+FAnY3KQFgMcS9AvbpDnyoRv6GxJ7swdGE/O6EPFdYI3GFwuYj7GFHdiycFMyfO7gh2E9AXtuCnKZLIeF/HJI9Dl4G8hiIB9rwqwHeG1VUfev/+iXrOz0oBW5zDftRKDrANuSlbk6DBPg3vtO3svqbCX0AAAAASUVORK5CYII="
          }
        ),
        /* @__PURE__ */ L(
          "filter",
          {
            id: "alpha",
            filterUnits: "objectBoundingBox",
            x: "0%",
            y: "0%",
            width: "100%",
            height: "100%",
            children: /* @__PURE__ */ L(
              "feColorMatrix",
              {
                type: "matrix",
                in: "SourceGraphic",
                values: "0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"
              }
            )
          }
        ),
        /* @__PURE__ */ L(
          "image",
          {
            id: "image170",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAACtklEQVRYhWNgGAWjYBSMglEwCkYcmGslLagZ26TedkTUMOD/H11nY2a5Sb+/sJBiBiOtHMfAwMCg73JCaNrNdN2kh/eF0eXKFXf+qZBhvfbqqMkdYsxior7zGBjUK65yXtwsbBq4/7wDNkcyMDAwdN53ZxE87KQX4tNtRIyZVA1Rc3M7ZpZn5eoNd1lVc1hCmInVJ7ov4fwRl0n38amhWoiyP3kmPbfVyfXNw0gNUhzJwMDA8D/3q1bnt2a8bqE4RFPWPhRMLPDTwxXFxIKtN84cUdFSe4VLnuwQhaVDmbBtjpQ6koGBgWHPo6d8+ORJKiIYGBDp0CgsQTXM4Dczw+9y8l2HBB4kJFEv6p2NmeVYi1m170ewcVLmLEzw6HHhye/yjU9xyRMV9XaXNnLcmHTA9slpbhNaONLtgvpfZV5TnOmTgYGIEP3LGciWdPSB/QmDu7zUcxoquNv66c6fWoZL+NQQDNFwZysdWjpS8mnzhzsL664RUoc3M9ld2sixVWiFvBz13IUC2HjqXtzv4z+jcCf/DyG1eKOeb66bnGTiCRPqOQ0Ccpjzvq3gTr5y9IviE2L14I163YZ8HsqdhQDP3hn9vf8m5tq3r+y7SHEkAwOBqH/ncPYvZU6DgEjWToYZ/8UefWbsusrwd9p3ckpevCEqdNL9E5lug4N58opvn6zy2v/iX/AZhr8nv5NrDl6H7vx0/ZXyhqBf5BisuOLXdxnTr2esH188OCdY/j15zkMAguUoX8haFclViXrEGvjsndHfn/+0bjbzSN4q56r9R5nzEICoKlQvzsrk54IreEspWDp8wdh1lZIoxgWIrusrJBTVpl6R15QSOofR1qzc+eH1kW+Pr1AjiqkCJv3+wuJszCwnwaeq23ZE1JC9Q0ktq+09/0C7axSMglEwCkbBKKA/AABq8ekilgplTAAAAABJRU5ErkJggg=="
          }
        ),
        /* @__PURE__ */ L("mask", { id: "mask0", children: /* @__PURE__ */ L("g", { filter: "url(#alpha)", children: /* @__PURE__ */ L("use", { xlinkHref: "#image170" }) }) }),
        /* @__PURE__ */ L(
          "image",
          {
            id: "image125",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAEF0lEQVRYhe2WTYscVRSGn3NvVXdPzySabwQN2SlGkQgjCC4EFWMU/A+CG925EhN0JSiof8BtxC8SSVZZiK7MRjRElPwEF8Ik0z3d9XXPOS6qJhM1pHucGXHRLxRFN9Sth/d977kFCy200EILLfR/kvwXL/n69NFvs6Y56MmGjUIlsU55TK9998eT866xp6DfvHTkcm9Snop1epBkqDuNQulCHWNT9Xq/s5FOv/7rxo1Za2V7AXjhzLEv+pPy5ODm+KSoSlQDdZI5GCQVCtdcKzuuw/5V4MCsNXfV0S9feeD8YKM4vlKVq5J0kJsR3Ajq4JAcygSjBOMkbEhEl3Ky+5dGb/6wdt+91t41Ry8+f+jS8tr6M3nTHNwEjO5EBxdwQFwIAcBxcxSjqY1Q6vKs9XcMevHMka+WxtPV/mh8IqiSWwcISJdXCIFkYIB5+5/jaHJSdIJa3DPQCy8f+3w4nj7auzl6PDYq0YzMncwcCYBDkIAByaAxaBxq2/pdG6iC2ez3bRv0dg/X1p8KSfu5GcGMgBMFEBAEFyG1ewg1qB3qBJVCqU6lLbDOCbEt0AvPHbyyf219Nd7Rw+BOJrQOGnjnYrfRW/e8A0zOVJ0iQaFQK7hu1WHHoJ+9ePTKynjy8HC0cSIzpff3HhpICLc7qNbu8Mah0TbmonEKc6YJxg1MGiikBWiH1g5Bz79w7Pul9Y3Hsro+nJkykLv38E4HN11sNmO21sVJgo0E0wSlQQpCiELMg+4Y1CfFQxTN4dyULBhBWhfv1sOmm5W1Qp2c0pxSaSEVyqaNfCqCBSH2I/kg03wQZ87ze4J++uzhn8NocsJUMTcQcAOTgPtfY07eRlwlpzYo7ujitLuXBjWCx0DWjwxX8rRvf+5vXV3r7Qg01WlfXVmM6m2sgAQB6SB9K+5aodqMWWHadIDWXgnBsoDkgf4g08Ew0+u/jT++DO/MgpwJqrUNK3OkcfIAwQR1QLbibiHbmKvOvYlCqVAZ1CZoDHge6PWi5ctZWh5mcvanW/15AOcCTU5UBVOQbozkAuCdm23MlbbRFtqe5UWCMggmAoNA7EUfLGVpaZhx7tr6tgDnArUQaFyoVUjm1Or0usPuzsgLawHL7rSpRPAQyHqRwXKWloaZvXt99K8A5wINecg0hFQgWZmEQpzYQOiiT9qC1d7GnOSfPfzlxviDS8Z7O4GEOT7z3n9i/6hcr/bV0wZJRugect8aRykIEgOSBXr9aPnwdg9n7uZdA3018MapR1Y+KTaaflMlUmrnknePexQkD/Ty6P1hloZLkXPX1ncNcG5QgI+ePlSMxrVURerVlYl3oCEIsRfo92MaDqKf3QPAbYFu6sPVA1XdKEk9OEgWxXt54O0fb+V7BbjQQgsttNBC/0/9CbvrotNPsOneAAAAAElFTkSuQmCC"
          }
        ),
        /* @__PURE__ */ L(
          "image",
          {
            id: "image142",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAAmklEQVRYhe2U0QqAIBAE1/7/n+tFIaQyur21aAdEX4RhDgWMMemUul7BkciZ3JopMqKXGhWcJltOzldMkS3dfhe5bOTBSGWXwF3pjxARBYSyUVFAJMsQBQSyLNF0mKKpVdlF02R/OfpGStWsonTZX4++Qa3qohVaVRfdQanqoh3hqi7KRikaGr+LslGLPh6/i7KxKBuLsvmM6AZK+AVU/UCtAQAAAABJRU5ErkJggg=="
          }
        ),
        /* @__PURE__ */ L("mask", { id: "mask1", children: /* @__PURE__ */ L("g", { filter: "url(#alpha)", children: /* @__PURE__ */ L(
          "rect",
          {
            x: 0,
            y: 0,
            width: 42,
            height: 42,
            style: {
              fill: "rgb(0%,0%,0%)",
              fillOpacity: 0.6,
              stroke: "none"
            }
          }
        ) }) }),
        /* @__PURE__ */ L(
          "image",
          {
            id: "image148",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAEI0lEQVRYhe3XTW4kuREF4I9kZqX+7B61gAFGR5CWPsucZ9zn6Sv4Ct5ZfQAv1IABuaftaUlVmWR4kZS6tPKitBjDegCRZBaT9RA/Lxi84Q1veMMbDkF6msTTPPChz28kP+NTX99+3/+MSwGuhI+47utfhETS169BNEgvCF5JPkluJZeSO8lF/+3rHtl3ncSdcCHcCpfCjXAtXpPs8ILkjeRa8kVyJ7uUkE0SknvJuz2idzgWJg3hUkNzLlxpPiBEJOlQsilI/txJnu+RI7tXJPl5TJKtZJaMwiRshdCE5lhF8141aT4LNL+IlA4jml+QnGRfFQwejE6Mso1qMplwpDl2tj6POTKZVJNs49GIwd8NPituJVfSc0gdgAFcd9d+lb1T/GpwrPhmlAyKwaKoiiy7lxTxsNX626paDDJmZ9At/hd80Q4lmt30pCErsgdFMUg2Tm1kR5IjyYlwKpwa+zOcSk40xzbdst9sMLhXDD2Ufj6UJsOe/GRniq3BHwxmG4uNbFKMFhvJICua1L+omA3mHsfJpsflieY3zZ32LG8HEf0keS/5Z0+gSTEbVWNfTZpJ6cRDUSRNqKowS7bmrh5VM/dwyKqLZ48dSPR2T3pWCsXOIPdEaibVUSe9urVKslAsmkHuKlBVG7MHA93Kt3KXrQOJ/gnfJA/dootiUIRBMqg2hp75q2WH7vjAIssDbVlUYbE1SP2cU0k93Jor0c/doqw2mCRNlrtMMQijbBRGYUDWRElSJRYWydzTsXhUjJLHfu7d4WTz8+xYspEsUo/B78KvOzo6kbyGSE2KppT9fbV/v3StuH8di+b/vuX3ge9EH4SdMAhVyF1mnsYabVXrI9QSa2bX/X2lfz8Ij8LJ69yesp+EP/bDRmHutbuqWDzFXzMXdpoZO9murlV/HWHp9WmVplk46udevMLtyV+td8roFhlUO1W2CItit+a2VJNQ1C74a9aHnWRnsFN7mZi79R+Ef4leUg8keim8F/4h/KiiShbVjNKTg6RZVHlP8Jsqm4WtpRN+tGiq0ndcam5fw6JXwifhx27RrWoy00siqxgtandz2RP8JptVs9HWbKeYHVlQewmN5y7gIKIfcd4vvb+piuTfXU/HnhBh0SxjUebaLVp7smXLJsy7MCt2dmajxb2qai6Eq9cguvY4659WyZnqV0kI30SX/8Fonmu/SDdPJaIJdRe95ofFqRmLE9Vd99LHQ2k+ydNN73cWzVfVD6sFLXaKrerR4MHkXnP/4jl4UD0abTU7T0qxhlF77p8OxP9QK8La2l6LfhNvflLdqU7Mjs0WO5Ote1uTrTOPJlt3/f1i57i7nMXfNOf9rN6JHoohWbtEIXwA4Vzq7W9yqdlKziQnXrbLT0K+Fc722uUvXUleubd/wxve8IY3/B/gP+5/MI8x65+AAAAAAElFTkSuQmCC"
          }
        ),
        /* @__PURE__ */ L("mask", { id: "mask2", children: /* @__PURE__ */ L("g", { filter: "url(#alpha)", children: /* @__PURE__ */ L(
          "rect",
          {
            x: 0,
            y: 0,
            width: 42,
            height: 42,
            style: {
              fill: "rgb(0%,0%,0%)",
              fillOpacity: 0.701961,
              stroke: "none"
            }
          }
        ) }) }),
        /* @__PURE__ */ L(
          "image",
          {
            id: "image154",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAA/ElEQVRYhe2VwW7DIAxAn9M0qcSN///G3JDaFEIPwRvqoUHdWKXJT/IhMokeNiZgGIZhGIZh/EPkVTLnLGWNxvD0Ti6xAVlEtk6eDA1rBDgBZ2ACZu/9DMzleSz5lm+9zVFFh0pyrELYK5m89/dlWSIQRWT9lOipiE1VnCvRCKwaInLtJXrULj2Xdesn4EJpvXPuT1o/NqxR2Vp4YB+gLYSgki+781PeqUL+dYsGWkT1+tmAxH4uNZJzLpVc1w0ctV4lE3Dne4i+himEEEu+2x0KxxV9Fr0B1ypu3vuVvbpdRVv+TDpEGvXmdBMJ2EQkdvI0DMMwDMMwjI/yAInrT4nWGUiJAAAAAElFTkSuQmCC"
          }
        ),
        /* @__PURE__ */ L(
          "image",
          {
            id: "image160",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAACY0lEQVRYhe2W227iQBBEj7mFcAkbZf3/HxjtLUtCAtjeh6laN9YSDCHSPkxLrZE92BzXVPcM5MiRI0eOj0RxzZc1TeP3FcBAoxOgCWOtsSmKouFEjD4JcNgZBx3ASlmH688FFWQEHAJj5Uhp0ArYA7uQvv85oAGw6ABOgClwoxwLtBbkG/CqhNYO1wUNy+wl7QLeAjPlNIBWgnzRM9Bz2c8CPeJDL/GNAOfAIuSt5gG2AbImLfuW1hYfBz3iw4kApyT1FsBSeafraQDb6P8q0rKPNder87wL2sOHBlwIzrnU3ESvsnJb2iKL7ety0H+oOOoAzgW0HA6Hd1VVrXS90NxEz+5JBdNtUXG8HDRClmU5fnx8dKFEBVfAqqoqqzjXhxiyInnR1e7c6r576VVADWkFV8ovSvvxluRZ+24PvA0Gg+e6rn8DzjXJr1v9phfoexVnX45JKs0FdQ98BUqN97o/04c3AlwDP+u6/g58U/4Q7AvwWpblri/oUSM3TeO2MyMpeQ88CO6BpOZSH2FAL/ELSbkn4JfySfkXFKlaFMX+FGifpXcRuVc6b8Lz7okb4FkwT51cC3Cjj7F3r+JRwxrYhwz0B1vawogqRvUi4GsAdCFdbQv1i7zd7Wj36SFtA19zqOSapK4V7FZ6DdDniHcKtKHtdTv92YZUXA1JJTS34bCqnzn0oQErzjiDngPqE4/95y1wQ7s1Rm9GwK4P60sA+4LGpfZRzft0EeattgHdIw98eCnkOaDQqudjm+/5IOzCioBn+fAjoPZnhPZhwqD2XlfBi5c5R44cOXLkyJHjv40/gQUmD3HnzocAAAAASUVORK5CYII="
          }
        ),
        /* @__PURE__ */ L("mask", { id: "mask3", children: /* @__PURE__ */ L("g", { filter: "url(#alpha)", children: /* @__PURE__ */ L(
          "rect",
          {
            x: 0,
            y: 0,
            width: 42,
            height: 42,
            style: {
              fill: "rgb(0%,0%,0%)",
              fillOpacity: 0.2,
              stroke: "none"
            }
          }
        ) }) }),
        /* @__PURE__ */ L(
          "image",
          {
            id: "image166",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAACY0lEQVRYhe2W227iQBBEj7mFcAkbZf3/HxjtLUtCAtjeh6laN9YSDCHSPkxLrZE92BzXVPcM5MiRI0eOj0RxzZc1TeP3FcBAoxOgCWOtsSmKouFEjD4JcNgZBx3ASlmH688FFWQEHAJj5Uhp0ArYA7uQvv85oAGw6ABOgClwoxwLtBbkG/CqhNYO1wUNy+wl7QLeAjPlNIBWgnzRM9Bz2c8CPeJDL/GNAOfAIuSt5gG2AbImLfuW1hYfBz3iw4kApyT1FsBSeafraQDb6P8q0rKPNder87wL2sOHBlwIzrnU3ESvsnJb2iKL7ety0H+oOOoAzgW0HA6Hd1VVrXS90NxEz+5JBdNtUXG8HDRClmU5fnx8dKFEBVfAqqoqqzjXhxiyInnR1e7c6r576VVADWkFV8ovSvvxluRZ+24PvA0Gg+e6rn8DzjXJr1v9phfoexVnX45JKs0FdQ98BUqN97o/04c3AlwDP+u6/g58U/4Q7AvwWpblri/oUSM3TeO2MyMpeQ88CO6BpOZSH2FAL/ELSbkn4JfySfkXFKlaFMX+FGifpXcRuVc6b8Lz7okb4FkwT51cC3Cjj7F3r+JRwxrYhwz0B1vawogqRvUi4GsAdCFdbQv1i7zd7Wj36SFtA19zqOSapK4V7FZ6DdDniHcKtKHtdTv92YZUXA1JJTS34bCqnzn0oQErzjiDngPqE4/95y1wQ7s1Rm9GwK4P60sA+4LGpfZRzft0EeattgHdIw98eCnkOaDQqudjm+/5IOzCioBn+fAjoPZnhPZhwqD2XlfBi5c5R44cOXLkyJHjv40/gQUmD3HnzocAAAAASUVORK5CYII="
          }
        ),
        /* @__PURE__ */ L("clipPath", { id: "clip2", children: /* @__PURE__ */ L("rect", { x: 0, y: 0, width: 42, height: 42 }) }),
        /* @__PURE__ */ Pt("g", { id: "surface169", clipPath: "url(#clip2)", children: [
          /* @__PURE__ */ L("use", { xlinkHref: "#image125" }),
          /* @__PURE__ */ L("use", { xlinkHref: "#image142" }),
          /* @__PURE__ */ L("use", { xlinkHref: "#image148", mask: "url(#mask1)" }),
          /* @__PURE__ */ L("use", { xlinkHref: "#image154", mask: "url(#mask2)" }),
          /* @__PURE__ */ L("use", { xlinkHref: "#image160" }),
          /* @__PURE__ */ L("use", { xlinkHref: "#image166", mask: "url(#mask3)" })
        ] })
      ] }),
      /* @__PURE__ */ L("g", { id: "surface1", children: /* @__PURE__ */ Pt("g", { clipPath: "url(#clip1)", clipRule: "nonzero", children: [
        /* @__PURE__ */ L(
          "path",
          {
            style: {
              stroke: "none",
              fillRule: "nonzero",
              fill: "url(#radial0)"
            },
            d: "M 9.433594 0 L 32.566406 0 C 37.777344 0 42 4.222656 42 9.433594 L 42 32.566406 C 42 37.777344 37.777344 42 32.566406 42 L 9.433594 42 C 4.222656 42 0 37.777344 0 32.566406 L 0 9.433594 C 0 4.222656 4.222656 0 9.433594 0 Z M 9.433594 0 "
          }
        ),
        /* @__PURE__ */ L("use", { xlinkHref: "#image42" }),
        /* @__PURE__ */ L("use", { xlinkHref: "#image91" }),
        /* @__PURE__ */ L("use", { xlinkHref: "#surface169", mask: "url(#mask0)" })
      ] }) })
    ]
  }
), n8e = [
  { transform: "translate(40.2375 0.627991) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.627991)",
    fill: "#FFDE31"
  },
  { transform: "translate(63.9086 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 16.4087) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.4087)",
    fill: "#FFF065"
  },
  { transform: "translate(32.3471 16.4087) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.4087)",
    fill: "#FFDE31"
  },
  { transform: "translate(32.3471 32.1895) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(48.1278 32.1895) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(48.1278 16.4087) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.4087)",
    fill: "#FFDE31"
  },
  { transform: "translate(48.1278 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 32.1895) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.1895)",
    fill: "#FFF065"
  },
  { transform: "translate(32.3471 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 40.0798) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 40.0798)",
    fill: "#FFDE31"
  },
  { transform: "translate(24.4567 32.1895) rotate(-180)", fill: "#FFF065" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.1895)",
    fill: "#FFF065"
  },
  { transform: "translate(40.2375 47.9702) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.9702)",
    fill: "#FFDE31"
  },
  { transform: "translate(16.5664 32.1895) rotate(-180)", fill: "#FFF065" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.1895)",
    fill: "#FFF065"
  },
  { transform: "translate(8.67601 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 8.51831) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.51831)",
    fill: "#FFDE31"
  },
  { transform: "translate(56.0182 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 24.2991) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.2991)",
    fill: "#FFF065"
  }
], o8e = [
  { transform: "translate(40.2375 0.232574) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.232574)",
    fill: "#00E45D"
  },
  { transform: "translate(63.9086 31.794) rotate(-180)", fill: "#00E45D" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(40.2375 16.0133) rotate(90)", fill: "#8AFF76" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.0133)",
    fill: "#8AFF76"
  },
  { transform: "translate(32.3471 16.0133) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.0133)",
    fill: "#00E45D"
  },
  { transform: "translate(32.3471 31.794) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(48.1278 31.794) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(48.1278 16.0133) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.0133)",
    fill: "#00E45D"
  },
  { transform: "translate(48.1278 31.794) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.794)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 31.794) rotate(90)", fill: "#8AFF76" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.794)",
    fill: "#8AFF76"
  },
  { transform: "translate(32.3471 31.794) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.794)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.6844) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.6844)",
    fill: "#00E45D"
  },
  { transform: "translate(24.4567 31.794) rotate(-180)", fill: "#8AFF76" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.794)",
    fill: "#8AFF76"
  },
  { transform: "translate(40.2375 47.5748) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.5748)",
    fill: "#00E45D"
  },
  { transform: "translate(16.5664 31.794) rotate(-180)", fill: "#8AFF76" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.794)",
    fill: "#8AFF76"
  },
  { transform: "translate(8.67601 31.794) rotate(-180)", fill: "#00E45D" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(40.2375 8.12296) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.12296)",
    fill: "#00E45D"
  },
  { transform: "translate(56.0182 31.794) rotate(-180)", fill: "#00E45D" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(40.2375 23.9037) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 23.9037)",
    fill: "#FFF065"
  }
], i8e = [
  { transform: "translate(40.2375 0.395386) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.395386)",
    fill: "#FF701E"
  },
  { transform: "translate(63.9086 31.9568) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(40.2375 16.1761) rotate(90)", fill: "#FF9345" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.1761)",
    fill: "#FF9345"
  },
  { transform: "translate(32.3471 16.1761) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.1761)",
    fill: "#FF701E"
  },
  { transform: "translate(32.3471 31.9568) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(48.1278 31.9568) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(48.1278 16.1761) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.1761)",
    fill: "#FF701E"
  },
  { transform: "translate(48.1278 31.9568) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.9568)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 31.9568) rotate(90)", fill: "#FF9345" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.9568)",
    fill: "#FF9345"
  },
  { transform: "translate(32.3471 31.9568) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.9568)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.8472) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.8472)",
    fill: "#FF701E"
  },
  { transform: "translate(24.4567 31.9568) rotate(-180)", fill: "#FF9345" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.9568)",
    fill: "#FF9345"
  },
  { transform: "translate(40.2375 47.7375) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.7375)",
    fill: "#FF701E"
  },
  { transform: "translate(16.5664 31.9568) rotate(-180)", fill: "#FF9345" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.9568)",
    fill: "#FF9345"
  },
  { transform: "translate(8.67601 31.9568) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(40.2375 8.28577) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.28577)",
    fill: "#FF701E"
  },
  { transform: "translate(56.0182 31.9568) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(40.2375 24.0665) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.0665)",
    fill: "#FFF065"
  }
], a8e = [
  { transform: "translate(40.2375) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0)",
    fill: "#F42F3B"
  },
  { transform: "translate(63.9086 31.5615) rotate(-180)", fill: "#F42F3B" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(40.2375 15.7807) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 15.7807)",
    fill: "#FF701E"
  },
  { transform: "translate(32.3471 15.7807) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 15.7807)",
    fill: "#F42F3B"
  },
  { transform: "translate(32.3471 31.5615) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(48.1278 31.5615) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(48.1278 15.7807) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 15.7807)",
    fill: "#F42F3B"
  },
  { transform: "translate(48.1278 31.5615) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.5615)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 31.5615) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.5615)",
    fill: "#FF701E"
  },
  { transform: "translate(32.3471 31.5615) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.5615)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.4518) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.4518)",
    fill: "#F42F3B"
  },
  { transform: "translate(24.4567 31.5615) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.5615)",
    fill: "#FF701E"
  },
  { transform: "translate(40.2375 47.3422) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.3422)",
    fill: "#F42F3B"
  },
  { transform: "translate(16.5664 31.5615) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.5615)",
    fill: "#FF701E"
  },
  { transform: "translate(8.67601 31.5615) rotate(-180)", fill: "#F42F3B" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(40.2375 7.89038) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 7.89038)",
    fill: "#F42F3B"
  },
  { transform: "translate(56.0182 31.5615) rotate(-180)", fill: "#F42F3B" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(40.2375 23.6711) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 23.6711)",
    fill: "#FFF065"
  }
], s8e = [
  { transform: "translate(40.2375 0.465149) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.465149)",
    fill: "#36DBFF"
  },
  { transform: "translate(63.9086 32.0266) rotate(-180)", fill: "#36DBFF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(40.2375 16.2459) rotate(90)", fill: "#7FE8FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.2459)",
    fill: "#7FE8FF"
  },
  { transform: "translate(32.3471 16.2459) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.2459)",
    fill: "#36DBFF"
  },
  { transform: "translate(32.3471 32.0266) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(48.1278 32.0266) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(48.1278 16.2459) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.2459)",
    fill: "#36DBFF"
  },
  { transform: "translate(48.1278 32.0266) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.0266)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 32.0266) rotate(90)", fill: "#7FE8FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.0266)",
    fill: "#7FE8FF"
  },
  { transform: "translate(32.3471 32.0266) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.0266)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.917) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.917)",
    fill: "#36DBFF"
  },
  { transform: "translate(24.4567 32.0266) rotate(-180)", fill: "#7FE8FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.0266)",
    fill: "#7FE8FF"
  },
  { transform: "translate(40.2375 47.8073) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.8073)",
    fill: "#36DBFF"
  },
  { transform: "translate(16.5664 32.0266) rotate(-180)", fill: "#7FE8FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.0266)",
    fill: "#7FE8FF"
  },
  { transform: "translate(8.67601 32.0266) rotate(-180)", fill: "#36DBFF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(40.2375 8.35553) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.35553)",
    fill: "#36DBFF"
  },
  { transform: "translate(56.0182 32.0266) rotate(-180)", fill: "#36DBFF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(40.2375 24.1363) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.1363)",
    fill: "#FFF065"
  }
], u8e = [
  { transform: "translate(40.2375 0.697693) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.697693)",
    fill: "#1657FF"
  },
  { transform: "translate(63.9086 32.2592) rotate(-180)", fill: "#1657FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(40.2375 16.4785) rotate(90)", fill: "#3AA0FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.4785)",
    fill: "#3AA0FF"
  },
  { transform: "translate(32.3471 16.4785) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.4785)",
    fill: "#1657FF"
  },
  { transform: "translate(32.3471 32.2592) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(48.1278 32.2592) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(48.1278 16.4785) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.4785)",
    fill: "#1657FF"
  },
  { transform: "translate(48.1278 32.2592) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.2592)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 32.2592) rotate(90)", fill: "#3AA0FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.2592)",
    fill: "#3AA0FF"
  },
  { transform: "translate(32.3471 32.2592) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.2592)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 40.1495) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 40.1495)",
    fill: "#1657FF"
  },
  { transform: "translate(24.4567 32.2592) rotate(-180)", fill: "#3AA0FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.2592)",
    fill: "#3AA0FF"
  },
  { transform: "translate(40.2375 48.0399) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 48.0399)",
    fill: "#1657FF"
  },
  { transform: "translate(16.5664 32.2592) rotate(-180)", fill: "#3AA0FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.2592)",
    fill: "#3AA0FF"
  },
  { transform: "translate(8.67601 32.2592) rotate(-180)", fill: "#1657FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(40.2375 8.58807) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.58807)",
    fill: "#1657FF"
  },
  { transform: "translate(56.0182 32.2592) rotate(-180)", fill: "#1657FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(40.2375 24.3688) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.3688)",
    fill: "#FFF065"
  }
], c8e = [
  { transform: "translate(40.2375 0.930267) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.930267)",
    fill: "#A528F2"
  },
  { transform: "translate(63.9086 32.4917) rotate(-180)", fill: "#A528F2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(40.2375 16.711) rotate(90)", fill: "#BF58FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.711)",
    fill: "#BF58FF"
  },
  { transform: "translate(32.3471 16.711) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.711)",
    fill: "#A528F2"
  },
  { transform: "translate(32.3471 32.4917) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(48.1278 32.4917) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(48.1278 16.711) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.711)",
    fill: "#A528F2"
  },
  { transform: "translate(48.1278 32.4917) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.4917)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 32.4917) rotate(90)", fill: "#BF58FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.4917)",
    fill: "#BF58FF"
  },
  { transform: "translate(32.3471 32.4917) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.4917)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 40.3821) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 40.3821)",
    fill: "#A528F2"
  },
  { transform: "translate(24.4567 32.4917) rotate(-180)", fill: "#BF58FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.4917)",
    fill: "#BF58FF"
  },
  { transform: "translate(40.2375 48.2725) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 48.2725)",
    fill: "#A528F2"
  },
  { transform: "translate(16.5664 32.4917) rotate(-180)", fill: "#BF58FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.4917)",
    fill: "#BF58FF"
  },
  { transform: "translate(8.67601 32.4917) rotate(-180)", fill: "#A528F2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(40.2375 8.82065) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.82065)",
    fill: "#A528F2"
  },
  { transform: "translate(56.0182 32.4917) rotate(-180)", fill: "#A528F2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(40.2375 24.6014) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.6014)",
    fill: "#FFF065"
  }
], wU = [
  { transform: "translate(40.2375 0.162842) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.162842)",
    fill: "#FB51C1"
  },
  { transform: "translate(63.9086 31.7243) rotate(-180)", fill: "#FB51C1" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(40.2375 15.9436) rotate(90)", fill: "#FF7CD2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 15.9436)",
    fill: "#FF7CD2"
  },
  { transform: "translate(32.3471 15.9436) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 15.9436)",
    fill: "#FB51C1"
  },
  { transform: "translate(32.3471 31.7243) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(48.1278 31.7243) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(48.1278 15.9436) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 15.9436)",
    fill: "#FB51C1"
  },
  { transform: "translate(48.1278 31.7243) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.7243)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 31.7243) rotate(90)", fill: "#FF7CD2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.7243)",
    fill: "#FF7CD2"
  },
  { transform: "translate(32.3471 31.7243) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.7243)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.6147) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.6147)",
    fill: "#FB51C1"
  },
  { transform: "translate(24.4567 31.7243) rotate(-180)", fill: "#FF7CD2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.7243)",
    fill: "#FF7CD2"
  },
  { transform: "translate(40.2375 47.505) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.505)",
    fill: "#FB51C1"
  },
  { transform: "translate(16.5664 31.7243) rotate(-180)", fill: "#FF7CD2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.7243)",
    fill: "#FF7CD2"
  },
  { transform: "translate(8.67601 31.7243) rotate(-180)", fill: "#FB51C1" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(40.2375 8.05322) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.05322)",
    fill: "#FB51C1"
  },
  { transform: "translate(56.0182 31.7243) rotate(-180)", fill: "#FB51C1" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(40.2375 23.834) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 23.834)",
    fill: "#FFF065"
  }
], l8e = {
  pink: wU,
  purple: c8e,
  darkBlue: u8e,
  blue: s8e,
  red: a8e,
  orange: i8e,
  green: o8e,
  yellow: n8e
}, F5e = ({
  width: e = 135,
  height: t,
  className: r = "",
  color: n = "green"
}) => {
  const o = 2.4107142857142856, a = t || e / o, i = e || t * o, s = l8e[n] || wU;
  return /* @__PURE__ */ L(
    "svg",
    {
      width: i,
      height: a,
      viewBox: "0 0 135 56",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: r,
      children: s.map((u, l) => /* @__PURE__ */ L(
        "rect",
        {
          width: 7.89036,
          height: 7.89036,
          transform: u.transform,
          fill: u.fill
        },
        l
      ))
    }
  );
}, f8e = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Pt(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    id: "Ebene_2",
    "data-name": "Ebene 2",
    viewBox: "0 0 314.29 111.66",
    width: e,
    height: e,
    ...n,
    children: [
      /* @__PURE__ */ L("defs", { children: /* @__PURE__ */ L("style", { children: ".cls-1{fill:#fff;stroke-width:0}" }) }),
      /* @__PURE__ */ Pt("g", { id: "Ebene_1-2", "data-name": "Ebene 1", children: [
        /* @__PURE__ */ L(
          "path",
          {
            d: "M118.13 0c-8.69-.1-16.81 2.21-23.8 6.26-2.57 1.49-3.29 4.91-1.55 7.33 3.44 4.8 6.15 10.15 7.97 15.9 1.01 3.2 4.82 4.23 7.65 2.43 3.55-2.25 7.97-3.25 12.67-2.33 6.53 1.27 11.95 6.44 13.44 12.93 2.61 11.39-5.97 21.5-16.91 21.5-3.41 0-6.58-.99-9.24-2.7-2.82-1.8-6.61-.66-7.63 2.53-4.48 14.04-14.26 25.71-27.02 32.66-1.67.91-2.75 2.6-2.75 4.5v5.58c0 2.8 2.27 5.07 5.07 5.07h19.13c2.8 0 5.07-2.27 5.07-5.07v-9.76c0-3.35 3.16-5.67 6.42-4.87 3.52.86 7.18 1.32 10.96 1.32 26.19 0 47.34-21.59 46.62-47.95C163.55 20.67 142.8.28 118.13 0Z",
            style: {
              fill: "#ff7900",
              strokeWidth: 0
            }
          }
        ),
        /* @__PURE__ */ L(
          "path",
          {
            d: "M46.64 0C20.88 0 0 20.88 0 46.64s20.88 46.64 46.64 46.64S93.28 72.4 93.28 46.64 72.4 0 46.64 0Zm0 64.03c-9.6 0-17.38-7.78-17.38-17.39s7.78-17.39 17.38-17.39 17.39 7.78 17.39 17.39-7.78 17.39-17.39 17.39ZM188.46 41.7l20.14 33.14h11.26V18.5h-13.02v34.05L185.9 18.5h-10.38v56.34h12.94V41.7zM265.74 63.57h-24.29V51.9h15.46V40.8h-15.46V29.77h24.29V18.5h-37.88v56.34h37.88V63.57zM286.16 74.84h14.06V29.77h14.07V18.5H272.1v11.27h14.06v45.07z",
            className: "cls-1"
          }
        )
      ] })
    ]
  }
), d8e = ({
  size: e = 42,
  className: t,
  ...r
}) => /* @__PURE__ */ Pt(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 200 200",
    fill: "none",
    className: t,
    ...r,
    children: [
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.14
          },
          fill: "#090a0b",
          d: "M 81.5,9.5 C 82.2423,11.4258 83.2423,13.2591 84.5,15C 82.7184,15.1218 81.0518,14.6218 79.5,13.5C 79.2291,11.6203 79.8958,10.287 81.5,9.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#4f585a",
          d: "M 125.5,38.5 C 112.548,31.863 99.8817,25.0297 87.5,18C 100.667,29.0023 113.667,40.1689 126.5,51.5C 127.634,54.3704 128.3,57.3704 128.5,60.5C 126.668,59.7515 125.001,58.7515 123.5,57.5C 110.167,46.8333 96.8333,36.1667 83.5,25.5C 80.3626,22.7015 78.0293,19.3681 76.5,15.5C 76.9731,14.0937 77.9731,13.427 79.5,13.5C 81.0518,14.6218 82.7184,15.1218 84.5,15C 83.2423,13.2591 82.2423,11.4258 81.5,9.5C 83.4346,8.29099 85.4346,8.45766 87.5,10C 100.414,19.2774 113.08,28.7774 125.5,38.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.161
          },
          fill: "#08090a",
          d: "M 76.5,15.5 C 78.0293,19.3681 80.3626,22.7015 83.5,25.5C 80.5498,24.6916 77.8831,23.3582 75.5,21.5C 73.9378,19.0993 74.2712,17.0993 76.5,15.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.999
          },
          fill: "#778085",
          d: "M 75.5,21.5 C 77.8831,23.3582 80.5498,24.6916 83.5,25.5C 96.8333,36.1667 110.167,46.8333 123.5,57.5C 118.285,55.5594 113.285,53.0594 108.5,50C 99.2121,47.5708 90.0454,44.7374 81,41.5C 80.2352,41.5699 79.7352,41.9033 79.5,42.5C 75.0157,41.6841 72.6824,39.0174 72.5,34.5C 72.8417,33.6618 73.5084,33.3284 74.5,33.5C 77.4258,34.868 80.4258,35.7013 83.5,36C 80.3333,32.8333 77.1667,29.6667 74,26.5C 73.51,25.2068 73.3433,23.8734 73.5,22.5C 73.8417,21.6618 74.5084,21.3284 75.5,21.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.165
          },
          fill: "#070809",
          d: "M 73.5,22.5 C 73.3433,23.8734 73.51,25.2068 74,26.5C 77.1667,29.6667 80.3333,32.8333 83.5,36C 80.4258,35.7013 77.4258,34.868 74.5,33.5C 73.2222,31.2009 71.8889,28.8676 70.5,26.5C 71.0351,24.739 72.0351,23.4057 73.5,22.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#8d9999",
          d: "M 125.5,38.5 C 126.125,42.3258 126.791,46.1592 127.5,50C 127.43,50.7648 127.097,51.2648 126.5,51.5C 113.667,40.1689 100.667,29.0023 87.5,18C 99.8817,25.0297 112.548,31.863 125.5,38.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#8e9a9a",
          d: "M 123.5,57.5 C 125.001,58.7515 126.668,59.7515 128.5,60.5C 128.5,61.8333 128.5,63.1667 128.5,64.5C 128.5,65.8333 128.5,67.1667 128.5,68.5C 112.879,61.0229 97.5452,53.0229 82.5,44.5C 81.2905,44.0679 80.2905,43.4013 79.5,42.5C 79.7352,41.9033 80.2352,41.5699 81,41.5C 90.0454,44.7374 99.2121,47.5708 108.5,50C 113.285,53.0594 118.285,55.5594 123.5,57.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#777f85",
          d: "M 125.5,38.5 C 129.5,41.5 133.5,44.5 137.5,47.5C 136.428,51.7555 134.261,55.4222 131,58.5C 130.155,60.6115 129.322,62.6115 128.5,64.5C 128.5,63.1667 128.5,61.8333 128.5,60.5C 128.3,57.3704 127.634,54.3704 126.5,51.5C 127.097,51.2648 127.43,50.7648 127.5,50C 126.791,46.1592 126.125,42.3258 125.5,38.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.997
          },
          fill: "#888889",
          d: "M 58.5,63.5 C 48.5374,62.2002 38.7041,60.2002 29,57.5C 27.9302,57.528 27.0968,57.8614 26.5,58.5C 24.2459,57.5849 22.2459,56.2516 20.5,54.5C 18.4985,51.6662 15.9985,49.3329 13,47.5C 12.51,46.2068 12.3433,44.8734 12.5,43.5C 13.2506,42.4265 14.2506,42.2599 15.5,43C 29.1035,51.4694 43.4368,58.3027 58.5,63.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.17
          },
          fill: "#0e0f0f",
          d: "M 12.5,43.5 C 12.3433,44.8734 12.51,46.2068 13,47.5C 15.9985,49.3329 18.4985,51.6662 20.5,54.5C 20.44,55.0431 20.1067,55.3764 19.5,55.5C 16.3707,53.6001 13.0373,52.2667 9.5,51.5C 10.7279,49.9902 10.7279,48.4902 9.5,47C 10.1634,45.4815 11.1634,44.3149 12.5,43.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7b848a",
          d: "M 82.5,44.5 C 97.5452,53.0229 112.879,61.0229 128.5,68.5C 128.72,71.4005 128.054,74.0671 126.5,76.5C 113.14,69.1544 99.8062,61.8211 86.5,54.5C 83.5279,52.6778 80.5279,50.8445 77.5,49C 76.6198,47.6439 76.2865,46.1439 76.5,44.5C 78.7411,44.9539 80.7411,44.9539 82.5,44.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.153
          },
          fill: "#050506",
          d: "M 72.5,34.5 C 72.6824,39.0174 75.0157,41.6841 79.5,42.5C 80.2905,43.4013 81.2905,44.0679 82.5,44.5C 80.7411,44.9539 78.7411,44.9539 76.5,44.5C 76.2865,46.1439 76.6198,47.6439 77.5,49C 80.5279,50.8445 83.5279,52.6778 86.5,54.5C 86.2774,59.2804 87.944,63.2804 91.5,66.5C 91.1496,69.4534 92.1496,71.7867 94.5,73.5C 92.4471,73.5979 90.7804,72.9313 89.5,71.5C 89.6495,70.448 89.4828,69.448 89,68.5C 85.7393,65.9786 84.0726,62.6453 84,58.5C 80.5991,56.6387 77.5991,54.3053 75,51.5C 74.2419,49.2305 74.4086,47.0639 75.5,45C 70.4866,42.378 69.4866,38.878 72.5,34.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.016
          },
          fill: "#0f1010",
          d: "M 138.5,48.5 C 140.539,49.911 141.539,51.911 141.5,54.5C 139.992,52.8185 138.992,50.8185 138.5,48.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.999
          },
          fill: "#343f49",
          d: "M 9.5,51.5 C 13.0373,52.2667 16.3707,53.6001 19.5,55.5C 20.1067,55.3764 20.44,55.0431 20.5,54.5C 22.2459,56.2516 24.2459,57.5849 26.5,58.5C 35.1667,62.8333 43.8333,67.1667 52.5,71.5C 56.6478,75.4041 60.9811,79.0708 65.5,82.5C 65.5,82.8333 65.5,83.1667 65.5,83.5C 50.001,77.6719 34.6676,71.6719 19.5,65.5C 16.9116,63.4392 14.0783,60.7726 11,57.5C 9.87201,55.6547 9.37201,53.6547 9.5,51.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.191
          },
          fill: "#070809",
          d: "M 9.5,51.5 C 9.37201,53.6547 9.87201,55.6547 11,57.5C 14.0783,60.7726 16.9116,63.4392 19.5,65.5C 16.2854,65.0951 13.2854,64.0951 10.5,62.5C 8.3912,60.8783 7.3912,58.7116 7.5,56C 7.30684,53.9919 7.9735,52.4919 9.5,51.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.05
          },
          fill: "#060707",
          d: "M 141.5,54.5 C 142.633,56.0552 143.299,57.8886 143.5,60C 142.418,65.9944 141.418,71.9944 140.5,78C 140.899,79.7275 141.566,81.2275 142.5,82.5C 142.167,83.5 141.5,84.1667 140.5,84.5C 140.046,81.1349 139.38,77.8015 138.5,74.5C 139.874,67.8812 140.874,61.2146 141.5,54.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#c9cbcb",
          d: "M 26.5,58.5 C 27.0968,57.8614 27.9302,57.528 29,57.5C 38.7041,60.2002 48.5374,62.2002 58.5,63.5C 61.221,63.9628 63.8877,64.6295 66.5,65.5C 72.5358,70.1912 78.8691,74.5245 85.5,78.5C 74.6653,76.7183 63.6653,74.385 52.5,71.5C 43.8333,67.1667 35.1667,62.8333 26.5,58.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#929294",
          d: "M 10.5,62.5 C 13.2854,64.0951 16.2854,65.0951 19.5,65.5C 34.6676,71.6719 50.001,77.6719 65.5,83.5C 63.9504,84.7199 62.2837,84.7199 60.5,83.5C 47.2117,81.5939 34.2117,78.5939 21.5,74.5C 15.1127,73.7734 10.7793,70.4401 8.5,64.5C 8.83333,63.5 9.5,62.8333 10.5,62.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#494f51",
          d: "M 137.5,47.5 C 138.167,47.5 138.5,47.8333 138.5,48.5C 138.992,50.8185 139.992,52.8185 141.5,54.5C 140.874,61.2146 139.874,67.8812 138.5,74.5C 139.38,77.8015 140.046,81.1349 140.5,84.5C 138.83,87.0016 136.664,89.0016 134,90.5C 132.478,88.2591 131.145,85.9258 130,83.5C 128.544,86.0324 127.377,88.6991 126.5,91.5C 115.094,82.7537 103.427,74.4203 91.5,66.5C 87.944,63.2804 86.2774,59.2804 86.5,54.5C 99.8062,61.8211 113.14,69.1544 126.5,76.5C 128.054,74.0671 128.72,71.4005 128.5,68.5C 128.5,67.1667 128.5,65.8333 128.5,64.5C 129.322,62.6115 130.155,60.6115 131,58.5C 134.261,55.4222 136.428,51.7555 137.5,47.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.183
          },
          fill: "#060606",
          d: "M 8.5,64.5 C 10.7793,70.4401 15.1127,73.7734 21.5,74.5C 19.3021,75.1653 16.9688,75.8319 14.5,76.5C 16.3737,81.6139 20.0404,84.6139 25.5,85.5C 26.5,85.5 27.5,85.5 28.5,85.5C 28.2627,86.791 28.596,87.791 29.5,88.5C 29.5106,90.0174 30.1772,91.1841 31.5,92C 34.7365,93.7862 38.0698,95.2862 41.5,96.5C 41.5,97.1667 41.8333,97.5 42.5,97.5C 42.5494,100.099 43.5494,102.266 45.5,104C 48.8168,104.498 52.1501,104.665 55.5,104.5C 55.2627,105.791 55.596,106.791 56.5,107.5C 56.9528,108.458 57.6195,109.292 58.5,110C 61.3771,111.127 64.3771,111.794 67.5,112C 68.9852,114.237 70.9852,115.737 73.5,116.5C 76.9386,117.019 80.272,118.019 83.5,119.5C 87.2508,121.079 91.2508,122.079 95.5,122.5C 95.5,122.833 95.5,123.167 95.5,123.5C 92.5715,130.285 90.2382,137.285 88.5,144.5C 88.1667,145.167 87.8333,145.833 87.5,146.5C 87.1667,146.5 86.8333,146.5 86.5,146.5C 87.7936,139.786 89.7936,133.286 92.5,127C 87.5169,126.897 83.1836,125.23 79.5,122C 74.2686,122.485 69.9353,120.819 66.5,117C 60.8614,116.865 56.528,114.531 53.5,110C 50.1853,109.059 46.852,108.226 43.5,107.5C 41.5592,105.166 39.8925,102.666 38.5,100C 32.4206,98.8085 28.0872,95.4752 25.5,90C 17.189,88.6898 12.689,83.8564 12,75.5C 9.28221,73.2292 7.44888,70.3958 6.5,67C 7.06594,66.0053 7.73261,65.172 8.5,64.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#b8b6ac",
          d: "M 52.5,71.5 C 63.6653,74.385 74.6653,76.7183 85.5,78.5C 89.228,81.5589 93.228,84.2256 97.5,86.5C 91.3341,87.3789 85.0007,87.3789 78.5,86.5C 75.3915,86.7359 72.3915,86.4025 69.5,85.5C 68.205,84.5116 66.8717,83.5116 65.5,82.5C 60.9811,79.0708 56.6478,75.4041 52.5,71.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#343f48",
          d: "M 21.5,74.5 C 34.2117,78.5939 47.2117,81.5939 60.5,83.5C 48.8333,84.1667 37.1667,84.8333 25.5,85.5C 20.0404,84.6139 16.3737,81.6139 14.5,76.5C 16.9688,75.8319 19.3021,75.1653 21.5,74.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#565a5e",
          d: "M 66.5,65.5 C 74.1667,67.5 81.8333,69.5 89.5,71.5C 90.7804,72.9313 92.4471,73.5979 94.5,73.5C 104.436,81.5934 114.269,89.9267 124,98.5C 124.333,100.5 124.667,102.5 125,104.5C 127.25,100.332 129.75,96.3318 132.5,92.5C 130.604,91.5344 128.604,91.2011 126.5,91.5C 127.377,88.6991 128.544,86.0324 130,83.5C 131.145,85.9258 132.478,88.2591 134,90.5C 136.664,89.0016 138.83,87.0016 140.5,84.5C 141.5,84.1667 142.167,83.5 142.5,82.5C 146.184,80.4717 149.85,78.4717 153.5,76.5C 153.5,76.8333 153.5,77.1667 153.5,77.5C 150.542,81.6911 148.542,86.3578 147.5,91.5C 151.5,90.5 155.5,89.5 159.5,88.5C 160.492,88.3284 161.158,88.6618 161.5,89.5C 160.26,90.6588 158.926,91.6588 157.5,92.5C 154.615,92.1936 151.948,92.5269 149.5,93.5C 148.391,93.4431 147.391,93.1098 146.5,92.5C 142.6,91.5701 138.6,91.2367 134.5,91.5C 134.46,94.8806 134.793,98.2139 135.5,101.5C 135.5,102.833 135.5,104.167 135.5,105.5C 131.563,105.207 127.73,105.54 124,106.5C 115.993,99.572 107.493,93.2387 98.5,87.5C 98.5,86.8333 98.1667,86.5 97.5,86.5C 93.228,84.2256 89.228,81.5589 85.5,78.5C 78.8691,74.5245 72.5358,70.1912 66.5,65.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#c0bbb1",
          d: "M 153.5,76.5 C 156.5,76.5 159.5,76.5 162.5,76.5C 164.526,80.5813 165.526,84.9146 165.5,89.5C 164.167,89.5 162.833,89.5 161.5,89.5C 161.158,88.6618 160.492,88.3284 159.5,88.5C 157.5,84.8333 155.5,81.1667 153.5,77.5C 153.5,77.1667 153.5,76.8333 153.5,76.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7c858b",
          d: "M 153.5,77.5 C 155.5,81.1667 157.5,84.8333 159.5,88.5C 155.5,89.5 151.5,90.5 147.5,91.5C 148.542,86.3578 150.542,81.6911 153.5,77.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.996
          },
          fill: "#898a89",
          d: "M 162.5,76.5 C 167.023,78.0073 171.523,79.674 176,81.5C 177.03,81.8361 177.53,82.5028 177.5,83.5C 177.992,85.8185 178.992,87.8185 180.5,89.5C 181.338,89.8417 181.672,90.5084 181.5,91.5C 178.012,91.7054 174.679,92.5387 171.5,94C 176.66,95.6954 181.66,97.5287 186.5,99.5C 181.93,100.441 177.263,100.774 172.5,100.5C 171.793,98.2186 170.793,96.0519 169.5,94C 165.534,93.1721 161.534,92.6721 157.5,92.5C 158.926,91.6588 160.26,90.6588 161.5,89.5C 162.184,91.1852 163.517,92.1852 165.5,92.5C 168.012,91.2162 168.012,90.2162 165.5,89.5C 165.526,84.9146 164.526,80.5813 162.5,76.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5c676f",
          d: "M 65.5,82.5 C 66.8717,83.5116 68.205,84.5116 69.5,85.5C 66.8333,87.5 64.1667,89.5 61.5,91.5C 51.2474,90.3957 41.0808,88.729 31,86.5C 29.9701,86.8361 29.4701,87.5028 29.5,88.5C 28.596,87.791 28.2627,86.791 28.5,85.5C 27.5,85.5 26.5,85.5 25.5,85.5C 37.1667,84.8333 48.8333,84.1667 60.5,83.5C 62.2837,84.7199 63.9504,84.7199 65.5,83.5C 65.5,83.1667 65.5,82.8333 65.5,82.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.018
          },
          fill: "#191919",
          d: "M 177.5,83.5 C 179.539,84.911 180.539,86.911 180.5,89.5C 178.992,87.8185 177.992,85.8185 177.5,83.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#cdcfd0",
          d: "M 61.5,91.5 C 64.3522,93.0765 67.3522,94.5765 70.5,96C 60.8391,96.4998 51.1724,96.6665 41.5,96.5C 38.0698,95.2862 34.7365,93.7862 31.5,92C 30.1772,91.1841 29.5106,90.0174 29.5,88.5C 29.4701,87.5028 29.9701,86.8361 31,86.5C 41.0808,88.729 51.2474,90.3957 61.5,91.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7c858b",
          d: "M 78.5,86.5 C 85.0007,87.3789 91.3341,87.3789 97.5,86.5C 98.1667,86.5 98.5,86.8333 98.5,87.5C 95.9058,93.1859 92.9058,98.6859 89.5,104C 89.7284,104.399 90.0618,104.565 90.5,104.5C 94.7789,107.029 99.1122,109.363 103.5,111.5C 97.296,115.128 90.6293,117.795 83.5,119.5C 80.272,118.019 76.9386,117.019 73.5,116.5C 76.1873,116.664 78.854,116.497 81.5,116C 83.5871,112.492 85.9204,109.158 88.5,106C 88.2716,105.601 87.9382,105.435 87.5,105.5C 87.5,104.833 87.5,104.167 87.5,103.5C 87.9382,103.565 88.2716,103.399 88.5,103C 84.7673,97.6938 81.434,92.1938 78.5,86.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#3c413e",
          d: "M 91.5,66.5 C 103.427,74.4203 115.094,82.7537 126.5,91.5C 128.604,91.2011 130.604,91.5344 132.5,92.5C 129.75,96.3318 127.25,100.332 125,104.5C 124.667,102.5 124.333,100.5 124,98.5C 114.269,89.9267 104.436,81.5934 94.5,73.5C 92.1496,71.7867 91.1496,69.4534 91.5,66.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#e2730e",
          d: "M 161.5,89.5 C 162.833,89.5 164.167,89.5 165.5,89.5C 168.012,90.2162 168.012,91.2162 165.5,92.5C 163.517,92.1852 162.184,91.1852 161.5,89.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#b7b5ac",
          d: "M 146.5,92.5 C 147.265,95.0961 147.599,97.7628 147.5,100.5C 147.5,100.833 147.5,101.167 147.5,101.5C 143.569,102.132 140.235,103.799 137.5,106.5C 137.167,106.5 136.833,106.5 136.5,106.5C 136.784,104.585 136.451,102.919 135.5,101.5C 134.793,98.2139 134.46,94.8806 134.5,91.5C 138.6,91.2367 142.6,91.5701 146.5,92.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.998
          },
          fill: "#babbba",
          d: "M 181.5,91.5 C 184.81,93.4821 187.81,95.8154 190.5,98.5C 189.432,99.4345 188.099,99.7678 186.5,99.5C 181.66,97.5287 176.66,95.6954 171.5,94C 174.679,92.5387 178.012,91.7054 181.5,91.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#353f49",
          d: "M 146.5,92.5 C 147.391,93.1098 148.391,93.4431 149.5,93.5C 153.167,94.1667 156.833,94.8333 160.5,95.5C 156.624,98.1293 152.29,99.796 147.5,100.5C 147.599,97.7628 147.265,95.0961 146.5,92.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#d0c9c0",
          d: "M 149.5,93.5 C 151.948,92.5269 154.615,92.1936 157.5,92.5C 161.534,92.6721 165.534,93.1721 169.5,94C 170.793,96.0519 171.793,98.2186 172.5,100.5C 168.52,98.8702 164.52,97.2035 160.5,95.5C 156.833,94.8333 153.167,94.1667 149.5,93.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7e8182",
          d: "M 160.5,95.5 C 164.52,97.2035 168.52,98.8702 172.5,100.5C 172.5,101.167 172.167,101.5 171.5,101.5C 163.981,101.175 156.648,101.508 149.5,102.5C 148.833,102.167 148.167,101.833 147.5,101.5C 147.5,101.167 147.5,100.833 147.5,100.5C 152.29,99.796 156.624,98.1293 160.5,95.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5c666f",
          d: "M 42.5,97.5 C 52.1724,97.3335 61.8391,97.5002 71.5,98C 66.7133,99.8932 62.0466,102.06 57.5,104.5C 56.6143,105.325 56.281,106.325 56.5,107.5C 55.596,106.791 55.2627,105.791 55.5,104.5C 52.1501,104.665 48.8168,104.498 45.5,104C 43.5494,102.266 42.5494,100.099 42.5,97.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5d6871",
          d: "M 87.5,103.5 C 87.5,104.167 87.5,104.833 87.5,105.5C 81.5738,106.774 75.7404,108.441 70,110.5C 69.5,110.167 69,109.833 68.5,109.5C 69.9376,105.167 71.9376,101.167 74.5,97.5C 78.9793,99.2405 83.3126,101.24 87.5,103.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.165
          },
          fill: "#070707",
          d: "M 190.5,98.5 C 192.676,99.7133 193.009,101.38 191.5,103.5C 185.274,105.018 178.94,105.852 172.5,106C 168.352,109.314 164.352,112.814 160.5,116.5C 157.833,124.323 154.667,131.99 151,139.5C 147.796,142.369 144.963,145.535 142.5,149C 139.761,150.026 137.428,151.526 135.5,153.5C 134.609,152.89 133.609,152.557 132.5,152.5C 131.833,152.5 131.167,152.5 130.5,152.5C 130.5,151.833 130.5,151.167 130.5,150.5C 131.167,150.5 131.5,150.167 131.5,149.5C 139.372,146.766 145.372,141.766 149.5,134.5C 150.167,134.5 150.5,134.167 150.5,133.5C 153.099,127.704 155.099,121.704 156.5,115.5C 157.167,115.5 157.5,115.167 157.5,114.5C 157.833,113.5 158.5,112.833 159.5,112.5C 163.5,108.833 167.5,105.167 171.5,101.5C 172.167,101.5 172.5,101.167 172.5,100.5C 177.263,100.774 181.93,100.441 186.5,99.5C 188.099,99.7678 189.432,99.4345 190.5,98.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#cdcfcf",
          d: "M 147.5,101.5 C 148.167,101.833 148.833,102.167 149.5,102.5C 153.14,105.473 156.473,108.806 159.5,112.5C 158.5,112.833 157.833,113.5 157.5,114.5C 150.833,111.833 144.167,109.167 137.5,106.5C 140.235,103.799 143.569,102.132 147.5,101.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#343e48",
          d: "M 171.5,101.5 C 167.5,105.167 163.5,108.833 159.5,112.5C 156.473,108.806 153.14,105.473 149.5,102.5C 156.648,101.508 163.981,101.175 171.5,101.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#969798",
          d: "M 69.5,85.5 C 72.3915,86.4025 75.3915,86.7359 78.5,86.5C 81.434,92.1938 84.7673,97.6938 88.5,103C 88.2716,103.399 87.9382,103.565 87.5,103.5C 83.3126,101.24 78.9793,99.2405 74.5,97.5C 71.9376,101.167 69.9376,105.167 68.5,109.5C 69,109.833 69.5,110.167 70,110.5C 75.7404,108.441 81.5738,106.774 87.5,105.5C 87.9382,105.435 88.2716,105.601 88.5,106C 85.9204,109.158 83.5871,112.492 81.5,116C 78.854,116.497 76.1873,116.664 73.5,116.5C 70.9852,115.737 68.9852,114.237 67.5,112C 64.3771,111.794 61.3771,111.127 58.5,110C 57.6195,109.292 56.9528,108.458 56.5,107.5C 56.281,106.325 56.6143,105.325 57.5,104.5C 62.0466,102.06 66.7133,99.8932 71.5,98C 61.8391,97.5002 52.1724,97.3335 42.5,97.5C 41.8333,97.5 41.5,97.1667 41.5,96.5C 51.1724,96.6665 60.8391,96.4998 70.5,96C 67.3522,94.5765 64.3522,93.0765 61.5,91.5C 64.1667,89.5 66.8333,87.5 69.5,85.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#bfc2c4",
          d: "M 90.5,104.5 C 100.989,105.041 111.322,105.707 121.5,106.5C 115.431,107.914 109.431,109.581 103.5,111.5C 99.1122,109.363 94.7789,107.029 90.5,104.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5d6870",
          d: "M 98.5,87.5 C 107.493,93.2387 115.993,99.572 124,106.5C 127.73,105.54 131.563,105.207 135.5,105.5C 135.5,104.167 135.5,102.833 135.5,101.5C 136.451,102.919 136.784,104.585 136.5,106.5C 135.724,113.137 135.391,119.804 135.5,126.5C 129.121,126.038 122.788,125.538 116.5,125C 118.606,128.039 120.106,131.205 121,134.5C 116.332,132.082 111.499,130.082 106.5,128.5C 106.5,128.167 106.5,127.833 106.5,127.5C 106.5,126.833 106.833,126.5 107.5,126.5C 110.315,126.796 112.982,125.796 115.5,123.5C 114.639,121.089 113.306,119.089 111.5,117.5C 115.841,114.189 119.174,110.522 121.5,106.5C 111.322,105.707 100.989,105.041 90.5,104.5C 90.0618,104.565 89.7284,104.399 89.5,104C 92.9058,98.6859 95.9058,93.1859 98.5,87.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#959697",
          d: "M 136.5,106.5 C 136.833,106.5 137.167,106.5 137.5,106.5C 144.167,109.167 150.833,111.833 157.5,114.5C 157.5,115.167 157.167,115.5 156.5,115.5C 150.409,118.408 144.409,121.574 138.5,125C 137.619,125.708 136.953,126.542 136.5,127.5C 131.952,129.107 127.619,131.274 123.5,134C 127.152,134.499 130.818,134.665 134.5,134.5C 131.038,135.482 127.371,135.815 123.5,135.5C 121.308,139.098 120.308,143.098 120.5,147.5C 119.869,149.934 118.869,152.268 117.5,154.5C 116.833,155.5 116.167,156.5 115.5,157.5C 114.18,156.058 112.514,155.392 110.5,155.5C 108.704,154.207 107.037,152.707 105.5,151C 108.833,150.667 112.167,150.333 115.5,150C 107.624,149.113 99.7911,147.946 92,146.5C 90.6244,146.316 89.7911,145.649 89.5,144.5C 95.1404,139.195 100.807,133.861 106.5,128.5C 111.499,130.082 116.332,132.082 121,134.5C 120.106,131.205 118.606,128.039 116.5,125C 122.788,125.538 129.121,126.038 135.5,126.5C 135.391,119.804 135.724,113.137 136.5,106.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#56595b",
          d: "M 121.5,106.5 C 119.174,110.522 115.841,114.189 111.5,117.5C 106.167,119.167 100.833,120.833 95.5,122.5C 91.2508,122.079 87.2508,121.079 83.5,119.5C 90.6293,117.795 97.296,115.128 103.5,111.5C 109.431,109.581 115.431,107.914 121.5,106.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#56585a",
          d: "M 156.5,115.5 C 155.099,121.704 153.099,127.704 150.5,133.5C 145.597,132.048 140.93,130.048 136.5,127.5C 136.953,126.542 137.619,125.708 138.5,125C 144.409,121.574 150.409,118.408 156.5,115.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#858689",
          d: "M 111.5,117.5 C 110.16,120.529 108.827,123.529 107.5,126.5C 106.833,126.5 106.5,126.833 106.5,127.5C 102.721,126.442 99.0541,125.109 95.5,123.5C 95.5,123.167 95.5,122.833 95.5,122.5C 100.833,120.833 106.167,119.167 111.5,117.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#37414b",
          d: "M 111.5,117.5 C 113.306,119.089 114.639,121.089 115.5,123.5C 112.982,125.796 110.315,126.796 107.5,126.5C 108.827,123.529 110.16,120.529 111.5,117.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#343e48",
          d: "M 95.5,123.5 C 99.0541,125.109 102.721,126.442 106.5,127.5C 106.5,127.833 106.5,128.167 106.5,128.5C 100.807,133.861 95.1404,139.195 89.5,144.5C 89.1667,144.5 88.8333,144.5 88.5,144.5C 90.2382,137.285 92.5715,130.285 95.5,123.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#ced0d0",
          d: "M 136.5,127.5 C 140.93,130.048 145.597,132.048 150.5,133.5C 150.5,134.167 150.167,134.5 149.5,134.5C 144.5,134.5 139.5,134.5 134.5,134.5C 130.818,134.665 127.152,134.499 123.5,134C 127.619,131.274 131.952,129.107 136.5,127.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7b8389",
          d: "M 134.5,134.5 C 139.5,134.5 144.5,134.5 149.5,134.5C 145.372,141.766 139.372,146.766 131.5,149.5C 128.406,145.074 125.739,140.407 123.5,135.5C 127.371,135.815 131.038,135.482 134.5,134.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#36414b",
          d: "M 123.5,135.5 C 125.739,140.407 128.406,145.074 131.5,149.5C 131.5,150.167 131.167,150.5 130.5,150.5C 126.881,150.119 123.548,149.119 120.5,147.5C 120.308,143.098 121.308,139.098 123.5,135.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5d676f",
          d: "M 88.5,144.5 C 88.8333,144.5 89.1667,144.5 89.5,144.5C 89.7911,145.649 90.6244,146.316 92,146.5C 99.7911,147.946 107.624,149.113 115.5,150C 112.167,150.333 108.833,150.667 105.5,151C 107.037,152.707 108.704,154.207 110.5,155.5C 107.085,162 103.418,168.333 99.5,174.5C 101.095,168.717 103.095,163.051 105.5,157.5C 103.5,156.833 101.5,156.167 99.5,155.5C 101.316,154.185 102.983,152.685 104.5,151C 99.8333,150.333 95.1667,150.333 90.5,151C 91.4118,153.205 92.7451,155.038 94.5,156.5C 94.5,157.167 94.1667,157.5 93.5,157.5C 83.3942,165.095 73.3942,172.928 63.5,181C 62.8333,181.667 62.1667,181.667 61.5,181C 69.3025,172.197 77.4691,163.697 86,155.5C 87.1821,153.656 88.3488,151.823 89.5,150C 89.1918,148.541 88.5251,147.374 87.5,146.5C 87.8333,145.833 88.1667,145.167 88.5,144.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.999
          },
          fill: "#5e686e",
          d: "M 120.5,147.5 C 123.548,149.119 126.881,150.119 130.5,150.5C 130.5,151.167 130.5,151.833 130.5,152.5C 129.039,151.314 127.705,151.314 126.5,152.5C 123.402,152.756 120.402,153.422 117.5,154.5C 118.869,152.268 119.869,149.934 120.5,147.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.961
          },
          fill: "#b3afa3",
          d: "M 130.5,152.5 C 131.167,152.5 131.833,152.5 132.5,152.5C 133.306,153.728 134.306,154.728 135.5,155.5C 132.145,155.31 129.145,154.31 126.5,152.5C 127.705,151.314 129.039,151.314 130.5,152.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.988
          },
          fill: "#686b65",
          d: "M 132.5,152.5 C 133.609,152.557 134.609,152.89 135.5,153.5C 137.292,153.366 138.958,153.699 140.5,154.5C 139.789,156.03 138.789,157.363 137.5,158.5C 134.932,158.594 133.432,159.928 133,162.5C 131.794,159.162 132.96,157.329 136.5,157C 135.944,156.617 135.611,156.117 135.5,155.5C 134.306,154.728 133.306,153.728 132.5,152.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.176
          },
          fill: "#030404",
          d: "M 110.5,155.5 C 112.514,155.392 114.18,156.058 115.5,157.5C 117.986,159.155 119.986,161.322 121.5,164C 119.419,166.818 119.085,169.818 120.5,173C 121.167,173.667 121.833,173.667 122.5,173C 120.775,166.133 122.608,164.966 128,169.5C 129.505,171.298 129.672,173.132 128.5,175C 132.204,174.516 132.538,172.849 129.5,170C 132.657,170.176 134.157,172.009 134,175.5C 135.689,173.68 135.855,171.68 134.5,169.5C 137.686,172.399 138.02,175.566 135.5,179C 132.207,179.826 128.874,180.326 125.5,180.5C 127.089,177.036 126.589,174.036 124,171.5C 125.225,174.331 124.559,176.664 122,178.5C 119.086,177.252 117.253,175.086 116.5,172C 117.791,169.95 118.291,167.783 118,165.5C 116.316,163.649 114.483,161.982 112.5,160.5C 111.522,160.977 110.689,161.643 110,162.5C 105.922,170.991 101.588,179.324 97,187.5C 95.786,189.049 94.286,190.215 92.5,191C 77.4054,197.181 62.9054,196.014 49,187.5C 48.1742,184.788 48.6742,182.455 50.5,180.5C 50.238,181.978 50.5713,183.311 51.5,184.5C 56.3296,185.951 60.9962,187.617 65.5,189.5C 70.2981,190.744 74.9648,190.744 79.5,189.5C 82.9419,190.172 85.6086,189.172 87.5,186.5C 90.1569,186.838 92.4902,186.171 94.5,184.5C 96.705,181.423 98.3716,178.09 99.5,174.5C 103.418,168.333 107.085,162 110.5,155.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#555759",
          d: "M 94.5,156.5 C 96.0481,156.821 96.7148,157.821 96.5,159.5C 89.8331,168.856 83.4997,178.523 77.5,188.5C 77.9569,189.298 78.6236,189.631 79.5,189.5C 74.9648,190.744 70.2981,190.744 65.5,189.5C 68.4045,187.101 71.2379,184.435 74,181.5C 80.2688,173.286 86.7688,165.286 93.5,157.5C 94.1667,157.5 94.5,157.167 94.5,156.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.99
          },
          fill: "#2d363e",
          d: "M 140.5,154.5 C 143.802,155.294 147.135,155.96 150.5,156.5C 149.645,158.787 149.478,161.12 150,163.5C 148.334,164.34 148.167,163.84 149.5,162C 148.25,159.375 146.25,158.375 143.5,159C 146.47,162.145 145.97,164.645 142,166.5C 141.667,164.953 142.167,163.62 143.5,162.5C 142.833,159.167 140.833,157.833 137.5,158.5C 138.789,157.363 139.789,156.03 140.5,154.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#898f8c",
          d: "M 99.5,174.5 C 98.3716,178.09 96.705,181.423 94.5,184.5C 92.4902,186.171 90.1569,186.838 87.5,186.5C 90.2985,177.438 93.2985,168.438 96.5,159.5C 96.7148,157.821 96.0481,156.821 94.5,156.5C 92.7451,155.038 91.4118,153.205 90.5,151C 95.1667,150.333 99.8333,150.333 104.5,151C 102.983,152.685 101.316,154.185 99.5,155.5C 101.5,156.167 103.5,156.833 105.5,157.5C 103.095,163.051 101.095,168.717 99.5,174.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 0.132
          },
          fill: "#040505",
          d: "M 126.5,152.5 C 129.145,154.31 132.145,155.31 135.5,155.5C 135.611,156.117 135.944,156.617 136.5,157C 132.96,157.329 131.794,159.162 133,162.5C 133.432,159.928 134.932,158.594 137.5,158.5C 140.833,157.833 142.833,159.167 143.5,162.5C 142.167,163.62 141.667,164.953 142,166.5C 145.97,164.645 146.47,162.145 143.5,159C 146.25,158.375 148.25,159.375 149.5,162C 148.167,163.84 148.334,164.34 150,163.5C 149.478,161.12 149.645,158.787 150.5,156.5C 153.859,160.675 153.525,164.842 149.5,169C 146.36,168.418 143.36,168.751 140.5,170C 139.351,168.396 139.351,166.73 140.5,165C 140.387,163.72 139.72,162.887 138.5,162.5C 136.599,164.006 134.932,165.673 133.5,167.5C 132.29,167.068 131.29,166.401 130.5,165.5C 130.784,163.123 130.784,160.956 130.5,159C 128.722,158.296 126.888,157.796 125,157.5C 123.301,157.387 122.134,158.053 121.5,159.5C 119.413,158.415 118.08,156.749 117.5,154.5C 120.402,153.422 123.402,152.756 126.5,152.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#828688",
          d: "M 86.5,146.5 C 86.8333,146.5 87.1667,146.5 87.5,146.5C 88.5251,147.374 89.1918,148.541 89.5,150C 88.3488,151.823 87.1821,153.656 86,155.5C 77.4691,163.697 69.3025,172.197 61.5,181C 62.1667,181.667 62.8333,181.667 63.5,181C 73.3942,172.928 83.3942,165.095 93.5,157.5C 86.7688,165.286 80.2688,173.286 74,181.5C 71.2379,184.435 68.4045,187.101 65.5,189.5C 60.9962,187.617 56.3296,185.951 51.5,184.5C 50.5713,183.311 50.238,181.978 50.5,180.5C 62.1716,168.829 74.1716,157.495 86.5,146.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5c666f",
          d: "M 96.5,159.5 C 93.2985,168.438 90.2985,177.438 87.5,186.5C 85.6086,189.172 82.9419,190.172 79.5,189.5C 78.6236,189.631 77.9569,189.298 77.5,188.5C 83.4997,178.523 89.8331,168.856 96.5,159.5 Z"
        }
      ) }),
      /* @__PURE__ */ L("g", { children: /* @__PURE__ */ L(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#3b4346",
          d: "M 117.5,154.5 C 118.08,156.749 119.413,158.415 121.5,159.5C 124.328,161.748 127.328,163.748 130.5,165.5C 131.29,166.401 132.29,167.068 133.5,167.5C 133.833,168.167 134.167,168.833 134.5,169.5C 135.855,171.68 135.689,173.68 134,175.5C 134.157,172.009 132.657,170.176 129.5,170C 132.538,172.849 132.204,174.516 128.5,175C 129.672,173.132 129.505,171.298 128,169.5C 122.608,164.966 120.775,166.133 122.5,173C 121.833,173.667 121.167,173.667 120.5,173C 119.085,169.818 119.419,166.818 121.5,164C 119.986,161.322 117.986,159.155 115.5,157.5C 116.167,156.5 116.833,155.5 117.5,154.5 Z"
        }
      ) })
    ]
  }
), D5e = ({
  size: e,
  className: t,
  variant: r,
  walletName: n
}) => n === Au ? /* @__PURE__ */ L(Yve, { size: e, className: t, variant: r }) : n === xc ? /* @__PURE__ */ L(Qve, { size: e, className: t, variant: r }) : n === uf ? /* @__PURE__ */ L(Bk, { size: e, className: t, variant: r }) : n === qa ? /* @__PURE__ */ L(t8e, { size: e, className: t, variant: r }) : n === cf ? /* @__PURE__ */ L(e8e, { size: e, className: t, variant: r }) : n === Ac ? /* @__PURE__ */ L(d8e, { size: e, className: t, variant: r }) : n === Su ? /* @__PURE__ */ L(Xve, { size: e, className: t, variant: r }) : n === kc ? /* @__PURE__ */ L(Jve, { size: e, className: t, variant: r }) : n === sf ? /* @__PURE__ */ L(Wve, { size: e, className: t, variant: r }) : n === _u ? /* @__PURE__ */ L(r8e, { size: e, className: t, variant: r }) : n === Iu ? /* @__PURE__ */ L(f8e, { size: e, className: t, variant: r }) : /* @__PURE__ */ L(Bk, { size: e, className: t, variant: r });
export {
  E5e as ALKANES,
  o5e as APPLICATION_ATOM_XML,
  i5e as APPLICATION_FORM_URLENCODED,
  t5e as APPLICATION_GZIP,
  Y3e as APPLICATION_JAVASCRIPT,
  X3e as APPLICATION_JSON,
  a5e as APPLICATION_OCTET_STREAM,
  Q3e as APPLICATION_PDF,
  n5e as APPLICATION_RSS_XML,
  r5e as APPLICATION_XHTML_XML,
  J3e as APPLICATION_XML,
  e5e as APPLICATION_ZIP,
  m5e as AUDIO_MP3,
  b5e as AUDIO_OGG,
  y5e as AUDIO_WAV,
  i5 as BIP322,
  fy as BIP322_SIMPLE,
  v5e as BRC20,
  YE as BTC,
  OE as CMDRUID_MAINNET,
  eY as CMDRUID_SIGNET,
  QX as CMDRUID_TESTNET,
  Bp as ECDSA,
  fl as FRACTAL_MAINNET,
  Nn as FRACTAL_TESTNET,
  c5e as IMAGE_GIF,
  d5e as IMAGE_ICON,
  s5e as IMAGE_JPEG,
  u5e as IMAGE_PNG,
  l5e as IMAGE_SVG_XML,
  f5e as IMAGE_WEBP,
  rh as LEATHER,
  mv as LEATHER_MAINNET,
  X_ as LEATHER_TESTNET,
  Db as LOCAL_STORAGE_DEFAULT_WALLET,
  R5e as LaserEyesClient,
  F5e as LaserEyesLogo,
  H5e as LaserEyesProvider,
  Bk as LeatherLogo,
  vu as MAGIC_EDEN,
  Ot as MAINNET,
  w5e as MULTIPART_FORM_DATA,
  t8e as MagicEdenLogo,
  nh as OKX,
  XX as OKX_MAINNET,
  YX as OKX_TESTNET,
  hc as OP_NET,
  C3e as OP_WALLET_MAINNET,
  B3e as OP_WALLET_TESTNET,
  dc as ORANGE,
  PE as ORANGE_MAINNET,
  JX as ORANGE_TESTNET,
  th as OYL,
  e8e as OkxLogo,
  Wve as OylLogo,
  BU as P2PKH,
  g8e as P2PSH,
  B8 as P2SH,
  NU as P2SH_P2WPKH,
  tf as P2TR,
  Aw as P2WPKH,
  UU as P2WSH,
  fc as PHANTOM,
  Xve as PhantomLogo,
  N3e as REGTEST,
  JE as RUNES,
  pn as SIGNET,
  Zl as SPARROW,
  m8e as SUPPORTED_WALLETS,
  Yt as TESTNET,
  on as TESTNET4,
  G3e as TEXT_CSS,
  V3e as TEXT_HTML,
  Z3e as TEXT_JAVASCRIPT,
  W3e as TEXT_MARKDOWN,
  UQ as TEXT_PLAIN,
  Vl as UNISAT,
  q_ as UNISAT_FRACTAL_MAINNET,
  V_ as UNISAT_FRACTAL_TESTNET,
  hv as UNISAT_MAINNET,
  K_ as UNISAT_SIGNET,
  D_ as UNISAT_TESTNET,
  M_ as UNISAT_TESTNET4,
  Tv as UNSUPPORTED_PROVIDER_METHOD_ERROR,
  Jve as UnisatLogo,
  h5e as VIDEO_MP4,
  g5e as VIDEO_OGG,
  p5e as VIDEO_WEBM,
  wee as WALLET_NOT_INSTALLED_ERROR,
  Gl as WIZZ,
  xg as WIZZ_MAINNET,
  W_ as WIZZ_SIGNET,
  gv as WIZZ_TESTNET,
  Z_ as WIZZ_TESTNET4,
  D5e as WalletIcon,
  Bi as WalletProvider,
  Qve as WizzLogo,
  lc as XVERSE,
  pv as XVERSE_MAINNET,
  $3e as XVERSE_NETWORK,
  WX as XVERSE_SIGNET,
  G_ as XVERSE_TESTNET,
  Yve as XverseLogo,
  A5e as createConfig,
  x5e as createStores,
  tY as getCmDruidNetwork,
  U3e as getLeatherNetwork,
  j3e as getNetworkForLeather,
  rY as getNetworkForOkx,
  Ag as getNetworkForUnisat,
  $E as getNetworkForWizz,
  z3e as getNetworkForXverse,
  v2 as getOrangeNetwork,
  x1 as getSatsConnectNetwork,
  Y_ as getUnisatNetwork,
  R3e as getWizzNetwork,
  L5e as useLaserEyes
};
