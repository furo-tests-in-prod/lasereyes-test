import { MapStore, WritableAtom } from 'nanostores';
import { BTCSendArgs, Config, ContentType, NetworkType, Protocol, ProviderType, RuneSendArgs } from '../types';
import { WalletProvider } from './providers';
import { LaserEyesStoreType, SignMessageOptions } from './types';
export declare class LaserEyesClient {
    readonly config?: Config | undefined;
    readonly $store: MapStore<LaserEyesStoreType>;
    readonly $network: WritableAtom<NetworkType>;
    readonly $providerMap: Partial<Record<ProviderType, WalletProvider>>;
    private disposed;
    dispose(): void;
    constructor(stores: {
        readonly $store: MapStore<LaserEyesStoreType>;
        readonly $network: WritableAtom<NetworkType>;
    }, config?: Config | undefined);
    initialize(): void;
    private handleIsInitializingChanged;
    connect(defaultWallet: ProviderType): Promise<void>;
    requestAccounts(): Promise<string[] | undefined>;
    disconnect(): void;
    switchNetwork(network: NetworkType): Promise<void>;
    private watchNetworkChange;
    getNetwork(): Promise<NetworkType | undefined>;
    sendBTC(to: string, amount: number): Promise<string | undefined>;
    signMessage(message: string, toSignAddressOrOptions?: string | SignMessageOptions): Promise<string | undefined>;
    signPsbt(tx: string, finalize?: boolean, broadcast?: boolean): Promise<{
        signedPsbtHex: string | undefined;
        signedPsbtBase64: string | undefined;
        txId?: string;
    } | undefined>;
    pushPsbt(tx: string): Promise<string | undefined>;
    inscribe(content: string, mimeType: ContentType): Promise<string | string[] | undefined>;
    send(protocol: Protocol, sendArgs: BTCSendArgs | RuneSendArgs): Promise<string | undefined>;
    getPublicKey(): Promise<string | undefined>;
    getBalance(): Promise<string | number | bigint | undefined>;
    getMetaBalances(protocol: Protocol): Promise<any>;
    getInscriptions(offset?: number, limit?: number): Promise<any[] | undefined>;
}
//# sourceMappingURL=index.d.ts.map